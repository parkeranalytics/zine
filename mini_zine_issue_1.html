<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">

<head>

<meta charset="utf-8">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="pandoc" />
<meta name="viewport" content="width=device-width">
<meta property="og:title" content="Zine" />






<meta name="description" content="Zine">

<script id="pandoc-meta" type="application/json">
{"newpage_html_class":"page-break-after","output":{"pagedown::html_paged":{"css":["zine.css","default-page","default"],"pandoc_args":["–quiet"],"self_contained":true,"toc":false}},"pagetitle":"Zine","title":""}
</script>

<title>Zine</title>


<style type="text/css">
@page {
size: 6in 9in; 
}
@page :blank {
}

.shorttitle1 {
string-set: h1-text content(text);
}
.shorttitle2 {
string-set: h2-text content(text);
}

.running-h1-title {
position: running(runningH1Title);
width: var(--running-title-width);
text-overflow: ellipsis;
overflow: hidden;
}
.running-h1-title:before {
content: string(h1-text);
}
@page chapter:left {
@top-left {
content: counter(page);
}
@top-right {
content: element(runningH1Title);
white-space: nowrap !important;
}
}

.running-h2-title {
position: running(runningH2Title);
width: var(--running-title-width);
text-overflow: ellipsis;
overflow: hidden;
}
.running-h2-title:before {



content: string(h2-text);
}
@page chapter:right {
@top-right {
content: counter(page);
}
@top-left {
content: element(runningH2Title);
white-space: nowrap !important;
}
}

@page chapter:first {
@top-left {
content: none;
}
@top-right {
content: none;
}
@bottom-right {
content: counter(page);
}
}
@page :first {
@top-left {
content: none;
}
@top-right {
content: none;
}
@bottom-right {
content: none !important;
}
background-image: var(--front-cover);
background-position: center;
background-size: contain;
background-repeat: no-repeat;
}

.front-cover {
break-after: recto;
}

.front-page {
counter-reset: page 1;
}

@page frontmatter:left {
@top-left {
content: counter(page, lower-roman);
}
@top-right {
content: element(runningH1Title);
white-space: nowrap !important;
}
}
@page frontmatter:right {
@top-right {
content: counter(page, lower-roman);
}
@top-left {
content: element(runningH1Title);
white-space: nowrap !important;
}
}
@page frontmatter:first {
@top-left {
content: none;
}
@top-right {
content: none;
}
@bottom-right {
content: counter(page, lower-roman);
}
}

.back-cover {
break-before: verso;
}
.pagedjs_page:nth-last-of-type(1) {
background-image: var(--back-cover);
background-position: center;
background-size: contain;
background-repeat: no-repeat;
}

.level1 {
break-before: recto;
page: chapter;
}
.front-matter-container .level1 {
page: frontmatter;
}
.section > h1, .section > h2, .section > h3, .section > h4, .section > h5, .section > h6 {
break-after: avoid;
}
.footenotes {
break-before: always;
break-after: always;
}
.figure {
break-inside: avoid;
}

.main .level1:first-child h1 {
counter-reset: page 1;
}

caption {
break-inside: avoid;
break-after: avoid;
}
</style>
<style type="text/css">:root {
--background: whitesmoke;
--pagedjs-width: 6in;
--pagedjs-height: 9in;
--color-paper: white;
--color-mbox: rgba(0, 0, 0, 0.2);
--running-title-width: 2.5in;
--screen-pages-spacing: 5mm;
}
html {
line-height: 1.3;
}

a[href^="http"]:not([class="uri"])::after {
content: " (" attr(href) ")";
font-size: 90%;
hyphens: none;
word-break: break-all;
}
.references a[href^=http]:not([class=uri])::after {
content: none;
}
.main a[href^="#"]:not([class^="footnote-"]):not([href*=":"])::after {
content: " (page " target-counter(attr(href), page) ")";
}
.main a.front-matter-ref[href^="#"]:not([class^="footnote-"]):not([href*=":"])::after {
content: " (page " target-counter(attr(href), page, lower-roman) ")";
}

.sourceCode a[href^="#"]:not([class^="footnote-"]):not([href*=":"])::after,
.sourceCode a.front-matter-ref[href^="#"]:not([class^="footnote-"]):not([href*=":"])::after {
content: unset;
}

.toc ul, .lot ul, .lof ul {
list-style: none;
padding-left: 0;
overflow-x: clip;
}
.toc li li {
padding-left: 1em;
}
.toc a, .lot a, .lof a {
text-decoration: none;
background: white;
padding-right: .33em;
}
.toc a::after, .lot a::after, .lof a::after {

content: target-counter(attr(href), page);
float: right;
background: white;
}
.toc a.front-matter-ref::after, .lot a.front-matter-ref::after, .lof a.front-matter-ref::after {

content: target-counter(attr(href), page, lower-roman);
}
.toc .leaders::before, .lot .leaders::before, .lof .leaders::before {
float: left;
width: 0;
white-space: nowrap;
content: ". . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . ";
}

.chapter > h1 > .header-section-number::before, .chapter-ref > .toc-section-number::before {
content: var(--chapter-name-before, "Chapter ");
}
.chapter > h1 > .header-section-number::after, .chapter-ref > .toc-section-number::after {
content: var(--chapter-name-after, "");
}

.subtitle span {
font-size: .9em;
}
img {
max-width: 100%;
}
pre {
padding: 1em;
white-space: pre-wrap;
}
pre[class] {
background: #f9f9f9;
}
abbr {
text-decoration: none;
}
@media screen {
div.sourceCode {
overflow: visible !important;
}
a.sourceLine::before {
text-decoration: unset !important;
}
}
pre.numberSource a.sourceLine {
left: 0 !important;
text-indent: -5em
}
pre.numberSource {
margin-left: 0 !important;
}
table {
margin: auto;
border-top: 1px solid #666;
border-bottom: 1px solid #666;
}
table thead th {
border-bottom: 1px solid #ddd;
}
thead, tfoot, tr:nth-child(even) {
background: #eee;
}

.kable_wrapper > tbody > tr > td {
vertical-align: top;
}
.footnotes {
font-size: 90%;
}
.footnotes hr::before {
content: "Footnotes:";
}
.footnotes hr {
border: none;
}
.footnote-break {
width: 1in;
}
body {
hyphens: auto;
}
code {
hyphens: none;
}

@media screen {
body {
background-color: var(--background);
margin: var(--screen-pages-spacing) auto 0 auto;
}
.pagedjs_pages {
display: flex;
max-width: calc(var(--pagedjs-width) * 2);
flex: 0;
flex-wrap: wrap;
margin: 0 auto;
}
.pagedjs_page {
background-color: var(--color-paper);
box-shadow: 0 0 0 1px var(--color-mbox);
flex-shrink: 0;
flex-grow: 0;
margin: auto auto var(--screen-pages-spacing) auto;
}
}

@media screen and (min-width: 12.32in) {
.pagedjs_page {
margin: auto 0 var(--screen-pages-spacing) 0;
}
.pagedjs_first_page {
margin-left: var(--pagedjs-width);
}
}

@media screen and (max-width:1180px) {
body {
width: calc(var(--pagedjs-width) + 2 * var(--screen-pages-spacing));
}
}
</style>
<script>// Configuration script for paged.js

(function() {
  // Retrieve previous config object if defined
  window.PagedConfig = window.PagedConfig || {};
  const {before: beforePaged, after: afterPaged} = window.PagedConfig;

  // utils
  const insertCSS = text => {
    let style = document.createElement('style');
		style.type = 'text/css';
		style.appendChild(document.createTextNode(text));
    document.head.appendChild(style);
  };

  // Util function for front and back covers images
  const insertCSSForCover = type => {
    const links = document.querySelectorAll('link[id^=' + type + ']');
    if (!links.length) return;
    const re = new RegExp(type + '-\\d+');
    let text = ':root {--' + type + ': var(--' + type + '-1);';
    for (const link of links) {
      text += '--' + re.exec(link.id)[0] + ': url("' + link.href + '");';
    }
    text += '}';
    insertCSS(text);
  };

  const insertPageBreaksCSS = () => {
    insertCSS(`
    .page-break-after {break-after: page;}
    .page-break-before {break-before: page;}
    `);
  };

  window.PagedConfig.before = async () => {
    // Front and back covers support
    let frontCover = document.querySelector('.front-cover');
    let backCover = document.querySelector('.back-cover');
    if (frontCover) document.body.prepend(frontCover);
    if (backCover) document.body.append(backCover);
    insertCSSForCover('front-cover');
    insertCSSForCover('back-cover');
    insertPageBreaksCSS();

    if (beforePaged) await beforePaged();
  };

  // from https://stackoverflow.com/q/21647928
  const toUTF16BE = x => {
    let res = '';
    for (i=0; i < x.length; i++) {
      let hex = x.charCodeAt(i).toString(16);
      hex = ('000' + hex).slice(-4);
      res += hex
    }
    res = 'feff' + res ;
    return res;
  }

  const findPage = el => {
    while (el.parentElement) {
      el = el.parentElement;
      if (el.getAttribute('data-page-number')) {
        return parseInt(el.getAttribute('data-page-number'));
      }
    }
    return null;
  };

  const tocEntriesInfos = ul => {
    let result = []; // where we store the results
    // if there is no element, return an empty array
    if (!ul) {
      return result;
    }
    const tocEntries = ul.children; // tocEntries are 'li' elements

    for (const li of tocEntries) {
      // Since parts entries in TOC have no anchor,
      // do not use them in the PDF outline.
      if (li.classList.contains('part')) {
        continue;
      }

      // get the title and encode it in UTF16BE (pdfmark is encoded in UTF16BE with BOM)
      const title = toUTF16BE(li.querySelector('a').textContent);

      // get the page number
      const href = li.querySelector('a').getAttribute('href');
      const el = document.getElementById(href.substring(1));
      const page = findPage(el);

      // get the children
      children = tocEntriesInfos(li.querySelector('ul'));

      result.push({
        title: title,
        page: page,
        children: children
      });
    }

    return result;
  };
  window.PagedConfig.after = (flow) => {
    // force redraw, see https://github.com/rstudio/pagedown/issues/35#issuecomment-475905361
    // and https://stackoverflow.com/a/24753578/6500804
    document.body.style.display = 'none';
    document.body.offsetHeight;
    document.body.style.display = '';

    // run previous PagedConfig.after function if defined
    if (afterPaged) afterPaged(flow);

    // pagedownListener is a binding added by the chrome_print function
    // this binding exists only when chrome_print opens the html file
    if (window.pagedownListener) {
      // the html file is opened for printing
      // call the binding to signal to the R session that Paged.js has finished
      const tocList = flow.source.querySelector('.toc > ul');
      const tocInfos = tocEntriesInfos(tocList);
      pagedownListener(JSON.stringify({
        pagedjs: true,
        pages: flow.total,
        elapsedtime: flow.performance,
        tocInfos: tocInfos
      }));
      return;
    }
    if (sessionStorage.getItem('pagedown-scroll')) {
      // scroll to the last position before the page is reloaded
      window.scrollTo(0, sessionStorage.getItem('pagedown-scroll'));
      return;
    }
    if (window.location.hash) {
      const id = decodeURIComponent(window.location.hash).replace(/^#/, '');
      document.getElementById(id).scrollIntoView({behavior: 'smooth'});
    }
  };
})();
</script>
<script>/**
 * @license Paged.js v0.1.43 | MIT | https://gitlab.pagedmedia.org/tools/pagedjs
 */

(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
	typeof define === 'function' && define.amd ? define(factory) :
	(global = global || self, global.PagedPolyfill = factory());
}(this, (function () { 'use strict';

	function createCommonjsModule(fn, module) {
		return module = { exports: {} }, fn(module, module.exports), module.exports;
	}

	function getCjsExportFromNamespace (n) {
		return n && n['default'] || n;
	}

	var isImplemented = function () {
		var assign = Object.assign, obj;
		if (typeof assign !== "function") return false;
		obj = { foo: "raz" };
		assign(obj, { bar: "dwa" }, { trzy: "trzy" });
		return (obj.foo + obj.bar + obj.trzy) === "razdwatrzy";
	};

	var isImplemented$1 = function () {
		try {
			Object.keys("primitive");
			return true;
		} catch (e) {
	 return false;
	}
	};

	// eslint-disable-next-line no-empty-function
	var noop = function () {};

	var _undefined = noop(); // Support ES3 engines

	var isValue = function (val) {
	 return (val !== _undefined) && (val !== null);
	};

	var keys = Object.keys;

	var shim = function (object) {
		return keys(isValue(object) ? Object(object) : object);
	};

	var keys$1 = isImplemented$1()
		? Object.keys
		: shim;

	var validValue = function (value) {
		if (!isValue(value)) throw new TypeError("Cannot use null or undefined");
		return value;
	};

	var max   = Math.max;

	var shim$1 = function (dest, src /*, …srcn*/) {
		var error, i, length = max(arguments.length, 2), assign;
		dest = Object(validValue(dest));
		assign = function (key) {
			try {
				dest[key] = src[key];
			} catch (e) {
				if (!error) error = e;
			}
		};
		for (i = 1; i < length; ++i) {
			src = arguments[i];
			keys$1(src).forEach(assign);
		}
		if (error !== undefined) throw error;
		return dest;
	};

	var assign = isImplemented()
		? Object.assign
		: shim$1;

	var forEach = Array.prototype.forEach, create = Object.create;

	var process = function (src, obj) {
		var key;
		for (key in src) obj[key] = src[key];
	};

	// eslint-disable-next-line no-unused-vars
	var normalizeOptions = function (opts1 /*, …options*/) {
		var result = create(null);
		forEach.call(arguments, function (options) {
			if (!isValue(options)) return;
			process(Object(options), result);
		});
		return result;
	};

	// Deprecated

	var isCallable = function (obj) {
	 return typeof obj === "function";
	};

	var str = "razdwatrzy";

	var isImplemented$2 = function () {
		if (typeof str.contains !== "function") return false;
		return (str.contains("dwa") === true) && (str.contains("foo") === false);
	};

	var indexOf = String.prototype.indexOf;

	var shim$2 = function (searchString/*, position*/) {
		return indexOf.call(this, searchString, arguments[1]) > -1;
	};

	var contains = isImplemented$2()
		? String.prototype.contains
		: shim$2;

	var d_1 = createCommonjsModule(function (module) {

	var d;

	d = module.exports = function (dscr, value/*, options*/) {
		var c, e, w, options, desc;
		if ((arguments.length < 2) || (typeof dscr !== 'string')) {
			options = value;
			value = dscr;
			dscr = null;
		} else {
			options = arguments[2];
		}
		if (dscr == null) {
			c = w = true;
			e = false;
		} else {
			c = contains.call(dscr, 'c');
			e = contains.call(dscr, 'e');
			w = contains.call(dscr, 'w');
		}

		desc = { value: value, configurable: c, enumerable: e, writable: w };
		return !options ? desc : assign(normalizeOptions(options), desc);
	};

	d.gs = function (dscr, get, set/*, options*/) {
		var c, e, options, desc;
		if (typeof dscr !== 'string') {
			options = set;
			set = get;
			get = dscr;
			dscr = null;
		} else {
			options = arguments[3];
		}
		if (get == null) {
			get = undefined;
		} else if (!isCallable(get)) {
			options = get;
			get = set = undefined;
		} else if (set == null) {
			set = undefined;
		} else if (!isCallable(set)) {
			options = set;
			set = undefined;
		}
		if (dscr == null) {
			c = true;
			e = false;
		} else {
			c = contains.call(dscr, 'c');
			e = contains.call(dscr, 'e');
		}

		desc = { get: get, set: set, configurable: c, enumerable: e };
		return !options ? desc : assign(normalizeOptions(options), desc);
	};
	});

	var validCallable = function (fn) {
		if (typeof fn !== "function") throw new TypeError(fn + " is not a function");
		return fn;
	};

	var eventEmitter = createCommonjsModule(function (module, exports) {

	var apply = Function.prototype.apply, call = Function.prototype.call
	  , create = Object.create, defineProperty = Object.defineProperty
	  , defineProperties = Object.defineProperties
	  , hasOwnProperty = Object.prototype.hasOwnProperty
	  , descriptor = { configurable: true, enumerable: false, writable: true }

	  , on, once, off, emit, methods, descriptors, base;

	on = function (type, listener) {
		var data;

		validCallable(listener);

		if (!hasOwnProperty.call(this, '__ee__')) {
			data = descriptor.value = create(null);
			defineProperty(this, '__ee__', descriptor);
			descriptor.value = null;
		} else {
			data = this.__ee__;
		}
		if (!data[type]) data[type] = listener;
		else if (typeof data[type] === 'object') data[type].push(listener);
		else data[type] = [data[type], listener];

		return this;
	};

	once = function (type, listener) {
		var once, self;

		validCallable(listener);
		self = this;
		on.call(this, type, once = function () {
			off.call(self, type, once);
			apply.call(listener, this, arguments);
		});

		once.__eeOnceListener__ = listener;
		return this;
	};

	off = function (type, listener) {
		var data, listeners, candidate, i;

		validCallable(listener);

		if (!hasOwnProperty.call(this, '__ee__')) return this;
		data = this.__ee__;
		if (!data[type]) return this;
		listeners = data[type];

		if (typeof listeners === 'object') {
			for (i = 0; (candidate = listeners[i]); ++i) {
				if ((candidate === listener) ||
						(candidate.__eeOnceListener__ === listener)) {
					if (listeners.length === 2) data[type] = listeners[i ? 0 : 1];
					else listeners.splice(i, 1);
				}
			}
		} else {
			if ((listeners === listener) ||
					(listeners.__eeOnceListener__ === listener)) {
				delete data[type];
			}
		}

		return this;
	};

	emit = function (type) {
		var i, l, listener, listeners, args;

		if (!hasOwnProperty.call(this, '__ee__')) return;
		listeners = this.__ee__[type];
		if (!listeners) return;

		if (typeof listeners === 'object') {
			l = arguments.length;
			args = new Array(l - 1);
			for (i = 1; i < l; ++i) args[i - 1] = arguments[i];

			listeners = listeners.slice();
			for (i = 0; (listener = listeners[i]); ++i) {
				apply.call(listener, this, args);
			}
		} else {
			switch (arguments.length) {
			case 1:
				call.call(listeners, this);
				break;
			case 2:
				call.call(listeners, this, arguments[1]);
				break;
			case 3:
				call.call(listeners, this, arguments[1], arguments[2]);
				break;
			default:
				l = arguments.length;
				args = new Array(l - 1);
				for (i = 1; i < l; ++i) {
					args[i - 1] = arguments[i];
				}
				apply.call(listeners, this, args);
			}
		}
	};

	methods = {
		on: on,
		once: once,
		off: off,
		emit: emit
	};

	descriptors = {
		on: d_1(on),
		once: d_1(once),
		off: d_1(off),
		emit: d_1(emit)
	};

	base = defineProperties({}, descriptors);

	module.exports = exports = function (o) {
		return (o == null) ? create(base) : defineProperties(Object(o), descriptors);
	};
	exports.methods = methods;
	});
	var eventEmitter_1 = eventEmitter.methods;

	/**
	 * Hooks allow for injecting functions that must all complete in order before finishing
	 * They will execute in parallel but all must finish before continuing
	 * Functions may return a promise if they are asycn.
	 * From epubjs/src/utils/hooks
	 * @param {any} context scope of this
	 * @example this.content = new Hook(this);
	 */
	class Hook {
		constructor(context){
			this.context = context || this;
			this.hooks = [];
		}

		/**
		 * Adds a function to be run before a hook completes
		 * @example this.content.register(function(){...});
		 * @return {undefined} void
		 */
		register(){
			for(var i = 0; i < arguments.length; ++i) {
				if (typeof arguments[i]  === "function") {
					this.hooks.push(arguments[i]);
				} else {
					// unpack array
					for(var j = 0; j < arguments[i].length; ++j) {
						this.hooks.push(arguments[i][j]);
					}
				}
			}
		}

		/**
		 * Triggers a hook to run all functions
		 * @example this.content.trigger(args).then(function(){...});
		 * @return {Promise} results
		 */
		trigger(){
			var args = arguments;
			var context = this.context;
			var promises = [];

			this.hooks.forEach(function(task) {
				var executing = task.apply(context, args);

				if(executing && typeof executing["then"] === "function") {
					// Task is a function that returns a promise
					promises.push(executing);
				}
				// Otherwise Task resolves immediately, add resolved promise with result
				promises.push(new Promise((resolve, reject) => {
					resolve(executing);
				}));
			});


			return Promise.all(promises);
		}

		/**
	   * Triggers a hook to run all functions synchronously
	   * @example this.content.trigger(args).then(function(){...});
	   * @return {Array} results
	   */
		triggerSync(){
			var args = arguments;
			var context = this.context;
			var results = [];

			this.hooks.forEach(function(task) {
				var executing = task.apply(context, args);

				results.push(executing);
			});


			return results;
		}

		// Adds a function to be run before a hook completes
		list(){
			return this.hooks;
		}

		clear(){
			return this.hooks = [];
		}
	}

	function getBoundingClientRect(element) {
		if (!element) {
			return;
		}
		let rect;
		if (typeof element.getBoundingClientRect !== "undefined") {
			rect = element.getBoundingClientRect();
		} else {
			let range = document.createRange();
			range.selectNode(element);
			rect = range.getBoundingClientRect();
		}
		return rect;
	}

	function getClientRects(element) {
		if (!element) {
			return;
		}
		let rect;
		if (typeof element.getClientRects !== "undefined") {
			rect = element.getClientRects();
		} else {
			let range = document.createRange();
			range.selectNode(element);
			rect = range.getClientRects();
		}
		return rect;
	}

	/**
	 * Generates a UUID
	 * based on: http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript
	 * @returns {string} uuid
	 */
	function UUID() {
		var d = new Date().getTime();
		if (typeof performance !== "undefined" && typeof performance.now === "function") {
			d += performance.now(); //use high-precision timer if available
		}
		return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function (c) {
			var r = (d + Math.random() * 16) % 16 | 0;
			d = Math.floor(d / 16);
			return (c === "x" ? r : (r & 0x3 | 0x8)).toString(16);
		});
	}

	function attr(element, attributes) {
		for (var i = 0; i < attributes.length; i++) {
			if (element.hasAttribute(attributes[i])) {
				return element.getAttribute(attributes[i]);
			}
		}
	}

	/* Based on by https://mths.be/cssescape v1.5.1 by @mathias | MIT license
	 * Allows # and .
	 */
	function querySelectorEscape(value) {
		if (arguments.length == 0) {
			throw new TypeError("`CSS.escape` requires an argument.");
		}
		var string = String(value);

		var length = string.length;
		var index = -1;
		var codeUnit;
		var result = "";
		var firstCodeUnit = string.charCodeAt(0);
		while (++index < length) {
			codeUnit = string.charCodeAt(index);



			// Note: there’s no need to special-case astral symbols, surrogate
			// pairs, or lone surrogates.

			// If the character is NULL (U+0000), then the REPLACEMENT CHARACTER
			// (U+FFFD).
			if (codeUnit == 0x0000) {
				result += "\uFFFD";
				continue;
			}

			if (
				// If the character is in the range [\1-\1F] (U+0001 to U+001F) or is
				// U+007F, […]
				(codeUnit >= 0x0001 && codeUnit <= 0x001F) || codeUnit == 0x007F ||
				// If the character is the first character and is in the range [0-9]
				// (U+0030 to U+0039), […]
				(index == 0 && codeUnit >= 0x0030 && codeUnit <= 0x0039) ||
				// If the character is the second character and is in the range [0-9]
				// (U+0030 to U+0039) and the first character is a `-` (U+002D), […]
				(
					index == 1 &&
					codeUnit >= 0x0030 && codeUnit <= 0x0039 &&
					firstCodeUnit == 0x002D
				)
			) {
				// https://drafts.csswg.org/cssom/#escape-a-character-as-code-point
				result += "\\" + codeUnit.toString(16) + " ";
				continue;
			}

			if (
				// If the character is the first character and is a `-` (U+002D), and
				// there is no second character, […]
				index == 0 &&
				length == 1 &&
				codeUnit == 0x002D
			) {
				result += "\\" + string.charAt(index);
				continue;
			}

			// support for period character in id
			if (codeUnit == 0x002E) {
				if (string.charAt(0) == "#") {
					result += "\\.";
					continue;
				}
			}


			// If the character is not handled by one of the above rules and is
			// greater than or equal to U+0080, is `-` (U+002D) or `_` (U+005F), or
			// is in one of the ranges [0-9] (U+0030 to U+0039), [A-Z] (U+0041 to
			// U+005A), or [a-z] (U+0061 to U+007A), […]
			if (
				codeUnit >= 0x0080 ||
				codeUnit == 0x002D ||
				codeUnit == 0x005F ||
				codeUnit == 35 || // Allow #
				codeUnit == 46 || // Allow .
				codeUnit >= 0x0030 && codeUnit <= 0x0039 ||
				codeUnit >= 0x0041 && codeUnit <= 0x005A ||
				codeUnit >= 0x0061 && codeUnit <= 0x007A
			) {
				// the character itself
				result += string.charAt(index);
				continue;
			}

			// Otherwise, the escaped character.
			// https://drafts.csswg.org/cssom/#escape-a-character
			result += "\\" + string.charAt(index);

		}
		return result;
	}

	/**
	 * Creates a new pending promise and provides methods to resolve or reject it.
	 * From: https://developer.mozilla.org/en-US/docs/Mozilla/JavaScript_code_modules/Promise.jsm/Deferred#backwards_forwards_compatible
	 * @returns {object} defered
	 */
	function defer() {
		this.resolve = null;

		this.reject = null;

		this.id = UUID();

		this.promise = new Promise((resolve, reject) => {
			this.resolve = resolve;
			this.reject = reject;
		});
		Object.freeze(this);
	}

	const requestIdleCallback = typeof window !== "undefined" && ("requestIdleCallback" in window ? window.requestIdleCallback : window.requestAnimationFrame);

	function CSSValueToString(obj) {
		return obj.value + (obj.unit || "");
	}

	function isElement(node) {
		return node && node.nodeType === 1;
	}

	function isText(node) {
		return node && node.nodeType === 3;
	}

	function *walk(start, limiter) {
		let node = start;

		while (node) {

			yield node;

			if (node.childNodes.length) {
				node = node.firstChild;
			} else if (node.nextSibling) {
				if (limiter && node === limiter) {
					node = undefined;
					break;
				}
				node = node.nextSibling;
			} else {
				while (node) {
					node = node.parentNode;
					if (limiter && node === limiter) {
						node = undefined;
						break;
					}
					if (node && node.nextSibling) {
						node = node.nextSibling;
						break;
					}

				}
			}
		}
	}

	function nodeAfter(node, limiter) {
		if (limiter && node === limiter) {
			return;
		}
		let significantNode = nextSignificantNode(node);
		if (significantNode) {
			return significantNode;
		}
		if (node.parentNode) {
			while ((node = node.parentNode)) {
				if (limiter && node === limiter) {
					return;
				}
				significantNode = nextSignificantNode(node);
				if (significantNode) {
					return significantNode;
				}
			}
		}
	}

	function nodeBefore(node, limiter) {
		if (limiter && node === limiter) {
			return;
		}
		let significantNode = previousSignificantNode(node);
		if (significantNode) {
			return significantNode;
		}
		if (node.parentNode) {
			while ((node = node.parentNode)) {
				if (limiter && node === limiter) {
					return;
				}
				significantNode = previousSignificantNode(node);
				if (significantNode) {
					return significantNode;
				}
			}
		}
	}

	function elementAfter(node, limiter) {
		let after = nodeAfter(node, limiter);

		while (after && after.nodeType !== 1) {
			after = nodeAfter(after, limiter);
		}

		return after;
	}

	function elementBefore(node, limiter) {
		let before = nodeBefore(node, limiter);

		while (before && before.nodeType !== 1) {
			before = nodeBefore(before, limiter);
		}

		return before;
	}

	function displayedElementAfter(node, limiter) {
		let after = elementAfter(node, limiter);

		while (after && after.dataset.undisplayed) {
			after = elementAfter(after);
		}

		return after;
	}

	function displayedElementBefore(node, limiter) {
		let before = elementBefore(node, limiter);

		while (before && before.dataset.undisplayed) {
			before = elementBefore(before);
		}

		return before;
	}

	function rebuildAncestors(node) {
		let parent, ancestor;
		let ancestors = [];
		let added = [];

		let fragment = document.createDocumentFragment();

		// Gather all ancestors
		let element = node;
		while(element.parentNode && element.parentNode.nodeType === 1) {
			ancestors.unshift(element.parentNode);
			element = element.parentNode;
		}

		for (var i = 0; i < ancestors.length; i++) {
			ancestor = ancestors[i];
			parent = ancestor.cloneNode(false);

			parent.setAttribute("data-split-from", parent.getAttribute("data-ref"));
			// ancestor.setAttribute("data-split-to", parent.getAttribute("data-ref"));

			if (parent.hasAttribute("id")) {
				let dataID = parent.getAttribute("id");
				parent.setAttribute("data-id", dataID);
				parent.removeAttribute("id");
			}

			// This is handled by css :not, but also tidied up here
			if (parent.hasAttribute("data-break-before")) {
				parent.removeAttribute("data-break-before");
			}

			if (parent.hasAttribute("data-previous-break-after")) {
				parent.removeAttribute("data-previous-break-after");
			}

			if (added.length) {
				let container = added[added.length-1];
				container.appendChild(parent);
			} else {
				fragment.appendChild(parent);
			}
			added.push(parent);
		}

		added = undefined;
		return fragment;
	}

	/*
	export function split(bound, cutElement, breakAfter) {
			let needsRemoval = [];
			let index = indexOf(cutElement);

			if (!breakAfter && index === 0) {
				return;
			}

			if (breakAfter && index === (cutElement.parentNode.children.length - 1)) {
				return;
			}

			// Create a fragment with rebuilt ancestors
			let fragment = rebuildAncestors(cutElement);

			// Clone cut
			if (!breakAfter) {
				let clone = cutElement.cloneNode(true);
				let ref = cutElement.parentNode.getAttribute('data-ref');
				let parent = fragment.querySelector("[data-ref='" + ref + "']");
				parent.appendChild(clone);
				needsRemoval.push(cutElement);
			}

			// Remove all after cut
			let next = nodeAfter(cutElement, bound);
			while (next) {
				let clone = next.cloneNode(true);
				let ref = next.parentNode.getAttribute('data-ref');
				let parent = fragment.querySelector("[data-ref='" + ref + "']");
				parent.appendChild(clone);
				needsRemoval.push(next);
				next = nodeAfter(next, bound);
			}

			// Remove originals
			needsRemoval.forEach((node) => {
				if (node) {
					node.remove();
				}
			});

			// Insert after bounds
			bound.parentNode.insertBefore(fragment, bound.nextSibling);
			return [bound, bound.nextSibling];
	}
	*/

	function needsBreakBefore(node) {
		if( typeof node !== "undefined" &&
				typeof node.dataset !== "undefined" &&
				typeof node.dataset.breakBefore !== "undefined" &&
				(node.dataset.breakBefore === "always" ||
				 node.dataset.breakBefore === "page" ||
				 node.dataset.breakBefore === "left" ||
				 node.dataset.breakBefore === "right" ||
				 node.dataset.breakBefore === "recto" ||
				 node.dataset.breakBefore === "verso")
			 ) {
			return true;
		}

		return false;
	}

	function needsPreviousBreakAfter(node) {
		if( typeof node !== "undefined" &&
				typeof node.dataset !== "undefined" &&
				typeof node.dataset.previousBreakAfter !== "undefined" &&
				(node.dataset.previousBreakAfter === "always" ||
				 node.dataset.previousBreakAfter === "page" ||
				 node.dataset.previousBreakAfter === "left" ||
				 node.dataset.previousBreakAfter === "right" ||
				 node.dataset.previousBreakAfter === "recto" ||
				 node.dataset.previousBreakAfter === "verso")
			 ) {
			return true;
		}

		return false;
	}

	function needsPageBreak(node, previousSignificantNode) {
		if (typeof node === "undefined" || !previousSignificantNode || isIgnorable(node)) {
			return false;
		}
		if (node.dataset && node.dataset.undisplayed) {
			return false;
		}
		const previousSignificantNodePage = previousSignificantNode.dataset ? previousSignificantNode.dataset.page : undefined;
		const currentNodePage = node.dataset ? node.dataset.page : undefined;
		return currentNodePage !== previousSignificantNodePage;
	}

	function *words(node) {
		let currentText = node.nodeValue;
		let max = currentText.length;
		let currentOffset = 0;
		let currentLetter;

		let range;

		while(currentOffset < max) {
			currentLetter = currentText[currentOffset];
			if (/^[\S\u202F\u00A0]$/.test(currentLetter)) {
				if (!range) {
					range = document.createRange();
					range.setStart(node, currentOffset);
				}
			} else {
				if (range) {
					range.setEnd(node, currentOffset);
					yield range;
					range = undefined;
				}
			}

			currentOffset += 1;
		}

		if (range) {
			range.setEnd(node, currentOffset);
			yield range;
			range = undefined;
		}
	}

	function *letters(wordRange) {
		let currentText = wordRange.startContainer;
		let max = currentText.length;
		let currentOffset = wordRange.startOffset;
		// let currentLetter;

		let range;

		while(currentOffset < max) {
			 // currentLetter = currentText[currentOffset];
			 range = document.createRange();
			 range.setStart(currentText, currentOffset);
			 range.setEnd(currentText, currentOffset+1);

			 yield range;

			 currentOffset += 1;
		}
	}

	function isContainer(node) {
		let container;

		if (typeof node.tagName === "undefined") {
			return true;
		}

		if (node.style && node.style.display === "none") {
			return false;
		}

		switch (node.tagName) {
			// Inline
			case "A":
			case "ABBR":
			case "ACRONYM":
			case "B":
			case "BDO":
			case "BIG":
			case "BR":
			case "BUTTON":
			case "CITE":
			case "CODE":
			case "DFN":
			case "EM":
			case "I":
			case "IMG":
			case "INPUT":
			case "KBD":
			case "LABEL":
			case "MAP":
			case "OBJECT":
			case "Q":
			case "SAMP":
			case "SCRIPT":
			case "SELECT":
			case "SMALL":
			case "SPAN":
			case "STRONG":
			case "SUB":
			case "SUP":
			case "TEXTAREA":
			case "TIME":
			case "TT":
			case "VAR":
			case "P":
			case "H1":
			case "H2":
			case "H3":
			case "H4":
			case "H5":
			case "H6":
			case "FIGCAPTION":
			case "BLOCKQUOTE":
			case "PRE":
			case "LI":
			case "TR":
			case "DT":
			case "DD":
			case "VIDEO":
			case "CANVAS":
				container = false;
				break;
			default:
				container = true;
		}

		return container;
	}

	function cloneNode(n, deep=false) {
		return n.cloneNode(deep);
	}

	function findElement(node, doc) {
		const ref = node.getAttribute("data-ref");
		return findRef(ref, doc);
	}

	function findRef(ref, doc) {
		return doc.querySelector(`[data-ref='${ref}']`);
	}

	function validNode(node) {
		if (isText(node)) {
			return true;
		}

		if (isElement(node) && node.dataset.ref) {
			return true;
		}

		return false;
	}

	function prevValidNode(node) {
		while (!validNode(node)) {
			if (node.previousSibling) {
				node = node.previousSibling;
			} else {
				node = node.parentNode;
			}

			if (!node) {
				break;
			}
		}

		return node;
	}


	function indexOf$1(node) {
		let parent = node.parentNode;
		if (!parent) {
			return 0;
		}
		return Array.prototype.indexOf.call(parent.childNodes, node);
	}

	function child(node, index) {
		return node.childNodes[index];
	}

	function hasContent(node) {
		if (isElement(node)) {
			return true;
		} else if (isText(node) &&
				node.textContent.trim().length) {
			return true;
		}
		return false;
	}

	function indexOfTextNode(node, parent) {
		if (!isText(node)) {
			return -1;
		}
		let nodeTextContent = node.textContent;
		let child;
		let index = -1;
		for (var i = 0; i < parent.childNodes.length; i++) {
			child = parent.childNodes[i];
			if (child.nodeType === 3) {
				let text = parent.childNodes[i].textContent;
				if (text.includes(nodeTextContent)) {
					index = i;
					break;
				}
			}
		}

		return index;
	}


	/**
	 * Throughout, whitespace is defined as one of the characters
	 *  "\t" TAB \u0009
	 *  "\n" LF  \u000A
	 *  "\r" CR  \u000D
	 *  " "  SPC \u0020
	 *
	 * This does not use Javascript's "\s" because that includes non-breaking
	 * spaces (and also some other characters).
	 */

	/**
	 * Determine if a node should be ignored by the iterator functions.
	 * taken from https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model/Whitespace#Whitespace_helper_functions
	 *
	 * @param {Node} node An object implementing the DOM1 |Node| interface.
	 * @return {boolean} true if the node is:
	 *  1) A |Text| node that is all whitespace
	 *  2) A |Comment| node
	 *  and otherwise false.
	 */
	function isIgnorable(node) {
		return (node.nodeType === 8) || // A comment node
			((node.nodeType === 3) && isAllWhitespace(node)); // a text node, all whitespace
	}

	/**
	 * Determine whether a node's text content is entirely whitespace.
	 *
	 * @param {Node} node  A node implementing the |CharacterData| interface (i.e., a |Text|, |Comment|, or |CDATASection| node
	 * @return {boolean} true if all of the text content of |nod| is whitespace, otherwise false.
	 */
	function isAllWhitespace(node) {
		return !(/[^\t\n\r ]/.test(node.textContent));
	}

	/**
	 * Version of |previousSibling| that skips nodes that are entirely
	 * whitespace or comments.  (Normally |previousSibling| is a property
	 * of all DOM nodes that gives the sibling node, the node that is
	 * a child of the same parent, that occurs immediately before the
	 * reference node.)
	 *
	 * @param {ChildNode} sib  The reference node.
	 * @return {Node|null} Either:
	 *  1) The closest previous sibling to |sib| that is not ignorable according to |is_ignorable|, or
	 *  2) null if no such node exists.
	 */
	function previousSignificantNode(sib) {
		while ((sib = sib.previousSibling)) {
			if (!isIgnorable(sib)) return sib;
		}
		return null;
	}

	function breakInsideAvoidParentNode(node) {
		while ((node = node.parentNode)) {
			if (node && node.dataset && node.dataset.breakInside === "avoid") {
				return node;
			}
		}
		return null;
	}

	/**
	 * Find a parent with a given node name.
	 * @param {Node} node - initial Node
	 * @param {string} nodeName - node name (eg. "TD", "TABLE", "STRONG"...)
	 * @param {Node} limiter - go up to the parent until there's no more parent or the current node is equals to the limiter
	 * @returns {Node|undefined} - Either:
	 *  1) The closest parent for a the given node name, or
	 *  2) undefined if no such node exists.
	 */
	function parentOf(node, nodeName, limiter) {
		if (limiter && node === limiter) {
			return;
		}
		if (node.parentNode) {
			while ((node = node.parentNode)) {
				if (limiter && node === limiter) {
					return;
				}
				if (node.nodeName === nodeName) {
					return node;
				}
			}
		}
	}

	/**
	 * Version of |nextSibling| that skips nodes that are entirely
	 * whitespace or comments.
	 *
	 * @param {ChildNode} sib  The reference node.
	 * @return {Node|null} Either:
	 *  1) The closest next sibling to |sib| that is not ignorable according to |is_ignorable|, or
	 *  2) null if no such node exists.
	 */
	function nextSignificantNode(sib) {
		while ((sib = sib.nextSibling)) {
			if (!isIgnorable(sib)) return sib;
		}
		return null;
	}

	function filterTree(content, func, what) {
		const treeWalker = document.createTreeWalker(
			content || this.dom,
			what || NodeFilter.SHOW_ALL,
			func ? { acceptNode: func } : null,
			false
		);

		let node;
		let current;
		node = treeWalker.nextNode();
		while(node) {
			current = node;
			node = treeWalker.nextNode();
			current.parentNode.removeChild(current);
		}
	}

	/**
	 * Layout
	 * @class
	 */
	class BreakToken {

		constructor(node, offset) {
			this.node = node;
			this.offset = offset;
		}

		equals(otherBreakToken) {
			if (!otherBreakToken) {
				return false;
			}
			if (this["node"] && otherBreakToken["node"] &&
				this["node"] !== otherBreakToken["node"]) {
				return false;
			}
			if (this["offset"] && otherBreakToken["offset"] &&
				this["offset"] !== otherBreakToken["offset"]) {
				return false;
			}
			return true;
		}

	}

	const MAX_CHARS_PER_BREAK = 1500;

	/**
	 * Layout
	 * @class
	 */
	class Layout {

		constructor(element, hooks, options) {
			this.element = element;

			this.bounds = this.element.getBoundingClientRect();

			if (hooks) {
				this.hooks = hooks;
			} else {
				this.hooks = {};
				this.hooks.layout = new Hook();
				this.hooks.renderNode = new Hook();
				this.hooks.layoutNode = new Hook();
				this.hooks.beforeOverflow = new Hook();
				this.hooks.onOverflow = new Hook();
				this.hooks.onBreakToken = new Hook();
			}

			this.settings = options || {};

			this.maxChars = this.settings.maxChars || MAX_CHARS_PER_BREAK;
			this.forceRenderBreak = false;
		}

		async renderTo(wrapper, source, breakToken, bounds = this.bounds) {
			let start = this.getStart(source, breakToken);
			let walker = walk(start, source);

			let node;
			let prevNode;
			let done;
			let next;

			let hasRenderedContent = false;
			let newBreakToken;

			let length = 0;

			let prevBreakToken = breakToken || new BreakToken(start);

			while (!done && !newBreakToken) {
				next = walker.next();
				prevNode = node;
				node = next.value;
				done = next.done;

				if (!node) {
					this.hooks && this.hooks.layout.trigger(wrapper, this);

					let imgs = wrapper.querySelectorAll("img");
					if (imgs.length) {
						await this.waitForImages(imgs);
					}

					newBreakToken = this.findBreakToken(wrapper, source, bounds, prevBreakToken);

					if (newBreakToken && newBreakToken.equals(prevBreakToken)) {
						console.warn("Unable to layout item: ", prevNode);
						return undefined;
					}
					return newBreakToken;
				}

				this.hooks && this.hooks.layoutNode.trigger(node);

				// Check if the rendered element has a break set
				if (hasRenderedContent && this.shouldBreak(node)) {
					this.hooks && this.hooks.layout.trigger(wrapper, this);

					let imgs = wrapper.querySelectorAll("img");
					if (imgs.length) {
						await this.waitForImages(imgs);
					}

					newBreakToken = this.findBreakToken(wrapper, source, bounds, prevBreakToken);

					if (!newBreakToken) {
						newBreakToken = this.breakAt(node);
					}

					if (newBreakToken && newBreakToken.equals(prevBreakToken)) {
						console.warn("Unable to layout item: ", node);
						return undefined;
					}

					length = 0;

					break;
				}

				// Should the Node be a shallow or deep clone
				let shallow = isContainer(node);

				let rendered = this.append(node, wrapper, breakToken, shallow);

				length += rendered.textContent.length;

				// Check if layout has content yet
				if (!hasRenderedContent) {
					hasRenderedContent = hasContent(node);
				}

				// Skip to the next node if a deep clone was rendered
				if (!shallow) {
					walker = walk(nodeAfter(node, source), source);
				}

				if (this.forceRenderBreak) {
					this.hooks && this.hooks.layout.trigger(wrapper, this);

					newBreakToken = this.findBreakToken(wrapper, source, bounds, prevBreakToken);

					if (!newBreakToken) {
						newBreakToken = this.breakAt(node);
					}

					length = 0;
					this.forceRenderBreak = false;

					break;
				}

				// Only check x characters
				if (length >= this.maxChars) {

					this.hooks && this.hooks.layout.trigger(wrapper, this);

					let imgs = wrapper.querySelectorAll("img");
					if (imgs.length) {
						await this.waitForImages(imgs);
					}

					newBreakToken = this.findBreakToken(wrapper, source, bounds, prevBreakToken);

					if (newBreakToken && newBreakToken.equals(prevBreakToken)) {
						console.warn("Unable to layout item: ", node);
						return undefined;
					}

					if (newBreakToken) {
						length = 0;
					}
				}

			}

			return newBreakToken;
		}

		breakAt(node, offset = 0) {
			let newBreakToken = new BreakToken(
				node,
				offset
			);
			let breakHooks = this.hooks.onBreakToken.triggerSync(newBreakToken, undefined, node, this);
			breakHooks.forEach((newToken) => {
				if (typeof newToken != "undefined") {
					newBreakToken = newToken;
				}
			});

			return newBreakToken;
		}

		shouldBreak(node) {
			let previousSibling = previousSignificantNode(node);
			let parentNode = node.parentNode;
			let parentBreakBefore = needsBreakBefore(node) && parentNode && !previousSibling && needsBreakBefore(parentNode);
			let doubleBreakBefore;

			if (parentBreakBefore) {
				doubleBreakBefore = node.dataset.breakBefore === parentNode.dataset.breakBefore;
			}

			return !doubleBreakBefore && needsBreakBefore(node) || needsPreviousBreakAfter(node) || needsPageBreak(node, previousSibling);
		}

		forceBreak() {
			this.forceRenderBreak = true;
		}

		getStart(source, breakToken) {
			let start;
			let node = breakToken && breakToken.node;

			if (node) {
				start = node;
			} else {
				start = source.firstChild;
			}

			return start;
		}

		append(node, dest, breakToken, shallow = true, rebuild = true) {

			let clone = cloneNode(node, !shallow);

			if (node.parentNode && isElement(node.parentNode)) {
				let parent = findElement(node.parentNode, dest);
				// Rebuild chain
				if (parent) {
					parent.appendChild(clone);
				} else if (rebuild) {
					let fragment = rebuildAncestors(node);
					parent = findElement(node.parentNode, fragment);
					if (!parent) {
						dest.appendChild(clone);
					} else if (breakToken && isText(breakToken.node) && breakToken.offset > 0) {
						clone.textContent = clone.textContent.substring(breakToken.offset);
						parent.appendChild(clone);
					} else {
						parent.appendChild(clone);
					}

					dest.appendChild(fragment);
				} else {
					dest.appendChild(clone);
				}


			} else {
				dest.appendChild(clone);
			}

			let nodeHooks = this.hooks.renderNode.triggerSync(clone, node, this);
			nodeHooks.forEach((newNode) => {
				if (typeof newNode != "undefined") {
					clone = newNode;
				}
			});

			return clone;
		}

		async waitForImages(imgs) {
			let results = Array.from(imgs).map(async (img) => {
				return this.awaitImageLoaded(img);
			});
			await Promise.all(results);
		}

		async awaitImageLoaded(image) {
			return new Promise(resolve => {
				if (image.complete !== true) {
					image.onload = function () {
						let {width, height} = window.getComputedStyle(image);
						resolve(width, height);
					};
					image.onerror = function (e) {
						let {width, height} = window.getComputedStyle(image);
						resolve(width, height, e);
					};
				} else {
					let {width, height} = window.getComputedStyle(image);
					resolve(width, height);
				}
			});
		}

		avoidBreakInside(node, limiter) {
			let breakNode;

			if (node === limiter) {
				return;
			}

			while (node.parentNode) {
				node = node.parentNode;

				if (node === limiter) {
					break;
				}

				if (window.getComputedStyle(node)["break-inside"] === "avoid") {
					breakNode = node;
					break;
				}

			}
			return breakNode;
		}

		createBreakToken(overflow, rendered, source) {
			let container = overflow.startContainer;
			let offset = overflow.startOffset;
			let node, renderedNode, parent, index, temp;

			if (isElement(container)) {
				temp = child(container, offset);

				if (isElement(temp)) {
					renderedNode = findElement(temp, rendered);

					if (!renderedNode) {
						// Find closest element with data-ref
						let prevNode = prevValidNode(temp);
						if (!isElement(prevNode)) {
							prevNode = prevNode.parentElement;
						}
						renderedNode = findElement(prevNode, rendered);
						// Check if temp is the last rendered node at its level.
						if (!temp.nextSibling) {
							// We need to ensure that the previous sibling of temp is fully rendered.
							const renderedNodeFromSource = findElement(renderedNode, source);
							const walker = document.createTreeWalker(renderedNodeFromSource, NodeFilter.SHOW_ELEMENT);
							const lastChildOfRenderedNodeFromSource = walker.lastChild();
							const lastChildOfRenderedNodeMatchingFromRendered = findElement(lastChildOfRenderedNodeFromSource, rendered);
							// Check if we found that the last child in source
							if (!lastChildOfRenderedNodeMatchingFromRendered) {
								// Pending content to be rendered before virtual break token
								return;
							}
							// Otherwise we will return a break token as per below
						}
						// renderedNode is actually the last unbroken box that does not overflow.
						// Break Token is therefore the next sibling of renderedNode within source node.
						node = findElement(renderedNode, source).nextSibling;
						offset = 0;
					} else {
						node = findElement(renderedNode, source);
						offset = 0;
					}
				} else {
					renderedNode = findElement(container, rendered);

					if (!renderedNode) {
						renderedNode = findElement(prevValidNode(container), rendered);
					}

					parent = findElement(renderedNode, source);
					index = indexOfTextNode(temp, parent);
					// No seperatation for the first textNode of an element
					if(index === 0) {
						node = parent;
						offset = 0;
					} else {
						node = child(parent, index);
						offset = 0;
					}
				}
			} else {
				renderedNode = findElement(container.parentNode, rendered);

				if (!renderedNode) {
					renderedNode = findElement(prevValidNode(container.parentNode), rendered);
				}

				parent = findElement(renderedNode, source);
				index = indexOfTextNode(container, parent);

				if (index === -1) {
					return;
				}

				node = child(parent, index);

				offset += node.textContent.indexOf(container.textContent);
			}

			if (!node) {
				return;
			}

			return new BreakToken(
				node,
				offset
			);

		}

		findBreakToken(rendered, source, bounds = this.bounds, prevBreakToken, extract = true) {
			let overflow = this.findOverflow(rendered, bounds);
			let breakToken, breakLetter;

			let overflowHooks = this.hooks.onOverflow.triggerSync(overflow, rendered, bounds, this);
			overflowHooks.forEach((newOverflow) => {
				if (typeof newOverflow != "undefined") {
					overflow = newOverflow;
				}
			});

			if (overflow) {
				breakToken = this.createBreakToken(overflow, rendered, source);
				// breakToken is nullable
				let breakHooks = this.hooks.onBreakToken.triggerSync(breakToken, overflow, rendered, this);
				breakHooks.forEach((newToken) => {
					if (typeof newToken != "undefined") {
						breakToken = newToken;
					}
				});

				// Stop removal if we are in a loop
				if (breakToken && breakToken.equals(prevBreakToken)) {
					return breakToken;
				}

				if (breakToken && breakToken["node"] && breakToken["offset"] && breakToken["node"].textContent) {
					breakLetter = breakToken["node"].textContent.charAt(breakToken["offset"]);
				} else {
					breakLetter = undefined;
				}

				if (breakToken && breakToken.node && extract) {
					this.removeOverflow(overflow, breakLetter);
				}

			}
			return breakToken;
		}

		hasOverflow(element, bounds = this.bounds) {
			let constrainingElement = element && element.parentNode; // this gets the element, instead of the wrapper for the width workaround
			let {width} = element.getBoundingClientRect();
			let scrollWidth = constrainingElement ? constrainingElement.scrollWidth : 0;
			return Math.max(Math.floor(width), scrollWidth) > Math.round(bounds.width);
		}

		findOverflow(rendered, bounds = this.bounds) {
			if (!this.hasOverflow(rendered, bounds)) return;

			let start = Math.round(bounds.left);
			let end = Math.round(bounds.right);
			let range;

			let walker = walk(rendered.firstChild, rendered);

			// Find Start
			let next, done, node, offset, skip, breakAvoid, prev, br;
			while (!done) {
				next = walker.next();
				done = next.done;
				node = next.value;
				skip = false;
				breakAvoid = false;
				prev = undefined;
				br = undefined;

				if (node) {
					let pos = getBoundingClientRect(node);
					let left = Math.round(pos.left);
					let right = Math.floor(pos.right);

					if (!range && left >= end) {
						// Check if it is a float
						let isFloat = false;

						// Check if the node is inside a break-inside: avoid table cell
						const insideTableCell = parentOf(node, "TD", rendered);
						if (insideTableCell && window.getComputedStyle(insideTableCell)["break-inside"] === "avoid") {
							// breaking inside a table cell produces unexpected result, as a workaround, we forcibly avoid break inside in a cell.
							prev = insideTableCell;
						} else if (isElement(node)) {
							let styles = window.getComputedStyle(node);
							isFloat = styles.getPropertyValue("float") !== "none";
							skip = styles.getPropertyValue("break-inside") === "avoid";
							breakAvoid = node.dataset.breakBefore === "avoid" || node.dataset.previousBreakAfter === "avoid";
							prev = breakAvoid && nodeBefore(node, rendered);
							br = node.tagName === "BR" || node.tagName === "WBR";
						}

						if (prev) {
							range = document.createRange();
							range.selectNode(prev);
							break;
						}

						if (!br && !isFloat && isElement(node)) {
							range = document.createRange();
							range.selectNode(node);
							break;
						}

						if (isText(node) && node.textContent.trim().length) {
							range = document.createRange();
							range.selectNode(node);
							break;
						}

					}

					if (!range && isText(node) &&
						node.textContent.trim().length &&
						!breakInsideAvoidParentNode(node.parentNode)) {

						let rects = getClientRects(node);
						let rect;
						left = 0;
						for (var i = 0; i != rects.length; i++) {
							rect = rects[i];
							if (rect.width > 0 && (!left || rect.left > left)) {
								left = rect.left;
							}
						}

						if (left >= end) {
							range = document.createRange();
							offset = this.textBreak(node, start, end);
							if (!offset) {
								range = undefined;
							} else {
								range.setStart(node, offset);
							}
							break;
						}
					}

					// Skip children
					if (skip || right <= end) {
						next = nodeAfter(node, rendered);
						if (next) {
							walker = walk(next, rendered);
						}

					}

				}
			}

			// Find End
			if (range) {
				range.setEndAfter(rendered.lastChild);
				return range;
			}

		}

		findEndToken(rendered, source, bounds = this.bounds) {
			if (rendered.childNodes.length === 0) {
				return;
			}

			let lastChild = rendered.lastChild;

			let lastNodeIndex;
			while (lastChild && lastChild.lastChild) {
				if (!validNode(lastChild)) {
					// Only get elements with refs
					lastChild = lastChild.previousSibling;
				} else if (!validNode(lastChild.lastChild)) {
					// Deal with invalid dom items
					lastChild = prevValidNode(lastChild.lastChild);
					break;
				} else {
					lastChild = lastChild.lastChild;
				}
			}

			if (isText(lastChild)) {

				if (lastChild.parentNode.dataset.ref) {
					lastNodeIndex = indexOf$1(lastChild);
					lastChild = lastChild.parentNode;
				} else {
					lastChild = lastChild.previousSibling;
				}
			}

			let original = findElement(lastChild, source);

			if (lastNodeIndex) {
				original = original.childNodes[lastNodeIndex];
			}

			let after = nodeAfter(original);

			return this.breakAt(after);
		}

		textBreak(node, start, end) {
			let wordwalker = words(node);
			let left = 0;
			let right = 0;
			let word, next, done, pos;
			let offset;
			while (!done) {
				next = wordwalker.next();
				word = next.value;
				done = next.done;

				if (!word) {
					break;
				}

				pos = getBoundingClientRect(word);

				left = Math.floor(pos.left);
				right = Math.floor(pos.right);

				if (left >= end) {
					offset = word.startOffset;
					break;
				}

				if (right > end) {
					let letterwalker = letters(word);
					let letter, nextLetter, doneLetter;

					while (!doneLetter) {
						nextLetter = letterwalker.next();
						letter = nextLetter.value;
						doneLetter = nextLetter.done;

						if (!letter) {
							break;
						}

						pos = getBoundingClientRect(letter);
						left = Math.floor(pos.left);

						if (left >= end) {
							offset = letter.startOffset;
							done = true;

							break;
						}
					}
				}

			}

			return offset;
		}

		removeOverflow(overflow, breakLetter) {
			let {startContainer} = overflow;
			let extracted = overflow.extractContents();

			this.hyphenateAtBreak(startContainer, breakLetter);

			return extracted;
		}

		hyphenateAtBreak(startContainer, breakLetter) {
			if (isText(startContainer)) {
				let startText = startContainer.textContent;
				let prevLetter = startText[startText.length - 1];

				// Add a hyphen if previous character is a letter or soft hyphen
				if (
					(breakLetter && /^\w|\u00AD$/.test(prevLetter) && /^\w|\u00AD$/.test(breakLetter)) ||
					(!breakLetter && /^\w|\u00AD$/.test(prevLetter))
				) {
					startContainer.parentNode.classList.add("pagedjs_hyphen");
					startContainer.textContent += this.settings.hyphenGlyph || "\u2011";
				}
			}
		}

		equalTokens(a, b) {
			if (!a || !b) {
				return false;
			}
			if (a["node"] && b["node"] && a["node"] !== b["node"]) {
				return false;
			}
			if (a["offset"] && b["offset"] && a["offset"] !== b["offset"]) {
				return false;
			}
			return true;
		}
	}

	eventEmitter(Layout.prototype);

	/**
	 * Render a page
	 * @class
	 */
	class Page {
		constructor(pagesArea, pageTemplate, blank, hooks) {
			this.pagesArea = pagesArea;
			this.pageTemplate = pageTemplate;
			this.blank = blank;

			this.width = undefined;
			this.height = undefined;

			this.hooks = hooks;

			// this.element = this.create(this.pageTemplate);
		}

		create(template, after) {
			//let documentFragment = document.createRange().createContextualFragment( TEMPLATE );
			//let page = documentFragment.children[0];
			let clone = document.importNode(this.pageTemplate.content, true);

			let page, index;
			if (after) {
				this.pagesArea.insertBefore(clone, after.nextElementSibling);
				index = Array.prototype.indexOf.call(this.pagesArea.children, after.nextElementSibling);
				page = this.pagesArea.children[index];
			} else {
				this.pagesArea.appendChild(clone);
				page = this.pagesArea.lastChild;
			}

			let pagebox = page.querySelector(".pagedjs_pagebox");
			let area = page.querySelector(".pagedjs_page_content");


			let size = area.getBoundingClientRect();


			area.style.columnWidth = Math.round(size.width) + "px";
			area.style.columnGap = "calc(var(--pagedjs-margin-right) + var(--pagedjs-margin-left))";
			// area.style.overflow = "scroll";

			this.width = Math.round(size.width);
			this.height = Math.round(size.height);

			this.element = page;
			this.pagebox = pagebox;
			this.area = area;

			return page;
		}

		createWrapper() {
			let wrapper = document.createElement("div");

			this.area.appendChild(wrapper);

			this.wrapper = wrapper;

			return wrapper;
		}

		index(pgnum) {
			this.position = pgnum;

			let page = this.element;
			// let pagebox = this.pagebox;

			let index = pgnum + 1;

			let id = `page-${index}`;

			this.id = id;

			// page.dataset.pageNumber = index;

			page.dataset.pageNumber = index;
			page.setAttribute("id", id);

			if (this.name) {
				page.classList.add("pagedjs_" + this.name + "_page");
			}

			if (this.blank) {
				page.classList.add("pagedjs_blank_page");
			}

			if (pgnum === 0) {
				page.classList.add("pagedjs_first_page");
			}

			if (pgnum % 2 !== 1) {
				page.classList.remove("pagedjs_left_page");
				page.classList.add("pagedjs_right_page");
			} else {
				page.classList.remove("pagedjs_right_page");
				page.classList.add("pagedjs_left_page");
			}
		}

		/*
		size(width, height) {
			if (width === this.width && height === this.height) {
				return;
			}
			this.width = width;
			this.height = height;

			this.element.style.width = Math.round(width) + "px";
			this.element.style.height = Math.round(height) + "px";
			this.element.style.columnWidth = Math.round(width) + "px";
		}
		*/

		async layout(contents, breakToken, maxChars) {

			this.clear();

			this.startToken = breakToken;

			this.layoutMethod = new Layout(this.area, this.hooks, maxChars);

			let newBreakToken = await this.layoutMethod.renderTo(this.wrapper, contents, breakToken);
			
			this.addListeners(contents);

			this.endToken = newBreakToken;

			return newBreakToken;
		}

		async append(contents, breakToken) {

			if (!this.layoutMethod) {
				return this.layout(contents, breakToken);
			}

			let newBreakToken = await this.layoutMethod.renderTo(this.wrapper, contents, breakToken);

			this.endToken = newBreakToken;

			return newBreakToken;
		}

		getByParent(ref, entries) {
			let e;
			for (var i = 0; i < entries.length; i++) {
				e = entries[i];
				if (e.dataset.ref === ref) {
					return e;
				}
			}
		}

		onOverflow(func) {
			this._onOverflow = func;
		}

		onUnderflow(func) {
			this._onUnderflow = func;
		}

		clear() {
			this.removeListeners();
			this.wrapper && this.wrapper.remove();
			this.createWrapper();
		}

		addListeners(contents) {
			if (typeof ResizeObserver !== "undefined") {
				this.addResizeObserver(contents);
			} else {
				this._checkOverflowAfterResize = this.checkOverflowAfterResize.bind(this, contents);
				this.element.addEventListener("overflow", this._checkOverflowAfterResize, false);
				this.element.addEventListener("underflow", this._checkOverflowAfterResize, false);
			}
			// TODO: fall back to mutation observer?

			this._onScroll = function () {
				if (this.listening) {
					this.element.scrollLeft = 0;
				}
			}.bind(this);

			// Keep scroll left from changing
			this.element.addEventListener("scroll", this._onScroll);

			this.listening = true;

			return true;
		}

		removeListeners() {
			this.listening = false;

			if (typeof ResizeObserver !== "undefined" && this.ro) {
				this.ro.disconnect();
			} else if (this.element) {
				this.element.removeEventListener("overflow", this._checkOverflowAfterResize, false);
				this.element.removeEventListener("underflow", this._checkOverflowAfterResize, false);
			}

			this.element && this.element.removeEventListener("scroll", this._onScroll);

		}

		addResizeObserver(contents) {
			let wrapper = this.wrapper;
			let prevHeight = wrapper.getBoundingClientRect().height;
			this.ro = new ResizeObserver(entries => {

				if (!this.listening) {
					return;
				}
				requestAnimationFrame(() => {
					for (let entry of entries) {
						const cr = entry.contentRect;

						if (cr.height > prevHeight) {
							this.checkOverflowAfterResize(contents);
							prevHeight = wrapper.getBoundingClientRect().height;
						} else if (cr.height < prevHeight) { // TODO: calc line height && (prevHeight - cr.height) >= 22
							this.checkUnderflowAfterResize(contents);
							prevHeight = cr.height;
						}
					}
				});
			});

			this.ro.observe(wrapper);
		}

		checkOverflowAfterResize(contents) {
			if (!this.listening || !this.layoutMethod) {
				return;
			}

			let newBreakToken = this.layoutMethod.findBreakToken(this.wrapper, contents, this.startToken);

			if (newBreakToken) {
				this.endToken = newBreakToken;
				this._onOverflow && this._onOverflow(newBreakToken);
			}
		}

		checkUnderflowAfterResize(contents) {
			if (!this.listening || !this.layoutMethod) {
				return;
			}

			let endToken = this.layoutMethod.findEndToken(this.wrapper, contents);

			if (endToken) {
				this._onUnderflow && this._onUnderflow(endToken);
			}
		}


		destroy() {
			this.removeListeners();

			this.element.remove();

			this.element = undefined;
			this.wrapper = undefined;
		}
	}

	eventEmitter(Page.prototype);

	/**
	 * Render a flow of text offscreen
	 * @class
	 */
	class ContentParser {

		constructor(content, cb) {
			if (content && content.nodeType) {
				// handle dom
				this.dom = this.add(content);
			} else if (typeof content === "string") {
				this.dom = this.parse(content);
			}

			return this.dom;
		}

		parse(markup, mime) {
			let range = document.createRange();
			let fragment = range.createContextualFragment(markup);

			this.addRefs(fragment);

			return fragment;
		}

		add(contents) {
			// let fragment = document.createDocumentFragment();
			//
			// let children = [...contents.childNodes];
			// for (let child of children) {
			// 	let clone = child.cloneNode(true);
			// 	fragment.appendChild(clone);
			// }

			this.addRefs(contents);

			return contents;
		}

		addRefs(content) {
			var treeWalker = document.createTreeWalker(
				content,
				NodeFilter.SHOW_ELEMENT,
				null,
				false
			);

			let node = treeWalker.nextNode();
			while(node) {

				if (!node.hasAttribute("data-ref")) {
					let uuid = UUID();
					node.setAttribute("data-ref", uuid);
				}

				if (node.id) {
					node.setAttribute("data-id", node.id);
				}

				// node.setAttribute("data-children", node.childNodes.length);

				// node.setAttribute("data-text", node.textContent.trim().length);
				node = treeWalker.nextNode();
			}
		}

		find(ref) {
			return this.refs[ref];
		}

		destroy() {
			this.refs = undefined;
			this.dom = undefined;
		}
	}

	/**
	 * Queue for handling tasks one at a time
	 * @class
	 * @param {scope} context what this will resolve to in the tasks
	 */
	class Queue {
		constructor(context){
			this._q = [];
			this.context = context;
			this.tick = requestAnimationFrame;
			this.running = false;
			this.paused = false;
		}

		/**
		 * Add an item to the queue
		 * @return {Promise} enqueued
		 */
		enqueue() {
			var deferred, promise;
			var queued;
			var task = [].shift.call(arguments);
			var args = arguments;

			// Handle single args without context
			// if(args && !Array.isArray(args)) {
			//   args = [args];
			// }
			if(!task) {
				throw new Error("No Task Provided");
			}

			if(typeof task === "function"){

				deferred = new defer();
				promise = deferred.promise;

				queued = {
					"task" : task,
					"args"     : args,
					//"context"  : context,
					"deferred" : deferred,
					"promise" : promise
				};

			} else {
				// Task is a promise
				queued = {
					"promise" : task
				};

			}

			this._q.push(queued);

			// Wait to start queue flush
			if (this.paused == false && !this.running) {
				this.run();
			}

			return queued.promise;
		}

		/**
		 * Run one item
		 * @return {Promise} dequeued
		 */
		dequeue(){
			var inwait, task, result;

			if(this._q.length && !this.paused) {
				inwait = this._q.shift();
				task = inwait.task;
				if(task){
					// console.log(task)

					result = task.apply(this.context, inwait.args);

					if(result && typeof result["then"] === "function") {
						// Task is a function that returns a promise
						return result.then(function(){
							inwait.deferred.resolve.apply(this.context, arguments);
						}.bind(this), function() {
							inwait.deferred.reject.apply(this.context, arguments);
						}.bind(this));
					} else {
						// Task resolves immediately
						inwait.deferred.resolve.apply(this.context, result);
						return inwait.promise;
					}



				} else if(inwait.promise) {
					// Task is a promise
					return inwait.promise;
				}

			} else {
				inwait = new defer();
				inwait.deferred.resolve();
				return inwait.promise;
			}

		}

		// Run All Immediately
		dump(){
			while(this._q.length) {
				this.dequeue();
			}
		}

		/**
		 * Run all tasks sequentially, at convince
		 * @return {Promise} all run
		 */
		run(){

			if(!this.running){
				this.running = true;
				this.defered = new defer();
			}

			this.tick.call(window, () => {

				if(this._q.length) {

					this.dequeue()
						.then(function(){
							this.run();
						}.bind(this));

				} else {
					this.defered.resolve();
					this.running = undefined;
				}

			});

			// Unpause
			if(this.paused == true) {
				this.paused = false;
			}

			return this.defered.promise;
		}

		/**
		 * Flush all, as quickly as possible
		 * @return {Promise} ran
		 */
		flush(){

			if(this.running){
				return this.running;
			}

			if(this._q.length) {
				this.running = this.dequeue()
					.then(function(){
						this.running = undefined;
						return this.flush();
					}.bind(this));

				return this.running;
			}

		}

		/**
		 * Clear all items in wait
		 * @return {void}
		 */
		clear(){
			this._q = [];
		}

		/**
		 * Get the number of tasks in the queue
		 * @return {number} tasks
		 */
		length(){
			return this._q.length;
		}

		/**
		 * Pause a running queue
		 * @return {void}
		 */
		pause(){
			this.paused = true;
		}

		/**
		 * End the queue
		 * @return {void}
		 */
		stop(){
			this._q = [];
			this.running = false;
			this.paused = true;
		}
	}

	const TEMPLATE = `
<div class="pagedjs_page">
	<div class="pagedjs_sheet">
		<div class="pagedjs_bleed pagedjs_bleed-top">
			<div class="pagedjs_marks-crop"></div>
			<div class="pagedjs_marks-middle">
				<div class="pagedjs_marks-cross"></div>
			</div>
			<div class="pagedjs_marks-crop"></div>
		</div>
		<div class="pagedjs_bleed pagedjs_bleed-bottom">
			<div class="pagedjs_marks-crop"></div>
			<div class="pagedjs_marks-middle">
				<div class="pagedjs_marks-cross"></div>
			</div>		<div class="pagedjs_marks-crop"></div>
		</div>
		<div class="pagedjs_bleed pagedjs_bleed-left">
			<div class="pagedjs_marks-crop"></div>
			<div class="pagedjs_marks-middle">
				<div class="pagedjs_marks-cross"></div>
			</div>		<div class="pagedjs_marks-crop"></div>
		</div>
		<div class="pagedjs_bleed pagedjs_bleed-right">
			<div class="pagedjs_marks-crop"></div>
			<div class="pagedjs_marks-middle">
				<div class="pagedjs_marks-cross"></div>
			</div>
			<div class="pagedjs_marks-crop"></div>
		</div>
		<div class="pagedjs_pagebox">
			<div class="pagedjs_margin-top-left-corner-holder">
				<div class="pagedjs_margin pagedjs_margin-top-left-corner"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-top">
				<div class="pagedjs_margin pagedjs_margin-top-left"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-top-center"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-top-right"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-top-right-corner-holder">
				<div class="pagedjs_margin pagedjs_margin-top-right-corner"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-right">
				<div class="pagedjs_margin pagedjs_margin-right-top"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-right-middle"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-right-bottom"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-left">
				<div class="pagedjs_margin pagedjs_margin-left-top"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-left-middle"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-left-bottom"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-bottom-left-corner-holder">
				<div class="pagedjs_margin pagedjs_margin-bottom-left-corner"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-bottom">
				<div class="pagedjs_margin pagedjs_margin-bottom-left"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-bottom-center"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-bottom-right"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-bottom-right-corner-holder">
				<div class="pagedjs_margin pagedjs_margin-bottom-right-corner"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_area">
				<div class="pagedjs_page_content"></div>
			</div>
		</div>
	</div>
</div>`;

	/**
	 * Chop up text into flows
	 * @class
	 */
	class Chunker {
		constructor(content, renderTo, options) {
			// this.preview = preview;

			this.settings = options || {};

			this.hooks = {};
			this.hooks.beforeParsed = new Hook(this);
			this.hooks.filter = new Hook(this);
			this.hooks.afterParsed = new Hook(this);
			this.hooks.beforePageLayout = new Hook(this);
			this.hooks.layout = new Hook(this);
			this.hooks.renderNode = new Hook(this);
			this.hooks.layoutNode = new Hook(this);
			this.hooks.onOverflow = new Hook(this);
			this.hooks.onBreakToken = new Hook();
			this.hooks.afterPageLayout = new Hook(this);
			this.hooks.afterRendered = new Hook(this);

			this.pages = [];
			this.total = 0;

			this.q = new Queue(this);
			this.stopped = false;
			this.rendered = false;

			this.content = content;

			this.charsPerBreak = [];
			this.maxChars;

			if (content) {
				this.flow(content, renderTo);
			}
		}

		setup(renderTo) {
			this.pagesArea = document.createElement("div");
			this.pagesArea.classList.add("pagedjs_pages");

			if (renderTo) {
				renderTo.appendChild(this.pagesArea);
			} else {
				document.querySelector("body").appendChild(this.pagesArea);
			}

			this.pageTemplate = document.createElement("template");
			this.pageTemplate.innerHTML = TEMPLATE;

		}

		async flow(content, renderTo) {
			let parsed;

			await this.hooks.beforeParsed.trigger(content, this);

			parsed = new ContentParser(content);

			this.hooks.filter.triggerSync(parsed);

			this.source = parsed;
			this.breakToken = undefined;

			if (this.pagesArea && this.pageTemplate) {
				this.q.clear();
				this.removePages();
			} else {
				this.setup(renderTo);
			}

			this.emit("rendering", parsed);

			await this.hooks.afterParsed.trigger(parsed, this);

			await this.loadFonts();

			let rendered = await this.render(parsed, this.breakToken);
			while (rendered.canceled) {
				this.start();
				rendered = await this.render(parsed, this.breakToken);
			}

			this.rendered = true;
			this.pagesArea.style.setProperty("--pagedjs-page-count", this.total);

			await this.hooks.afterRendered.trigger(this.pages, this);

			this.emit("rendered", this.pages);



			return this;
		}

		// oversetPages() {
		// 	let overset = [];
		// 	for (let i = 0; i < this.pages.length; i++) {
		// 		let page = this.pages[i];
		// 		if (page.overset) {
		// 			overset.push(page);
		// 			// page.overset = false;
		// 		}
		// 	}
		// 	return overset;
		// }
		//
		// async handleOverset(parsed) {
		// 	let overset = this.oversetPages();
		// 	if (overset.length) {
		// 		console.log("overset", overset);
		// 		let index = this.pages.indexOf(overset[0]) + 1;
		// 		console.log("INDEX", index);
		//
		// 		// Remove pages
		// 		// this.removePages(index);
		//
		// 		// await this.render(parsed, overset[0].overset);
		//
		// 		// return this.handleOverset(parsed);
		// 	}
		// }

		async render(parsed, startAt) {
			let renderer = this.layout(parsed, startAt, this.settings);

			let done = false;
			let result;
			while (!done) {
				result = await this.q.enqueue(() => { return this.renderAsync(renderer); });
				done = result.done;
			}

			return result;
		}

		start() {
			this.rendered = false;
			this.stopped = false;
		}

		stop() {
			this.stopped = true;
			// this.q.clear();
		}

		renderOnIdle(renderer) {
			return new Promise(resolve => {
				requestIdleCallback(async () => {
					if (this.stopped) {
						return resolve({ done: true, canceled: true });
					}
					let result = await renderer.next();
					if (this.stopped) {
						resolve({ done: true, canceled: true });
					} else {
						resolve(result);
					}
				});
			});
		}

		async renderAsync(renderer) {
			if (this.stopped) {
				return { done: true, canceled: true };
			}
			let result = await renderer.next();
			if (this.stopped) {
				return { done: true, canceled: true };
			} else {
				return result;
			}
		}

		async handleBreaks(node) {
			let currentPage = this.total + 1;
			let currentPosition = currentPage % 2 === 0 ? "left" : "right";
			// TODO: Recto and Verso should reverse for rtl languages
			let currentSide = currentPage % 2 === 0 ? "verso" : "recto";
			let previousBreakAfter;
			let breakBefore;
			let page;

			if (currentPage === 1) {
				return;
			}

			if (node &&
					typeof node.dataset !== "undefined" &&
					typeof node.dataset.previousBreakAfter !== "undefined") {
				previousBreakAfter = node.dataset.previousBreakAfter;
			}

			if (node &&
					typeof node.dataset !== "undefined" &&
					typeof node.dataset.breakBefore !== "undefined") {
				breakBefore = node.dataset.breakBefore;
			}

			if( previousBreakAfter &&
					(previousBreakAfter === "left" || previousBreakAfter === "right") &&
					previousBreakAfter !== currentPosition) {
				page = this.addPage(true);
			} else if( previousBreakAfter &&
					(previousBreakAfter === "verso" || previousBreakAfter === "recto") &&
					previousBreakAfter !== currentSide) {
				page = this.addPage(true);
			} else if( breakBefore &&
					(breakBefore === "left" || breakBefore === "right") &&
					breakBefore !== currentPosition) {
				page = this.addPage(true);
			} else if( breakBefore &&
					(breakBefore === "verso" || breakBefore === "recto") &&
					breakBefore !== currentSide) {
				page = this.addPage(true);
			}

			if (page) {
				await this.hooks.beforePageLayout.trigger(page, undefined, undefined, this);
				this.emit("page", page);
				// await this.hooks.layout.trigger(page.element, page, undefined, this);
				await this.hooks.afterPageLayout.trigger(page.element, page, undefined, this);
				this.emit("renderedPage", page);
			}
		}

		async *layout(content, startAt) {
			let breakToken = startAt || false;

			while (breakToken !== undefined && ( true)) {

				if (breakToken && breakToken.node) {
					await this.handleBreaks(breakToken.node);
				} else {
					await this.handleBreaks(content.firstChild);
				}

				let page = this.addPage();

				await this.hooks.beforePageLayout.trigger(page, content, breakToken, this);
				this.emit("page", page);

				// Layout content in the page, starting from the breakToken
				breakToken = await page.layout(content, breakToken, this.maxChars);

				await this.hooks.afterPageLayout.trigger(page.element, page, breakToken, this);
				this.emit("renderedPage", page);

				this.recoredCharLength(page.wrapper.textContent.length);

				yield breakToken;

				// Stop if we get undefined, showing we have reached the end of the content
			}


		}

		recoredCharLength(length) {
			if (length === 0) {
				return;
			}

			this.charsPerBreak.push(length);

			// Keep the length of the last few breaks
			if (this.charsPerBreak.length > 4) {
				this.charsPerBreak.shift();
			}

			this.maxChars = this.charsPerBreak.reduce((a, b) => a + b, 0) / (this.charsPerBreak.length);
		}

		removePages(fromIndex=0) {

			if (fromIndex >= this.pages.length) {
				return;
			}

			// Remove pages
			for (let i = fromIndex; i < this.pages.length; i++) {
				this.pages[i].destroy();
			}

			if (fromIndex > 0) {
				this.pages.splice(fromIndex);
			} else {
				this.pages = [];
			}

			this.total = this.pages.length;
		}

		addPage(blank) {
			let lastPage = this.pages[this.pages.length - 1];
			// Create a new page from the template
			let page = new Page(this.pagesArea, this.pageTemplate, blank, this.hooks);

			this.pages.push(page);

			// Create the pages
			page.create(undefined, lastPage && lastPage.element);

			page.index(this.total);

			if (!blank) {
				// Listen for page overflow
				page.onOverflow((overflowToken) => {
					console.warn("overflow on", page.id, overflowToken);

					// Only reflow while rendering
					if (this.rendered) {
						return;
					}

					let index = this.pages.indexOf(page) + 1;

					// Stop the rendering
					this.stop();

					// Set the breakToken to resume at
					this.breakToken = overflowToken;

					// Remove pages
					this.removePages(index);

					if (this.rendered === true) {
						this.rendered = false;

						this.q.enqueue(async () => {

							this.start();

							await this.render(this.source, this.breakToken);

							this.rendered = true;

						});
					}


				});

				page.onUnderflow((overflowToken) => {
					// console.log("underflow on", page.id, overflowToken);

					// page.append(this.source, overflowToken);

				});
			}

			this.total = this.pages.length;

			return page;
		}
		/*
		insertPage(index, blank) {
			let lastPage = this.pages[index];
			// Create a new page from the template
			let page = new Page(this.pagesArea, this.pageTemplate, blank, this.hooks);

			let total = this.pages.splice(index, 0, page);

			// Create the pages
			page.create(undefined, lastPage && lastPage.element);

			page.index(index + 1);

			for (let i = index + 2; i < this.pages.length; i++) {
				this.pages[i].index(i);
			}

			if (!blank) {
				// Listen for page overflow
				page.onOverflow((overflowToken) => {
					if (total < this.pages.length) {
						this.pages[total].layout(this.source, overflowToken);
					} else {
						let newPage = this.addPage();
						newPage.layout(this.source, overflowToken);
					}
				});

				page.onUnderflow(() => {
					// console.log("underflow on", page.id);
				});
			}

			this.total += 1;

			return page;
		}
		*/



		loadFonts() {
			let fontPromises = [];
			(document.fonts || []).forEach((fontFace) => {
				if (fontFace.status !== "loaded") {
					let fontLoaded = fontFace.load().then((r) => {
						return fontFace.family;
					}, (r) => {
						console.warn("Failed to preload font-family:", fontFace.family);
						return fontFace.family;
					});
					fontPromises.push(fontLoaded);
				}
			});
			return Promise.all(fontPromises).catch((err) => {
				console.warn(err);
			});
		}

		destroy() {
			this.pagesArea.remove();
			this.pageTemplate.remove();
		}

	}

	eventEmitter(Chunker.prototype);

	//
	//                              list
	//                            ┌──────┐
	//             ┌──────────────┼─head │
	//             │              │ tail─┼──────────────┐
	//             │              └──────┘              │
	//             ▼                                    ▼
	//            item        item        item        item
	//          ┌──────┐    ┌──────┐    ┌──────┐    ┌──────┐
	//  null ◀──┼─prev │◀───┼─prev │◀───┼─prev │◀───┼─prev │
	//          │ next─┼───▶│ next─┼───▶│ next─┼───▶│ next─┼──▶ null
	//          ├──────┤    ├──────┤    ├──────┤    ├──────┤
	//          │ data │    │ data │    │ data │    │ data │
	//          └──────┘    └──────┘    └──────┘    └──────┘
	//

	function createItem(data) {
	    return {
	        prev: null,
	        next: null,
	        data: data
	    };
	}

	function allocateCursor(node, prev, next) {
	    var cursor;

	    if (cursors !== null) {
	        cursor = cursors;
	        cursors = cursors.cursor;
	        cursor.prev = prev;
	        cursor.next = next;
	        cursor.cursor = node.cursor;
	    } else {
	        cursor = {
	            prev: prev,
	            next: next,
	            cursor: node.cursor
	        };
	    }

	    node.cursor = cursor;

	    return cursor;
	}

	function releaseCursor(node) {
	    var cursor = node.cursor;

	    node.cursor = cursor.cursor;
	    cursor.prev = null;
	    cursor.next = null;
	    cursor.cursor = cursors;
	    cursors = cursor;
	}

	var cursors = null;
	var List = function() {
	    this.cursor = null;
	    this.head = null;
	    this.tail = null;
	};

	List.createItem = createItem;
	List.prototype.createItem = createItem;

	List.prototype.updateCursors = function(prevOld, prevNew, nextOld, nextNew) {
	    var cursor = this.cursor;

	    while (cursor !== null) {
	        if (cursor.prev === prevOld) {
	            cursor.prev = prevNew;
	        }

	        if (cursor.next === nextOld) {
	            cursor.next = nextNew;
	        }

	        cursor = cursor.cursor;
	    }
	};

	List.prototype.getSize = function() {
	    var size = 0;
	    var cursor = this.head;

	    while (cursor) {
	        size++;
	        cursor = cursor.next;
	    }

	    return size;
	};

	List.prototype.fromArray = function(array) {
	    var cursor = null;

	    this.head = null;

	    for (var i = 0; i < array.length; i++) {
	        var item = createItem(array[i]);

	        if (cursor !== null) {
	            cursor.next = item;
	        } else {
	            this.head = item;
	        }

	        item.prev = cursor;
	        cursor = item;
	    }

	    this.tail = cursor;

	    return this;
	};

	List.prototype.toArray = function() {
	    var cursor = this.head;
	    var result = [];

	    while (cursor) {
	        result.push(cursor.data);
	        cursor = cursor.next;
	    }

	    return result;
	};

	List.prototype.toJSON = List.prototype.toArray;

	List.prototype.isEmpty = function() {
	    return this.head === null;
	};

	List.prototype.first = function() {
	    return this.head && this.head.data;
	};

	List.prototype.last = function() {
	    return this.tail && this.tail.data;
	};

	List.prototype.each = function(fn, context) {
	    var item;

	    if (context === undefined) {
	        context = this;
	    }

	    // push cursor
	    var cursor = allocateCursor(this, null, this.head);

	    while (cursor.next !== null) {
	        item = cursor.next;
	        cursor.next = item.next;

	        fn.call(context, item.data, item, this);
	    }

	    // pop cursor
	    releaseCursor(this);
	};

	List.prototype.forEach = List.prototype.each;

	List.prototype.eachRight = function(fn, context) {
	    var item;

	    if (context === undefined) {
	        context = this;
	    }

	    // push cursor
	    var cursor = allocateCursor(this, this.tail, null);

	    while (cursor.prev !== null) {
	        item = cursor.prev;
	        cursor.prev = item.prev;

	        fn.call(context, item.data, item, this);
	    }

	    // pop cursor
	    releaseCursor(this);
	};

	List.prototype.forEachRight = List.prototype.eachRight;

	List.prototype.nextUntil = function(start, fn, context) {
	    if (start === null) {
	        return;
	    }

	    var item;

	    if (context === undefined) {
	        context = this;
	    }

	    // push cursor
	    var cursor = allocateCursor(this, null, start);

	    while (cursor.next !== null) {
	        item = cursor.next;
	        cursor.next = item.next;

	        if (fn.call(context, item.data, item, this)) {
	            break;
	        }
	    }

	    // pop cursor
	    releaseCursor(this);
	};

	List.prototype.prevUntil = function(start, fn, context) {
	    if (start === null) {
	        return;
	    }

	    var item;

	    if (context === undefined) {
	        context = this;
	    }

	    // push cursor
	    var cursor = allocateCursor(this, start, null);

	    while (cursor.prev !== null) {
	        item = cursor.prev;
	        cursor.prev = item.prev;

	        if (fn.call(context, item.data, item, this)) {
	            break;
	        }
	    }

	    // pop cursor
	    releaseCursor(this);
	};

	List.prototype.some = function(fn, context) {
	    var cursor = this.head;

	    if (context === undefined) {
	        context = this;
	    }

	    while (cursor !== null) {
	        if (fn.call(context, cursor.data, cursor, this)) {
	            return true;
	        }

	        cursor = cursor.next;
	    }

	    return false;
	};

	List.prototype.map = function(fn, context) {
	    var result = new List();
	    var cursor = this.head;

	    if (context === undefined) {
	        context = this;
	    }

	    while (cursor !== null) {
	        result.appendData(fn.call(context, cursor.data, cursor, this));
	        cursor = cursor.next;
	    }

	    return result;
	};

	List.prototype.filter = function(fn, context) {
	    var result = new List();
	    var cursor = this.head;

	    if (context === undefined) {
	        context = this;
	    }

	    while (cursor !== null) {
	        if (fn.call(context, cursor.data, cursor, this)) {
	            result.appendData(cursor.data);
	        }
	        cursor = cursor.next;
	    }

	    return result;
	};

	List.prototype.clear = function() {
	    this.head = null;
	    this.tail = null;
	};

	List.prototype.copy = function() {
	    var result = new List();
	    var cursor = this.head;

	    while (cursor !== null) {
	        result.insert(createItem(cursor.data));
	        cursor = cursor.next;
	    }

	    return result;
	};

	List.prototype.prepend = function(item) {
	    //      head
	    //    ^
	    // item
	    this.updateCursors(null, item, this.head, item);

	    // insert to the beginning of the list
	    if (this.head !== null) {
	        // new item <- first item
	        this.head.prev = item;

	        // new item -> first item
	        item.next = this.head;
	    } else {
	        // if list has no head, then it also has no tail
	        // in this case tail points to the new item
	        this.tail = item;
	    }

	    // head always points to new item
	    this.head = item;

	    return this;
	};

	List.prototype.prependData = function(data) {
	    return this.prepend(createItem(data));
	};

	List.prototype.append = function(item) {
	    return this.insert(item);
	};

	List.prototype.appendData = function(data) {
	    return this.insert(createItem(data));
	};

	List.prototype.insert = function(item, before) {
	    if (before !== undefined && before !== null) {
	        // prev   before
	        //      ^
	        //     item
	        this.updateCursors(before.prev, item, before, item);

	        if (before.prev === null) {
	            // insert to the beginning of list
	            if (this.head !== before) {
	                throw new Error('before doesn\'t belong to list');
	            }

	            // since head points to before therefore list doesn't empty
	            // no need to check tail
	            this.head = item;
	            before.prev = item;
	            item.next = before;

	            this.updateCursors(null, item);
	        } else {

	            // insert between two items
	            before.prev.next = item;
	            item.prev = before.prev;

	            before.prev = item;
	            item.next = before;
	        }
	    } else {
	        // tail
	        //      ^
	        //      item
	        this.updateCursors(this.tail, item, null, item);

	        // insert to the ending of the list
	        if (this.tail !== null) {
	            // last item -> new item
	            this.tail.next = item;

	            // last item <- new item
	            item.prev = this.tail;
	        } else {
	            // if list has no tail, then it also has no head
	            // in this case head points to new item
	            this.head = item;
	        }

	        // tail always points to new item
	        this.tail = item;
	    }

	    return this;
	};

	List.prototype.insertData = function(data, before) {
	    return this.insert(createItem(data), before);
	};

	List.prototype.remove = function(item) {
	    //      item
	    //       ^
	    // prev     next
	    this.updateCursors(item, item.prev, item, item.next);

	    if (item.prev !== null) {
	        item.prev.next = item.next;
	    } else {
	        if (this.head !== item) {
	            throw new Error('item doesn\'t belong to list');
	        }

	        this.head = item.next;
	    }

	    if (item.next !== null) {
	        item.next.prev = item.prev;
	    } else {
	        if (this.tail !== item) {
	            throw new Error('item doesn\'t belong to list');
	        }

	        this.tail = item.prev;
	    }

	    item.prev = null;
	    item.next = null;

	    return item;
	};

	List.prototype.push = function(data) {
	    this.insert(createItem(data));
	};

	List.prototype.pop = function() {
	    if (this.tail !== null) {
	        return this.remove(this.tail);
	    }
	};

	List.prototype.unshift = function(data) {
	    this.prepend(createItem(data));
	};

	List.prototype.shift = function() {
	    if (this.head !== null) {
	        return this.remove(this.head);
	    }
	};

	List.prototype.prependList = function(list) {
	    return this.insertList(list, this.head);
	};

	List.prototype.appendList = function(list) {
	    return this.insertList(list);
	};

	List.prototype.insertList = function(list, before) {
	    // ignore empty lists
	    if (list.head === null) {
	        return this;
	    }

	    if (before !== undefined && before !== null) {
	        this.updateCursors(before.prev, list.tail, before, list.head);

	        // insert in the middle of dist list
	        if (before.prev !== null) {
	            // before.prev <-> list.head
	            before.prev.next = list.head;
	            list.head.prev = before.prev;
	        } else {
	            this.head = list.head;
	        }

	        before.prev = list.tail;
	        list.tail.next = before;
	    } else {
	        this.updateCursors(this.tail, list.tail, null, list.head);

	        // insert to end of the list
	        if (this.tail !== null) {
	            // if destination list has a tail, then it also has a head,
	            // but head doesn't change

	            // dest tail -> source head
	            this.tail.next = list.head;

	            // dest tail <- source head
	            list.head.prev = this.tail;
	        } else {
	            // if list has no a tail, then it also has no a head
	            // in this case points head to new item
	            this.head = list.head;
	        }

	        // tail always start point to new item
	        this.tail = list.tail;
	    }

	    list.head = null;
	    list.tail = null;

	    return this;
	};

	List.prototype.replace = function(oldItem, newItemOrList) {
	    if ('head' in newItemOrList) {
	        this.insertList(newItemOrList, oldItem);
	    } else {
	        this.insert(newItemOrList, oldItem);
	    }

	    this.remove(oldItem);
	};

	var List_1 = List;

	var createCustomError = function createCustomError(name, message) {
	    // use Object.create(), because some VMs prevent setting line/column otherwise
	    // (iOS Safari 10 even throws an exception)
	    var error = Object.create(SyntaxError.prototype);
	    var errorStack = new Error();

	    error.name = name;
	    error.message = message;

	    Object.defineProperty(error, 'stack', {
	        get: function() {
	            return (errorStack.stack || '').replace(/^(.+\n){1,3}/, name + ': ' + message + '\n');
	        }
	    });

	    return error;
	};

	var MAX_LINE_LENGTH = 100;
	var OFFSET_CORRECTION = 60;
	var TAB_REPLACEMENT = '    ';

	function sourceFragment(error, extraLines) {
	    function processLines(start, end) {
	        return lines.slice(start, end).map(function(line, idx) {
	            var num = String(start + idx + 1);

	            while (num.length < maxNumLength) {
	                num = ' ' + num;
	            }

	            return num + ' |' + line;
	        }).join('\n');
	    }

	    var lines = error.source.split(/\r\n?|\n|\f/);
	    var line = error.line;
	    var column = error.column;
	    var startLine = Math.max(1, line - extraLines) - 1;
	    var endLine = Math.min(line + extraLines, lines.length + 1);
	    var maxNumLength = Math.max(4, String(endLine).length) + 1;
	    var cutLeft = 0;

	    // column correction according to replaced tab before column
	    column += (TAB_REPLACEMENT.length - 1) * (lines[line - 1].substr(0, column - 1).match(/\t/g) || []).length;

	    if (column > MAX_LINE_LENGTH) {
	        cutLeft = column - OFFSET_CORRECTION + 3;
	        column = OFFSET_CORRECTION - 2;
	    }

	    for (var i = startLine; i <= endLine; i++) {
	        if (i >= 0 && i < lines.length) {
	            lines[i] = lines[i].replace(/\t/g, TAB_REPLACEMENT);
	            lines[i] =
	                (cutLeft > 0 && lines[i].length > cutLeft ? '\u2026' : '') +
	                lines[i].substr(cutLeft, MAX_LINE_LENGTH - 2) +
	                (lines[i].length > cutLeft + MAX_LINE_LENGTH - 1 ? '\u2026' : '');
	        }
	    }

	    return [
	        processLines(startLine, line),
	        new Array(column + maxNumLength + 2).join('-') + '^',
	        processLines(line, endLine)
	    ].filter(Boolean).join('\n');
	}

	var SyntaxError$1 = function(message, source, offset, line, column) {
	    var error = createCustomError('SyntaxError', message);

	    error.source = source;
	    error.offset = offset;
	    error.line = line;
	    error.column = column;

	    error.sourceFragment = function(extraLines) {
	        return sourceFragment(error, isNaN(extraLines) ? 0 : extraLines);
	    };
	    Object.defineProperty(error, 'formattedMessage', {
	        get: function() {
	            return (
	                'Parse error: ' + error.message + '\n' +
	                sourceFragment(error, 2)
	            );
	        }
	    });

	    // for backward capability
	    error.parseError = {
	        offset: offset,
	        line: line,
	        column: column
	    };

	    return error;
	};

	var _SyntaxError = SyntaxError$1;

	// CSS Syntax Module Level 3
	// https://www.w3.org/TR/css-syntax-3/
	var TYPE = {
	    EOF: 0,                 // <EOF-token>
	    Ident: 1,               // <ident-token>
	    Function: 2,            // <function-token>
	    AtKeyword: 3,           // <at-keyword-token>
	    Hash: 4,                // <hash-token>
	    String: 5,              // <string-token>
	    BadString: 6,           // <bad-string-token>
	    Url: 7,                 // <url-token>
	    BadUrl: 8,              // <bad-url-token>
	    Delim: 9,               // <delim-token>
	    Number: 10,             // <number-token>
	    Percentage: 11,         // <percentage-token>
	    Dimension: 12,          // <dimension-token>
	    WhiteSpace: 13,         // <whitespace-token>
	    CDO: 14,                // <CDO-token>
	    CDC: 15,                // <CDC-token>
	    Colon: 16,              // <colon-token>     :
	    Semicolon: 17,          // <semicolon-token> ;
	    Comma: 18,              // <comma-token>     ,
	    LeftSquareBracket: 19,  // <[-token>
	    RightSquareBracket: 20, // <]-token>
	    LeftParenthesis: 21,    // <(-token>
	    RightParenthesis: 22,   // <)-token>
	    LeftCurlyBracket: 23,   // <{-token>
	    RightCurlyBracket: 24,  // <}-token>
	    Comment: 25
	};

	var NAME = Object.keys(TYPE).reduce(function(result, key) {
	    result[TYPE[key]] = key;
	    return result;
	}, {});

	var _const = {
	    TYPE: TYPE,
	    NAME: NAME
	};

	var EOF = 0;

	// https://drafts.csswg.org/css-syntax-3/
	// § 4.2. Definitions

	// digit
	// A code point between U+0030 DIGIT ZERO (0) and U+0039 DIGIT NINE (9).
	function isDigit(code) {
	    return code >= 0x0030 && code <= 0x0039;
	}

	// hex digit
	// A digit, or a code point between U+0041 LATIN CAPITAL LETTER A (A) and U+0046 LATIN CAPITAL LETTER F (F),
	// or a code point between U+0061 LATIN SMALL LETTER A (a) and U+0066 LATIN SMALL LETTER F (f).
	function isHexDigit(code) {
	    return (
	        isDigit(code) || // 0 .. 9
	        (code >= 0x0041 && code <= 0x0046) || // A .. F
	        (code >= 0x0061 && code <= 0x0066)    // a .. f
	    );
	}

	// uppercase letter
	// A code point between U+0041 LATIN CAPITAL LETTER A (A) and U+005A LATIN CAPITAL LETTER Z (Z).
	function isUppercaseLetter(code) {
	    return code >= 0x0041 && code <= 0x005A;
	}

	// lowercase letter
	// A code point between U+0061 LATIN SMALL LETTER A (a) and U+007A LATIN SMALL LETTER Z (z).
	function isLowercaseLetter(code) {
	    return code >= 0x0061 && code <= 0x007A;
	}

	// letter
	// An uppercase letter or a lowercase letter.
	function isLetter(code) {
	    return isUppercaseLetter(code) || isLowercaseLetter(code);
	}

	// non-ASCII code point
	// A code point with a value equal to or greater than U+0080 <control>.
	function isNonAscii(code) {
	    return code >= 0x0080;
	}

	// name-start code point
	// A letter, a non-ASCII code point, or U+005F LOW LINE (_).
	function isNameStart(code) {
	    return isLetter(code) || isNonAscii(code) || code === 0x005F;
	}

	// name code point
	// A name-start code point, a digit, or U+002D HYPHEN-MINUS (-).
	function isName(code) {
	    return isNameStart(code) || isDigit(code) || code === 0x002D;
	}

	// non-printable code point
	// A code point between U+0000 NULL and U+0008 BACKSPACE, or U+000B LINE TABULATION,
	// or a code point between U+000E SHIFT OUT and U+001F INFORMATION SEPARATOR ONE, or U+007F DELETE.
	function isNonPrintable(code) {
	    return (
	        (code >= 0x0000 && code <= 0x0008) ||
	        (code === 0x000B) ||
	        (code >= 0x000E && code <= 0x001F) ||
	        (code === 0x007F)
	    );
	}

	// newline
	// U+000A LINE FEED. Note that U+000D CARRIAGE RETURN and U+000C FORM FEED are not included in this definition,
	// as they are converted to U+000A LINE FEED during preprocessing.
	// TODO: we doesn't do a preprocessing, so check a code point for U+000D CARRIAGE RETURN and U+000C FORM FEED
	function isNewline(code) {
	    return code === 0x000A || code === 0x000D || code === 0x000C;
	}

	// whitespace
	// A newline, U+0009 CHARACTER TABULATION, or U+0020 SPACE.
	function isWhiteSpace(code) {
	    return isNewline(code) || code === 0x0020 || code === 0x0009;
	}

	// § 4.3.8. Check if two code points are a valid escape
	function isValidEscape(first, second) {
	    // If the first code point is not U+005C REVERSE SOLIDUS (\), return false.
	    if (first !== 0x005C) {
	        return false;
	    }

	    // Otherwise, if the second code point is a newline or EOF, return false.
	    if (isNewline(second) || second === EOF) {
	        return false;
	    }

	    // Otherwise, return true.
	    return true;
	}

	// § 4.3.9. Check if three code points would start an identifier
	function isIdentifierStart(first, second, third) {
	    // Look at the first code point:

	    // U+002D HYPHEN-MINUS
	    if (first === 0x002D) {
	        // If the second code point is a name-start code point or a U+002D HYPHEN-MINUS,
	        // or the second and third code points are a valid escape, return true. Otherwise, return false.
	        return (
	            isNameStart(second) ||
	            second === 0x002D ||
	            isValidEscape(second, third)
	        );
	    }

	    // name-start code point
	    if (isNameStart(first)) {
	        // Return true.
	        return true;
	    }

	    // U+005C REVERSE SOLIDUS (\)
	    if (first === 0x005C) {
	        // If the first and second code points are a valid escape, return true. Otherwise, return false.
	        return isValidEscape(first, second);
	    }

	    // anything else
	    // Return false.
	    return false;
	}

	// § 4.3.10. Check if three code points would start a number
	function isNumberStart(first, second, third) {
	    // Look at the first code point:

	    // U+002B PLUS SIGN (+)
	    // U+002D HYPHEN-MINUS (-)
	    if (first === 0x002B || first === 0x002D) {
	        // If the second code point is a digit, return true.
	        if (isDigit(second)) {
	            return 2;
	        }

	        // Otherwise, if the second code point is a U+002E FULL STOP (.)
	        // and the third code point is a digit, return true.
	        // Otherwise, return false.
	        return second === 0x002E && isDigit(third) ? 3 : 0;
	    }

	    // U+002E FULL STOP (.)
	    if (first === 0x002E) {
	        // If the second code point is a digit, return true. Otherwise, return false.
	        return isDigit(second) ? 2 : 0;
	    }

	    // digit
	    if (isDigit(first)) {
	        // Return true.
	        return 1;
	    }

	    // anything else
	    // Return false.
	    return 0;
	}

	//
	// Misc
	//

	// detect BOM (https://en.wikipedia.org/wiki/Byte_order_mark)
	function isBOM(code) {
	    // UTF-16BE
	    if (code === 0xFEFF) {
	        return 1;
	    }

	    // UTF-16LE
	    if (code === 0xFFFE) {
	        return 1;
	    }

	    return 0;
	}

	// Fast code category
	//
	// https://drafts.csswg.org/css-syntax/#tokenizer-definitions
	// > non-ASCII code point
	// >   A code point with a value equal to or greater than U+0080 <control>
	// > name-start code point
	// >   A letter, a non-ASCII code point, or U+005F LOW LINE (_).
	// > name code point
	// >   A name-start code point, a digit, or U+002D HYPHEN-MINUS (-)
	// That means only ASCII code points has a special meaning and we define a maps for 0..127 codes only
	var CATEGORY = new Array(0x80);
	charCodeCategory.Eof = 0x80;
	charCodeCategory.WhiteSpace = 0x82;
	charCodeCategory.Digit = 0x83;
	charCodeCategory.NameStart = 0x84;
	charCodeCategory.NonPrintable = 0x85;

	for (var i = 0; i < CATEGORY.length; i++) {
	    switch (true) {
	        case isWhiteSpace(i):
	            CATEGORY[i] = charCodeCategory.WhiteSpace;
	            break;

	        case isDigit(i):
	            CATEGORY[i] = charCodeCategory.Digit;
	            break;

	        case isNameStart(i):
	            CATEGORY[i] = charCodeCategory.NameStart;
	            break;

	        case isNonPrintable(i):
	            CATEGORY[i] = charCodeCategory.NonPrintable;
	            break;

	        default:
	            CATEGORY[i] = i || charCodeCategory.Eof;
	    }
	}

	function charCodeCategory(code) {
	    return code < 0x80 ? CATEGORY[code] : charCodeCategory.NameStart;
	}
	var charCodeDefinitions = {
	    isDigit: isDigit,
	    isHexDigit: isHexDigit,
	    isUppercaseLetter: isUppercaseLetter,
	    isLowercaseLetter: isLowercaseLetter,
	    isLetter: isLetter,
	    isNonAscii: isNonAscii,
	    isNameStart: isNameStart,
	    isName: isName,
	    isNonPrintable: isNonPrintable,
	    isNewline: isNewline,
	    isWhiteSpace: isWhiteSpace,
	    isValidEscape: isValidEscape,
	    isIdentifierStart: isIdentifierStart,
	    isNumberStart: isNumberStart,

	    isBOM: isBOM,
	    charCodeCategory: charCodeCategory
	};

	var isDigit$1 = charCodeDefinitions.isDigit;
	var isHexDigit$1 = charCodeDefinitions.isHexDigit;
	var isUppercaseLetter$1 = charCodeDefinitions.isUppercaseLetter;
	var isName$1 = charCodeDefinitions.isName;
	var isWhiteSpace$1 = charCodeDefinitions.isWhiteSpace;
	var isValidEscape$1 = charCodeDefinitions.isValidEscape;

	function getCharCode(source, offset) {
	    return offset < source.length ? source.charCodeAt(offset) : 0;
	}

	function getNewlineLength(source, offset, code) {
	    if (code === 13 /* \r */ && getCharCode(source, offset + 1) === 10 /* \n */) {
	        return 2;
	    }

	    return 1;
	}

	function cmpChar(testStr, offset, referenceCode) {
	    var code = testStr.charCodeAt(offset);

	    // code.toLowerCase() for A..Z
	    if (isUppercaseLetter$1(code)) {
	        code = code | 32;
	    }

	    return code === referenceCode;
	}

	function cmpStr(testStr, start, end, referenceStr) {
	    if (end - start !== referenceStr.length) {
	        return false;
	    }

	    if (start < 0 || end > testStr.length) {
	        return false;
	    }

	    for (var i = start; i < end; i++) {
	        var testCode = testStr.charCodeAt(i);
	        var referenceCode = referenceStr.charCodeAt(i - start);

	        // testCode.toLowerCase() for A..Z
	        if (isUppercaseLetter$1(testCode)) {
	            testCode = testCode | 32;
	        }

	        if (testCode !== referenceCode) {
	            return false;
	        }
	    }

	    return true;
	}

	function findWhiteSpaceStart(source, offset) {
	    for (; offset >= 0; offset--) {
	        if (!isWhiteSpace$1(source.charCodeAt(offset))) {
	            break;
	        }
	    }

	    return offset + 1;
	}

	function findWhiteSpaceEnd(source, offset) {
	    for (; offset < source.length; offset++) {
	        if (!isWhiteSpace$1(source.charCodeAt(offset))) {
	            break;
	        }
	    }

	    return offset;
	}

	function findDecimalNumberEnd(source, offset) {
	    for (; offset < source.length; offset++) {
	        if (!isDigit$1(source.charCodeAt(offset))) {
	            break;
	        }
	    }

	    return offset;
	}

	// § 4.3.7. Consume an escaped code point
	function consumeEscaped(source, offset) {
	    // It assumes that the U+005C REVERSE SOLIDUS (\) has already been consumed and
	    // that the next input code point has already been verified to be part of a valid escape.
	    offset += 2;

	    // hex digit
	    if (isHexDigit$1(getCharCode(source, offset - 1))) {
	        // Consume as many hex digits as possible, but no more than 5.
	        // Note that this means 1-6 hex digits have been consumed in total.
	        for (var maxOffset = Math.min(source.length, offset + 5); offset < maxOffset; offset++) {
	            if (!isHexDigit$1(getCharCode(source, offset))) {
	                break;
	            }
	        }

	        // If the next input code point is whitespace, consume it as well.
	        var code = getCharCode(source, offset);
	        if (isWhiteSpace$1(code)) {
	            offset += getNewlineLength(source, offset, code);
	        }
	    }

	    return offset;
	}

	// §4.3.11. Consume a name
	// Note: This algorithm does not do the verification of the first few code points that are necessary
	// to ensure the returned code points would constitute an <ident-token>. If that is the intended use,
	// ensure that the stream starts with an identifier before calling this algorithm.
	function consumeName(source, offset) {
	    // Let result initially be an empty string.
	    // Repeatedly consume the next input code point from the stream:
	    for (; offset < source.length; offset++) {
	        var code = source.charCodeAt(offset);

	        // name code point
	        if (isName$1(code)) {
	            // Append the code point to result.
	            continue;
	        }

	        // the stream starts with a valid escape
	        if (isValidEscape$1(code, getCharCode(source, offset + 1))) {
	            // Consume an escaped code point. Append the returned code point to result.
	            offset = consumeEscaped(source, offset) - 1;
	            continue;
	        }

	        // anything else
	        // Reconsume the current input code point. Return result.
	        break;
	    }

	    return offset;
	}

	// §4.3.12. Consume a number
	function consumeNumber(source, offset) {
	    var code = source.charCodeAt(offset);

	    // 2. If the next input code point is U+002B PLUS SIGN (+) or U+002D HYPHEN-MINUS (-),
	    // consume it and append it to repr.
	    if (code === 0x002B || code === 0x002D) {
	        code = source.charCodeAt(offset += 1);
	    }

	    // 3. While the next input code point is a digit, consume it and append it to repr.
	    if (isDigit$1(code)) {
	        offset = findDecimalNumberEnd(source, offset + 1);
	        code = source.charCodeAt(offset);
	    }

	    // 4. If the next 2 input code points are U+002E FULL STOP (.) followed by a digit, then:
	    if (code === 0x002E && isDigit$1(source.charCodeAt(offset + 1))) {
	        // 4.1 Consume them.
	        // 4.2 Append them to repr.
	        code = source.charCodeAt(offset += 2);

	        // 4.3 Set type to "number".
	        // TODO

	        // 4.4 While the next input code point is a digit, consume it and append it to repr.

	        offset = findDecimalNumberEnd(source, offset);
	    }

	    // 5. If the next 2 or 3 input code points are U+0045 LATIN CAPITAL LETTER E (E)
	    // or U+0065 LATIN SMALL LETTER E (e), ... , followed by a digit, then:
	    if (cmpChar(source, offset, 101 /* e */)) {
	        var sign = 0;
	        code = source.charCodeAt(offset + 1);

	        // ... optionally followed by U+002D HYPHEN-MINUS (-) or U+002B PLUS SIGN (+) ...
	        if (code === 0x002D || code === 0x002B) {
	            sign = 1;
	            code = source.charCodeAt(offset + 2);
	        }

	        // ... followed by a digit
	        if (isDigit$1(code)) {
	            // 5.1 Consume them.
	            // 5.2 Append them to repr.

	            // 5.3 Set type to "number".
	            // TODO

	            // 5.4 While the next input code point is a digit, consume it and append it to repr.
	            offset = findDecimalNumberEnd(source, offset + 1 + sign + 1);
	        }
	    }

	    return offset;
	}

	// § 4.3.14. Consume the remnants of a bad url
	// ... its sole use is to consume enough of the input stream to reach a recovery point
	// where normal tokenizing can resume.
	function consumeBadUrlRemnants(source, offset) {
	    // Repeatedly consume the next input code point from the stream:
	    for (; offset < source.length; offset++) {
	        var code = source.charCodeAt(offset);

	        // U+0029 RIGHT PARENTHESIS ())
	        // EOF
	        if (code === 0x0029) {
	            // Return.
	            offset++;
	            break;
	        }

	        if (isValidEscape$1(code, getCharCode(source, offset + 1))) {
	            // Consume an escaped code point.
	            // Note: This allows an escaped right parenthesis ("\)") to be encountered
	            // without ending the <bad-url-token>. This is otherwise identical to
	            // the "anything else" clause.
	            offset = consumeEscaped(source, offset);
	        }
	    }

	    return offset;
	}

	var utils = {
	    consumeEscaped: consumeEscaped,
	    consumeName: consumeName,
	    consumeNumber: consumeNumber,
	    consumeBadUrlRemnants: consumeBadUrlRemnants,

	    cmpChar: cmpChar,
	    cmpStr: cmpStr,

	    getNewlineLength: getNewlineLength,
	    findWhiteSpaceStart: findWhiteSpaceStart,
	    findWhiteSpaceEnd: findWhiteSpaceEnd
	};

	var TYPE$1 = _const.TYPE;
	var NAME$1 = _const.NAME;


	var cmpStr$1 = utils.cmpStr;

	var EOF$1 = TYPE$1.EOF;
	var WHITESPACE = TYPE$1.WhiteSpace;
	var COMMENT = TYPE$1.Comment;

	var OFFSET_MASK = 0x00FFFFFF;
	var TYPE_SHIFT = 24;

	var TokenStream = function() {
	    this.offsetAndType = null;
	    this.balance = null;

	    this.reset();
	};

	TokenStream.prototype = {
	    reset: function() {
	        this.eof = false;
	        this.tokenIndex = -1;
	        this.tokenType = 0;
	        this.tokenStart = this.firstCharOffset;
	        this.tokenEnd = this.firstCharOffset;
	    },

	    lookupType: function(offset) {
	        offset += this.tokenIndex;

	        if (offset < this.tokenCount) {
	            return this.offsetAndType[offset] >> TYPE_SHIFT;
	        }

	        return EOF$1;
	    },
	    lookupOffset: function(offset) {
	        offset += this.tokenIndex;

	        if (offset < this.tokenCount) {
	            return this.offsetAndType[offset - 1] & OFFSET_MASK;
	        }

	        return this.source.length;
	    },
	    lookupValue: function(offset, referenceStr) {
	        offset += this.tokenIndex;

	        if (offset < this.tokenCount) {
	            return cmpStr$1(
	                this.source,
	                this.offsetAndType[offset - 1] & OFFSET_MASK,
	                this.offsetAndType[offset] & OFFSET_MASK,
	                referenceStr
	            );
	        }

	        return false;
	    },
	    getTokenStart: function(tokenIndex) {
	        if (tokenIndex === this.tokenIndex) {
	            return this.tokenStart;
	        }

	        if (tokenIndex > 0) {
	            return tokenIndex < this.tokenCount
	                ? this.offsetAndType[tokenIndex - 1] & OFFSET_MASK
	                : this.offsetAndType[this.tokenCount] & OFFSET_MASK;
	        }

	        return this.firstCharOffset;
	    },

	    // TODO: -> skipUntilBalanced
	    getRawLength: function(startToken, mode) {
	        var cursor = startToken;
	        var balanceEnd;
	        var offset = this.offsetAndType[Math.max(cursor - 1, 0)] & OFFSET_MASK;
	        var type;

	        loop:
	        for (; cursor < this.tokenCount; cursor++) {
	            balanceEnd = this.balance[cursor];

	            // stop scanning on balance edge that points to offset before start token
	            if (balanceEnd < startToken) {
	                break loop;
	            }

	            type = this.offsetAndType[cursor] >> TYPE_SHIFT;

	            // check token is stop type
	            switch (mode(type, this.source, offset)) {
	                case 1:
	                    break loop;

	                case 2:
	                    cursor++;
	                    break loop;

	                default:
	                    offset = this.offsetAndType[cursor] & OFFSET_MASK;

	                    // fast forward to the end of balanced block
	                    if (this.balance[balanceEnd] === cursor) {
	                        cursor = balanceEnd;
	                    }
	            }
	        }

	        return cursor - this.tokenIndex;
	    },
	    isBalanceEdge: function(pos) {
	        return this.balance[this.tokenIndex] < pos;
	    },
	    isDelim: function(code, offset) {
	        if (offset) {
	            return (
	                this.lookupType(offset) === TYPE$1.Delim &&
	                this.source.charCodeAt(this.lookupOffset(offset)) === code
	            );
	        }

	        return (
	            this.tokenType === TYPE$1.Delim &&
	            this.source.charCodeAt(this.tokenStart) === code
	        );
	    },

	    getTokenValue: function() {
	        return this.source.substring(this.tokenStart, this.tokenEnd);
	    },
	    getTokenLength: function() {
	        return this.tokenEnd - this.tokenStart;
	    },
	    substrToCursor: function(start) {
	        return this.source.substring(start, this.tokenStart);
	    },

	    skipWS: function() {
	        for (var i = this.tokenIndex, skipTokenCount = 0; i < this.tokenCount; i++, skipTokenCount++) {
	            if ((this.offsetAndType[i] >> TYPE_SHIFT) !== WHITESPACE) {
	                break;
	            }
	        }

	        if (skipTokenCount > 0) {
	            this.skip(skipTokenCount);
	        }
	    },
	    skipSC: function() {
	        while (this.tokenType === WHITESPACE || this.tokenType === COMMENT) {
	            this.next();
	        }
	    },
	    skip: function(tokenCount) {
	        var next = this.tokenIndex + tokenCount;

	        if (next < this.tokenCount) {
	            this.tokenIndex = next;
	            this.tokenStart = this.offsetAndType[next - 1] & OFFSET_MASK;
	            next = this.offsetAndType[next];
	            this.tokenType = next >> TYPE_SHIFT;
	            this.tokenEnd = next & OFFSET_MASK;
	        } else {
	            this.tokenIndex = this.tokenCount;
	            this.next();
	        }
	    },
	    next: function() {
	        var next = this.tokenIndex + 1;

	        if (next < this.tokenCount) {
	            this.tokenIndex = next;
	            this.tokenStart = this.tokenEnd;
	            next = this.offsetAndType[next];
	            this.tokenType = next >> TYPE_SHIFT;
	            this.tokenEnd = next & OFFSET_MASK;
	        } else {
	            this.tokenIndex = this.tokenCount;
	            this.eof = true;
	            this.tokenType = EOF$1;
	            this.tokenStart = this.tokenEnd = this.source.length;
	        }
	    },

	    dump: function() {
	        var offset = this.firstCharOffset;

	        return Array.prototype.slice.call(this.offsetAndType, 0, this.tokenCount).map(function(item, idx) {
	            var start = offset;
	            var end = item & OFFSET_MASK;

	            offset = end;

	            return {
	                idx: idx,
	                type: NAME$1[item >> TYPE_SHIFT],
	                chunk: this.source.substring(start, end),
	                balance: this.balance[idx]
	            };
	        }, this);
	    }
	};

	var TokenStream_1 = TokenStream;

	function noop$1(value) {
	    return value;
	}

	function generateMultiplier(multiplier) {
	    if (multiplier.min === 0 && multiplier.max === 0) {
	        return '*';
	    }

	    if (multiplier.min === 0 && multiplier.max === 1) {
	        return '?';
	    }

	    if (multiplier.min === 1 && multiplier.max === 0) {
	        return multiplier.comma ? '#' : '+';
	    }

	    if (multiplier.min === 1 && multiplier.max === 1) {
	        return '';
	    }

	    return (
	        (multiplier.comma ? '#' : '') +
	        (multiplier.min === multiplier.max
	            ? '{' + multiplier.min + '}'
	            : '{' + multiplier.min + ',' + (multiplier.max !== 0 ? multiplier.max : '') + '}'
	        )
	    );
	}

	function generateTypeOpts(node) {
	    switch (node.type) {
	        case 'Range':
	            return (
	                ' [' +
	                (node.min === null ? '-∞' : node.min) +
	                ',' +
	                (node.max === null ? '∞' : node.max) +
	                ']'
	            );

	        default:
	            throw new Error('Unknown node type `' + node.type + '`');
	    }
	}

	function generateSequence(node, decorate, forceBraces, compact) {
	    var combinator = node.combinator === ' ' || compact ? node.combinator : ' ' + node.combinator + ' ';
	    var result = node.terms.map(function(term) {
	        return generate(term, decorate, forceBraces, compact);
	    }).join(combinator);

	    if (node.explicit || forceBraces) {
	        result = (compact || result[0] === ',' ? '[' : '[ ') + result + (compact ? ']' : ' ]');
	    }

	    return result;
	}

	function generate(node, decorate, forceBraces, compact) {
	    var result;

	    switch (node.type) {
	        case 'Group':
	            result =
	                generateSequence(node, decorate, forceBraces, compact) +
	                (node.disallowEmpty ? '!' : '');
	            break;

	        case 'Multiplier':
	            // return since node is a composition
	            return (
	                generate(node.term, decorate, forceBraces, compact) +
	                decorate(generateMultiplier(node), node)
	            );

	        case 'Type':
	            result = '<' + node.name + (node.opts ? decorate(generateTypeOpts(node.opts), node.opts) : '') + '>';
	            break;

	        case 'Property':
	            result = '<\'' + node.name + '\'>';
	            break;

	        case 'Keyword':
	            result = node.name;
	            break;

	        case 'AtKeyword':
	            result = '@' + node.name;
	            break;

	        case 'Function':
	            result = node.name + '(';
	            break;

	        case 'String':
	        case 'Token':
	            result = node.value;
	            break;

	        case 'Comma':
	            result = ',';
	            break;

	        default:
	            throw new Error('Unknown node type `' + node.type + '`');
	    }

	    return decorate(result, node);
	}

	var generate_1 = function(node, options) {
	    var decorate = noop$1;
	    var forceBraces = false;
	    var compact = false;

	    if (typeof options === 'function') {
	        decorate = options;
	    } else if (options) {
	        forceBraces = Boolean(options.forceBraces);
	        compact = Boolean(options.compact);
	        if (typeof options.decorate === 'function') {
	            decorate = options.decorate;
	        }
	    }

	    return generate(node, decorate, forceBraces, compact);
	};

	function fromMatchResult(matchResult) {
	    var tokens = matchResult.tokens;
	    var longestMatch = matchResult.longestMatch;
	    var node = longestMatch < tokens.length ? tokens[longestMatch].node : null;
	    var mismatchOffset = -1;
	    var entries = 0;
	    var css = '';

	    for (var i = 0; i < tokens.length; i++) {
	        if (i === longestMatch) {
	            mismatchOffset = css.length;
	        }

	        if (node !== null && tokens[i].node === node) {
	            if (i <= longestMatch) {
	                entries++;
	            } else {
	                entries = 0;
	            }
	        }

	        css += tokens[i].value;
	    }

	    return {
	        node: node,
	        css: css,
	        mismatchOffset: mismatchOffset === -1 ? css.length : mismatchOffset,
	        last: node === null || entries > 1
	    };
	}

	function getLocation(node, point) {
	    var loc = node && node.loc && node.loc[point];

	    if (loc) {
	        return {
	            offset: loc.offset,
	            line: loc.line,
	            column: loc.column
	        };
	    }

	    return null;
	}

	var SyntaxReferenceError = function(type, referenceName) {
	    var error = createCustomError(
	        'SyntaxReferenceError',
	        type + (referenceName ? ' `' + referenceName + '`' : '')
	    );

	    error.reference = referenceName;

	    return error;
	};

	var MatchError = function(message, syntax, node, matchResult) {
	    var error = createCustomError('SyntaxMatchError', message);
	    var details = fromMatchResult(matchResult);
	    var mismatchOffset = details.mismatchOffset || 0;
	    var badNode = details.node || node;
	    var end = getLocation(badNode, 'end');
	    var start = details.last ? end : getLocation(badNode, 'start');
	    var css = details.css;

	    error.rawMessage = message;
	    error.syntax = syntax ? generate_1(syntax) : '<generic>';
	    error.css = css;
	    error.mismatchOffset = mismatchOffset;
	    error.loc = {
	        source: (badNode && badNode.loc && badNode.loc.source) || '<unknown>',
	        start: start,
	        end: end
	    };
	    error.line = start ? start.line : undefined;
	    error.column = start ? start.column : undefined;
	    error.offset = start ? start.offset : undefined;
	    error.message = message + '\n' +
	        '  syntax: ' + error.syntax + '\n' +
	        '   value: ' + (error.css || '<empty string>') + '\n' +
	        '  --------' + new Array(error.mismatchOffset + 1).join('-') + '^';

	    return error;
	};

	var error = {
	    SyntaxReferenceError: SyntaxReferenceError,
	    MatchError: MatchError
	};

	var hasOwnProperty = Object.prototype.hasOwnProperty;
	var keywords = Object.create(null);
	var properties = Object.create(null);
	var HYPHENMINUS = 45; // '-'.charCodeAt()

	function isCustomProperty(str, offset) {
	    offset = offset || 0;

	    return str.length - offset >= 2 &&
	           str.charCodeAt(offset) === HYPHENMINUS &&
	           str.charCodeAt(offset + 1) === HYPHENMINUS;
	}

	function getVendorPrefix(str, offset) {
	    offset = offset || 0;

	    // verdor prefix should be at least 3 chars length
	    if (str.length - offset >= 3) {
	        // vendor prefix starts with hyper minus following non-hyper minus
	        if (str.charCodeAt(offset) === HYPHENMINUS &&
	            str.charCodeAt(offset + 1) !== HYPHENMINUS) {
	            // vendor prefix should contain a hyper minus at the ending
	            var secondDashIndex = str.indexOf('-', offset + 2);

	            if (secondDashIndex !== -1) {
	                return str.substring(offset, secondDashIndex + 1);
	            }
	        }
	    }

	    return '';
	}

	function getKeywordDescriptor(keyword) {
	    if (hasOwnProperty.call(keywords, keyword)) {
	        return keywords[keyword];
	    }

	    var name = keyword.toLowerCase();

	    if (hasOwnProperty.call(keywords, name)) {
	        return keywords[keyword] = keywords[name];
	    }

	    var custom = isCustomProperty(name, 0);
	    var vendor = !custom ? getVendorPrefix(name, 0) : '';

	    return keywords[keyword] = Object.freeze({
	        basename: name.substr(vendor.length),
	        name: name,
	        vendor: vendor,
	        prefix: vendor,
	        custom: custom
	    });
	}

	function getPropertyDescriptor(property) {
	    if (hasOwnProperty.call(properties, property)) {
	        return properties[property];
	    }

	    var name = property;
	    var hack = property[0];

	    if (hack === '/') {
	        hack = property[1] === '/' ? '//' : '/';
	    } else if (hack !== '_' &&
	               hack !== '*' &&
	               hack !== '$' &&
	               hack !== '#' &&
	               hack !== '+' &&
	               hack !== '&') {
	        hack = '';
	    }

	    var custom = isCustomProperty(name, hack.length);

	    // re-use result when possible (the same as for lower case)
	    if (!custom) {
	        name = name.toLowerCase();
	        if (hasOwnProperty.call(properties, name)) {
	            return properties[property] = properties[name];
	        }
	    }

	    var vendor = !custom ? getVendorPrefix(name, hack.length) : '';
	    var prefix = name.substr(0, hack.length + vendor.length);

	    return properties[property] = Object.freeze({
	        basename: name.substr(prefix.length),
	        name: name.substr(hack.length),
	        hack: hack,
	        vendor: vendor,
	        prefix: prefix,
	        custom: custom
	    });
	}

	var names = {
	    keyword: getKeywordDescriptor,
	    property: getPropertyDescriptor,
	    isCustomProperty: isCustomProperty,
	    vendorPrefix: getVendorPrefix
	};

	var MIN_SIZE = 16 * 1024;
	var SafeUint32Array = typeof Uint32Array !== 'undefined' ? Uint32Array : Array; // fallback on Array when TypedArray is not supported

	var adoptBuffer = function adoptBuffer(buffer, size) {
	    if (buffer === null || buffer.length < size) {
	        return new SafeUint32Array(Math.max(size + 1024, MIN_SIZE));
	    }

	    return buffer;
	};

	var TYPE$2 = _const.TYPE;


	var isNewline$1 = charCodeDefinitions.isNewline;
	var isName$2 = charCodeDefinitions.isName;
	var isValidEscape$2 = charCodeDefinitions.isValidEscape;
	var isNumberStart$1 = charCodeDefinitions.isNumberStart;
	var isIdentifierStart$1 = charCodeDefinitions.isIdentifierStart;
	var charCodeCategory$1 = charCodeDefinitions.charCodeCategory;
	var isBOM$1 = charCodeDefinitions.isBOM;


	var cmpStr$2 = utils.cmpStr;
	var getNewlineLength$1 = utils.getNewlineLength;
	var findWhiteSpaceEnd$1 = utils.findWhiteSpaceEnd;
	var consumeEscaped$1 = utils.consumeEscaped;
	var consumeName$1 = utils.consumeName;
	var consumeNumber$1 = utils.consumeNumber;
	var consumeBadUrlRemnants$1 = utils.consumeBadUrlRemnants;

	var OFFSET_MASK$1 = 0x00FFFFFF;
	var TYPE_SHIFT$1 = 24;

	function tokenize(source, stream) {
	    function getCharCode(offset) {
	        return offset < sourceLength ? source.charCodeAt(offset) : 0;
	    }

	    // § 4.3.3. Consume a numeric token
	    function consumeNumericToken() {
	        // Consume a number and let number be the result.
	        offset = consumeNumber$1(source, offset);

	        // If the next 3 input code points would start an identifier, then:
	        if (isIdentifierStart$1(getCharCode(offset), getCharCode(offset + 1), getCharCode(offset + 2))) {
	            // Create a <dimension-token> with the same value and type flag as number, and a unit set initially to the empty string.
	            // Consume a name. Set the <dimension-token>’s unit to the returned value.
	            // Return the <dimension-token>.
	            type = TYPE$2.Dimension;
	            offset = consumeName$1(source, offset);
	            return;
	        }

	        // Otherwise, if the next input code point is U+0025 PERCENTAGE SIGN (%), consume it.
	        if (getCharCode(offset) === 0x0025) {
	            // Create a <percentage-token> with the same value as number, and return it.
	            type = TYPE$2.Percentage;
	            offset++;
	            return;
	        }

	        // Otherwise, create a <number-token> with the same value and type flag as number, and return it.
	        type = TYPE$2.Number;
	    }

	    // § 4.3.4. Consume an ident-like token
	    function consumeIdentLikeToken() {
	        const nameStartOffset = offset;

	        // Consume a name, and let string be the result.
	        offset = consumeName$1(source, offset);

	        // If string’s value is an ASCII case-insensitive match for "url",
	        // and the next input code point is U+0028 LEFT PARENTHESIS ((), consume it.
	        if (cmpStr$2(source, nameStartOffset, offset, 'url') && getCharCode(offset) === 0x0028) {
	            // While the next two input code points are whitespace, consume the next input code point.
	            offset = findWhiteSpaceEnd$1(source, offset + 1);

	            // If the next one or two input code points are U+0022 QUOTATION MARK ("), U+0027 APOSTROPHE ('),
	            // or whitespace followed by U+0022 QUOTATION MARK (") or U+0027 APOSTROPHE ('),
	            // then create a <function-token> with its value set to string and return it.
	            if (getCharCode(offset) === 0x0022 ||
	                getCharCode(offset) === 0x0027) {
	                type = TYPE$2.Function;
	                offset = nameStartOffset + 4;
	                return;
	            }

	            // Otherwise, consume a url token, and return it.
	            consumeUrlToken();
	            return;
	        }

	        // Otherwise, if the next input code point is U+0028 LEFT PARENTHESIS ((), consume it.
	        // Create a <function-token> with its value set to string and return it.
	        if (getCharCode(offset) === 0x0028) {
	            type = TYPE$2.Function;
	            offset++;
	            return;
	        }

	        // Otherwise, create an <ident-token> with its value set to string and return it.
	        type = TYPE$2.Ident;
	    }

	    // § 4.3.5. Consume a string token
	    function consumeStringToken(endingCodePoint) {
	        // This algorithm may be called with an ending code point, which denotes the code point
	        // that ends the string. If an ending code point is not specified,
	        // the current input code point is used.
	        if (!endingCodePoint) {
	            endingCodePoint = getCharCode(offset++);
	        }

	        // Initially create a <string-token> with its value set to the empty string.
	        type = TYPE$2.String;

	        // Repeatedly consume the next input code point from the stream:
	        for (; offset < source.length; offset++) {
	            var code = source.charCodeAt(offset);

	            switch (charCodeCategory$1(code)) {
	                // ending code point
	                case endingCodePoint:
	                    // Return the <string-token>.
	                    offset++;
	                    return;

	                // EOF
	                case charCodeCategory$1.Eof:
	                    // This is a parse error. Return the <string-token>.
	                    return;

	                // newline
	                case charCodeCategory$1.WhiteSpace:
	                    if (isNewline$1(code)) {
	                        // This is a parse error. Reconsume the current input code point,
	                        // create a <bad-string-token>, and return it.
	                        offset += getNewlineLength$1(source, offset, code);
	                        type = TYPE$2.BadString;
	                        return;
	                    }
	                    break;

	                // U+005C REVERSE SOLIDUS (\)
	                case 0x005C:
	                    // If the next input code point is EOF, do nothing.
	                    if (offset === source.length - 1) {
	                        break;
	                    }

	                    var nextCode = getCharCode(offset + 1);

	                    // Otherwise, if the next input code point is a newline, consume it.
	                    if (isNewline$1(nextCode)) {
	                        offset += getNewlineLength$1(source, offset + 1, nextCode);
	                    } else if (isValidEscape$2(code, nextCode)) {
	                        // Otherwise, (the stream starts with a valid escape) consume
	                        // an escaped code point and append the returned code point to
	                        // the <string-token>’s value.
	                        offset = consumeEscaped$1(source, offset) - 1;
	                    }
	                    break;

	                // anything else
	                // Append the current input code point to the <string-token>’s value.
	            }
	        }
	    }

	    // § 4.3.6. Consume a url token
	    // Note: This algorithm assumes that the initial "url(" has already been consumed.
	    // This algorithm also assumes that it’s being called to consume an "unquoted" value, like url(foo).
	    // A quoted value, like url("foo"), is parsed as a <function-token>. Consume an ident-like token
	    // automatically handles this distinction; this algorithm shouldn’t be called directly otherwise.
	    function consumeUrlToken() {
	        // Initially create a <url-token> with its value set to the empty string.
	        type = TYPE$2.Url;

	        // Consume as much whitespace as possible.
	        offset = findWhiteSpaceEnd$1(source, offset);

	        // Repeatedly consume the next input code point from the stream:
	        for (; offset < source.length; offset++) {
	            var code = source.charCodeAt(offset);

	            switch (charCodeCategory$1(code)) {
	                // U+0029 RIGHT PARENTHESIS ())
	                case 0x0029:
	                    // Return the <url-token>.
	                    offset++;
	                    return;

	                // EOF
	                case charCodeCategory$1.Eof:
	                    // This is a parse error. Return the <url-token>.
	                    return;

	                // whitespace
	                case charCodeCategory$1.WhiteSpace:
	                    // Consume as much whitespace as possible.
	                    offset = findWhiteSpaceEnd$1(source, offset);

	                    // If the next input code point is U+0029 RIGHT PARENTHESIS ()) or EOF,
	                    // consume it and return the <url-token>
	                    // (if EOF was encountered, this is a parse error);
	                    if (getCharCode(offset) === 0x0029 || offset >= source.length) {
	                        if (offset < source.length) {
	                            offset++;
	                        }
	                        return;
	                    }

	                    // otherwise, consume the remnants of a bad url, create a <bad-url-token>,
	                    // and return it.
	                    offset = consumeBadUrlRemnants$1(source, offset);
	                    type = TYPE$2.BadUrl;
	                    return;

	                // U+0022 QUOTATION MARK (")
	                // U+0027 APOSTROPHE (')
	                // U+0028 LEFT PARENTHESIS (()
	                // non-printable code point
	                case 0x0022:
	                case 0x0027:
	                case 0x0028:
	                case charCodeCategory$1.NonPrintable:
	                    // This is a parse error. Consume the remnants of a bad url,
	                    // create a <bad-url-token>, and return it.
	                    offset = consumeBadUrlRemnants$1(source, offset);
	                    type = TYPE$2.BadUrl;
	                    return;

	                // U+005C REVERSE SOLIDUS (\)
	                case 0x005C:
	                    // If the stream starts with a valid escape, consume an escaped code point and
	                    // append the returned code point to the <url-token>’s value.
	                    if (isValidEscape$2(code, getCharCode(offset + 1))) {
	                        offset = consumeEscaped$1(source, offset) - 1;
	                        break;
	                    }

	                    // Otherwise, this is a parse error. Consume the remnants of a bad url,
	                    // create a <bad-url-token>, and return it.
	                    offset = consumeBadUrlRemnants$1(source, offset);
	                    type = TYPE$2.BadUrl;
	                    return;

	                // anything else
	                // Append the current input code point to the <url-token>’s value.
	            }
	        }
	    }

	    if (!stream) {
	        stream = new TokenStream_1();
	    }

	    // ensure source is a string
	    source = String(source || '');

	    var sourceLength = source.length;
	    var offsetAndType = adoptBuffer(stream.offsetAndType, sourceLength + 1); // +1 because of eof-token
	    var balance = adoptBuffer(stream.balance, sourceLength + 1);
	    var tokenCount = 0;
	    var start = isBOM$1(getCharCode(0));
	    var offset = start;
	    var balanceCloseType = 0;
	    var balanceStart = 0;
	    var balancePrev = 0;

	    // https://drafts.csswg.org/css-syntax-3/#consume-token
	    // § 4.3.1. Consume a token
	    while (offset < sourceLength) {
	        var code = source.charCodeAt(offset);
	        var type = 0;

	        balance[tokenCount] = sourceLength;

	        switch (charCodeCategory$1(code)) {
	            // whitespace
	            case charCodeCategory$1.WhiteSpace:
	                // Consume as much whitespace as possible. Return a <whitespace-token>.
	                type = TYPE$2.WhiteSpace;
	                offset = findWhiteSpaceEnd$1(source, offset + 1);
	                break;

	            // U+0022 QUOTATION MARK (")
	            case 0x0022:
	                // Consume a string token and return it.
	                consumeStringToken();
	                break;

	            // U+0023 NUMBER SIGN (#)
	            case 0x0023:
	                // If the next input code point is a name code point or the next two input code points are a valid escape, then:
	                if (isName$2(getCharCode(offset + 1)) || isValidEscape$2(getCharCode(offset + 1), getCharCode(offset + 2))) {
	                    // Create a <hash-token>.
	                    type = TYPE$2.Hash;

	                    // If the next 3 input code points would start an identifier, set the <hash-token>’s type flag to "id".
	                    // if (isIdentifierStart(getCharCode(offset + 1), getCharCode(offset + 2), getCharCode(offset + 3))) {
	                    //     // TODO: set id flag
	                    // }

	                    // Consume a name, and set the <hash-token>’s value to the returned string.
	                    offset = consumeName$1(source, offset + 1);

	                    // Return the <hash-token>.
	                } else {
	                    // Otherwise, return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }

	                break;

	            // U+0027 APOSTROPHE (')
	            case 0x0027:
	                // Consume a string token and return it.
	                consumeStringToken();
	                break;

	            // U+0028 LEFT PARENTHESIS (()
	            case 0x0028:
	                // Return a <(-token>.
	                type = TYPE$2.LeftParenthesis;
	                offset++;
	                break;

	            // U+0029 RIGHT PARENTHESIS ())
	            case 0x0029:
	                // Return a <)-token>.
	                type = TYPE$2.RightParenthesis;
	                offset++;
	                break;

	            // U+002B PLUS SIGN (+)
	            case 0x002B:
	                // If the input stream starts with a number, ...
	                if (isNumberStart$1(code, getCharCode(offset + 1), getCharCode(offset + 2))) {
	                    // ... reconsume the current input code point, consume a numeric token, and return it.
	                    consumeNumericToken();
	                } else {
	                    // Otherwise, return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }
	                break;

	            // U+002C COMMA (,)
	            case 0x002C:
	                // Return a <comma-token>.
	                type = TYPE$2.Comma;
	                offset++;
	                break;

	            // U+002D HYPHEN-MINUS (-)
	            case 0x002D:
	                // If the input stream starts with a number, reconsume the current input code point, consume a numeric token, and return it.
	                if (isNumberStart$1(code, getCharCode(offset + 1), getCharCode(offset + 2))) {
	                    consumeNumericToken();
	                } else {
	                    // Otherwise, if the next 2 input code points are U+002D HYPHEN-MINUS U+003E GREATER-THAN SIGN (->), consume them and return a <CDC-token>.
	                    if (getCharCode(offset + 1) === 0x002D &&
	                        getCharCode(offset + 2) === 0x003E) {
	                        type = TYPE$2.CDC;
	                        offset = offset + 3;
	                    } else {
	                        // Otherwise, if the input stream starts with an identifier, ...
	                        if (isIdentifierStart$1(code, getCharCode(offset + 1), getCharCode(offset + 2))) {
	                            // ... reconsume the current input code point, consume an ident-like token, and return it.
	                            consumeIdentLikeToken();
	                        } else {
	                            // Otherwise, return a <delim-token> with its value set to the current input code point.
	                            type = TYPE$2.Delim;
	                            offset++;
	                        }
	                    }
	                }
	                break;

	            // U+002E FULL STOP (.)
	            case 0x002E:
	                // If the input stream starts with a number, ...
	                if (isNumberStart$1(code, getCharCode(offset + 1), getCharCode(offset + 2))) {
	                    // ... reconsume the current input code point, consume a numeric token, and return it.
	                    consumeNumericToken();
	                } else {
	                    // Otherwise, return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }

	                break;

	            // U+002F SOLIDUS (/)
	            case 0x002F:
	                // If the next two input code point are U+002F SOLIDUS (/) followed by a U+002A ASTERISK (*),
	                if (getCharCode(offset + 1) === 0x002A) {
	                    // ... consume them and all following code points up to and including the first U+002A ASTERISK (*)
	                    // followed by a U+002F SOLIDUS (/), or up to an EOF code point.
	                    type = TYPE$2.Comment;
	                    offset = source.indexOf('*/', offset + 2) + 2;
	                    if (offset === 1) {
	                        offset = source.length;
	                    }
	                } else {
	                    type = TYPE$2.Delim;
	                    offset++;
	                }
	                break;

	            // U+003A COLON (:)
	            case 0x003A:
	                // Return a <colon-token>.
	                type = TYPE$2.Colon;
	                offset++;
	                break;

	            // U+003B SEMICOLON (;)
	            case 0x003B:
	                // Return a <semicolon-token>.
	                type = TYPE$2.Semicolon;
	                offset++;
	                break;

	            // U+003C LESS-THAN SIGN (<)
	            case 0x003C:
	                // If the next 3 input code points are U+0021 EXCLAMATION MARK U+002D HYPHEN-MINUS U+002D HYPHEN-MINUS (!--), ...
	                if (getCharCode(offset + 1) === 0x0021 &&
	                    getCharCode(offset + 2) === 0x002D &&
	                    getCharCode(offset + 3) === 0x002D) {
	                    // ... consume them and return a <CDO-token>.
	                    type = TYPE$2.CDO;
	                    offset = offset + 4;
	                } else {
	                    // Otherwise, return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }

	                break;

	            // U+0040 COMMERCIAL AT (@)
	            case 0x0040:
	                // If the next 3 input code points would start an identifier, ...
	                if (isIdentifierStart$1(getCharCode(offset + 1), getCharCode(offset + 2), getCharCode(offset + 3))) {
	                    // ... consume a name, create an <at-keyword-token> with its value set to the returned value, and return it.
	                    type = TYPE$2.AtKeyword;
	                    offset = consumeName$1(source, offset + 1);
	                } else {
	                    // Otherwise, return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }

	                break;

	            // U+005B LEFT SQUARE BRACKET ([)
	            case 0x005B:
	                // Return a <[-token>.
	                type = TYPE$2.LeftSquareBracket;
	                offset++;
	                break;

	            // U+005C REVERSE SOLIDUS (\)
	            case 0x005C:
	                // If the input stream starts with a valid escape, ...
	                if (isValidEscape$2(code, getCharCode(offset + 1))) {
	                    // ... reconsume the current input code point, consume an ident-like token, and return it.
	                    consumeIdentLikeToken();
	                } else {
	                    // Otherwise, this is a parse error. Return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }
	                break;

	            // U+005D RIGHT SQUARE BRACKET (])
	            case 0x005D:
	                // Return a <]-token>.
	                type = TYPE$2.RightSquareBracket;
	                offset++;
	                break;

	            // U+007B LEFT CURLY BRACKET ({)
	            case 0x007B:
	                // Return a <{-token>.
	                type = TYPE$2.LeftCurlyBracket;
	                offset++;
	                break;

	            // U+007D RIGHT CURLY BRACKET (})
	            case 0x007D:
	                // Return a <}-token>.
	                type = TYPE$2.RightCurlyBracket;
	                offset++;
	                break;

	            // digit
	            case charCodeCategory$1.Digit:
	                // Reconsume the current input code point, consume a numeric token, and return it.
	                consumeNumericToken();
	                break;

	            // name-start code point
	            case charCodeCategory$1.NameStart:
	                // Reconsume the current input code point, consume an ident-like token, and return it.
	                consumeIdentLikeToken();
	                break;

	            // EOF
	            case charCodeCategory$1.Eof:
	                // Return an <EOF-token>.
	                break;

	            // anything else
	            default:
	                // Return a <delim-token> with its value set to the current input code point.
	                type = TYPE$2.Delim;
	                offset++;
	        }

	        switch (type) {
	            case balanceCloseType:
	                balancePrev = balanceStart & OFFSET_MASK$1;
	                balanceStart = balance[balancePrev];
	                balanceCloseType = balanceStart >> TYPE_SHIFT$1;
	                balance[tokenCount] = balancePrev;
	                balance[balancePrev++] = tokenCount;
	                for (; balancePrev < tokenCount; balancePrev++) {
	                    if (balance[balancePrev] === sourceLength) {
	                        balance[balancePrev] = tokenCount;
	                    }
	                }
	                break;

	            case TYPE$2.LeftParenthesis:
	            case TYPE$2.Function:
	                balance[tokenCount] = balanceStart;
	                balanceCloseType = TYPE$2.RightParenthesis;
	                balanceStart = (balanceCloseType << TYPE_SHIFT$1) | tokenCount;
	                break;

	            case TYPE$2.LeftSquareBracket:
	                balance[tokenCount] = balanceStart;
	                balanceCloseType = TYPE$2.RightSquareBracket;
	                balanceStart = (balanceCloseType << TYPE_SHIFT$1) | tokenCount;
	                break;

	            case TYPE$2.LeftCurlyBracket:
	                balance[tokenCount] = balanceStart;
	                balanceCloseType = TYPE$2.RightCurlyBracket;
	                balanceStart = (balanceCloseType << TYPE_SHIFT$1) | tokenCount;
	                break;
	        }

	        offsetAndType[tokenCount++] = (type << TYPE_SHIFT$1) | offset;
	    }

	    // finalize buffers
	    offsetAndType[tokenCount] = (TYPE$2.EOF << TYPE_SHIFT$1) | offset; // <EOF-token>
	    balance[tokenCount] = sourceLength;
	    balance[sourceLength] = sourceLength; // prevents false positive balance match with any token
	    while (balanceStart !== 0) {
	        balancePrev = balanceStart & OFFSET_MASK$1;
	        balanceStart = balance[balancePrev];
	        balance[balancePrev] = sourceLength;
	    }

	    // update stream
	    stream.source = source;
	    stream.firstCharOffset = start;
	    stream.offsetAndType = offsetAndType;
	    stream.tokenCount = tokenCount;
	    stream.balance = balance;
	    stream.reset();
	    stream.next();

	    return stream;
	}

	// extend tokenizer with constants
	Object.keys(_const).forEach(function(key) {
	    tokenize[key] = _const[key];
	});

	// extend tokenizer with static methods from utils
	Object.keys(charCodeDefinitions).forEach(function(key) {
	    tokenize[key] = charCodeDefinitions[key];
	});
	Object.keys(utils).forEach(function(key) {
	    tokenize[key] = utils[key];
	});

	var tokenizer = tokenize;

	var isDigit$2 = tokenizer.isDigit;
	var cmpChar$1 = tokenizer.cmpChar;
	var TYPE$3 = tokenizer.TYPE;

	var DELIM = TYPE$3.Delim;
	var WHITESPACE$1 = TYPE$3.WhiteSpace;
	var COMMENT$1 = TYPE$3.Comment;
	var IDENT = TYPE$3.Ident;
	var NUMBER = TYPE$3.Number;
	var DIMENSION = TYPE$3.Dimension;
	var PLUSSIGN = 0x002B;    // U+002B PLUS SIGN (+)
	var HYPHENMINUS$1 = 0x002D; // U+002D HYPHEN-MINUS (-)
	var N = 0x006E;           // U+006E LATIN SMALL LETTER N (n)
	var DISALLOW_SIGN = true;
	var ALLOW_SIGN = false;

	function isDelim(token, code) {
	    return token !== null && token.type === DELIM && token.value.charCodeAt(0) === code;
	}

	function skipSC(token, offset, getNextToken) {
	    while (token !== null && (token.type === WHITESPACE$1 || token.type === COMMENT$1)) {
	        token = getNextToken(++offset);
	    }

	    return offset;
	}

	function checkInteger(token, valueOffset, disallowSign, offset) {
	    if (!token) {
	        return 0;
	    }

	    var code = token.value.charCodeAt(valueOffset);

	    if (code === PLUSSIGN || code === HYPHENMINUS$1) {
	        if (disallowSign) {
	            // Number sign is not allowed
	            return 0;
	        }
	        valueOffset++;
	    }

	    for (; valueOffset < token.value.length; valueOffset++) {
	        if (!isDigit$2(token.value.charCodeAt(valueOffset))) {
	            // Integer is expected
	            return 0;
	        }
	    }

	    return offset + 1;
	}

	// ... <signed-integer>
	// ... ['+' | '-'] <signless-integer>
	function consumeB(token, offset_, getNextToken) {
	    var sign = false;
	    var offset = skipSC(token, offset_, getNextToken);

	    token = getNextToken(offset);

	    if (token === null) {
	        return offset_;
	    }

	    if (token.type !== NUMBER) {
	        if (isDelim(token, PLUSSIGN) || isDelim(token, HYPHENMINUS$1)) {
	            sign = true;
	            offset = skipSC(getNextToken(++offset), offset, getNextToken);
	            token = getNextToken(offset);

	            if (token === null && token.type !== NUMBER) {
	                return 0;
	            }
	        } else {
	            return offset_;
	        }
	    }

	    if (!sign) {
	        var code = token.value.charCodeAt(0);
	        if (code !== PLUSSIGN && code !== HYPHENMINUS$1) {
	            // Number sign is expected
	            return 0;
	        }
	    }

	    return checkInteger(token, sign ? 0 : 1, sign, offset);
	}

	// An+B microsyntax https://www.w3.org/TR/css-syntax-3/#anb
	var genericAnPlusB = function anPlusB(token, getNextToken) {
	    /* eslint-disable brace-style*/
	    var offset = 0;

	    if (!token) {
	        return 0;
	    }

	    // <integer>
	    if (token.type === NUMBER) {
	        return checkInteger(token, 0, ALLOW_SIGN, offset); // b
	    }

	    // -n
	    // -n <signed-integer>
	    // -n ['+' | '-'] <signless-integer>
	    // -n- <signless-integer>
	    // <dashndashdigit-ident>
	    else if (token.type === IDENT && token.value.charCodeAt(0) === HYPHENMINUS$1) {
	        // expect 1st char is N
	        if (!cmpChar$1(token.value, 1, N)) {
	            return 0;
	        }

	        switch (token.value.length) {
	            // -n
	            // -n <signed-integer>
	            // -n ['+' | '-'] <signless-integer>
	            case 2:
	                return consumeB(getNextToken(++offset), offset, getNextToken);

	            // -n- <signless-integer>
	            case 3:
	                if (token.value.charCodeAt(2) !== HYPHENMINUS$1) {
	                    return 0;
	                }

	                offset = skipSC(getNextToken(++offset), offset, getNextToken);
	                token = getNextToken(offset);

	                return checkInteger(token, 0, DISALLOW_SIGN, offset);

	            // <dashndashdigit-ident>
	            default:
	                if (token.value.charCodeAt(2) !== HYPHENMINUS$1) {
	                    return 0;
	                }

	                return checkInteger(token, 3, DISALLOW_SIGN, offset);
	        }
	    }

	    // '+'? n
	    // '+'? n <signed-integer>
	    // '+'? n ['+' | '-'] <signless-integer>
	    // '+'? n- <signless-integer>
	    // '+'? <ndashdigit-ident>
	    else if (token.type === IDENT || (isDelim(token, PLUSSIGN) && getNextToken(offset + 1).type === IDENT)) {
	        // just ignore a plus
	        if (token.type !== IDENT) {
	            token = getNextToken(++offset);
	        }

	        if (token === null || !cmpChar$1(token.value, 0, N)) {
	            return 0;
	        }

	        switch (token.value.length) {
	            // '+'? n
	            // '+'? n <signed-integer>
	            // '+'? n ['+' | '-'] <signless-integer>
	            case 1:
	                return consumeB(getNextToken(++offset), offset, getNextToken);

	            // '+'? n- <signless-integer>
	            case 2:
	                if (token.value.charCodeAt(1) !== HYPHENMINUS$1) {
	                    return 0;
	                }

	                offset = skipSC(getNextToken(++offset), offset, getNextToken);
	                token = getNextToken(offset);

	                return checkInteger(token, 0, DISALLOW_SIGN, offset);

	            // '+'? <ndashdigit-ident>
	            default:
	                if (token.value.charCodeAt(1) !== HYPHENMINUS$1) {
	                    return 0;
	                }

	                return checkInteger(token, 2, DISALLOW_SIGN, offset);
	        }
	    }

	    // <ndashdigit-dimension>
	    // <ndash-dimension> <signless-integer>
	    // <n-dimension>
	    // <n-dimension> <signed-integer>
	    // <n-dimension> ['+' | '-'] <signless-integer>
	    else if (token.type === DIMENSION) {
	        var code = token.value.charCodeAt(0);
	        var sign = code === PLUSSIGN || code === HYPHENMINUS$1 ? 1 : 0;

	        for (var i = sign; i < token.value.length; i++) {
	            if (!isDigit$2(token.value.charCodeAt(i))) {
	                break;
	            }
	        }

	        if (i === sign) {
	            // Integer is expected
	            return 0;
	        }

	        if (!cmpChar$1(token.value, i, N)) {
	            return 0;
	        }

	        // <n-dimension>
	        // <n-dimension> <signed-integer>
	        // <n-dimension> ['+' | '-'] <signless-integer>
	        if (i + 1 === token.value.length) {
	            return consumeB(getNextToken(++offset), offset, getNextToken);
	        } else {
	            if (token.value.charCodeAt(i + 1) !== HYPHENMINUS$1) {
	                return 0;
	            }

	            // <ndash-dimension> <signless-integer>
	            if (i + 2 === token.value.length) {
	                offset = skipSC(getNextToken(++offset), offset, getNextToken);
	                token = getNextToken(offset);

	                return checkInteger(token, 0, DISALLOW_SIGN, offset);
	            }
	            // <ndashdigit-dimension>
	            else {
	                return checkInteger(token, i + 2, DISALLOW_SIGN, offset);
	            }
	        }
	    }

	    return 0;
	};

	var isHexDigit$2 = tokenizer.isHexDigit;
	var cmpChar$2 = tokenizer.cmpChar;
	var TYPE$4 = tokenizer.TYPE;

	var IDENT$1 = TYPE$4.Ident;
	var DELIM$1 = TYPE$4.Delim;
	var NUMBER$1 = TYPE$4.Number;
	var DIMENSION$1 = TYPE$4.Dimension;
	var PLUSSIGN$1 = 0x002B;     // U+002B PLUS SIGN (+)
	var HYPHENMINUS$2 = 0x002D;  // U+002D HYPHEN-MINUS (-)
	var QUESTIONMARK = 0x003F; // U+003F QUESTION MARK (?)
	var U = 0x0075;            // U+0075 LATIN SMALL LETTER U (u)

	function isDelim$1(token, code) {
	    return token !== null && token.type === DELIM$1 && token.value.charCodeAt(0) === code;
	}

	function startsWith(token, code) {
	    return token.value.charCodeAt(0) === code;
	}

	function hexSequence(token, offset, allowDash) {
	    for (var pos = offset, hexlen = 0; pos < token.value.length; pos++) {
	        var code = token.value.charCodeAt(pos);

	        if (code === HYPHENMINUS$2 && allowDash && hexlen !== 0) {
	            if (hexSequence(token, offset + hexlen + 1, false) > 0) {
	                return 6; // dissallow following question marks
	            }

	            return 0; // dash at the ending of a hex sequence is not allowed
	        }

	        if (!isHexDigit$2(code)) {
	            return 0; // not a hex digit
	        }

	        if (++hexlen > 6) {
	            return 0; // too many hex digits
	        }    }

	    return hexlen;
	}

	function withQuestionMarkSequence(consumed, length, getNextToken) {
	    if (!consumed) {
	        return 0; // nothing consumed
	    }

	    while (isDelim$1(getNextToken(length), QUESTIONMARK)) {
	        if (++consumed > 6) {
	            return 0; // too many question marks
	        }

	        length++;
	    }

	    return length;
	}

	// https://drafts.csswg.org/css-syntax/#urange
	// Informally, the <urange> production has three forms:
	// U+0001
	//      Defines a range consisting of a single code point, in this case the code point "1".
	// U+0001-00ff
	//      Defines a range of codepoints between the first and the second value, in this case
	//      the range between "1" and "ff" (255 in decimal) inclusive.
	// U+00??
	//      Defines a range of codepoints where the "?" characters range over all hex digits,
	//      in this case defining the same as the value U+0000-00ff.
	// In each form, a maximum of 6 digits is allowed for each hexadecimal number (if you treat "?" as a hexadecimal digit).
	//
	// <urange> =
	//   u '+' <ident-token> '?'* |
	//   u <dimension-token> '?'* |
	//   u <number-token> '?'* |
	//   u <number-token> <dimension-token> |
	//   u <number-token> <number-token> |
	//   u '+' '?'+
	var genericUrange = function urange(token, getNextToken) {
	    var length = 0;

	    // should start with `u` or `U`
	    if (token === null || token.type !== IDENT$1 || !cmpChar$2(token.value, 0, U)) {
	        return 0;
	    }

	    token = getNextToken(++length);
	    if (token === null) {
	        return 0;
	    }

	    // u '+' <ident-token> '?'*
	    // u '+' '?'+
	    if (isDelim$1(token, PLUSSIGN$1)) {
	        token = getNextToken(++length);
	        if (token === null) {
	            return 0;
	        }

	        if (token.type === IDENT$1) {
	            // u '+' <ident-token> '?'*
	            return withQuestionMarkSequence(hexSequence(token, 0, true), ++length, getNextToken);
	        }

	        if (isDelim$1(token, QUESTIONMARK)) {
	            // u '+' '?'+
	            return withQuestionMarkSequence(1, ++length, getNextToken);
	        }

	        // Hex digit or question mark is expected
	        return 0;
	    }

	    // u <number-token> '?'*
	    // u <number-token> <dimension-token>
	    // u <number-token> <number-token>
	    if (token.type === NUMBER$1) {
	        if (!startsWith(token, PLUSSIGN$1)) {
	            return 0;
	        }

	        var consumedHexLength = hexSequence(token, 1, true);
	        if (consumedHexLength === 0) {
	            return 0;
	        }

	        token = getNextToken(++length);
	        if (token === null) {
	            // u <number-token> <eof>
	            return length;
	        }

	        if (token.type === DIMENSION$1 || token.type === NUMBER$1) {
	            // u <number-token> <dimension-token>
	            // u <number-token> <number-token>
	            if (!startsWith(token, HYPHENMINUS$2) || !hexSequence(token, 1, false)) {
	                return 0;
	            }

	            return length + 1;
	        }

	        // u <number-token> '?'*
	        return withQuestionMarkSequence(consumedHexLength, length, getNextToken);
	    }

	    // u <dimension-token> '?'*
	    if (token.type === DIMENSION$1) {
	        if (!startsWith(token, PLUSSIGN$1)) {
	            return 0;
	        }

	        return withQuestionMarkSequence(hexSequence(token, 1, true), ++length, getNextToken);
	    }

	    return 0;
	};

	var isIdentifierStart$2 = tokenizer.isIdentifierStart;
	var isHexDigit$3 = tokenizer.isHexDigit;
	var isDigit$3 = tokenizer.isDigit;
	var cmpStr$3 = tokenizer.cmpStr;
	var consumeNumber$2 = tokenizer.consumeNumber;
	var TYPE$5 = tokenizer.TYPE;



	var cssWideKeywords = ['unset', 'initial', 'inherit'];
	var calcFunctionNames = ['calc(', '-moz-calc(', '-webkit-calc('];

	// https://www.w3.org/TR/css-values-3/#lengths
	var LENGTH = {
	    // absolute length units
	    'px': true,
	    'mm': true,
	    'cm': true,
	    'in': true,
	    'pt': true,
	    'pc': true,
	    'q': true,

	    // relative length units
	    'em': true,
	    'ex': true,
	    'ch': true,
	    'rem': true,

	    // viewport-percentage lengths
	    'vh': true,
	    'vw': true,
	    'vmin': true,
	    'vmax': true,
	    'vm': true
	};

	var ANGLE = {
	    'deg': true,
	    'grad': true,
	    'rad': true,
	    'turn': true
	};

	var TIME = {
	    's': true,
	    'ms': true
	};

	var FREQUENCY = {
	    'hz': true,
	    'khz': true
	};

	// https://www.w3.org/TR/css-values-3/#resolution (https://drafts.csswg.org/css-values/#resolution)
	var RESOLUTION = {
	    'dpi': true,
	    'dpcm': true,
	    'dppx': true,
	    'x': true      // https://github.com/w3c/csswg-drafts/issues/461
	};

	// https://drafts.csswg.org/css-grid/#fr-unit
	var FLEX = {
	    'fr': true
	};

	// https://www.w3.org/TR/css3-speech/#mixing-props-voice-volume
	var DECIBEL = {
	    'db': true
	};

	// https://www.w3.org/TR/css3-speech/#voice-props-voice-pitch
	var SEMITONES = {
	    'st': true
	};

	// safe char code getter
	function charCode(str, index) {
	    return index < str.length ? str.charCodeAt(index) : 0;
	}

	function eqStr(actual, expected) {
	    return cmpStr$3(actual, 0, actual.length, expected);
	}

	function eqStrAny(actual, expected) {
	    for (var i = 0; i < expected.length; i++) {
	        if (eqStr(actual, expected[i])) {
	            return true;
	        }
	    }

	    return false;
	}

	// IE postfix hack, i.e. 123\0 or 123px\9
	function isPostfixIeHack(str, offset) {
	    if (offset !== str.length - 2) {
	        return false;
	    }

	    return (
	        str.charCodeAt(offset) === 0x005C &&  // U+005C REVERSE SOLIDUS (\)
	        isDigit$3(str.charCodeAt(offset + 1))
	    );
	}

	function outOfRange(opts, value, numEnd) {
	    if (opts && opts.type === 'Range') {
	        var num = Number(
	            numEnd !== undefined && numEnd !== value.length
	                ? value.substr(0, numEnd)
	                : value
	        );

	        if (isNaN(num)) {
	            return true;
	        }

	        if (opts.min !== null && num < opts.min) {
	            return true;
	        }

	        if (opts.max !== null && num > opts.max) {
	            return true;
	        }
	    }

	    return false;
	}

	function consumeFunction(token, getNextToken) {
	    var startIdx = token.index;
	    var length = 0;

	    // balanced token consuming
	    do {
	        length++;

	        if (token.balance <= startIdx) {
	            break;
	        }
	    } while (token = getNextToken(length));

	    return length;
	}

	// TODO: implement
	// can be used wherever <length>, <frequency>, <angle>, <time>, <percentage>, <number>, or <integer> values are allowed
	// https://drafts.csswg.org/css-values/#calc-notation
	function calc(next) {
	    return function(token, getNextToken, opts) {
	        if (token === null) {
	            return 0;
	        }

	        if (token.type === TYPE$5.Function && eqStrAny(token.value, calcFunctionNames)) {
	            return consumeFunction(token, getNextToken);
	        }

	        return next(token, getNextToken, opts);
	    };
	}

	function tokenType(expectedTokenType) {
	    return function(token) {
	        if (token === null || token.type !== expectedTokenType) {
	            return 0;
	        }

	        return 1;
	    };
	}

	function func(name) {
	    name = name + '(';

	    return function(token, getNextToken) {
	        if (token !== null && eqStr(token.value, name)) {
	            return consumeFunction(token, getNextToken);
	        }

	        return 0;
	    };
	}

	// =========================
	// Complex types
	//

	// https://drafts.csswg.org/css-values-4/#custom-idents
	// 4.2. Author-defined Identifiers: the <custom-ident> type
	// Some properties accept arbitrary author-defined identifiers as a component value.
	// This generic data type is denoted by <custom-ident>, and represents any valid CSS identifier
	// that would not be misinterpreted as a pre-defined keyword in that property’s value definition.
	//
	// See also: https://developer.mozilla.org/en-US/docs/Web/CSS/custom-ident
	function customIdent(token) {
	    if (token === null || token.type !== TYPE$5.Ident) {
	        return 0;
	    }

	    var name = token.value.toLowerCase();

	    // The CSS-wide keywords are not valid <custom-ident>s
	    if (eqStrAny(name, cssWideKeywords)) {
	        return 0;
	    }

	    // The default keyword is reserved and is also not a valid <custom-ident>
	    if (eqStr(name, 'default')) {
	        return 0;
	    }

	    // TODO: ignore property specific keywords (as described https://developer.mozilla.org/en-US/docs/Web/CSS/custom-ident)
	    // Specifications using <custom-ident> must specify clearly what other keywords
	    // are excluded from <custom-ident>, if any—for example by saying that any pre-defined keywords
	    // in that property’s value definition are excluded. Excluded keywords are excluded
	    // in all ASCII case permutations.

	    return 1;
	}

	// https://drafts.csswg.org/css-variables/#typedef-custom-property-name
	// A custom property is any property whose name starts with two dashes (U+002D HYPHEN-MINUS), like --foo.
	// The <custom-property-name> production corresponds to this: it’s defined as any valid identifier
	// that starts with two dashes, except -- itself, which is reserved for future use by CSS.
	// NOTE: Current implementation treat `--` as a valid name since most (all?) major browsers treat it as valid.
	function customPropertyName(token) {
	    // ... defined as any valid identifier
	    if (token === null || token.type !== TYPE$5.Ident) {
	        return 0;
	    }

	    // ... that starts with two dashes (U+002D HYPHEN-MINUS)
	    if (charCode(token.value, 0) !== 0x002D || charCode(token.value, 1) !== 0x002D) {
	        return 0;
	    }

	    return 1;
	}

	// https://drafts.csswg.org/css-color-4/#hex-notation
	// The syntax of a <hex-color> is a <hash-token> token whose value consists of 3, 4, 6, or 8 hexadecimal digits.
	// In other words, a hex color is written as a hash character, "#", followed by some number of digits 0-9 or
	// letters a-f (the case of the letters doesn’t matter - #00ff00 is identical to #00FF00).
	function hexColor(token) {
	    if (token === null || token.type !== TYPE$5.Hash) {
	        return 0;
	    }

	    var length = token.value.length;

	    // valid values (length): #rgb (4), #rgba (5), #rrggbb (7), #rrggbbaa (9)
	    if (length !== 4 && length !== 5 && length !== 7 && length !== 9) {
	        return 0;
	    }

	    for (var i = 1; i < length; i++) {
	        if (!isHexDigit$3(token.value.charCodeAt(i))) {
	            return 0;
	        }
	    }

	    return 1;
	}

	function idSelector(token) {
	    if (token === null || token.type !== TYPE$5.Hash) {
	        return 0;
	    }

	    if (!isIdentifierStart$2(charCode(token.value, 1), charCode(token.value, 2), charCode(token.value, 3))) {
	        return 0;
	    }

	    return 1;
	}

	// https://drafts.csswg.org/css-syntax/#any-value
	// It represents the entirety of what a valid declaration can have as its value.
	function declarationValue(token, getNextToken) {
	    if (!token) {
	        return 0;
	    }

	    var length = 0;
	    var level = 0;
	    var startIdx = token.index;

	    // The <declaration-value> production matches any sequence of one or more tokens,
	    // so long as the sequence ...
	    scan:
	    do {
	        switch (token.type) {
	            // ... does not contain <bad-string-token>, <bad-url-token>,
	            case TYPE$5.BadString:
	            case TYPE$5.BadUrl:
	                break scan;

	            // ... unmatched <)-token>, <]-token>, or <}-token>,
	            case TYPE$5.RightCurlyBracket:
	            case TYPE$5.RightParenthesis:
	            case TYPE$5.RightSquareBracket:
	                if (token.balance > token.index || token.balance < startIdx) {
	                    break scan;
	                }

	                level--;
	                break;

	            // ... or top-level <semicolon-token> tokens
	            case TYPE$5.Semicolon:
	                if (level === 0) {
	                    break scan;
	                }

	                break;

	            // ... or <delim-token> tokens with a value of "!"
	            case TYPE$5.Delim:
	                if (token.value === '!' && level === 0) {
	                    break scan;
	                }

	                break;

	            case TYPE$5.Function:
	            case TYPE$5.LeftParenthesis:
	            case TYPE$5.LeftSquareBracket:
	            case TYPE$5.LeftCurlyBracket:
	                level++;
	                break;
	        }

	        length++;

	        // until balance closing
	        if (token.balance <= startIdx) {
	            break;
	        }
	    } while (token = getNextToken(length));

	    return length;
	}

	// https://drafts.csswg.org/css-syntax/#any-value
	// The <any-value> production is identical to <declaration-value>, but also
	// allows top-level <semicolon-token> tokens and <delim-token> tokens
	// with a value of "!". It represents the entirety of what valid CSS can be in any context.
	function anyValue(token, getNextToken) {
	    if (!token) {
	        return 0;
	    }

	    var startIdx = token.index;
	    var length = 0;

	    // The <any-value> production matches any sequence of one or more tokens,
	    // so long as the sequence ...
	    scan:
	    do {
	        switch (token.type) {
	            // ... does not contain <bad-string-token>, <bad-url-token>,
	            case TYPE$5.BadString:
	            case TYPE$5.BadUrl:
	                break scan;

	            // ... unmatched <)-token>, <]-token>, or <}-token>,
	            case TYPE$5.RightCurlyBracket:
	            case TYPE$5.RightParenthesis:
	            case TYPE$5.RightSquareBracket:
	                if (token.balance > token.index || token.balance < startIdx) {
	                    break scan;
	                }

	                break;
	        }

	        length++;

	        // until balance closing
	        if (token.balance <= startIdx) {
	            break;
	        }
	    } while (token = getNextToken(length));

	    return length;
	}

	// =========================
	// Dimensions
	//

	function dimension(type) {
	    return function(token, getNextToken, opts) {
	        if (token === null || token.type !== TYPE$5.Dimension) {
	            return 0;
	        }

	        var numberEnd = consumeNumber$2(token.value, 0);

	        // check unit
	        if (type !== null) {
	            // check for IE postfix hack, i.e. 123px\0 or 123px\9
	            var reverseSolidusOffset = token.value.indexOf('\\', numberEnd);
	            var unit = reverseSolidusOffset === -1 || !isPostfixIeHack(token.value, reverseSolidusOffset)
	                ? token.value.substr(numberEnd)
	                : token.value.substring(numberEnd, reverseSolidusOffset);

	            if (type.hasOwnProperty(unit.toLowerCase()) === false) {
	                return 0;
	            }
	        }

	        // check range if specified
	        if (outOfRange(opts, token.value, numberEnd)) {
	            return 0;
	        }

	        return 1;
	    };
	}

	// =========================
	// Percentage
	//

	// §5.5. Percentages: the <percentage> type
	// https://drafts.csswg.org/css-values-4/#percentages
	function percentage(token, getNextToken, opts) {
	    // ... corresponds to the <percentage-token> production
	    if (token === null || token.type !== TYPE$5.Percentage) {
	        return 0;
	    }

	    // check range if specified
	    if (outOfRange(opts, token.value, token.value.length - 1)) {
	        return 0;
	    }

	    return 1;
	}

	// =========================
	// Numeric
	//

	// https://drafts.csswg.org/css-values-4/#numbers
	// The value <zero> represents a literal number with the value 0. Expressions that merely
	// evaluate to a <number> with the value 0 (for example, calc(0)) do not match <zero>;
	// only literal <number-token>s do.
	function zero(next) {
	    if (typeof next !== 'function') {
	        next = function() {
	            return 0;
	        };
	    }

	    return function(token, getNextToken, opts) {
	        if (token !== null && token.type === TYPE$5.Number) {
	            if (Number(token.value) === 0) {
	                return 1;
	            }
	        }

	        return next(token, getNextToken, opts);
	    };
	}

	// § 5.3. Real Numbers: the <number> type
	// https://drafts.csswg.org/css-values-4/#numbers
	// Number values are denoted by <number>, and represent real numbers, possibly with a fractional component.
	// ... It corresponds to the <number-token> production
	function number(token, getNextToken, opts) {
	    if (token === null) {
	        return 0;
	    }

	    var numberEnd = consumeNumber$2(token.value, 0);
	    var isNumber = numberEnd === token.value.length;
	    if (!isNumber && !isPostfixIeHack(token.value, numberEnd)) {
	        return 0;
	    }

	    // check range if specified
	    if (outOfRange(opts, token.value, numberEnd)) {
	        return 0;
	    }

	    return 1;
	}

	// §5.2. Integers: the <integer> type
	// https://drafts.csswg.org/css-values-4/#integers
	function integer(token, getNextToken, opts) {
	    // ... corresponds to a subset of the <number-token> production
	    if (token === null || token.type !== TYPE$5.Number) {
	        return 0;
	    }

	    // The first digit of an integer may be immediately preceded by `-` or `+` to indicate the integer’s sign.
	    var i = token.value.charCodeAt(0) === 0x002B ||       // U+002B PLUS SIGN (+)
	            token.value.charCodeAt(0) === 0x002D ? 1 : 0; // U+002D HYPHEN-MINUS (-)

	    // When written literally, an integer is one or more decimal digits 0 through 9 ...
	    for (; i < token.value.length; i++) {
	        if (!isDigit$3(token.value.charCodeAt(i))) {
	            return 0;
	        }
	    }

	    // check range if specified
	    if (outOfRange(opts, token.value, i)) {
	        return 0;
	    }

	    return 1;
	}

	var generic = {
	    // token types
	    'ident-token': tokenType(TYPE$5.Ident),
	    'function-token': tokenType(TYPE$5.Function),
	    'at-keyword-token': tokenType(TYPE$5.AtKeyword),
	    'hash-token': tokenType(TYPE$5.Hash),
	    'string-token': tokenType(TYPE$5.String),
	    'bad-string-token': tokenType(TYPE$5.BadString),
	    'url-token': tokenType(TYPE$5.Url),
	    'bad-url-token': tokenType(TYPE$5.BadUrl),
	    'delim-token': tokenType(TYPE$5.Delim),
	    'number-token': tokenType(TYPE$5.Number),
	    'percentage-token': tokenType(TYPE$5.Percentage),
	    'dimension-token': tokenType(TYPE$5.Dimension),
	    'whitespace-token': tokenType(TYPE$5.WhiteSpace),
	    'CDO-token': tokenType(TYPE$5.CDO),
	    'CDC-token': tokenType(TYPE$5.CDC),
	    'colon-token': tokenType(TYPE$5.Colon),
	    'semicolon-token': tokenType(TYPE$5.Semicolon),
	    'comma-token': tokenType(TYPE$5.Comma),
	    '[-token': tokenType(TYPE$5.LeftSquareBracket),
	    ']-token': tokenType(TYPE$5.RightSquareBracket),
	    '(-token': tokenType(TYPE$5.LeftParenthesis),
	    ')-token': tokenType(TYPE$5.RightParenthesis),
	    '{-token': tokenType(TYPE$5.LeftCurlyBracket),
	    '}-token': tokenType(TYPE$5.RightCurlyBracket),

	    // token type aliases
	    'string': tokenType(TYPE$5.String),
	    'ident': tokenType(TYPE$5.Ident),

	    // complex types
	    'custom-ident': customIdent,
	    'custom-property-name': customPropertyName,
	    'hex-color': hexColor,
	    'id-selector': idSelector, // element( <id-selector> )
	    'an-plus-b': genericAnPlusB,
	    'urange': genericUrange,
	    'declaration-value': declarationValue,
	    'any-value': anyValue,

	    // dimensions
	    'dimension': calc(dimension(null)),
	    'angle': calc(dimension(ANGLE)),
	    'decibel': calc(dimension(DECIBEL)),
	    'frequency': calc(dimension(FREQUENCY)),
	    'flex': calc(dimension(FLEX)),
	    'length': calc(zero(dimension(LENGTH))),
	    'resolution': calc(dimension(RESOLUTION)),
	    'semitones': calc(dimension(SEMITONES)),
	    'time': calc(dimension(TIME)),

	    // percentage
	    'percentage': calc(percentage),

	    // numeric
	    'zero': zero(),
	    'number': calc(number),
	    'integer': calc(integer),

	    // old IE stuff
	    '-ms-legacy-expression': func('expression')
	};

	var _SyntaxError$1 = function SyntaxError(message, input, offset) {
	    var error = createCustomError('SyntaxError', message);

	    error.input = input;
	    error.offset = offset;
	    error.rawMessage = message;
	    error.message = error.rawMessage + '\n' +
	        '  ' + error.input + '\n' +
	        '--' + new Array((error.offset || error.input.length) + 1).join('-') + '^';

	    return error;
	};

	var TAB = 9;
	var N$1 = 10;
	var F = 12;
	var R = 13;
	var SPACE = 32;

	var Tokenizer = function(str) {
	    this.str = str;
	    this.pos = 0;
	};

	Tokenizer.prototype = {
	    charCodeAt: function(pos) {
	        return pos < this.str.length ? this.str.charCodeAt(pos) : 0;
	    },
	    charCode: function() {
	        return this.charCodeAt(this.pos);
	    },
	    nextCharCode: function() {
	        return this.charCodeAt(this.pos + 1);
	    },
	    nextNonWsCode: function(pos) {
	        return this.charCodeAt(this.findWsEnd(pos));
	    },
	    findWsEnd: function(pos) {
	        for (; pos < this.str.length; pos++) {
	            var code = this.str.charCodeAt(pos);
	            if (code !== R && code !== N$1 && code !== F && code !== SPACE && code !== TAB) {
	                break;
	            }
	        }

	        return pos;
	    },
	    substringToPos: function(end) {
	        return this.str.substring(this.pos, this.pos = end);
	    },
	    eat: function(code) {
	        if (this.charCode() !== code) {
	            this.error('Expect `' + String.fromCharCode(code) + '`');
	        }

	        this.pos++;
	    },
	    peek: function() {
	        return this.pos < this.str.length ? this.str.charAt(this.pos++) : '';
	    },
	    error: function(message) {
	        throw new _SyntaxError$1(message, this.str, this.pos);
	    }
	};

	var tokenizer$1 = Tokenizer;

	var TAB$1 = 9;
	var N$2 = 10;
	var F$1 = 12;
	var R$1 = 13;
	var SPACE$1 = 32;
	var EXCLAMATIONMARK = 33;    // !
	var NUMBERSIGN = 35;         // #
	var AMPERSAND = 38;          // &
	var APOSTROPHE = 39;         // '
	var LEFTPARENTHESIS = 40;    // (
	var RIGHTPARENTHESIS = 41;   // )
	var ASTERISK = 42;           // *
	var PLUSSIGN$2 = 43;           // +
	var COMMA = 44;              // ,
	var HYPERMINUS = 45;         // -
	var LESSTHANSIGN = 60;       // <
	var GREATERTHANSIGN = 62;    // >
	var QUESTIONMARK$1 = 63;       // ?
	var COMMERCIALAT = 64;       // @
	var LEFTSQUAREBRACKET = 91;  // [
	var RIGHTSQUAREBRACKET = 93; // ]
	var LEFTCURLYBRACKET = 123;  // {
	var VERTICALLINE = 124;      // |
	var RIGHTCURLYBRACKET = 125; // }
	var INFINITY = 8734;         // ∞
	var NAME_CHAR = createCharMap(function(ch) {
	    return /[a-zA-Z0-9\-]/.test(ch);
	});
	var COMBINATOR_PRECEDENCE = {
	    ' ': 1,
	    '&&': 2,
	    '||': 3,
	    '|': 4
	};

	function createCharMap(fn) {
	    var array = typeof Uint32Array === 'function' ? new Uint32Array(128) : new Array(128);
	    for (var i = 0; i < 128; i++) {
	        array[i] = fn(String.fromCharCode(i)) ? 1 : 0;
	    }
	    return array;
	}

	function scanSpaces(tokenizer) {
	    return tokenizer.substringToPos(
	        tokenizer.findWsEnd(tokenizer.pos)
	    );
	}

	function scanWord(tokenizer) {
	    var end = tokenizer.pos;

	    for (; end < tokenizer.str.length; end++) {
	        var code = tokenizer.str.charCodeAt(end);
	        if (code >= 128 || NAME_CHAR[code] === 0) {
	            break;
	        }
	    }

	    if (tokenizer.pos === end) {
	        tokenizer.error('Expect a keyword');
	    }

	    return tokenizer.substringToPos(end);
	}

	function scanNumber(tokenizer) {
	    var end = tokenizer.pos;

	    for (; end < tokenizer.str.length; end++) {
	        var code = tokenizer.str.charCodeAt(end);
	        if (code < 48 || code > 57) {
	            break;
	        }
	    }

	    if (tokenizer.pos === end) {
	        tokenizer.error('Expect a number');
	    }

	    return tokenizer.substringToPos(end);
	}

	function scanString(tokenizer) {
	    var end = tokenizer.str.indexOf('\'', tokenizer.pos + 1);

	    if (end === -1) {
	        tokenizer.pos = tokenizer.str.length;
	        tokenizer.error('Expect an apostrophe');
	    }

	    return tokenizer.substringToPos(end + 1);
	}

	function readMultiplierRange(tokenizer) {
	    var min = null;
	    var max = null;

	    tokenizer.eat(LEFTCURLYBRACKET);

	    min = scanNumber(tokenizer);

	    if (tokenizer.charCode() === COMMA) {
	        tokenizer.pos++;
	        if (tokenizer.charCode() !== RIGHTCURLYBRACKET) {
	            max = scanNumber(tokenizer);
	        }
	    } else {
	        max = min;
	    }

	    tokenizer.eat(RIGHTCURLYBRACKET);

	    return {
	        min: Number(min),
	        max: max ? Number(max) : 0
	    };
	}

	function readMultiplier(tokenizer) {
	    var range = null;
	    var comma = false;

	    switch (tokenizer.charCode()) {
	        case ASTERISK:
	            tokenizer.pos++;

	            range = {
	                min: 0,
	                max: 0
	            };

	            break;

	        case PLUSSIGN$2:
	            tokenizer.pos++;

	            range = {
	                min: 1,
	                max: 0
	            };

	            break;

	        case QUESTIONMARK$1:
	            tokenizer.pos++;

	            range = {
	                min: 0,
	                max: 1
	            };

	            break;

	        case NUMBERSIGN:
	            tokenizer.pos++;

	            comma = true;

	            if (tokenizer.charCode() === LEFTCURLYBRACKET) {
	                range = readMultiplierRange(tokenizer);
	            } else {
	                range = {
	                    min: 1,
	                    max: 0
	                };
	            }

	            break;

	        case LEFTCURLYBRACKET:
	            range = readMultiplierRange(tokenizer);
	            break;

	        default:
	            return null;
	    }

	    return {
	        type: 'Multiplier',
	        comma: comma,
	        min: range.min,
	        max: range.max,
	        term: null
	    };
	}

	function maybeMultiplied(tokenizer, node) {
	    var multiplier = readMultiplier(tokenizer);

	    if (multiplier !== null) {
	        multiplier.term = node;
	        return multiplier;
	    }

	    return node;
	}

	function maybeToken(tokenizer) {
	    var ch = tokenizer.peek();

	    if (ch === '') {
	        return null;
	    }

	    return {
	        type: 'Token',
	        value: ch
	    };
	}

	function readProperty(tokenizer) {
	    var name;

	    tokenizer.eat(LESSTHANSIGN);
	    tokenizer.eat(APOSTROPHE);

	    name = scanWord(tokenizer);

	    tokenizer.eat(APOSTROPHE);
	    tokenizer.eat(GREATERTHANSIGN);

	    return maybeMultiplied(tokenizer, {
	        type: 'Property',
	        name: name
	    });
	}

	// https://drafts.csswg.org/css-values-3/#numeric-ranges
	// 4.1. Range Restrictions and Range Definition Notation
	//
	// Range restrictions can be annotated in the numeric type notation using CSS bracketed
	// range notation—[min,max]—within the angle brackets, after the identifying keyword,
	// indicating a closed range between (and including) min and max.
	// For example, <integer [0, 10]> indicates an integer between 0 and 10, inclusive.
	function readTypeRange(tokenizer) {
	    // use null for Infinity to make AST format JSON serializable/deserializable
	    var min = null; // -Infinity
	    var max = null; // Infinity
	    var sign = 1;

	    tokenizer.eat(LEFTSQUAREBRACKET);

	    if (tokenizer.charCode() === HYPERMINUS) {
	        tokenizer.peek();
	        sign = -1;
	    }

	    if (sign == -1 && tokenizer.charCode() === INFINITY) {
	        tokenizer.peek();
	    } else {
	        min = sign * Number(scanNumber(tokenizer));
	    }

	    scanSpaces(tokenizer);
	    tokenizer.eat(COMMA);
	    scanSpaces(tokenizer);

	    if (tokenizer.charCode() === INFINITY) {
	        tokenizer.peek();
	    } else {
	        sign = 1;

	        if (tokenizer.charCode() === HYPERMINUS) {
	            tokenizer.peek();
	            sign = -1;
	        }

	        max = sign * Number(scanNumber(tokenizer));
	    }

	    tokenizer.eat(RIGHTSQUAREBRACKET);

	    // If no range is indicated, either by using the bracketed range notation
	    // or in the property description, then [−∞,∞] is assumed.
	    if (min === null && max === null) {
	        return null;
	    }

	    return {
	        type: 'Range',
	        min: min,
	        max: max
	    };
	}

	function readType(tokenizer) {
	    var name;
	    var opts = null;

	    tokenizer.eat(LESSTHANSIGN);
	    name = scanWord(tokenizer);

	    if (tokenizer.charCode() === LEFTPARENTHESIS &&
	        tokenizer.nextCharCode() === RIGHTPARENTHESIS) {
	        tokenizer.pos += 2;
	        name += '()';
	    }

	    if (tokenizer.charCodeAt(tokenizer.findWsEnd(tokenizer.pos)) === LEFTSQUAREBRACKET) {
	        scanSpaces(tokenizer);
	        opts = readTypeRange(tokenizer);
	    }

	    tokenizer.eat(GREATERTHANSIGN);

	    return maybeMultiplied(tokenizer, {
	        type: 'Type',
	        name: name,
	        opts: opts
	    });
	}

	function readKeywordOrFunction(tokenizer) {
	    var name;

	    name = scanWord(tokenizer);

	    if (tokenizer.charCode() === LEFTPARENTHESIS) {
	        tokenizer.pos++;

	        return {
	            type: 'Function',
	            name: name
	        };
	    }

	    return maybeMultiplied(tokenizer, {
	        type: 'Keyword',
	        name: name
	    });
	}

	function regroupTerms(terms, combinators) {
	    function createGroup(terms, combinator) {
	        return {
	            type: 'Group',
	            terms: terms,
	            combinator: combinator,
	            disallowEmpty: false,
	            explicit: false
	        };
	    }

	    combinators = Object.keys(combinators).sort(function(a, b) {
	        return COMBINATOR_PRECEDENCE[a] - COMBINATOR_PRECEDENCE[b];
	    });

	    while (combinators.length > 0) {
	        var combinator = combinators.shift();
	        for (var i = 0, subgroupStart = 0; i < terms.length; i++) {
	            var term = terms[i];
	            if (term.type === 'Combinator') {
	                if (term.value === combinator) {
	                    if (subgroupStart === -1) {
	                        subgroupStart = i - 1;
	                    }
	                    terms.splice(i, 1);
	                    i--;
	                } else {
	                    if (subgroupStart !== -1 && i - subgroupStart > 1) {
	                        terms.splice(
	                            subgroupStart,
	                            i - subgroupStart,
	                            createGroup(terms.slice(subgroupStart, i), combinator)
	                        );
	                        i = subgroupStart + 1;
	                    }
	                    subgroupStart = -1;
	                }
	            }
	        }

	        if (subgroupStart !== -1 && combinators.length) {
	            terms.splice(
	                subgroupStart,
	                i - subgroupStart,
	                createGroup(terms.slice(subgroupStart, i), combinator)
	            );
	        }
	    }

	    return combinator;
	}

	function readImplicitGroup(tokenizer) {
	    var terms = [];
	    var combinators = {};
	    var token;
	    var prevToken = null;
	    var prevTokenPos = tokenizer.pos;

	    while (token = peek(tokenizer)) {
	        if (token.type !== 'Spaces') {
	            if (token.type === 'Combinator') {
	                // check for combinator in group beginning and double combinator sequence
	                if (prevToken === null || prevToken.type === 'Combinator') {
	                    tokenizer.pos = prevTokenPos;
	                    tokenizer.error('Unexpected combinator');
	                }

	                combinators[token.value] = true;
	            } else if (prevToken !== null && prevToken.type !== 'Combinator') {
	                combinators[' '] = true;  // a b
	                terms.push({
	                    type: 'Combinator',
	                    value: ' '
	                });
	            }

	            terms.push(token);
	            prevToken = token;
	            prevTokenPos = tokenizer.pos;
	        }
	    }

	    // check for combinator in group ending
	    if (prevToken !== null && prevToken.type === 'Combinator') {
	        tokenizer.pos -= prevTokenPos;
	        tokenizer.error('Unexpected combinator');
	    }

	    return {
	        type: 'Group',
	        terms: terms,
	        combinator: regroupTerms(terms, combinators) || ' ',
	        disallowEmpty: false,
	        explicit: false
	    };
	}

	function readGroup(tokenizer) {
	    var result;

	    tokenizer.eat(LEFTSQUAREBRACKET);
	    result = readImplicitGroup(tokenizer);
	    tokenizer.eat(RIGHTSQUAREBRACKET);

	    result.explicit = true;

	    if (tokenizer.charCode() === EXCLAMATIONMARK) {
	        tokenizer.pos++;
	        result.disallowEmpty = true;
	    }

	    return result;
	}

	function peek(tokenizer) {
	    var code = tokenizer.charCode();

	    if (code < 128 && NAME_CHAR[code] === 1) {
	        return readKeywordOrFunction(tokenizer);
	    }

	    switch (code) {
	        case RIGHTSQUAREBRACKET:
	            // don't eat, stop scan a group
	            break;

	        case LEFTSQUAREBRACKET:
	            return maybeMultiplied(tokenizer, readGroup(tokenizer));

	        case LESSTHANSIGN:
	            return tokenizer.nextCharCode() === APOSTROPHE
	                ? readProperty(tokenizer)
	                : readType(tokenizer);

	        case VERTICALLINE:
	            return {
	                type: 'Combinator',
	                value: tokenizer.substringToPos(
	                    tokenizer.nextCharCode() === VERTICALLINE
	                        ? tokenizer.pos + 2
	                        : tokenizer.pos + 1
	                )
	            };

	        case AMPERSAND:
	            tokenizer.pos++;
	            tokenizer.eat(AMPERSAND);

	            return {
	                type: 'Combinator',
	                value: '&&'
	            };

	        case COMMA:
	            tokenizer.pos++;
	            return {
	                type: 'Comma'
	            };

	        case APOSTROPHE:
	            return maybeMultiplied(tokenizer, {
	                type: 'String',
	                value: scanString(tokenizer)
	            });

	        case SPACE$1:
	        case TAB$1:
	        case N$2:
	        case R$1:
	        case F$1:
	            return {
	                type: 'Spaces',
	                value: scanSpaces(tokenizer)
	            };

	        case COMMERCIALAT:
	            code = tokenizer.nextCharCode();

	            if (code < 128 && NAME_CHAR[code] === 1) {
	                tokenizer.pos++;
	                return {
	                    type: 'AtKeyword',
	                    name: scanWord(tokenizer)
	                };
	            }

	            return maybeToken(tokenizer);

	        case ASTERISK:
	        case PLUSSIGN$2:
	        case QUESTIONMARK$1:
	        case NUMBERSIGN:
	        case EXCLAMATIONMARK:
	            // prohibited tokens (used as a multiplier start)
	            break;

	        case LEFTCURLYBRACKET:
	            // LEFTCURLYBRACKET is allowed since mdn/data uses it w/o quoting
	            // check next char isn't a number, because it's likely a disjoined multiplier
	            code = tokenizer.nextCharCode();

	            if (code < 48 || code > 57) {
	                return maybeToken(tokenizer);
	            }

	            break;

	        default:
	            return maybeToken(tokenizer);
	    }
	}

	function parse(source) {
	    var tokenizer = new tokenizer$1(source);
	    var result = readImplicitGroup(tokenizer);

	    if (tokenizer.pos !== source.length) {
	        tokenizer.error('Unexpected input');
	    }

	    // reduce redundant groups with single group term
	    if (result.terms.length === 1 && result.terms[0].type === 'Group') {
	        result = result.terms[0];
	    }

	    return result;
	}

	// warm up parse to elimitate code branches that never execute
	// fix soft deoptimizations (insufficient type feedback)
	parse('[a&&<b>#|<\'c\'>*||e() f{2} /,(% g#{1,2} h{2,})]!');

	var parse_1 = parse;

	var noop$2 = function() {};

	function ensureFunction(value) {
	    return typeof value === 'function' ? value : noop$2;
	}

	var walk$1 = function(node, options, context) {
	    function walk(node) {
	        enter.call(context, node);

	        switch (node.type) {
	            case 'Group':
	                node.terms.forEach(walk);
	                break;

	            case 'Multiplier':
	                walk(node.term);
	                break;

	            case 'Type':
	            case 'Property':
	            case 'Keyword':
	            case 'AtKeyword':
	            case 'Function':
	            case 'String':
	            case 'Token':
	            case 'Comma':
	                break;

	            default:
	                throw new Error('Unknown type: ' + node.type);
	        }

	        leave.call(context, node);
	    }

	    var enter = noop$2;
	    var leave = noop$2;

	    if (typeof options === 'function') {
	        enter = options;
	    } else if (options) {
	        enter = ensureFunction(options.enter);
	        leave = ensureFunction(options.leave);
	    }

	    if (enter === noop$2 && leave === noop$2) {
	        throw new Error('Neither `enter` nor `leave` walker handler is set or both aren\'t a function');
	    }

	    walk(node);
	};

	var tokenStream = new TokenStream_1();
	var astToTokens = {
	    decorator: function(handlers) {
	        var curNode = null;
	        var prev = { len: 0, node: null };
	        var nodes = [prev];
	        var buffer = '';

	        return {
	            children: handlers.children,
	            node: function(node) {
	                var tmp = curNode;
	                curNode = node;
	                handlers.node.call(this, node);
	                curNode = tmp;
	            },
	            chunk: function(chunk) {
	                buffer += chunk;
	                if (prev.node !== curNode) {
	                    nodes.push({
	                        len: chunk.length,
	                        node: curNode
	                    });
	                } else {
	                    prev.len += chunk.length;
	                }
	            },
	            result: function() {
	                return prepareTokens(buffer, nodes);
	            }
	        };
	    }
	};

	function prepareTokens(str, nodes) {
	    var tokens = [];
	    var nodesOffset = 0;
	    var nodesIndex = 0;
	    var currentNode = nodes ? nodes[nodesIndex].node : null;

	    tokenizer(str, tokenStream);

	    while (!tokenStream.eof) {
	        if (nodes) {
	            while (nodesIndex < nodes.length && nodesOffset + nodes[nodesIndex].len <= tokenStream.tokenStart) {
	                nodesOffset += nodes[nodesIndex++].len;
	                currentNode = nodes[nodesIndex].node;
	            }
	        }

	        tokens.push({
	            type: tokenStream.tokenType,
	            value: tokenStream.getTokenValue(),
	            index: tokenStream.tokenIndex, // TODO: remove it, temporary solution
	            balance: tokenStream.balance[tokenStream.tokenIndex], // TODO: remove it, temporary solution
	            node: currentNode
	        });
	        tokenStream.next();
	        // console.log({ ...tokens[tokens.length - 1], node: undefined });
	    }

	    return tokens;
	}

	var prepareTokens_1 = function(value, syntax) {
	    if (typeof value === 'string') {
	        return prepareTokens(value, null);
	    }

	    return syntax.generate(value, astToTokens);
	};

	var MATCH = { type: 'Match' };
	var MISMATCH = { type: 'Mismatch' };
	var DISALLOW_EMPTY = { type: 'DisallowEmpty' };
	var LEFTPARENTHESIS$1 = 40;  // (
	var RIGHTPARENTHESIS$1 = 41; // )

	function createCondition(match, thenBranch, elseBranch) {
	    // reduce node count
	    if (thenBranch === MATCH && elseBranch === MISMATCH) {
	        return match;
	    }

	    if (match === MATCH && thenBranch === MATCH && elseBranch === MATCH) {
	        return match;
	    }

	    if (match.type === 'If' && match.else === MISMATCH && thenBranch === MATCH) {
	        thenBranch = match.then;
	        match = match.match;
	    }

	    return {
	        type: 'If',
	        match: match,
	        then: thenBranch,
	        else: elseBranch
	    };
	}

	function isFunctionType(name) {
	    return (
	        name.length > 2 &&
	        name.charCodeAt(name.length - 2) === LEFTPARENTHESIS$1 &&
	        name.charCodeAt(name.length - 1) === RIGHTPARENTHESIS$1
	    );
	}

	function isEnumCapatible(term) {
	    return (
	        term.type === 'Keyword' ||
	        term.type === 'AtKeyword' ||
	        term.type === 'Function' ||
	        term.type === 'Type' && isFunctionType(term.name)
	    );
	}

	function buildGroupMatchGraph(combinator, terms, atLeastOneTermMatched) {
	    switch (combinator) {
	        case ' ':
	            // Juxtaposing components means that all of them must occur, in the given order.
	            //
	            // a b c
	            // =
	            // match a
	            //   then match b
	            //     then match c
	            //       then MATCH
	            //       else MISMATCH
	            //     else MISMATCH
	            //   else MISMATCH
	            var result = MATCH;

	            for (var i = terms.length - 1; i >= 0; i--) {
	                var term = terms[i];

	                result = createCondition(
	                    term,
	                    result,
	                    MISMATCH
	                );
	            }
	            return result;

	        case '|':
	            // A bar (|) separates two or more alternatives: exactly one of them must occur.
	            //
	            // a | b | c
	            // =
	            // match a
	            //   then MATCH
	            //   else match b
	            //     then MATCH
	            //     else match c
	            //       then MATCH
	            //       else MISMATCH

	            var result = MISMATCH;
	            var map = null;

	            for (var i = terms.length - 1; i >= 0; i--) {
	                var term = terms[i];

	                // reduce sequence of keywords into a Enum
	                if (isEnumCapatible(term)) {
	                    if (map === null && i > 0 && isEnumCapatible(terms[i - 1])) {
	                        map = Object.create(null);
	                        result = createCondition(
	                            {
	                                type: 'Enum',
	                                map: map
	                            },
	                            MATCH,
	                            result
	                        );
	                    }

	                    if (map !== null) {
	                        var key = (isFunctionType(term.name) ? term.name.slice(0, -1) : term.name).toLowerCase();
	                        if (key in map === false) {
	                            map[key] = term;
	                            continue;
	                        }
	                    }
	                }

	                map = null;

	                // create a new conditonal node
	                result = createCondition(
	                    term,
	                    MATCH,
	                    result
	                );
	            }
	            return result;

	        case '&&':
	            // A double ampersand (&&) separates two or more components,
	            // all of which must occur, in any order.

	            // Use MatchOnce for groups with a large number of terms,
	            // since &&-groups produces at least N!-node trees
	            if (terms.length > 5) {
	                return {
	                    type: 'MatchOnce',
	                    terms: terms,
	                    all: true
	                };
	            }

	            // Use a combination tree for groups with small number of terms
	            //
	            // a && b && c
	            // =
	            // match a
	            //   then [b && c]
	            //   else match b
	            //     then [a && c]
	            //     else match c
	            //       then [a && b]
	            //       else MISMATCH
	            //
	            // a && b
	            // =
	            // match a
	            //   then match b
	            //     then MATCH
	            //     else MISMATCH
	            //   else match b
	            //     then match a
	            //       then MATCH
	            //       else MISMATCH
	            //     else MISMATCH
	            var result = MISMATCH;

	            for (var i = terms.length - 1; i >= 0; i--) {
	                var term = terms[i];
	                var thenClause;

	                if (terms.length > 1) {
	                    thenClause = buildGroupMatchGraph(
	                        combinator,
	                        terms.filter(function(newGroupTerm) {
	                            return newGroupTerm !== term;
	                        }),
	                        false
	                    );
	                } else {
	                    thenClause = MATCH;
	                }

	                result = createCondition(
	                    term,
	                    thenClause,
	                    result
	                );
	            }
	            return result;

	        case '||':
	            // A double bar (||) separates two or more options:
	            // one or more of them must occur, in any order.

	            // Use MatchOnce for groups with a large number of terms,
	            // since ||-groups produces at least N!-node trees
	            if (terms.length > 5) {
	                return {
	                    type: 'MatchOnce',
	                    terms: terms,
	                    all: false
	                };
	            }

	            // Use a combination tree for groups with small number of terms
	            //
	            // a || b || c
	            // =
	            // match a
	            //   then [b || c]
	            //   else match b
	            //     then [a || c]
	            //     else match c
	            //       then [a || b]
	            //       else MISMATCH
	            //
	            // a || b
	            // =
	            // match a
	            //   then match b
	            //     then MATCH
	            //     else MATCH
	            //   else match b
	            //     then match a
	            //       then MATCH
	            //       else MATCH
	            //     else MISMATCH
	            var result = atLeastOneTermMatched ? MATCH : MISMATCH;

	            for (var i = terms.length - 1; i >= 0; i--) {
	                var term = terms[i];
	                var thenClause;

	                if (terms.length > 1) {
	                    thenClause = buildGroupMatchGraph(
	                        combinator,
	                        terms.filter(function(newGroupTerm) {
	                            return newGroupTerm !== term;
	                        }),
	                        true
	                    );
	                } else {
	                    thenClause = MATCH;
	                }

	                result = createCondition(
	                    term,
	                    thenClause,
	                    result
	                );
	            }
	            return result;
	    }
	}

	function buildMultiplierMatchGraph(node) {
	    var result = MATCH;
	    var matchTerm = buildMatchGraph(node.term);

	    if (node.max === 0) {
	        // disable repeating of empty match to prevent infinite loop
	        matchTerm = createCondition(
	            matchTerm,
	            DISALLOW_EMPTY,
	            MISMATCH
	        );

	        // an occurrence count is not limited, make a cycle;
	        // to collect more terms on each following matching mismatch
	        result = createCondition(
	            matchTerm,
	            null, // will be a loop
	            MISMATCH
	        );

	        result.then = createCondition(
	            MATCH,
	            MATCH,
	            result // make a loop
	        );

	        if (node.comma) {
	            result.then.else = createCondition(
	                { type: 'Comma', syntax: node },
	                result,
	                MISMATCH
	            );
	        }
	    } else {
	        // create a match node chain for [min .. max] interval with optional matches
	        for (var i = node.min || 1; i <= node.max; i++) {
	            if (node.comma && result !== MATCH) {
	                result = createCondition(
	                    { type: 'Comma', syntax: node },
	                    result,
	                    MISMATCH
	                );
	            }

	            result = createCondition(
	                matchTerm,
	                createCondition(
	                    MATCH,
	                    MATCH,
	                    result
	                ),
	                MISMATCH
	            );
	        }
	    }

	    if (node.min === 0) {
	        // allow zero match
	        result = createCondition(
	            MATCH,
	            MATCH,
	            result
	        );
	    } else {
	        // create a match node chain to collect [0 ... min - 1] required matches
	        for (var i = 0; i < node.min - 1; i++) {
	            if (node.comma && result !== MATCH) {
	                result = createCondition(
	                    { type: 'Comma', syntax: node },
	                    result,
	                    MISMATCH
	                );
	            }

	            result = createCondition(
	                matchTerm,
	                result,
	                MISMATCH
	            );
	        }
	    }

	    return result;
	}

	function buildMatchGraph(node) {
	    if (typeof node === 'function') {
	        return {
	            type: 'Generic',
	            fn: node
	        };
	    }

	    switch (node.type) {
	        case 'Group':
	            var result = buildGroupMatchGraph(
	                node.combinator,
	                node.terms.map(buildMatchGraph),
	                false
	            );

	            if (node.disallowEmpty) {
	                result = createCondition(
	                    result,
	                    DISALLOW_EMPTY,
	                    MISMATCH
	                );
	            }

	            return result;

	        case 'Multiplier':
	            return buildMultiplierMatchGraph(node);

	        case 'Type':
	        case 'Property':
	            return {
	                type: node.type,
	                name: node.name,
	                syntax: node
	            };

	        case 'Keyword':
	            return {
	                type: node.type,
	                name: node.name.toLowerCase(),
	                syntax: node
	            };

	        case 'AtKeyword':
	            return {
	                type: node.type,
	                name: '@' + node.name.toLowerCase(),
	                syntax: node
	            };

	        case 'Function':
	            return {
	                type: node.type,
	                name: node.name.toLowerCase() + '(',
	                syntax: node
	            };

	        case 'String':
	            // convert a one char length String to a Token
	            if (node.value.length === 3) {
	                return {
	                    type: 'Token',
	                    value: node.value.charAt(1),
	                    syntax: node
	                };
	            }

	            // otherwise use it as is
	            return {
	                type: node.type,
	                value: node.value.substr(1, node.value.length - 2).replace(/\\'/g, '\''),
	                syntax: node
	            };

	        case 'Token':
	            return {
	                type: node.type,
	                value: node.value,
	                syntax: node
	            };

	        case 'Comma':
	            return {
	                type: node.type,
	                syntax: node
	            };

	        default:
	            throw new Error('Unknown node type:', node.type);
	    }
	}

	var matchGraph = {
	    MATCH: MATCH,
	    MISMATCH: MISMATCH,
	    DISALLOW_EMPTY: DISALLOW_EMPTY,
	    buildMatchGraph: function(syntaxTree, ref) {
	        if (typeof syntaxTree === 'string') {
	            syntaxTree = parse_1(syntaxTree);
	        }

	        return {
	            type: 'MatchGraph',
	            match: buildMatchGraph(syntaxTree),
	            syntax: ref || null,
	            source: syntaxTree
	        };
	    }
	};

	var hasOwnProperty$1 = Object.prototype.hasOwnProperty;

	var MATCH$1 = matchGraph.MATCH;
	var MISMATCH$1 = matchGraph.MISMATCH;
	var DISALLOW_EMPTY$1 = matchGraph.DISALLOW_EMPTY;
	var TYPE$6 = _const.TYPE;

	var STUB = 0;
	var TOKEN = 1;
	var OPEN_SYNTAX = 2;
	var CLOSE_SYNTAX = 3;

	var EXIT_REASON_MATCH = 'Match';
	var EXIT_REASON_MISMATCH = 'Mismatch';
	var EXIT_REASON_ITERATION_LIMIT = 'Maximum iteration number exceeded (please fill an issue on https://github.com/csstree/csstree/issues)';

	var ITERATION_LIMIT = 15000;
	var totalIterationCount = 0;

	function reverseList(list) {
	    var prev = null;
	    var next = null;
	    var item = list;

	    while (item !== null) {
	        next = item.prev;
	        item.prev = prev;
	        prev = item;
	        item = next;
	    }

	    return prev;
	}

	function areStringsEqualCaseInsensitive(testStr, referenceStr) {
	    if (testStr.length !== referenceStr.length) {
	        return false;
	    }

	    for (var i = 0; i < testStr.length; i++) {
	        var testCode = testStr.charCodeAt(i);
	        var referenceCode = referenceStr.charCodeAt(i);

	        // testCode.toLowerCase() for U+0041 LATIN CAPITAL LETTER A (A) .. U+005A LATIN CAPITAL LETTER Z (Z).
	        if (testCode >= 0x0041 && testCode <= 0x005A) {
	            testCode = testCode | 32;
	        }

	        if (testCode !== referenceCode) {
	            return false;
	        }
	    }

	    return true;
	}

	function isCommaContextStart(token) {
	    if (token === null) {
	        return true;
	    }

	    return (
	        token.type === TYPE$6.Comma ||
	        token.type === TYPE$6.Function ||
	        token.type === TYPE$6.LeftParenthesis ||
	        token.type === TYPE$6.LeftSquareBracket ||
	        token.type === TYPE$6.LeftCurlyBracket ||
	        token.type === TYPE$6.Delim
	    );
	}

	function isCommaContextEnd(token) {
	    if (token === null) {
	        return true;
	    }

	    return (
	        token.type === TYPE$6.RightParenthesis ||
	        token.type === TYPE$6.RightSquareBracket ||
	        token.type === TYPE$6.RightCurlyBracket ||
	        token.type === TYPE$6.Delim
	    );
	}

	function internalMatch(tokens, state, syntaxes) {
	    function moveToNextToken() {
	        do {
	            tokenIndex++;
	            token = tokenIndex < tokens.length ? tokens[tokenIndex] : null;
	        } while (token !== null && (token.type === TYPE$6.WhiteSpace || token.type === TYPE$6.Comment));
	    }

	    function getNextToken(offset) {
	        var nextIndex = tokenIndex + offset;

	        return nextIndex < tokens.length ? tokens[nextIndex] : null;
	    }

	    function stateSnapshotFromSyntax(nextState, prev) {
	        return {
	            nextState: nextState,
	            matchStack: matchStack,
	            syntaxStack: syntaxStack,
	            thenStack: thenStack,
	            tokenIndex: tokenIndex,
	            prev: prev
	        };
	    }

	    function pushThenStack(nextState) {
	        thenStack = {
	            nextState: nextState,
	            matchStack: matchStack,
	            syntaxStack: syntaxStack,
	            prev: thenStack
	        };
	    }

	    function pushElseStack(nextState) {
	        elseStack = stateSnapshotFromSyntax(nextState, elseStack);
	    }

	    function addTokenToMatch() {
	        matchStack = {
	            type: TOKEN,
	            syntax: state.syntax,
	            token: token,
	            prev: matchStack
	        };

	        moveToNextToken();
	        syntaxStash = null;

	        if (tokenIndex > longestMatch) {
	            longestMatch = tokenIndex;
	        }
	    }

	    function openSyntax() {
	        syntaxStack = {
	            syntax: state.syntax,
	            opts: state.syntax.opts || (syntaxStack !== null && syntaxStack.opts) || null,
	            prev: syntaxStack
	        };

	        matchStack = {
	            type: OPEN_SYNTAX,
	            syntax: state.syntax,
	            token: matchStack.token,
	            prev: matchStack
	        };
	    }

	    function closeSyntax() {
	        if (matchStack.type === OPEN_SYNTAX) {
	            matchStack = matchStack.prev;
	        } else {
	            matchStack = {
	                type: CLOSE_SYNTAX,
	                syntax: syntaxStack.syntax,
	                token: matchStack.token,
	                prev: matchStack
	            };
	        }

	        syntaxStack = syntaxStack.prev;
	    }

	    var syntaxStack = null;
	    var thenStack = null;
	    var elseStack = null;

	    // null – stashing allowed, nothing stashed
	    // false – stashing disabled, nothing stashed
	    // anithing else – fail stashable syntaxes, some syntax stashed
	    var syntaxStash = null;

	    var iterationCount = 0; // count iterations and prevent infinite loop
	    var exitReason = null;

	    var token = null;
	    var tokenIndex = -1;
	    var longestMatch = 0;
	    var matchStack = {
	        type: STUB,
	        syntax: null,
	        token: null,
	        prev: null
	    };

	    moveToNextToken();

	    while (exitReason === null && ++iterationCount < ITERATION_LIMIT) {
	        // function mapList(list, fn) {
	        //     var result = [];
	        //     while (list) {
	        //         result.unshift(fn(list));
	        //         list = list.prev;
	        //     }
	        //     return result;
	        // }
	        // console.log('--\n',
	        //     '#' + iterationCount,
	        //     require('util').inspect({
	        //         match: mapList(matchStack, x => x.type === TOKEN ? x.token && x.token.value : x.syntax ? ({ [OPEN_SYNTAX]: '<', [CLOSE_SYNTAX]: '</' }[x.type] || x.type) + '!' + x.syntax.name : null),
	        //         token: token && token.value,
	        //         tokenIndex,
	        //         syntax: syntax.type + (syntax.id ? ' #' + syntax.id : '')
	        //     }, { depth: null })
	        // );
	        switch (state.type) {
	            case 'Match':
	                if (thenStack === null) {
	                    // turn to MISMATCH when some tokens left unmatched
	                    if (token !== null) {
	                        // doesn't mismatch if just one token left and it's an IE hack
	                        if (tokenIndex !== tokens.length - 1 || (token.value !== '\\0' && token.value !== '\\9')) {
	                            state = MISMATCH$1;
	                            break;
	                        }
	                    }

	                    // break the main loop, return a result - MATCH
	                    exitReason = EXIT_REASON_MATCH;
	                    break;
	                }

	                // go to next syntax (`then` branch)
	                state = thenStack.nextState;

	                // check match is not empty
	                if (state === DISALLOW_EMPTY$1) {
	                    if (thenStack.matchStack === matchStack) {
	                        state = MISMATCH$1;
	                        break;
	                    } else {
	                        state = MATCH$1;
	                    }
	                }

	                // close syntax if needed
	                while (thenStack.syntaxStack !== syntaxStack) {
	                    closeSyntax();
	                }

	                // pop stack
	                thenStack = thenStack.prev;
	                break;

	            case 'Mismatch':
	                // when some syntax is stashed
	                if (syntaxStash !== null && syntaxStash !== false) {
	                    // there is no else branches or a branch reduce match stack
	                    if (elseStack === null || tokenIndex > elseStack.tokenIndex) {
	                        // restore state from the stash
	                        elseStack = syntaxStash;
	                        syntaxStash = false; // disable stashing
	                    }
	                } else if (elseStack === null) {
	                    // no else branches -> break the main loop
	                    // return a result - MISMATCH
	                    exitReason = EXIT_REASON_MISMATCH;
	                    break;
	                }

	                // go to next syntax (`else` branch)
	                state = elseStack.nextState;

	                // restore all the rest stack states
	                thenStack = elseStack.thenStack;
	                syntaxStack = elseStack.syntaxStack;
	                matchStack = elseStack.matchStack;
	                tokenIndex = elseStack.tokenIndex;
	                token = tokenIndex < tokens.length ? tokens[tokenIndex] : null;

	                // pop stack
	                elseStack = elseStack.prev;
	                break;

	            case 'MatchGraph':
	                state = state.match;
	                break;

	            case 'If':
	                // IMPORTANT: else stack push must go first,
	                // since it stores the state of thenStack before changes
	                if (state.else !== MISMATCH$1) {
	                    pushElseStack(state.else);
	                }

	                if (state.then !== MATCH$1) {
	                    pushThenStack(state.then);
	                }

	                state = state.match;
	                break;

	            case 'MatchOnce':
	                state = {
	                    type: 'MatchOnceBuffer',
	                    syntax: state,
	                    index: 0,
	                    mask: 0
	                };
	                break;

	            case 'MatchOnceBuffer':
	                var terms = state.syntax.terms;

	                if (state.index === terms.length) {
	                    // no matches at all or it's required all terms to be matched
	                    if (state.mask === 0 || state.syntax.all) {
	                        state = MISMATCH$1;
	                        break;
	                    }

	                    // a partial match is ok
	                    state = MATCH$1;
	                    break;
	                }

	                // all terms are matched
	                if (state.mask === (1 << terms.length) - 1) {
	                    state = MATCH$1;
	                    break;
	                }

	                for (; state.index < terms.length; state.index++) {
	                    var matchFlag = 1 << state.index;

	                    if ((state.mask & matchFlag) === 0) {
	                        // IMPORTANT: else stack push must go first,
	                        // since it stores the state of thenStack before changes
	                        pushElseStack(state);
	                        pushThenStack({
	                            type: 'AddMatchOnce',
	                            syntax: state.syntax,
	                            mask: state.mask | matchFlag
	                        });

	                        // match
	                        state = terms[state.index++];
	                        break;
	                    }
	                }
	                break;

	            case 'AddMatchOnce':
	                state = {
	                    type: 'MatchOnceBuffer',
	                    syntax: state.syntax,
	                    index: 0,
	                    mask: state.mask
	                };
	                break;

	            case 'Enum':
	                if (token !== null) {
	                    var name = token.value.toLowerCase();

	                    // drop \0 and \9 hack from keyword name
	                    if (name.indexOf('\\') !== -1) {
	                        name = name.replace(/\\[09].*$/, '');
	                    }

	                    if (hasOwnProperty$1.call(state.map, name)) {
	                        state = state.map[name];
	                        break;
	                    }
	                }

	                state = MISMATCH$1;
	                break;

	            case 'Generic':
	                var opts = syntaxStack !== null ? syntaxStack.opts : null;
	                var lastTokenIndex = tokenIndex + Math.floor(state.fn(token, getNextToken, opts));

	                if (!isNaN(lastTokenIndex) && lastTokenIndex > tokenIndex) {
	                    while (tokenIndex < lastTokenIndex) {
	                        addTokenToMatch();
	                    }

	                    state = MATCH$1;
	                } else {
	                    state = MISMATCH$1;
	                }

	                break;

	            case 'Type':
	            case 'Property':
	                var syntaxDict = state.type === 'Type' ? 'types' : 'properties';
	                var dictSyntax = hasOwnProperty$1.call(syntaxes, syntaxDict) ? syntaxes[syntaxDict][state.name] : null;

	                if (!dictSyntax || !dictSyntax.match) {
	                    throw new Error(
	                        'Bad syntax reference: ' +
	                        (state.type === 'Type'
	                            ? '<' + state.name + '>'
	                            : '<\'' + state.name + '\'>')
	                    );
	                }

	                // stash a syntax for types with low priority
	                if (syntaxStash !== false && token !== null && state.type === 'Type') {
	                    var lowPriorityMatching =
	                        // https://drafts.csswg.org/css-values-4/#custom-idents
	                        // When parsing positionally-ambiguous keywords in a property value, a <custom-ident> production
	                        // can only claim the keyword if no other unfulfilled production can claim it.
	                        (state.name === 'custom-ident' && token.type === TYPE$6.Ident) ||

	                        // https://drafts.csswg.org/css-values-4/#lengths
	                        // ... if a `0` could be parsed as either a <number> or a <length> in a property (such as line-height),
	                        // it must parse as a <number>
	                        (state.name === 'length' && token.value === '0');

	                    if (lowPriorityMatching) {
	                        if (syntaxStash === null) {
	                            syntaxStash = stateSnapshotFromSyntax(state, elseStack);
	                        }

	                        state = MISMATCH$1;
	                        break;
	                    }
	                }

	                openSyntax();
	                state = dictSyntax.match;
	                break;

	            case 'Keyword':
	                var name = state.name;

	                if (token !== null) {
	                    var keywordName = token.value;

	                    // drop \0 and \9 hack from keyword name
	                    if (keywordName.indexOf('\\') !== -1) {
	                        keywordName = keywordName.replace(/\\[09].*$/, '');
	                    }

	                    if (areStringsEqualCaseInsensitive(keywordName, name)) {
	                        addTokenToMatch();
	                        state = MATCH$1;
	                        break;
	                    }
	                }

	                state = MISMATCH$1;
	                break;

	            case 'AtKeyword':
	            case 'Function':
	                if (token !== null && areStringsEqualCaseInsensitive(token.value, state.name)) {
	                    addTokenToMatch();
	                    state = MATCH$1;
	                    break;
	                }

	                state = MISMATCH$1;
	                break;

	            case 'Token':
	                if (token !== null && token.value === state.value) {
	                    addTokenToMatch();
	                    state = MATCH$1;
	                    break;
	                }

	                state = MISMATCH$1;
	                break;

	            case 'Comma':
	                if (token !== null && token.type === TYPE$6.Comma) {
	                    if (isCommaContextStart(matchStack.token)) {
	                        state = MISMATCH$1;
	                    } else {
	                        addTokenToMatch();
	                        state = isCommaContextEnd(token) ? MISMATCH$1 : MATCH$1;
	                    }
	                } else {
	                    state = isCommaContextStart(matchStack.token) || isCommaContextEnd(token) ? MATCH$1 : MISMATCH$1;
	                }

	                break;

	            case 'String':
	                var string = '';

	                for (var lastTokenIndex = tokenIndex; lastTokenIndex < tokens.length && string.length < state.value.length; lastTokenIndex++) {
	                    string += tokens[lastTokenIndex].value;
	                }

	                if (areStringsEqualCaseInsensitive(string, state.value)) {
	                    while (tokenIndex < lastTokenIndex) {
	                        addTokenToMatch();
	                    }

	                    state = MATCH$1;
	                } else {
	                    state = MISMATCH$1;
	                }

	                break;

	            default:
	                throw new Error('Unknown node type: ' + state.type);
	        }
	    }

	    totalIterationCount += iterationCount;

	    switch (exitReason) {
	        case null:
	            console.warn('[csstree-match] BREAK after ' + ITERATION_LIMIT + ' iterations');
	            exitReason = EXIT_REASON_ITERATION_LIMIT;
	            matchStack = null;
	            break;

	        case EXIT_REASON_MATCH:
	            while (syntaxStack !== null) {
	                closeSyntax();
	            }
	            break;

	        default:
	            matchStack = null;
	    }

	    return {
	        tokens: tokens,
	        reason: exitReason,
	        iterations: iterationCount,
	        match: matchStack,
	        longestMatch: longestMatch
	    };
	}

	function matchAsList(tokens, matchGraph, syntaxes) {
	    var matchResult = internalMatch(tokens, matchGraph, syntaxes || {});

	    if (matchResult.match !== null) {
	        var item = reverseList(matchResult.match).prev;

	        matchResult.match = [];

	        while (item !== null) {
	            switch (item.type) {
	                case STUB:
	                    break;

	                case OPEN_SYNTAX:
	                case CLOSE_SYNTAX:
	                    matchResult.match.push({
	                        type: item.type,
	                        syntax: item.syntax
	                    });
	                    break;

	                default:
	                    matchResult.match.push({
	                        token: item.token.value,
	                        node: item.token.node
	                    });
	                    break;
	            }

	            item = item.prev;
	        }
	    }

	    return matchResult;
	}

	function matchAsTree(tokens, matchGraph, syntaxes) {
	    var matchResult = internalMatch(tokens, matchGraph, syntaxes || {});

	    if (matchResult.match === null) {
	        return matchResult;
	    }

	    var item = matchResult.match;
	    var host = matchResult.match = {
	        syntax: matchGraph.syntax || null,
	        match: []
	    };
	    var hostStack = [host];

	    // revert a list and start with 2nd item since 1st is a stub item
	    item = reverseList(item).prev;

	    // build a tree
	    while (item !== null) {
	        switch (item.type) {
	            case OPEN_SYNTAX:
	                host.match.push(host = {
	                    syntax: item.syntax,
	                    match: []
	                });
	                hostStack.push(host);
	                break;

	            case CLOSE_SYNTAX:
	                hostStack.pop();
	                host = hostStack[hostStack.length - 1];
	                break;

	            default:
	                host.match.push({
	                    syntax: item.syntax || null,
	                    token: item.token.value,
	                    node: item.token.node
	                });
	        }

	        item = item.prev;
	    }

	    return matchResult;
	}

	var match = {
	    matchAsList: matchAsList,
	    matchAsTree: matchAsTree,
	    getTotalIterationCount: function() {
	        return totalIterationCount;
	    }
	};

	function getTrace(node) {
	    function shouldPutToTrace(syntax) {
	        if (syntax === null) {
	            return false;
	        }

	        return (
	            syntax.type === 'Type' ||
	            syntax.type === 'Property' ||
	            syntax.type === 'Keyword'
	        );
	    }

	    function hasMatch(matchNode) {
	        if (Array.isArray(matchNode.match)) {
	            // use for-loop for better perfomance
	            for (var i = 0; i < matchNode.match.length; i++) {
	                if (hasMatch(matchNode.match[i])) {
	                    if (shouldPutToTrace(matchNode.syntax)) {
	                        result.unshift(matchNode.syntax);
	                    }

	                    return true;
	                }
	            }
	        } else if (matchNode.node === node) {
	            result = shouldPutToTrace(matchNode.syntax)
	                ? [matchNode.syntax]
	                : [];

	            return true;
	        }

	        return false;
	    }

	    var result = null;

	    if (this.matched !== null) {
	        hasMatch(this.matched);
	    }

	    return result;
	}

	function testNode(match, node, fn) {
	    var trace = getTrace.call(match, node);

	    if (trace === null) {
	        return false;
	    }

	    return trace.some(fn);
	}

	function isType(node, type) {
	    return testNode(this, node, function(matchNode) {
	        return matchNode.type === 'Type' && matchNode.name === type;
	    });
	}

	function isProperty(node, property) {
	    return testNode(this, node, function(matchNode) {
	        return matchNode.type === 'Property' && matchNode.name === property;
	    });
	}

	function isKeyword(node) {
	    return testNode(this, node, function(matchNode) {
	        return matchNode.type === 'Keyword';
	    });
	}

	var trace = {
	    getTrace: getTrace,
	    isType: isType,
	    isProperty: isProperty,
	    isKeyword: isKeyword
	};

	function getFirstMatchNode(matchNode) {
	    if ('node' in matchNode) {
	        return matchNode.node;
	    }

	    return getFirstMatchNode(matchNode.match[0]);
	}

	function getLastMatchNode(matchNode) {
	    if ('node' in matchNode) {
	        return matchNode.node;
	    }

	    return getLastMatchNode(matchNode.match[matchNode.match.length - 1]);
	}

	function matchFragments(lexer, ast, match, type, name) {
	    function findFragments(matchNode) {
	        if (matchNode.syntax !== null &&
	            matchNode.syntax.type === type &&
	            matchNode.syntax.name === name) {
	            var start = getFirstMatchNode(matchNode);
	            var end = getLastMatchNode(matchNode);

	            lexer.syntax.walk(ast, function(node, item, list) {
	                if (node === start) {
	                    var nodes = new List_1();

	                    do {
	                        nodes.appendData(item.data);

	                        if (item.data === end) {
	                            break;
	                        }

	                        item = item.next;
	                    } while (item !== null);

	                    fragments.push({
	                        parent: list,
	                        nodes: nodes
	                    });
	                }
	            });
	        }

	        if (Array.isArray(matchNode.match)) {
	            matchNode.match.forEach(findFragments);
	        }
	    }

	    var fragments = [];

	    if (match.matched !== null) {
	        findFragments(match.matched);
	    }

	    return fragments;
	}

	var search = {
	    matchFragments: matchFragments
	};

	var hasOwnProperty$2 = Object.prototype.hasOwnProperty;

	function isValidNumber(value) {
	    // Number.isInteger(value) && value >= 0
	    return (
	        typeof value === 'number' &&
	        isFinite(value) &&
	        Math.floor(value) === value &&
	        value >= 0
	    );
	}

	function isValidLocation(loc) {
	    return (
	        Boolean(loc) &&
	        isValidNumber(loc.offset) &&
	        isValidNumber(loc.line) &&
	        isValidNumber(loc.column)
	    );
	}

	function createNodeStructureChecker(type, fields) {
	    return function checkNode(node, warn) {
	        if (!node || node.constructor !== Object) {
	            return warn(node, 'Type of node should be an Object');
	        }

	        for (var key in node) {
	            var valid = true;

	            if (hasOwnProperty$2.call(node, key) === false) {
	                continue;
	            }

	            if (key === 'type') {
	                if (node.type !== type) {
	                    warn(node, 'Wrong node type `' + node.type + '`, expected `' + type + '`');
	                }
	            } else if (key === 'loc') {
	                if (node.loc === null) {
	                    continue;
	                } else if (node.loc && node.loc.constructor === Object) {
	                    if (typeof node.loc.source !== 'string') {
	                        key += '.source';
	                    } else if (!isValidLocation(node.loc.start)) {
	                        key += '.start';
	                    } else if (!isValidLocation(node.loc.end)) {
	                        key += '.end';
	                    } else {
	                        continue;
	                    }
	                }

	                valid = false;
	            } else if (fields.hasOwnProperty(key)) {
	                for (var i = 0, valid = false; !valid && i < fields[key].length; i++) {
	                    var fieldType = fields[key][i];

	                    switch (fieldType) {
	                        case String:
	                            valid = typeof node[key] === 'string';
	                            break;

	                        case Boolean:
	                            valid = typeof node[key] === 'boolean';
	                            break;

	                        case null:
	                            valid = node[key] === null;
	                            break;

	                        default:
	                            if (typeof fieldType === 'string') {
	                                valid = node[key] && node[key].type === fieldType;
	                            } else if (Array.isArray(fieldType)) {
	                                valid = node[key] instanceof List_1;
	                            }
	                    }
	                }
	            } else {
	                warn(node, 'Unknown field `' + key + '` for ' + type + ' node type');
	            }

	            if (!valid) {
	                warn(node, 'Bad value for `' + type + '.' + key + '`');
	            }
	        }

	        for (var key in fields) {
	            if (hasOwnProperty$2.call(fields, key) &&
	                hasOwnProperty$2.call(node, key) === false) {
	                warn(node, 'Field `' + type + '.' + key + '` is missed');
	            }
	        }
	    };
	}

	function processStructure(name, nodeType) {
	    var structure = nodeType.structure;
	    var fields = {
	        type: String,
	        loc: true
	    };
	    var docs = {
	        type: '"' + name + '"'
	    };

	    for (var key in structure) {
	        if (hasOwnProperty$2.call(structure, key) === false) {
	            continue;
	        }

	        var docsTypes = [];
	        var fieldTypes = fields[key] = Array.isArray(structure[key])
	            ? structure[key].slice()
	            : [structure[key]];

	        for (var i = 0; i < fieldTypes.length; i++) {
	            var fieldType = fieldTypes[i];
	            if (fieldType === String || fieldType === Boolean) {
	                docsTypes.push(fieldType.name);
	            } else if (fieldType === null) {
	                docsTypes.push('null');
	            } else if (typeof fieldType === 'string') {
	                docsTypes.push('<' + fieldType + '>');
	            } else if (Array.isArray(fieldType)) {
	                docsTypes.push('List'); // TODO: use type enum
	            } else {
	                throw new Error('Wrong value `' + fieldType + '` in `' + name + '.' + key + '` structure definition');
	            }
	        }

	        docs[key] = docsTypes.join(' | ');
	    }

	    return {
	        docs: docs,
	        check: createNodeStructureChecker(name, fields)
	    };
	}

	var structure = {
	    getStructureFromConfig: function(config) {
	        var structure = {};

	        if (config.node) {
	            for (var name in config.node) {
	                if (hasOwnProperty$2.call(config.node, name)) {
	                    var nodeType = config.node[name];

	                    if (nodeType.structure) {
	                        structure[name] = processStructure(name, nodeType);
	                    } else {
	                        throw new Error('Missed `structure` field in `' + name + '` node type definition');
	                    }
	                }
	            }
	        }

	        return structure;
	    }
	};

	var SyntaxReferenceError$1 = error.SyntaxReferenceError;
	var MatchError$1 = error.MatchError;






	var buildMatchGraph$1 = matchGraph.buildMatchGraph;
	var matchAsTree$1 = match.matchAsTree;


	var getStructureFromConfig = structure.getStructureFromConfig;
	var cssWideKeywords$1 = buildMatchGraph$1('inherit | initial | unset');
	var cssWideKeywordsWithExpression = buildMatchGraph$1('inherit | initial | unset | <-ms-legacy-expression>');

	function dumpMapSyntax(map, compact, syntaxAsAst) {
	    var result = {};

	    for (var name in map) {
	        if (map[name].syntax) {
	            result[name] = syntaxAsAst
	                ? map[name].syntax
	                : generate_1(map[name].syntax, { compact: compact });
	        }
	    }

	    return result;
	}

	function valueHasVar(tokens) {
	    for (var i = 0; i < tokens.length; i++) {
	        if (tokens[i].value.toLowerCase() === 'var(') {
	            return true;
	        }
	    }

	    return false;
	}

	function buildMatchResult(match, error, iterations) {
	    return {
	        matched: match,
	        iterations: iterations,
	        error: error,
	        getTrace: trace.getTrace,
	        isType: trace.isType,
	        isProperty: trace.isProperty,
	        isKeyword: trace.isKeyword
	    };
	}

	function matchSyntax(lexer, syntax, value, useCommon) {
	    var tokens = prepareTokens_1(value, lexer.syntax);
	    var result;

	    if (valueHasVar(tokens)) {
	        return buildMatchResult(null, new Error('Matching for a tree with var() is not supported'));
	    }

	    if (useCommon) {
	        result = matchAsTree$1(tokens, lexer.valueCommonSyntax, lexer);
	    }

	    if (!useCommon || !result.match) {
	        result = matchAsTree$1(tokens, syntax.match, lexer);
	        if (!result.match) {
	            return buildMatchResult(
	                null,
	                new MatchError$1(result.reason, syntax.syntax, value, result),
	                result.iterations
	            );
	        }
	    }

	    return buildMatchResult(result.match, null, result.iterations);
	}

	var Lexer = function(config, syntax, structure) {
	    this.valueCommonSyntax = cssWideKeywords$1;
	    this.syntax = syntax;
	    this.generic = false;
	    this.atrules = {};
	    this.properties = {};
	    this.types = {};
	    this.structure = structure || getStructureFromConfig(config);

	    if (config) {
	        if (config.types) {
	            for (var name in config.types) {
	                this.addType_(name, config.types[name]);
	            }
	        }

	        if (config.generic) {
	            this.generic = true;
	            for (var name in generic) {
	                this.addType_(name, generic[name]);
	            }
	        }

	        if (config.atrules) {
	            for (var name in config.atrules) {
	                this.addAtrule_(name, config.atrules[name]);
	            }
	        }

	        if (config.properties) {
	            for (var name in config.properties) {
	                this.addProperty_(name, config.properties[name]);
	            }
	        }
	    }
	};

	Lexer.prototype = {
	    structure: {},
	    checkStructure: function(ast) {
	        function collectWarning(node, message) {
	            warns.push({
	                node: node,
	                message: message
	            });
	        }

	        var structure = this.structure;
	        var warns = [];

	        this.syntax.walk(ast, function(node) {
	            if (structure.hasOwnProperty(node.type)) {
	                structure[node.type].check(node, collectWarning);
	            } else {
	                collectWarning(node, 'Unknown node type `' + node.type + '`');
	            }
	        });

	        return warns.length ? warns : false;
	    },

	    createDescriptor: function(syntax, type, name) {
	        var ref = {
	            type: type,
	            name: name
	        };
	        var descriptor = {
	            type: type,
	            name: name,
	            syntax: null,
	            match: null
	        };

	        if (typeof syntax === 'function') {
	            descriptor.match = buildMatchGraph$1(syntax, ref);
	        } else {
	            if (typeof syntax === 'string') {
	                // lazy parsing on first access
	                Object.defineProperty(descriptor, 'syntax', {
	                    get: function() {
	                        Object.defineProperty(descriptor, 'syntax', {
	                            value: parse_1(syntax)
	                        });

	                        return descriptor.syntax;
	                    }
	                });
	            } else {
	                descriptor.syntax = syntax;
	            }

	            // lazy graph build on first access
	            Object.defineProperty(descriptor, 'match', {
	                get: function() {
	                    Object.defineProperty(descriptor, 'match', {
	                        value: buildMatchGraph$1(descriptor.syntax, ref)
	                    });

	                    return descriptor.match;
	                }
	            });
	        }

	        return descriptor;
	    },
	    addAtrule_: function(name, syntax) {
	        this.atrules[name] = {
	            prelude: syntax.prelude ? this.createDescriptor(syntax.prelude, 'AtrulePrelude', name) : null,
	            descriptors: syntax.descriptors
	                ? Object.keys(syntax.descriptors).reduce((res, name) => {
	                    res[name] = this.createDescriptor(syntax.descriptors[name], 'AtruleDescriptor', name);
	                    return res;
	                }, {})
	                : null
	        };
	    },
	    addProperty_: function(name, syntax) {
	        this.properties[name] = this.createDescriptor(syntax, 'Property', name);
	    },
	    addType_: function(name, syntax) {
	        this.types[name] = this.createDescriptor(syntax, 'Type', name);

	        if (syntax === generic['-ms-legacy-expression']) {
	            this.valueCommonSyntax = cssWideKeywordsWithExpression;
	        }
	    },

	    matchAtrulePrelude: function(atruleName, prelude) {
	        var atrule = names.keyword(atruleName);

	        var atrulePreludeSyntax = atrule.vendor
	            ? this.getAtrulePrelude(atrule.name) || this.getAtrulePrelude(atrule.basename)
	            : this.getAtrulePrelude(atrule.name);

	        if (!atrulePreludeSyntax) {
	            if (atrule.basename in this.atrules) {
	                return buildMatchResult(null, new Error('At-rule `' + atruleName + '` should not contain a prelude'));
	            }

	            return buildMatchResult(null, new SyntaxReferenceError$1('Unknown at-rule', atruleName));
	        }

	        return matchSyntax(this, atrulePreludeSyntax, prelude, true);
	    },
	    matchAtruleDescriptor: function(atruleName, descriptorName, value) {
	        var atrule = names.keyword(atruleName);
	        var descriptor = names.keyword(descriptorName);

	        var atruleEntry = atrule.vendor
	            ? this.atrules[atrule.name] || this.atrules[atrule.basename]
	            : this.atrules[atrule.name];

	        if (!atruleEntry) {
	            return buildMatchResult(null, new SyntaxReferenceError$1('Unknown at-rule', atruleName));
	        }

	        if (!atruleEntry.descriptors) {
	            return buildMatchResult(null, new Error('At-rule `' + atruleName + '` has no known descriptors'));
	        }

	        var atruleDescriptorSyntax = descriptor.vendor
	            ? atruleEntry.descriptors[descriptor.name] || atruleEntry.descriptors[descriptor.basename]
	            : atruleEntry.descriptors[descriptor.name];

	        if (!atruleDescriptorSyntax) {
	            return buildMatchResult(null, new SyntaxReferenceError$1('Unknown at-rule descriptor', descriptorName));
	        }

	        return matchSyntax(this, atruleDescriptorSyntax, value, true);
	    },
	    matchDeclaration: function(node) {
	        if (node.type !== 'Declaration') {
	            return buildMatchResult(null, new Error('Not a Declaration node'));
	        }

	        return this.matchProperty(node.property, node.value);
	    },
	    matchProperty: function(propertyName, value) {
	        var property = names.property(propertyName);

	        // don't match syntax for a custom property
	        if (property.custom) {
	            return buildMatchResult(null, new Error('Lexer matching doesn\'t applicable for custom properties'));
	        }

	        var propertySyntax = property.vendor
	            ? this.getProperty(property.name) || this.getProperty(property.basename)
	            : this.getProperty(property.name);

	        if (!propertySyntax) {
	            return buildMatchResult(null, new SyntaxReferenceError$1('Unknown property', propertyName));
	        }

	        return matchSyntax(this, propertySyntax, value, true);
	    },
	    matchType: function(typeName, value) {
	        var typeSyntax = this.getType(typeName);

	        if (!typeSyntax) {
	            return buildMatchResult(null, new SyntaxReferenceError$1('Unknown type', typeName));
	        }

	        return matchSyntax(this, typeSyntax, value, false);
	    },
	    match: function(syntax, value) {
	        if (typeof syntax !== 'string' && (!syntax || !syntax.type)) {
	            return buildMatchResult(null, new SyntaxReferenceError$1('Bad syntax'));
	        }

	        if (typeof syntax === 'string' || !syntax.match) {
	            syntax = this.createDescriptor(syntax, 'Type', 'anonymous');
	        }

	        return matchSyntax(this, syntax, value, false);
	    },

	    findValueFragments: function(propertyName, value, type, name) {
	        return search.matchFragments(this, value, this.matchProperty(propertyName, value), type, name);
	    },
	    findDeclarationValueFragments: function(declaration, type, name) {
	        return search.matchFragments(this, declaration.value, this.matchDeclaration(declaration), type, name);
	    },
	    findAllFragments: function(ast, type, name) {
	        var result = [];

	        this.syntax.walk(ast, {
	            visit: 'Declaration',
	            enter: function(declaration) {
	                result.push.apply(result, this.findDeclarationValueFragments(declaration, type, name));
	            }.bind(this)
	        });

	        return result;
	    },

	    getAtrulePrelude: function(atruleName) {
	        return this.atrules.hasOwnProperty(atruleName) ? this.atrules[atruleName].prelude : null;
	    },
	    getAtruleDescriptor: function(atruleName, name) {
	        return this.atrules.hasOwnProperty(atruleName) && this.atrules.declarators
	            ? this.atrules[atruleName].declarators[name] || null
	            : null;
	    },
	    getProperty: function(name) {
	        return this.properties.hasOwnProperty(name) ? this.properties[name] : null;
	    },
	    getType: function(name) {
	        return this.types.hasOwnProperty(name) ? this.types[name] : null;
	    },

	    validate: function() {
	        function validate(syntax, name, broken, descriptor) {
	            if (broken.hasOwnProperty(name)) {
	                return broken[name];
	            }

	            broken[name] = false;
	            if (descriptor.syntax !== null) {
	                walk$1(descriptor.syntax, function(node) {
	                    if (node.type !== 'Type' && node.type !== 'Property') {
	                        return;
	                    }

	                    var map = node.type === 'Type' ? syntax.types : syntax.properties;
	                    var brokenMap = node.type === 'Type' ? brokenTypes : brokenProperties;

	                    if (!map.hasOwnProperty(node.name) || validate(syntax, node.name, brokenMap, map[node.name])) {
	                        broken[name] = true;
	                    }
	                }, this);
	            }
	        }

	        var brokenTypes = {};
	        var brokenProperties = {};

	        for (var key in this.types) {
	            validate(this, key, brokenTypes, this.types[key]);
	        }

	        for (var key in this.properties) {
	            validate(this, key, brokenProperties, this.properties[key]);
	        }

	        brokenTypes = Object.keys(brokenTypes).filter(function(name) {
	            return brokenTypes[name];
	        });
	        brokenProperties = Object.keys(brokenProperties).filter(function(name) {
	            return brokenProperties[name];
	        });

	        if (brokenTypes.length || brokenProperties.length) {
	            return {
	                types: brokenTypes,
	                properties: brokenProperties
	            };
	        }

	        return null;
	    },
	    dump: function(syntaxAsAst, pretty) {
	        return {
	            generic: this.generic,
	            types: dumpMapSyntax(this.types, !pretty, syntaxAsAst),
	            properties: dumpMapSyntax(this.properties, !pretty, syntaxAsAst)
	        };
	    },
	    toString: function() {
	        return JSON.stringify(this.dump());
	    }
	};

	var Lexer_1 = Lexer;

	var definitionSyntax = {
	    SyntaxError: _SyntaxError$1,
	    parse: parse_1,
	    generate: generate_1,
	    walk: walk$1
	};

	var isBOM$2 = tokenizer.isBOM;

	var N$3 = 10;
	var F$2 = 12;
	var R$2 = 13;

	function computeLinesAndColumns(host, source) {
	    var sourceLength = source.length;
	    var lines = adoptBuffer(host.lines, sourceLength); // +1
	    var line = host.startLine;
	    var columns = adoptBuffer(host.columns, sourceLength);
	    var column = host.startColumn;
	    var startOffset = source.length > 0 ? isBOM$2(source.charCodeAt(0)) : 0;

	    for (var i = startOffset; i < sourceLength; i++) { // -1
	        var code = source.charCodeAt(i);

	        lines[i] = line;
	        columns[i] = column++;

	        if (code === N$3 || code === R$2 || code === F$2) {
	            if (code === R$2 && i + 1 < sourceLength && source.charCodeAt(i + 1) === N$3) {
	                i++;
	                lines[i] = line;
	                columns[i] = column;
	            }

	            line++;
	            column = 1;
	        }
	    }

	    lines[i] = line;
	    columns[i] = column;

	    host.lines = lines;
	    host.columns = columns;
	}

	var OffsetToLocation = function() {
	    this.lines = null;
	    this.columns = null;
	    this.linesAndColumnsComputed = false;
	};

	OffsetToLocation.prototype = {
	    setSource: function(source, startOffset, startLine, startColumn) {
	        this.source = source;
	        this.startOffset = typeof startOffset === 'undefined' ? 0 : startOffset;
	        this.startLine = typeof startLine === 'undefined' ? 1 : startLine;
	        this.startColumn = typeof startColumn === 'undefined' ? 1 : startColumn;
	        this.linesAndColumnsComputed = false;
	    },

	    ensureLinesAndColumnsComputed: function() {
	        if (!this.linesAndColumnsComputed) {
	            computeLinesAndColumns(this, this.source);
	            this.linesAndColumnsComputed = true;
	        }
	    },
	    getLocation: function(offset, filename) {
	        this.ensureLinesAndColumnsComputed();

	        return {
	            source: filename,
	            offset: this.startOffset + offset,
	            line: this.lines[offset],
	            column: this.columns[offset]
	        };
	    },
	    getLocationRange: function(start, end, filename) {
	        this.ensureLinesAndColumnsComputed();

	        return {
	            source: filename,
	            start: {
	                offset: this.startOffset + start,
	                line: this.lines[start],
	                column: this.columns[start]
	            },
	            end: {
	                offset: this.startOffset + end,
	                line: this.lines[end],
	                column: this.columns[end]
	            }
	        };
	    }
	};

	var OffsetToLocation_1 = OffsetToLocation;

	var TYPE$7 = tokenizer.TYPE;
	var WHITESPACE$2 = TYPE$7.WhiteSpace;
	var COMMENT$2 = TYPE$7.Comment;

	var sequence = function readSequence(recognizer) {
	    var children = this.createList();
	    var child = null;
	    var context = {
	        recognizer: recognizer,
	        space: null,
	        ignoreWS: false,
	        ignoreWSAfter: false
	    };

	    this.scanner.skipSC();

	    while (!this.scanner.eof) {
	        switch (this.scanner.tokenType) {
	            case COMMENT$2:
	                this.scanner.next();
	                continue;

	            case WHITESPACE$2:
	                if (context.ignoreWS) {
	                    this.scanner.next();
	                } else {
	                    context.space = this.WhiteSpace();
	                }
	                continue;
	        }

	        child = recognizer.getNode.call(this, context);

	        if (child === undefined) {
	            break;
	        }

	        if (context.space !== null) {
	            children.push(context.space);
	            context.space = null;
	        }

	        children.push(child);

	        if (context.ignoreWSAfter) {
	            context.ignoreWSAfter = false;
	            context.ignoreWS = true;
	        } else {
	            context.ignoreWS = false;
	        }
	    }

	    return children;
	};

	var findWhiteSpaceStart$1 = utils.findWhiteSpaceStart;

	var noop$3 = function() {};

	var TYPE$8 = _const.TYPE;
	var NAME$2 = _const.NAME;
	var WHITESPACE$3 = TYPE$8.WhiteSpace;
	var IDENT$2 = TYPE$8.Ident;
	var FUNCTION = TYPE$8.Function;
	var URL$1 = TYPE$8.Url;
	var HASH = TYPE$8.Hash;
	var PERCENTAGE = TYPE$8.Percentage;
	var NUMBER$2 = TYPE$8.Number;
	var NUMBERSIGN$1 = 0x0023; // U+0023 NUMBER SIGN (#)
	var NULL = 0;

	function createParseContext(name) {
	    return function() {
	        return this[name]();
	    };
	}

	function processConfig(config) {
	    var parserConfig = {
	        context: {},
	        scope: {},
	        atrule: {},
	        pseudo: {}
	    };

	    if (config.parseContext) {
	        for (var name in config.parseContext) {
	            switch (typeof config.parseContext[name]) {
	                case 'function':
	                    parserConfig.context[name] = config.parseContext[name];
	                    break;

	                case 'string':
	                    parserConfig.context[name] = createParseContext(config.parseContext[name]);
	                    break;
	            }
	        }
	    }

	    if (config.scope) {
	        for (var name in config.scope) {
	            parserConfig.scope[name] = config.scope[name];
	        }
	    }

	    if (config.atrule) {
	        for (var name in config.atrule) {
	            var atrule = config.atrule[name];

	            if (atrule.parse) {
	                parserConfig.atrule[name] = atrule.parse;
	            }
	        }
	    }

	    if (config.pseudo) {
	        for (var name in config.pseudo) {
	            var pseudo = config.pseudo[name];

	            if (pseudo.parse) {
	                parserConfig.pseudo[name] = pseudo.parse;
	            }
	        }
	    }

	    if (config.node) {
	        for (var name in config.node) {
	            parserConfig[name] = config.node[name].parse;
	        }
	    }

	    return parserConfig;
	}

	var create$1 = function createParser(config) {
	    var parser = {
	        scanner: new TokenStream_1(),
	        locationMap: new OffsetToLocation_1(),

	        filename: '<unknown>',
	        needPositions: false,
	        onParseError: noop$3,
	        onParseErrorThrow: false,
	        parseAtrulePrelude: true,
	        parseRulePrelude: true,
	        parseValue: true,
	        parseCustomProperty: false,

	        readSequence: sequence,

	        createList: function() {
	            return new List_1();
	        },
	        createSingleNodeList: function(node) {
	            return new List_1().appendData(node);
	        },
	        getFirstListNode: function(list) {
	            return list && list.first();
	        },
	        getLastListNode: function(list) {
	            return list.last();
	        },

	        parseWithFallback: function(consumer, fallback) {
	            var startToken = this.scanner.tokenIndex;

	            try {
	                return consumer.call(this);
	            } catch (e) {
	                if (this.onParseErrorThrow) {
	                    throw e;
	                }

	                var fallbackNode = fallback.call(this, startToken);

	                this.onParseErrorThrow = true;
	                this.onParseError(e, fallbackNode);
	                this.onParseErrorThrow = false;

	                return fallbackNode;
	            }
	        },

	        lookupNonWSType: function(offset) {
	            do {
	                var type = this.scanner.lookupType(offset++);
	                if (type !== WHITESPACE$3) {
	                    return type;
	                }
	            } while (type !== NULL);

	            return NULL;
	        },

	        eat: function(tokenType) {
	            if (this.scanner.tokenType !== tokenType) {
	                var offset = this.scanner.tokenStart;
	                var message = NAME$2[tokenType] + ' is expected';

	                // tweak message and offset
	                switch (tokenType) {
	                    case IDENT$2:
	                        // when identifier is expected but there is a function or url
	                        if (this.scanner.tokenType === FUNCTION || this.scanner.tokenType === URL$1) {
	                            offset = this.scanner.tokenEnd - 1;
	                            message = 'Identifier is expected but function found';
	                        } else {
	                            message = 'Identifier is expected';
	                        }
	                        break;

	                    case HASH:
	                        if (this.scanner.isDelim(NUMBERSIGN$1)) {
	                            this.scanner.next();
	                            offset++;
	                            message = 'Name is expected';
	                        }
	                        break;

	                    case PERCENTAGE:
	                        if (this.scanner.tokenType === NUMBER$2) {
	                            offset = this.scanner.tokenEnd;
	                            message = 'Percent sign is expected';
	                        }
	                        break;

	                    default:
	                        // when test type is part of another token show error for current position + 1
	                        // e.g. eat(HYPHENMINUS) will fail on "-foo", but pointing on "-" is odd
	                        if (this.scanner.source.charCodeAt(this.scanner.tokenStart) === tokenType) {
	                            offset = offset + 1;
	                        }
	                }

	                this.error(message, offset);
	            }

	            this.scanner.next();
	        },

	        consume: function(tokenType) {
	            var value = this.scanner.getTokenValue();

	            this.eat(tokenType);

	            return value;
	        },
	        consumeFunctionName: function() {
	            var name = this.scanner.source.substring(this.scanner.tokenStart, this.scanner.tokenEnd - 1);

	            this.eat(FUNCTION);

	            return name;
	        },

	        getLocation: function(start, end) {
	            if (this.needPositions) {
	                return this.locationMap.getLocationRange(
	                    start,
	                    end,
	                    this.filename
	                );
	            }

	            return null;
	        },
	        getLocationFromList: function(list) {
	            if (this.needPositions) {
	                var head = this.getFirstListNode(list);
	                var tail = this.getLastListNode(list);
	                return this.locationMap.getLocationRange(
	                    head !== null ? head.loc.start.offset - this.locationMap.startOffset : this.scanner.tokenStart,
	                    tail !== null ? tail.loc.end.offset - this.locationMap.startOffset : this.scanner.tokenStart,
	                    this.filename
	                );
	            }

	            return null;
	        },

	        error: function(message, offset) {
	            var location = typeof offset !== 'undefined' && offset < this.scanner.source.length
	                ? this.locationMap.getLocation(offset)
	                : this.scanner.eof
	                    ? this.locationMap.getLocation(findWhiteSpaceStart$1(this.scanner.source, this.scanner.source.length - 1))
	                    : this.locationMap.getLocation(this.scanner.tokenStart);

	            throw new _SyntaxError(
	                message || 'Unexpected input',
	                this.scanner.source,
	                location.offset,
	                location.line,
	                location.column
	            );
	        }
	    };

	    config = processConfig(config || {});
	    for (var key in config) {
	        parser[key] = config[key];
	    }

	    return function(source, options) {
	        options = options || {};

	        var context = options.context || 'default';
	        var ast;

	        tokenizer(source, parser.scanner);
	        parser.locationMap.setSource(
	            source,
	            options.offset,
	            options.line,
	            options.column
	        );

	        parser.filename = options.filename || '<unknown>';
	        parser.needPositions = Boolean(options.positions);
	        parser.onParseError = typeof options.onParseError === 'function' ? options.onParseError : noop$3;
	        parser.onParseErrorThrow = false;
	        parser.parseAtrulePrelude = 'parseAtrulePrelude' in options ? Boolean(options.parseAtrulePrelude) : true;
	        parser.parseRulePrelude = 'parseRulePrelude' in options ? Boolean(options.parseRulePrelude) : true;
	        parser.parseValue = 'parseValue' in options ? Boolean(options.parseValue) : true;
	        parser.parseCustomProperty = 'parseCustomProperty' in options ? Boolean(options.parseCustomProperty) : false;

	        if (!parser.context.hasOwnProperty(context)) {
	            throw new Error('Unknown context `' + context + '`');
	        }

	        ast = parser.context[context].call(parser, options);

	        if (!parser.scanner.eof) {
	            parser.error();
	        }

	        return ast;
	    };
	};

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */

	var intToCharMap = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.split('');

	/**
	 * Encode an integer in the range of 0 to 63 to a single base 64 digit.
	 */
	var encode = function (number) {
	  if (0 <= number && number < intToCharMap.length) {
	    return intToCharMap[number];
	  }
	  throw new TypeError("Must be between 0 and 63: " + number);
	};

	/**
	 * Decode a single base 64 character code digit to an integer. Returns -1 on
	 * failure.
	 */
	var decode = function (charCode) {
	  var bigA = 65;     // 'A'
	  var bigZ = 90;     // 'Z'

	  var littleA = 97;  // 'a'
	  var littleZ = 122; // 'z'

	  var zero = 48;     // '0'
	  var nine = 57;     // '9'

	  var plus = 43;     // '+'
	  var slash = 47;    // '/'

	  var littleOffset = 26;
	  var numberOffset = 52;

	  // 0 - 25: ABCDEFGHIJKLMNOPQRSTUVWXYZ
	  if (bigA <= charCode && charCode <= bigZ) {
	    return (charCode - bigA);
	  }

	  // 26 - 51: abcdefghijklmnopqrstuvwxyz
	  if (littleA <= charCode && charCode <= littleZ) {
	    return (charCode - littleA + littleOffset);
	  }

	  // 52 - 61: 0123456789
	  if (zero <= charCode && charCode <= nine) {
	    return (charCode - zero + numberOffset);
	  }

	  // 62: +
	  if (charCode == plus) {
	    return 62;
	  }

	  // 63: /
	  if (charCode == slash) {
	    return 63;
	  }

	  // Invalid base64 digit.
	  return -1;
	};

	var base64 = {
		encode: encode,
		decode: decode
	};

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 *
	 * Based on the Base 64 VLQ implementation in Closure Compiler:
	 * https://code.google.com/p/closure-compiler/source/browse/trunk/src/com/google/debugging/sourcemap/Base64VLQ.java
	 *
	 * Copyright 2011 The Closure Compiler Authors. All rights reserved.
	 * Redistribution and use in source and binary forms, with or without
	 * modification, are permitted provided that the following conditions are
	 * met:
	 *
	 *  * Redistributions of source code must retain the above copyright
	 *    notice, this list of conditions and the following disclaimer.
	 *  * Redistributions in binary form must reproduce the above
	 *    copyright notice, this list of conditions and the following
	 *    disclaimer in the documentation and/or other materials provided
	 *    with the distribution.
	 *  * Neither the name of Google Inc. nor the names of its
	 *    contributors may be used to endorse or promote products derived
	 *    from this software without specific prior written permission.
	 *
	 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
	 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
	 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
	 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
	 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
	 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
	 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
	 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
	 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
	 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	 */



	// A single base 64 digit can contain 6 bits of data. For the base 64 variable
	// length quantities we use in the source map spec, the first bit is the sign,
	// the next four bits are the actual value, and the 6th bit is the
	// continuation bit. The continuation bit tells us whether there are more
	// digits in this value following this digit.
	//
	//   Continuation
	//   |    Sign
	//   |    |
	//   V    V
	//   101011

	var VLQ_BASE_SHIFT = 5;

	// binary: 100000
	var VLQ_BASE = 1 << VLQ_BASE_SHIFT;

	// binary: 011111
	var VLQ_BASE_MASK = VLQ_BASE - 1;

	// binary: 100000
	var VLQ_CONTINUATION_BIT = VLQ_BASE;

	/**
	 * Converts from a two-complement value to a value where the sign bit is
	 * placed in the least significant bit.  For example, as decimals:
	 *   1 becomes 2 (10 binary), -1 becomes 3 (11 binary)
	 *   2 becomes 4 (100 binary), -2 becomes 5 (101 binary)
	 */
	function toVLQSigned(aValue) {
	  return aValue < 0
	    ? ((-aValue) << 1) + 1
	    : (aValue << 1) + 0;
	}

	/**
	 * Converts to a two-complement value from a value where the sign bit is
	 * placed in the least significant bit.  For example, as decimals:
	 *   2 (10 binary) becomes 1, 3 (11 binary) becomes -1
	 *   4 (100 binary) becomes 2, 5 (101 binary) becomes -2
	 */
	function fromVLQSigned(aValue) {
	  var isNegative = (aValue & 1) === 1;
	  var shifted = aValue >> 1;
	  return isNegative
	    ? -shifted
	    : shifted;
	}

	/**
	 * Returns the base 64 VLQ encoded value.
	 */
	var encode$1 = function base64VLQ_encode(aValue) {
	  var encoded = "";
	  var digit;

	  var vlq = toVLQSigned(aValue);

	  do {
	    digit = vlq & VLQ_BASE_MASK;
	    vlq >>>= VLQ_BASE_SHIFT;
	    if (vlq > 0) {
	      // There are still more digits in this value, so we must make sure the
	      // continuation bit is marked.
	      digit |= VLQ_CONTINUATION_BIT;
	    }
	    encoded += base64.encode(digit);
	  } while (vlq > 0);

	  return encoded;
	};

	/**
	 * Decodes the next base 64 VLQ value from the given string and returns the
	 * value and the rest of the string via the out parameter.
	 */
	var decode$1 = function base64VLQ_decode(aStr, aIndex, aOutParam) {
	  var strLen = aStr.length;
	  var result = 0;
	  var shift = 0;
	  var continuation, digit;

	  do {
	    if (aIndex >= strLen) {
	      throw new Error("Expected more digits in base 64 VLQ value.");
	    }

	    digit = base64.decode(aStr.charCodeAt(aIndex++));
	    if (digit === -1) {
	      throw new Error("Invalid base64 digit: " + aStr.charAt(aIndex - 1));
	    }

	    continuation = !!(digit & VLQ_CONTINUATION_BIT);
	    digit &= VLQ_BASE_MASK;
	    result = result + (digit << shift);
	    shift += VLQ_BASE_SHIFT;
	  } while (continuation);

	  aOutParam.value = fromVLQSigned(result);
	  aOutParam.rest = aIndex;
	};

	var base64Vlq = {
		encode: encode$1,
		decode: decode$1
	};

	var util = createCommonjsModule(function (module, exports) {
	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */

	/**
	 * This is a helper function for getting values from parameter/options
	 * objects.
	 *
	 * @param args The object we are extracting values from
	 * @param name The name of the property we are getting.
	 * @param defaultValue An optional value to return if the property is missing
	 * from the object. If this is not specified and the property is missing, an
	 * error will be thrown.
	 */
	function getArg(aArgs, aName, aDefaultValue) {
	  if (aName in aArgs) {
	    return aArgs[aName];
	  } else if (arguments.length === 3) {
	    return aDefaultValue;
	  } else {
	    throw new Error('"' + aName + '" is a required argument.');
	  }
	}
	exports.getArg = getArg;

	var urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.-]*)(?::(\d+))?(.*)$/;
	var dataUrlRegexp = /^data:.+\,.+$/;

	function urlParse(aUrl) {
	  var match = aUrl.match(urlRegexp);
	  if (!match) {
	    return null;
	  }
	  return {
	    scheme: match[1],
	    auth: match[2],
	    host: match[3],
	    port: match[4],
	    path: match[5]
	  };
	}
	exports.urlParse = urlParse;

	function urlGenerate(aParsedUrl) {
	  var url = '';
	  if (aParsedUrl.scheme) {
	    url += aParsedUrl.scheme + ':';
	  }
	  url += '//';
	  if (aParsedUrl.auth) {
	    url += aParsedUrl.auth + '@';
	  }
	  if (aParsedUrl.host) {
	    url += aParsedUrl.host;
	  }
	  if (aParsedUrl.port) {
	    url += ":" + aParsedUrl.port;
	  }
	  if (aParsedUrl.path) {
	    url += aParsedUrl.path;
	  }
	  return url;
	}
	exports.urlGenerate = urlGenerate;

	/**
	 * Normalizes a path, or the path portion of a URL:
	 *
	 * - Replaces consecutive slashes with one slash.
	 * - Removes unnecessary '.' parts.
	 * - Removes unnecessary '<dir>/..' parts.
	 *
	 * Based on code in the Node.js 'path' core module.
	 *
	 * @param aPath The path or url to normalize.
	 */
	function normalize(aPath) {
	  var path = aPath;
	  var url = urlParse(aPath);
	  if (url) {
	    if (!url.path) {
	      return aPath;
	    }
	    path = url.path;
	  }
	  var isAbsolute = exports.isAbsolute(path);

	  var parts = path.split(/\/+/);
	  for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {
	    part = parts[i];
	    if (part === '.') {
	      parts.splice(i, 1);
	    } else if (part === '..') {
	      up++;
	    } else if (up > 0) {
	      if (part === '') {
	        // The first part is blank if the path is absolute. Trying to go
	        // above the root is a no-op. Therefore we can remove all '..' parts
	        // directly after the root.
	        parts.splice(i + 1, up);
	        up = 0;
	      } else {
	        parts.splice(i, 2);
	        up--;
	      }
	    }
	  }
	  path = parts.join('/');

	  if (path === '') {
	    path = isAbsolute ? '/' : '.';
	  }

	  if (url) {
	    url.path = path;
	    return urlGenerate(url);
	  }
	  return path;
	}
	exports.normalize = normalize;

	/**
	 * Joins two paths/URLs.
	 *
	 * @param aRoot The root path or URL.
	 * @param aPath The path or URL to be joined with the root.
	 *
	 * - If aPath is a URL or a data URI, aPath is returned, unless aPath is a
	 *   scheme-relative URL: Then the scheme of aRoot, if any, is prepended
	 *   first.
	 * - Otherwise aPath is a path. If aRoot is a URL, then its path portion
	 *   is updated with the result and aRoot is returned. Otherwise the result
	 *   is returned.
	 *   - If aPath is absolute, the result is aPath.
	 *   - Otherwise the two paths are joined with a slash.
	 * - Joining for example 'http://' and 'www.example.com' is also supported.
	 */
	function join(aRoot, aPath) {
	  if (aRoot === "") {
	    aRoot = ".";
	  }
	  if (aPath === "") {
	    aPath = ".";
	  }
	  var aPathUrl = urlParse(aPath);
	  var aRootUrl = urlParse(aRoot);
	  if (aRootUrl) {
	    aRoot = aRootUrl.path || '/';
	  }

	  // `join(foo, '//www.example.org')`
	  if (aPathUrl && !aPathUrl.scheme) {
	    if (aRootUrl) {
	      aPathUrl.scheme = aRootUrl.scheme;
	    }
	    return urlGenerate(aPathUrl);
	  }

	  if (aPathUrl || aPath.match(dataUrlRegexp)) {
	    return aPath;
	  }

	  // `join('http://', 'www.example.com')`
	  if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {
	    aRootUrl.host = aPath;
	    return urlGenerate(aRootUrl);
	  }

	  var joined = aPath.charAt(0) === '/'
	    ? aPath
	    : normalize(aRoot.replace(/\/+$/, '') + '/' + aPath);

	  if (aRootUrl) {
	    aRootUrl.path = joined;
	    return urlGenerate(aRootUrl);
	  }
	  return joined;
	}
	exports.join = join;

	exports.isAbsolute = function (aPath) {
	  return aPath.charAt(0) === '/' || urlRegexp.test(aPath);
	};

	/**
	 * Make a path relative to a URL or another path.
	 *
	 * @param aRoot The root path or URL.
	 * @param aPath The path or URL to be made relative to aRoot.
	 */
	function relative(aRoot, aPath) {
	  if (aRoot === "") {
	    aRoot = ".";
	  }

	  aRoot = aRoot.replace(/\/$/, '');

	  // It is possible for the path to be above the root. In this case, simply
	  // checking whether the root is a prefix of the path won't work. Instead, we
	  // need to remove components from the root one by one, until either we find
	  // a prefix that fits, or we run out of components to remove.
	  var level = 0;
	  while (aPath.indexOf(aRoot + '/') !== 0) {
	    var index = aRoot.lastIndexOf("/");
	    if (index < 0) {
	      return aPath;
	    }

	    // If the only part of the root that is left is the scheme (i.e. http://,
	    // file:///, etc.), one or more slashes (/), or simply nothing at all, we
	    // have exhausted all components, so the path is not relative to the root.
	    aRoot = aRoot.slice(0, index);
	    if (aRoot.match(/^([^\/]+:\/)?\/*$/)) {
	      return aPath;
	    }

	    ++level;
	  }

	  // Make sure we add a "../" for each component we removed from the root.
	  return Array(level + 1).join("../") + aPath.substr(aRoot.length + 1);
	}
	exports.relative = relative;

	var supportsNullProto = (function () {
	  var obj = Object.create(null);
	  return !('__proto__' in obj);
	}());

	function identity (s) {
	  return s;
	}

	/**
	 * Because behavior goes wacky when you set `__proto__` on objects, we
	 * have to prefix all the strings in our set with an arbitrary character.
	 *
	 * See https://github.com/mozilla/source-map/pull/31 and
	 * https://github.com/mozilla/source-map/issues/30
	 *
	 * @param String aStr
	 */
	function toSetString(aStr) {
	  if (isProtoString(aStr)) {
	    return '$' + aStr;
	  }

	  return aStr;
	}
	exports.toSetString = supportsNullProto ? identity : toSetString;

	function fromSetString(aStr) {
	  if (isProtoString(aStr)) {
	    return aStr.slice(1);
	  }

	  return aStr;
	}
	exports.fromSetString = supportsNullProto ? identity : fromSetString;

	function isProtoString(s) {
	  if (!s) {
	    return false;
	  }

	  var length = s.length;

	  if (length < 9 /* "__proto__".length */) {
	    return false;
	  }

	  if (s.charCodeAt(length - 1) !== 95  /* '_' */ ||
	      s.charCodeAt(length - 2) !== 95  /* '_' */ ||
	      s.charCodeAt(length - 3) !== 111 /* 'o' */ ||
	      s.charCodeAt(length - 4) !== 116 /* 't' */ ||
	      s.charCodeAt(length - 5) !== 111 /* 'o' */ ||
	      s.charCodeAt(length - 6) !== 114 /* 'r' */ ||
	      s.charCodeAt(length - 7) !== 112 /* 'p' */ ||
	      s.charCodeAt(length - 8) !== 95  /* '_' */ ||
	      s.charCodeAt(length - 9) !== 95  /* '_' */) {
	    return false;
	  }

	  for (var i = length - 10; i >= 0; i--) {
	    if (s.charCodeAt(i) !== 36 /* '$' */) {
	      return false;
	    }
	  }

	  return true;
	}

	/**
	 * Comparator between two mappings where the original positions are compared.
	 *
	 * Optionally pass in `true` as `onlyCompareGenerated` to consider two
	 * mappings with the same original source/line/column, but different generated
	 * line and column the same. Useful when searching for a mapping with a
	 * stubbed out mapping.
	 */
	function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {
	  var cmp = strcmp(mappingA.source, mappingB.source);
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalLine - mappingB.originalLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalColumn - mappingB.originalColumn;
	  if (cmp !== 0 || onlyCompareOriginal) {
	    return cmp;
	  }

	  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.generatedLine - mappingB.generatedLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  return strcmp(mappingA.name, mappingB.name);
	}
	exports.compareByOriginalPositions = compareByOriginalPositions;

	/**
	 * Comparator between two mappings with deflated source and name indices where
	 * the generated positions are compared.
	 *
	 * Optionally pass in `true` as `onlyCompareGenerated` to consider two
	 * mappings with the same generated line and column, but different
	 * source/name/original line and column the same. Useful when searching for a
	 * mapping with a stubbed out mapping.
	 */
	function compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {
	  var cmp = mappingA.generatedLine - mappingB.generatedLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
	  if (cmp !== 0 || onlyCompareGenerated) {
	    return cmp;
	  }

	  cmp = strcmp(mappingA.source, mappingB.source);
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalLine - mappingB.originalLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalColumn - mappingB.originalColumn;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  return strcmp(mappingA.name, mappingB.name);
	}
	exports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;

	function strcmp(aStr1, aStr2) {
	  if (aStr1 === aStr2) {
	    return 0;
	  }

	  if (aStr1 === null) {
	    return 1; // aStr2 !== null
	  }

	  if (aStr2 === null) {
	    return -1; // aStr1 !== null
	  }

	  if (aStr1 > aStr2) {
	    return 1;
	  }

	  return -1;
	}

	/**
	 * Comparator between two mappings with inflated source and name strings where
	 * the generated positions are compared.
	 */
	function compareByGeneratedPositionsInflated(mappingA, mappingB) {
	  var cmp = mappingA.generatedLine - mappingB.generatedLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = strcmp(mappingA.source, mappingB.source);
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalLine - mappingB.originalLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalColumn - mappingB.originalColumn;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  return strcmp(mappingA.name, mappingB.name);
	}
	exports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;

	/**
	 * Strip any JSON XSSI avoidance prefix from the string (as documented
	 * in the source maps specification), and then parse the string as
	 * JSON.
	 */
	function parseSourceMapInput(str) {
	  return JSON.parse(str.replace(/^\)]}'[^\n]*\n/, ''));
	}
	exports.parseSourceMapInput = parseSourceMapInput;

	/**
	 * Compute the URL of a source given the the source root, the source's
	 * URL, and the source map's URL.
	 */
	function computeSourceURL(sourceRoot, sourceURL, sourceMapURL) {
	  sourceURL = sourceURL || '';

	  if (sourceRoot) {
	    // This follows what Chrome does.
	    if (sourceRoot[sourceRoot.length - 1] !== '/' && sourceURL[0] !== '/') {
	      sourceRoot += '/';
	    }
	    // The spec says:
	    //   Line 4: An optional source root, useful for relocating source
	    //   files on a server or removing repeated values in the
	    //   “sources” entry.  This value is prepended to the individual
	    //   entries in the “source” field.
	    sourceURL = sourceRoot + sourceURL;
	  }

	  // Historically, SourceMapConsumer did not take the sourceMapURL as
	  // a parameter.  This mode is still somewhat supported, which is why
	  // this code block is conditional.  However, it's preferable to pass
	  // the source map URL to SourceMapConsumer, so that this function
	  // can implement the source URL resolution algorithm as outlined in
	  // the spec.  This block is basically the equivalent of:
	  //    new URL(sourceURL, sourceMapURL).toString()
	  // ... except it avoids using URL, which wasn't available in the
	  // older releases of node still supported by this library.
	  //
	  // The spec says:
	  //   If the sources are not absolute URLs after prepending of the
	  //   “sourceRoot”, the sources are resolved relative to the
	  //   SourceMap (like resolving script src in a html document).
	  if (sourceMapURL) {
	    var parsed = urlParse(sourceMapURL);
	    if (!parsed) {
	      throw new Error("sourceMapURL could not be parsed");
	    }
	    if (parsed.path) {
	      // Strip the last path component, but keep the "/".
	      var index = parsed.path.lastIndexOf('/');
	      if (index >= 0) {
	        parsed.path = parsed.path.substring(0, index + 1);
	      }
	    }
	    sourceURL = join(urlGenerate(parsed), sourceURL);
	  }

	  return normalize(sourceURL);
	}
	exports.computeSourceURL = computeSourceURL;
	});
	var util_1 = util.getArg;
	var util_2 = util.urlParse;
	var util_3 = util.urlGenerate;
	var util_4 = util.normalize;
	var util_5 = util.join;
	var util_6 = util.isAbsolute;
	var util_7 = util.relative;
	var util_8 = util.toSetString;
	var util_9 = util.fromSetString;
	var util_10 = util.compareByOriginalPositions;
	var util_11 = util.compareByGeneratedPositionsDeflated;
	var util_12 = util.compareByGeneratedPositionsInflated;
	var util_13 = util.parseSourceMapInput;
	var util_14 = util.computeSourceURL;

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */


	var has = Object.prototype.hasOwnProperty;
	var hasNativeMap = typeof Map !== "undefined";

	/**
	 * A data structure which is a combination of an array and a set. Adding a new
	 * member is O(1), testing for membership is O(1), and finding the index of an
	 * element is O(1). Removing elements from the set is not supported. Only
	 * strings are supported for membership.
	 */
	function ArraySet() {
	  this._array = [];
	  this._set = hasNativeMap ? new Map() : Object.create(null);
	}

	/**
	 * Static method for creating ArraySet instances from an existing array.
	 */
	ArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {
	  var set = new ArraySet();
	  for (var i = 0, len = aArray.length; i < len; i++) {
	    set.add(aArray[i], aAllowDuplicates);
	  }
	  return set;
	};

	/**
	 * Return how many unique items are in this ArraySet. If duplicates have been
	 * added, than those do not count towards the size.
	 *
	 * @returns Number
	 */
	ArraySet.prototype.size = function ArraySet_size() {
	  return hasNativeMap ? this._set.size : Object.getOwnPropertyNames(this._set).length;
	};

	/**
	 * Add the given string to this set.
	 *
	 * @param String aStr
	 */
	ArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {
	  var sStr = hasNativeMap ? aStr : util.toSetString(aStr);
	  var isDuplicate = hasNativeMap ? this.has(aStr) : has.call(this._set, sStr);
	  var idx = this._array.length;
	  if (!isDuplicate || aAllowDuplicates) {
	    this._array.push(aStr);
	  }
	  if (!isDuplicate) {
	    if (hasNativeMap) {
	      this._set.set(aStr, idx);
	    } else {
	      this._set[sStr] = idx;
	    }
	  }
	};

	/**
	 * Is the given string a member of this set?
	 *
	 * @param String aStr
	 */
	ArraySet.prototype.has = function ArraySet_has(aStr) {
	  if (hasNativeMap) {
	    return this._set.has(aStr);
	  } else {
	    var sStr = util.toSetString(aStr);
	    return has.call(this._set, sStr);
	  }
	};

	/**
	 * What is the index of the given string in the array?
	 *
	 * @param String aStr
	 */
	ArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {
	  if (hasNativeMap) {
	    var idx = this._set.get(aStr);
	    if (idx >= 0) {
	        return idx;
	    }
	  } else {
	    var sStr = util.toSetString(aStr);
	    if (has.call(this._set, sStr)) {
	      return this._set[sStr];
	    }
	  }

	  throw new Error('"' + aStr + '" is not in the set.');
	};

	/**
	 * What is the element at the given index?
	 *
	 * @param Number aIdx
	 */
	ArraySet.prototype.at = function ArraySet_at(aIdx) {
	  if (aIdx >= 0 && aIdx < this._array.length) {
	    return this._array[aIdx];
	  }
	  throw new Error('No element indexed by ' + aIdx);
	};

	/**
	 * Returns the array representation of this set (which has the proper indices
	 * indicated by indexOf). Note that this is a copy of the internal array used
	 * for storing the members so that no one can mess with internal state.
	 */
	ArraySet.prototype.toArray = function ArraySet_toArray() {
	  return this._array.slice();
	};

	var ArraySet_1 = ArraySet;

	var arraySet = {
		ArraySet: ArraySet_1
	};

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2014 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */



	/**
	 * Determine whether mappingB is after mappingA with respect to generated
	 * position.
	 */
	function generatedPositionAfter(mappingA, mappingB) {
	  // Optimized for most common case
	  var lineA = mappingA.generatedLine;
	  var lineB = mappingB.generatedLine;
	  var columnA = mappingA.generatedColumn;
	  var columnB = mappingB.generatedColumn;
	  return lineB > lineA || lineB == lineA && columnB >= columnA ||
	         util.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;
	}

	/**
	 * A data structure to provide a sorted view of accumulated mappings in a
	 * performance conscious manner. It trades a neglibable overhead in general
	 * case for a large speedup in case of mappings being added in order.
	 */
	function MappingList() {
	  this._array = [];
	  this._sorted = true;
	  // Serves as infimum
	  this._last = {generatedLine: -1, generatedColumn: 0};
	}

	/**
	 * Iterate through internal items. This method takes the same arguments that
	 * `Array.prototype.forEach` takes.
	 *
	 * NOTE: The order of the mappings is NOT guaranteed.
	 */
	MappingList.prototype.unsortedForEach =
	  function MappingList_forEach(aCallback, aThisArg) {
	    this._array.forEach(aCallback, aThisArg);
	  };

	/**
	 * Add the given source mapping.
	 *
	 * @param Object aMapping
	 */
	MappingList.prototype.add = function MappingList_add(aMapping) {
	  if (generatedPositionAfter(this._last, aMapping)) {
	    this._last = aMapping;
	    this._array.push(aMapping);
	  } else {
	    this._sorted = false;
	    this._array.push(aMapping);
	  }
	};

	/**
	 * Returns the flat, sorted array of mappings. The mappings are sorted by
	 * generated position.
	 *
	 * WARNING: This method returns internal data without copying, for
	 * performance. The return value must NOT be mutated, and should be treated as
	 * an immutable borrow. If you want to take ownership, you must make your own
	 * copy.
	 */
	MappingList.prototype.toArray = function MappingList_toArray() {
	  if (!this._sorted) {
	    this._array.sort(util.compareByGeneratedPositionsInflated);
	    this._sorted = true;
	  }
	  return this._array;
	};

	var MappingList_1 = MappingList;

	var mappingList = {
		MappingList: MappingList_1
	};

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */



	var ArraySet$1 = arraySet.ArraySet;
	var MappingList$1 = mappingList.MappingList;

	/**
	 * An instance of the SourceMapGenerator represents a source map which is
	 * being built incrementally. You may pass an object with the following
	 * properties:
	 *
	 *   - file: The filename of the generated source.
	 *   - sourceRoot: A root for all relative URLs in this source map.
	 */
	function SourceMapGenerator(aArgs) {
	  if (!aArgs) {
	    aArgs = {};
	  }
	  this._file = util.getArg(aArgs, 'file', null);
	  this._sourceRoot = util.getArg(aArgs, 'sourceRoot', null);
	  this._skipValidation = util.getArg(aArgs, 'skipValidation', false);
	  this._sources = new ArraySet$1();
	  this._names = new ArraySet$1();
	  this._mappings = new MappingList$1();
	  this._sourcesContents = null;
	}

	SourceMapGenerator.prototype._version = 3;

	/**
	 * Creates a new SourceMapGenerator based on a SourceMapConsumer
	 *
	 * @param aSourceMapConsumer The SourceMap.
	 */
	SourceMapGenerator.fromSourceMap =
	  function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {
	    var sourceRoot = aSourceMapConsumer.sourceRoot;
	    var generator = new SourceMapGenerator({
	      file: aSourceMapConsumer.file,
	      sourceRoot: sourceRoot
	    });
	    aSourceMapConsumer.eachMapping(function (mapping) {
	      var newMapping = {
	        generated: {
	          line: mapping.generatedLine,
	          column: mapping.generatedColumn
	        }
	      };

	      if (mapping.source != null) {
	        newMapping.source = mapping.source;
	        if (sourceRoot != null) {
	          newMapping.source = util.relative(sourceRoot, newMapping.source);
	        }

	        newMapping.original = {
	          line: mapping.originalLine,
	          column: mapping.originalColumn
	        };

	        if (mapping.name != null) {
	          newMapping.name = mapping.name;
	        }
	      }

	      generator.addMapping(newMapping);
	    });
	    aSourceMapConsumer.sources.forEach(function (sourceFile) {
	      var sourceRelative = sourceFile;
	      if (sourceRoot !== null) {
	        sourceRelative = util.relative(sourceRoot, sourceFile);
	      }

	      if (!generator._sources.has(sourceRelative)) {
	        generator._sources.add(sourceRelative);
	      }

	      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
	      if (content != null) {
	        generator.setSourceContent(sourceFile, content);
	      }
	    });
	    return generator;
	  };

	/**
	 * Add a single mapping from original source line and column to the generated
	 * source's line and column for this source map being created. The mapping
	 * object should have the following properties:
	 *
	 *   - generated: An object with the generated line and column positions.
	 *   - original: An object with the original line and column positions.
	 *   - source: The original source file (relative to the sourceRoot).
	 *   - name: An optional original token name for this mapping.
	 */
	SourceMapGenerator.prototype.addMapping =
	  function SourceMapGenerator_addMapping(aArgs) {
	    var generated = util.getArg(aArgs, 'generated');
	    var original = util.getArg(aArgs, 'original', null);
	    var source = util.getArg(aArgs, 'source', null);
	    var name = util.getArg(aArgs, 'name', null);

	    if (!this._skipValidation) {
	      this._validateMapping(generated, original, source, name);
	    }

	    if (source != null) {
	      source = String(source);
	      if (!this._sources.has(source)) {
	        this._sources.add(source);
	      }
	    }

	    if (name != null) {
	      name = String(name);
	      if (!this._names.has(name)) {
	        this._names.add(name);
	      }
	    }

	    this._mappings.add({
	      generatedLine: generated.line,
	      generatedColumn: generated.column,
	      originalLine: original != null && original.line,
	      originalColumn: original != null && original.column,
	      source: source,
	      name: name
	    });
	  };

	/**
	 * Set the source content for a source file.
	 */
	SourceMapGenerator.prototype.setSourceContent =
	  function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {
	    var source = aSourceFile;
	    if (this._sourceRoot != null) {
	      source = util.relative(this._sourceRoot, source);
	    }

	    if (aSourceContent != null) {
	      // Add the source content to the _sourcesContents map.
	      // Create a new _sourcesContents map if the property is null.
	      if (!this._sourcesContents) {
	        this._sourcesContents = Object.create(null);
	      }
	      this._sourcesContents[util.toSetString(source)] = aSourceContent;
	    } else if (this._sourcesContents) {
	      // Remove the source file from the _sourcesContents map.
	      // If the _sourcesContents map is empty, set the property to null.
	      delete this._sourcesContents[util.toSetString(source)];
	      if (Object.keys(this._sourcesContents).length === 0) {
	        this._sourcesContents = null;
	      }
	    }
	  };

	/**
	 * Applies the mappings of a sub-source-map for a specific source file to the
	 * source map being generated. Each mapping to the supplied source file is
	 * rewritten using the supplied source map. Note: The resolution for the
	 * resulting mappings is the minimium of this map and the supplied map.
	 *
	 * @param aSourceMapConsumer The source map to be applied.
	 * @param aSourceFile Optional. The filename of the source file.
	 *        If omitted, SourceMapConsumer's file property will be used.
	 * @param aSourceMapPath Optional. The dirname of the path to the source map
	 *        to be applied. If relative, it is relative to the SourceMapConsumer.
	 *        This parameter is needed when the two source maps aren't in the same
	 *        directory, and the source map to be applied contains relative source
	 *        paths. If so, those relative source paths need to be rewritten
	 *        relative to the SourceMapGenerator.
	 */
	SourceMapGenerator.prototype.applySourceMap =
	  function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {
	    var sourceFile = aSourceFile;
	    // If aSourceFile is omitted, we will use the file property of the SourceMap
	    if (aSourceFile == null) {
	      if (aSourceMapConsumer.file == null) {
	        throw new Error(
	          'SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, ' +
	          'or the source map\'s "file" property. Both were omitted.'
	        );
	      }
	      sourceFile = aSourceMapConsumer.file;
	    }
	    var sourceRoot = this._sourceRoot;
	    // Make "sourceFile" relative if an absolute Url is passed.
	    if (sourceRoot != null) {
	      sourceFile = util.relative(sourceRoot, sourceFile);
	    }
	    // Applying the SourceMap can add and remove items from the sources and
	    // the names array.
	    var newSources = new ArraySet$1();
	    var newNames = new ArraySet$1();

	    // Find mappings for the "sourceFile"
	    this._mappings.unsortedForEach(function (mapping) {
	      if (mapping.source === sourceFile && mapping.originalLine != null) {
	        // Check if it can be mapped by the source map, then update the mapping.
	        var original = aSourceMapConsumer.originalPositionFor({
	          line: mapping.originalLine,
	          column: mapping.originalColumn
	        });
	        if (original.source != null) {
	          // Copy mapping
	          mapping.source = original.source;
	          if (aSourceMapPath != null) {
	            mapping.source = util.join(aSourceMapPath, mapping.source);
	          }
	          if (sourceRoot != null) {
	            mapping.source = util.relative(sourceRoot, mapping.source);
	          }
	          mapping.originalLine = original.line;
	          mapping.originalColumn = original.column;
	          if (original.name != null) {
	            mapping.name = original.name;
	          }
	        }
	      }

	      var source = mapping.source;
	      if (source != null && !newSources.has(source)) {
	        newSources.add(source);
	      }

	      var name = mapping.name;
	      if (name != null && !newNames.has(name)) {
	        newNames.add(name);
	      }

	    }, this);
	    this._sources = newSources;
	    this._names = newNames;

	    // Copy sourcesContents of applied map.
	    aSourceMapConsumer.sources.forEach(function (sourceFile) {
	      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
	      if (content != null) {
	        if (aSourceMapPath != null) {
	          sourceFile = util.join(aSourceMapPath, sourceFile);
	        }
	        if (sourceRoot != null) {
	          sourceFile = util.relative(sourceRoot, sourceFile);
	        }
	        this.setSourceContent(sourceFile, content);
	      }
	    }, this);
	  };

	/**
	 * A mapping can have one of the three levels of data:
	 *
	 *   1. Just the generated position.
	 *   2. The Generated position, original position, and original source.
	 *   3. Generated and original position, original source, as well as a name
	 *      token.
	 *
	 * To maintain consistency, we validate that any new mapping being added falls
	 * in to one of these categories.
	 */
	SourceMapGenerator.prototype._validateMapping =
	  function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource,
	                                              aName) {
	    // When aOriginal is truthy but has empty values for .line and .column,
	    // it is most likely a programmer error. In this case we throw a very
	    // specific error message to try to guide them the right way.
	    // For example: https://github.com/Polymer/polymer-bundler/pull/519
	    if (aOriginal && typeof aOriginal.line !== 'number' && typeof aOriginal.column !== 'number') {
	        throw new Error(
	            'original.line and original.column are not numbers -- you probably meant to omit ' +
	            'the original mapping entirely and only map the generated position. If so, pass ' +
	            'null for the original mapping instead of an object with empty or null values.'
	        );
	    }

	    if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
	        && aGenerated.line > 0 && aGenerated.column >= 0
	        && !aOriginal && !aSource && !aName) {
	      // Case 1.
	      return;
	    }
	    else if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
	             && aOriginal && 'line' in aOriginal && 'column' in aOriginal
	             && aGenerated.line > 0 && aGenerated.column >= 0
	             && aOriginal.line > 0 && aOriginal.column >= 0
	             && aSource) {
	      // Cases 2 and 3.
	      return;
	    }
	    else {
	      throw new Error('Invalid mapping: ' + JSON.stringify({
	        generated: aGenerated,
	        source: aSource,
	        original: aOriginal,
	        name: aName
	      }));
	    }
	  };

	/**
	 * Serialize the accumulated mappings in to the stream of base 64 VLQs
	 * specified by the source map format.
	 */
	SourceMapGenerator.prototype._serializeMappings =
	  function SourceMapGenerator_serializeMappings() {
	    var previousGeneratedColumn = 0;
	    var previousGeneratedLine = 1;
	    var previousOriginalColumn = 0;
	    var previousOriginalLine = 0;
	    var previousName = 0;
	    var previousSource = 0;
	    var result = '';
	    var next;
	    var mapping;
	    var nameIdx;
	    var sourceIdx;

	    var mappings = this._mappings.toArray();
	    for (var i = 0, len = mappings.length; i < len; i++) {
	      mapping = mappings[i];
	      next = '';

	      if (mapping.generatedLine !== previousGeneratedLine) {
	        previousGeneratedColumn = 0;
	        while (mapping.generatedLine !== previousGeneratedLine) {
	          next += ';';
	          previousGeneratedLine++;
	        }
	      }
	      else {
	        if (i > 0) {
	          if (!util.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])) {
	            continue;
	          }
	          next += ',';
	        }
	      }

	      next += base64Vlq.encode(mapping.generatedColumn
	                                 - previousGeneratedColumn);
	      previousGeneratedColumn = mapping.generatedColumn;

	      if (mapping.source != null) {
	        sourceIdx = this._sources.indexOf(mapping.source);
	        next += base64Vlq.encode(sourceIdx - previousSource);
	        previousSource = sourceIdx;

	        // lines are stored 0-based in SourceMap spec version 3
	        next += base64Vlq.encode(mapping.originalLine - 1
	                                   - previousOriginalLine);
	        previousOriginalLine = mapping.originalLine - 1;

	        next += base64Vlq.encode(mapping.originalColumn
	                                   - previousOriginalColumn);
	        previousOriginalColumn = mapping.originalColumn;

	        if (mapping.name != null) {
	          nameIdx = this._names.indexOf(mapping.name);
	          next += base64Vlq.encode(nameIdx - previousName);
	          previousName = nameIdx;
	        }
	      }

	      result += next;
	    }

	    return result;
	  };

	SourceMapGenerator.prototype._generateSourcesContent =
	  function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {
	    return aSources.map(function (source) {
	      if (!this._sourcesContents) {
	        return null;
	      }
	      if (aSourceRoot != null) {
	        source = util.relative(aSourceRoot, source);
	      }
	      var key = util.toSetString(source);
	      return Object.prototype.hasOwnProperty.call(this._sourcesContents, key)
	        ? this._sourcesContents[key]
	        : null;
	    }, this);
	  };

	/**
	 * Externalize the source map.
	 */
	SourceMapGenerator.prototype.toJSON =
	  function SourceMapGenerator_toJSON() {
	    var map = {
	      version: this._version,
	      sources: this._sources.toArray(),
	      names: this._names.toArray(),
	      mappings: this._serializeMappings()
	    };
	    if (this._file != null) {
	      map.file = this._file;
	    }
	    if (this._sourceRoot != null) {
	      map.sourceRoot = this._sourceRoot;
	    }
	    if (this._sourcesContents) {
	      map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);
	    }

	    return map;
	  };

	/**
	 * Render the source map being generated to a string.
	 */
	SourceMapGenerator.prototype.toString =
	  function SourceMapGenerator_toString() {
	    return JSON.stringify(this.toJSON());
	  };

	var SourceMapGenerator_1 = SourceMapGenerator;

	var sourceMapGenerator = {
		SourceMapGenerator: SourceMapGenerator_1
	};

	var SourceMapGenerator$1 = sourceMapGenerator.SourceMapGenerator;
	var trackNodes = {
	    Atrule: true,
	    Selector: true,
	    Declaration: true
	};

	var sourceMap = function generateSourceMap(handlers) {
	    var map = new SourceMapGenerator$1();
	    var line = 1;
	    var column = 0;
	    var generated = {
	        line: 1,
	        column: 0
	    };
	    var original = {
	        line: 0, // should be zero to add first mapping
	        column: 0
	    };
	    var sourceMappingActive = false;
	    var activatedGenerated = {
	        line: 1,
	        column: 0
	    };
	    var activatedMapping = {
	        generated: activatedGenerated
	    };

	    var handlersNode = handlers.node;
	    handlers.node = function(node) {
	        if (node.loc && node.loc.start && trackNodes.hasOwnProperty(node.type)) {
	            var nodeLine = node.loc.start.line;
	            var nodeColumn = node.loc.start.column - 1;

	            if (original.line !== nodeLine ||
	                original.column !== nodeColumn) {
	                original.line = nodeLine;
	                original.column = nodeColumn;

	                generated.line = line;
	                generated.column = column;

	                if (sourceMappingActive) {
	                    sourceMappingActive = false;
	                    if (generated.line !== activatedGenerated.line ||
	                        generated.column !== activatedGenerated.column) {
	                        map.addMapping(activatedMapping);
	                    }
	                }

	                sourceMappingActive = true;
	                map.addMapping({
	                    source: node.loc.source,
	                    original: original,
	                    generated: generated
	                });
	            }
	        }

	        handlersNode.call(this, node);

	        if (sourceMappingActive && trackNodes.hasOwnProperty(node.type)) {
	            activatedGenerated.line = line;
	            activatedGenerated.column = column;
	        }
	    };

	    var handlersChunk = handlers.chunk;
	    handlers.chunk = function(chunk) {
	        for (var i = 0; i < chunk.length; i++) {
	            if (chunk.charCodeAt(i) === 10) { // \n
	                line++;
	                column = 0;
	            } else {
	                column++;
	            }
	        }

	        handlersChunk(chunk);
	    };

	    var handlersResult = handlers.result;
	    handlers.result = function() {
	        if (sourceMappingActive) {
	            map.addMapping(activatedMapping);
	        }

	        return {
	            css: handlersResult(),
	            map: map
	        };
	    };

	    return handlers;
	};

	var hasOwnProperty$3 = Object.prototype.hasOwnProperty;

	function processChildren(node, delimeter) {
	    var list = node.children;
	    var prev = null;

	    if (typeof delimeter !== 'function') {
	        list.forEach(this.node, this);
	    } else {
	        list.forEach(function(node) {
	            if (prev !== null) {
	                delimeter.call(this, prev);
	            }

	            this.node(node);
	            prev = node;
	        }, this);
	    }
	}

	var create$2 = function createGenerator(config) {
	    function processNode(node) {
	        if (hasOwnProperty$3.call(types, node.type)) {
	            types[node.type].call(this, node);
	        } else {
	            throw new Error('Unknown node type: ' + node.type);
	        }
	    }

	    var types = {};

	    if (config.node) {
	        for (var name in config.node) {
	            types[name] = config.node[name].generate;
	        }
	    }

	    return function(node, options) {
	        var buffer = '';
	        var handlers = {
	            children: processChildren,
	            node: processNode,
	            chunk: function(chunk) {
	                buffer += chunk;
	            },
	            result: function() {
	                return buffer;
	            }
	        };

	        if (options) {
	            if (typeof options.decorator === 'function') {
	                handlers = options.decorator(handlers);
	            }

	            if (options.sourceMap) {
	                handlers = sourceMap(handlers);
	            }
	        }

	        handlers.node(node);

	        return handlers.result();
	    };
	};

	var create$3 = function createConvertors(walk) {
	    return {
	        fromPlainObject: function(ast) {
	            walk(ast, {
	                enter: function(node) {
	                    if (node.children && node.children instanceof List_1 === false) {
	                        node.children = new List_1().fromArray(node.children);
	                    }
	                }
	            });

	            return ast;
	        },
	        toPlainObject: function(ast) {
	            walk(ast, {
	                leave: function(node) {
	                    if (node.children && node.children instanceof List_1) {
	                        node.children = node.children.toArray();
	                    }
	                }
	            });

	            return ast;
	        }
	    };
	};

	var hasOwnProperty$4 = Object.prototype.hasOwnProperty;
	var noop$4 = function() {};

	function ensureFunction$1(value) {
	    return typeof value === 'function' ? value : noop$4;
	}

	function invokeForType(fn, type) {
	    return function(node, item, list) {
	        if (node.type === type) {
	            fn.call(this, node, item, list);
	        }
	    };
	}

	function getWalkersFromStructure(name, nodeType) {
	    var structure = nodeType.structure;
	    var walkers = [];

	    for (var key in structure) {
	        if (hasOwnProperty$4.call(structure, key) === false) {
	            continue;
	        }

	        var fieldTypes = structure[key];
	        var walker = {
	            name: key,
	            type: false,
	            nullable: false
	        };

	        if (!Array.isArray(structure[key])) {
	            fieldTypes = [structure[key]];
	        }

	        for (var i = 0; i < fieldTypes.length; i++) {
	            var fieldType = fieldTypes[i];
	            if (fieldType === null) {
	                walker.nullable = true;
	            } else if (typeof fieldType === 'string') {
	                walker.type = 'node';
	            } else if (Array.isArray(fieldType)) {
	                walker.type = 'list';
	            }
	        }

	        if (walker.type) {
	            walkers.push(walker);
	        }
	    }

	    if (walkers.length) {
	        return {
	            context: nodeType.walkContext,
	            fields: walkers
	        };
	    }

	    return null;
	}

	function getTypesFromConfig(config) {
	    var types = {};

	    for (var name in config.node) {
	        if (hasOwnProperty$4.call(config.node, name)) {
	            var nodeType = config.node[name];

	            if (!nodeType.structure) {
	                throw new Error('Missed `structure` field in `' + name + '` node type definition');
	            }

	            types[name] = getWalkersFromStructure(name, nodeType);
	        }
	    }

	    return types;
	}

	function createTypeIterator(config, reverse) {
	    var fields = config.fields.slice();
	    var contextName = config.context;
	    var useContext = typeof contextName === 'string';

	    if (reverse) {
	        fields.reverse();
	    }

	    return function(node, context, walk) {
	        var prevContextValue;

	        if (useContext) {
	            prevContextValue = context[contextName];
	            context[contextName] = node;
	        }

	        for (var i = 0; i < fields.length; i++) {
	            var field = fields[i];
	            var ref = node[field.name];

	            if (!field.nullable || ref) {
	                if (field.type === 'list') {
	                    if (reverse) {
	                        ref.forEachRight(walk);
	                    } else {
	                        ref.forEach(walk);
	                    }
	                } else {
	                    walk(ref);
	                }
	            }
	        }

	        if (useContext) {
	            context[contextName] = prevContextValue;
	        }
	    };
	}

	function createFastTraveralMap(iterators) {
	    return {
	        Atrule: {
	            StyleSheet: iterators.StyleSheet,
	            Atrule: iterators.Atrule,
	            Rule: iterators.Rule,
	            Block: iterators.Block
	        },
	        Rule: {
	            StyleSheet: iterators.StyleSheet,
	            Atrule: iterators.Atrule,
	            Rule: iterators.Rule,
	            Block: iterators.Block
	        },
	        Declaration: {
	            StyleSheet: iterators.StyleSheet,
	            Atrule: iterators.Atrule,
	            Rule: iterators.Rule,
	            Block: iterators.Block,
	            DeclarationList: iterators.DeclarationList
	        }
	    };
	}

	var create$4 = function createWalker(config) {
	    var types = getTypesFromConfig(config);
	    var iteratorsNatural = {};
	    var iteratorsReverse = {};

	    for (var name in types) {
	        if (hasOwnProperty$4.call(types, name) && types[name] !== null) {
	            iteratorsNatural[name] = createTypeIterator(types[name], false);
	            iteratorsReverse[name] = createTypeIterator(types[name], true);
	        }
	    }

	    var fastTraversalIteratorsNatural = createFastTraveralMap(iteratorsNatural);
	    var fastTraversalIteratorsReverse = createFastTraveralMap(iteratorsReverse);

	    var walk = function(root, options) {
	        function walkNode(node, item, list) {
	            enter.call(context, node, item, list);

	            if (iterators.hasOwnProperty(node.type)) {
	                iterators[node.type](node, context, walkNode);
	            }

	            leave.call(context, node, item, list);
	        }

	        var enter = noop$4;
	        var leave = noop$4;
	        var iterators = iteratorsNatural;
	        var context = {
	            root: root,
	            stylesheet: null,
	            atrule: null,
	            atrulePrelude: null,
	            rule: null,
	            selector: null,
	            block: null,
	            declaration: null,
	            function: null
	        };

	        if (typeof options === 'function') {
	            enter = options;
	        } else if (options) {
	            enter = ensureFunction$1(options.enter);
	            leave = ensureFunction$1(options.leave);

	            if (options.reverse) {
	                iterators = iteratorsReverse;
	            }

	            if (options.visit) {
	                if (fastTraversalIteratorsNatural.hasOwnProperty(options.visit)) {
	                    iterators = options.reverse
	                        ? fastTraversalIteratorsReverse[options.visit]
	                        : fastTraversalIteratorsNatural[options.visit];
	                } else if (!types.hasOwnProperty(options.visit)) {
	                    throw new Error('Bad value `' + options.visit + '` for `visit` option (should be: ' + Object.keys(types).join(', ') + ')');
	                }

	                enter = invokeForType(enter, options.visit);
	                leave = invokeForType(leave, options.visit);
	            }
	        }

	        if (enter === noop$4 && leave === noop$4) {
	            throw new Error('Neither `enter` nor `leave` walker handler is set or both aren\'t a function');
	        }

	        // swap handlers in reverse mode to invert visit order
	        if (options.reverse) {
	            var tmp = enter;
	            enter = leave;
	            leave = tmp;
	        }

	        walkNode(root);
	    };

	    walk.find = function(ast, fn) {
	        var found = null;

	        walk(ast, function(node, item, list) {
	            if (found === null && fn.call(this, node, item, list)) {
	                found = node;
	            }
	        });

	        return found;
	    };

	    walk.findLast = function(ast, fn) {
	        var found = null;

	        walk(ast, {
	            reverse: true,
	            enter: function(node, item, list) {
	                if (found === null && fn.call(this, node, item, list)) {
	                    found = node;
	                }
	            }
	        });

	        return found;
	    };

	    walk.findAll = function(ast, fn) {
	        var found = [];

	        walk(ast, function(node, item, list) {
	            if (fn.call(this, node, item, list)) {
	                found.push(node);
	            }
	        });

	        return found;
	    };

	    return walk;
	};

	var clone = function clone(node) {
	    var result = {};

	    for (var key in node) {
	        var value = node[key];

	        if (value) {
	            if (Array.isArray(value) || value instanceof List_1) {
	                value = value.map(clone);
	            } else if (value.constructor === Object) {
	                value = clone(value);
	            }
	        }

	        result[key] = value;
	    }

	    return result;
	};

	var hasOwnProperty$5 = Object.prototype.hasOwnProperty;
	var shape = {
	    generic: true,
	    types: {},
	    atrules: {},
	    properties: {},
	    parseContext: {},
	    scope: {},
	    atrule: ['parse'],
	    pseudo: ['parse'],
	    node: ['name', 'structure', 'parse', 'generate', 'walkContext']
	};

	function isObject(value) {
	    return value && value.constructor === Object;
	}

	function copy(value) {
	    if (isObject(value)) {
	        return Object.assign({}, value);
	    } else {
	        return value;
	    }
	}
	function extend(dest, src) {
	    for (var key in src) {
	        if (hasOwnProperty$5.call(src, key)) {
	            if (isObject(dest[key])) {
	                extend(dest[key], copy(src[key]));
	            } else {
	                dest[key] = copy(src[key]);
	            }
	        }
	    }
	}

	function mix(dest, src, shape) {
	    for (var key in shape) {
	        if (hasOwnProperty$5.call(shape, key) === false) {
	            continue;
	        }

	        if (shape[key] === true) {
	            if (key in src) {
	                if (hasOwnProperty$5.call(src, key)) {
	                    dest[key] = copy(src[key]);
	                }
	            }
	        } else if (shape[key]) {
	            if (isObject(shape[key])) {
	                var res = {};
	                extend(res, dest[key]);
	                extend(res, src[key]);
	                dest[key] = res;
	            } else if (Array.isArray(shape[key])) {
	                var res = {};
	                var innerShape = shape[key].reduce(function(s, k) {
	                    s[k] = true;
	                    return s;
	                }, {});
	                for (var name in dest[key]) {
	                    if (hasOwnProperty$5.call(dest[key], name)) {
	                        res[name] = {};
	                        if (dest[key] && dest[key][name]) {
	                            mix(res[name], dest[key][name], innerShape);
	                        }
	                    }
	                }
	                for (var name in src[key]) {
	                    if (hasOwnProperty$5.call(src[key], name)) {
	                        if (!res[name]) {
	                            res[name] = {};
	                        }
	                        if (src[key] && src[key][name]) {
	                            mix(res[name], src[key][name], innerShape);
	                        }
	                    }
	                }
	                dest[key] = res;
	            }
	        }
	    }
	    return dest;
	}

	var mix_1 = function(dest, src) {
	    return mix(dest, src, shape);
	};

	function createSyntax(config) {
	    var parse = create$1(config);
	    var walk = create$4(config);
	    var generate = create$2(config);
	    var convert = create$3(walk);

	    var syntax = {
	        List: List_1,
	        SyntaxError: _SyntaxError,
	        TokenStream: TokenStream_1,
	        Lexer: Lexer_1,

	        vendorPrefix: names.vendorPrefix,
	        keyword: names.keyword,
	        property: names.property,
	        isCustomProperty: names.isCustomProperty,

	        definitionSyntax: definitionSyntax,
	        lexer: null,
	        createLexer: function(config) {
	            return new Lexer_1(config, syntax, syntax.lexer.structure);
	        },

	        tokenize: tokenizer,
	        parse: parse,
	        walk: walk,
	        generate: generate,

	        find: walk.find,
	        findLast: walk.findLast,
	        findAll: walk.findAll,

	        clone: clone,
	        fromPlainObject: convert.fromPlainObject,
	        toPlainObject: convert.toPlainObject,

	        createSyntax: function(config) {
	            return createSyntax(mix_1({}, config));
	        },
	        fork: function(extension) {
	            var base = mix_1({}, config); // copy of config
	            return createSyntax(
	                typeof extension === 'function'
	                    ? extension(base, Object.assign)
	                    : mix_1(base, extension)
	            );
	        }
	    };

	    syntax.lexer = new Lexer_1({
	        generic: true,
	        types: config.types,
	        atrules: config.atrules,
	        properties: config.properties,
	        node: config.node
	    }, syntax);

	    return syntax;
	}
	var create_1 = function(config) {
	    return createSyntax(mix_1({}, config));
	};

	var create$5 = {
		create: create_1
	};

	var atRules = {
		"@charset": {
		syntax: "@charset \"<charset>\";",
		groups: [
			"CSS Charsets"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@charset"
	},
		"@counter-style": {
		syntax: "@counter-style <counter-style-name> {\n  [ system: <counter-system>; ] ||\n  [ symbols: <counter-symbols>; ] ||\n  [ additive-symbols: <additive-symbols>; ] ||\n  [ negative: <negative-symbol>; ] ||\n  [ prefix: <prefix>; ] ||\n  [ suffix: <suffix>; ] ||\n  [ range: <range>; ] ||\n  [ pad: <padding>; ] ||\n  [ speak-as: <speak-as>; ] ||\n  [ fallback: <counter-style-name>; ]\n}",
		interfaces: [
			"CSSCounterStyleRule"
		],
		groups: [
			"CSS Counter Styles"
		],
		descriptors: {
			"additive-symbols": {
				syntax: "[ <integer> && <symbol> ]#",
				media: "all",
				initial: "N/A",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			fallback: {
				syntax: "<counter-style-name>",
				media: "all",
				initial: "decimal",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			negative: {
				syntax: "<symbol> <symbol>?",
				media: "all",
				initial: "\"-\" hyphen-minus",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			pad: {
				syntax: "<integer> && <symbol>",
				media: "all",
				initial: "0 \"\"",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			prefix: {
				syntax: "<symbol>",
				media: "all",
				initial: "\"\"",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			range: {
				syntax: "[ [ <integer> | infinite ]{2} ]# | auto",
				media: "all",
				initial: "auto",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			"speak-as": {
				syntax: "auto | bullets | numbers | words | spell-out | <counter-style-name>",
				media: "all",
				initial: "auto",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			suffix: {
				syntax: "<symbol>",
				media: "all",
				initial: "\". \"",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			symbols: {
				syntax: "<symbol>+",
				media: "all",
				initial: "N/A",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			system: {
				syntax: "cyclic | numeric | alphabetic | symbolic | additive | [ fixed <integer>? ] | [ extends <counter-style-name> ]",
				media: "all",
				initial: "symbolic",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			}
		},
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@counter-style"
	},
		"@document": {
		syntax: "@document [ <url> | url-prefix(<string>) | domain(<string>) | media-document(<string>) | regexp(<string>) ]# {\n  <group-rule-body>\n}",
		interfaces: [
			"CSSGroupingRule",
			"CSSConditionRule"
		],
		groups: [
			"CSS Conditional Rules"
		],
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@document"
	},
		"@font-face": {
		syntax: "@font-face {\n  [ font-family: <family-name>; ] ||\n  [ src: <src>; ] ||\n  [ unicode-range: <unicode-range>; ] ||\n  [ font-variant: <font-variant>; ] ||\n  [ font-feature-settings: <font-feature-settings>; ] ||\n  [ font-variation-settings: <font-variation-settings>; ] ||\n  [ font-stretch: <font-stretch>; ] ||\n  [ font-weight: <font-weight>; ] ||\n  [ font-style: <font-style>; ]\n}",
		interfaces: [
			"CSSFontFaceRule"
		],
		groups: [
			"CSS Fonts"
		],
		descriptors: {
			"font-display": {
				syntax: "[ auto | block | swap | fallback | optional ]",
				media: "visual",
				percentages: "no",
				initial: "auto",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "experimental"
			},
			"font-family": {
				syntax: "<family-name>",
				media: "all",
				initial: "n/a (required)",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			"font-feature-settings": {
				syntax: "normal | <feature-tag-value>#",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			"font-variation-settings": {
				syntax: "normal | [ <string> <number> ]#",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			"font-stretch": {
				syntax: "<font-stretch-absolute>{1,2}",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			"font-style": {
				syntax: "normal | italic | oblique <angle>{0,2}",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			"font-weight": {
				syntax: "<font-weight-absolute>{1,2}",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			"font-variant": {
				syntax: "normal | none | [ <common-lig-values> || <discretionary-lig-values> || <historical-lig-values> || <contextual-alt-values> || stylistic(<feature-value-name>) || historical-forms || styleset(<feature-value-name>#) || character-variant(<feature-value-name>#) || swash(<feature-value-name>) || ornaments(<feature-value-name>) || annotation(<feature-value-name>) || [ small-caps | all-small-caps | petite-caps | all-petite-caps | unicase | titling-caps ] || <numeric-figure-values> || <numeric-spacing-values> || <numeric-fraction-values> || ordinal || slashed-zero || <east-asian-variant-values> || <east-asian-width-values> || ruby ]",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			src: {
				syntax: "[ <url> [ format( <string># ) ]? | local( <family-name> ) ]#",
				media: "all",
				initial: "n/a (required)",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			"unicode-range": {
				syntax: "<unicode-range>#",
				media: "all",
				initial: "U+0-10FFFF",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			}
		},
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@font-face"
	},
		"@font-feature-values": {
		syntax: "@font-feature-values <family-name># {\n  <feature-value-block-list>\n}",
		interfaces: [
			"CSSFontFeatureValuesRule"
		],
		groups: [
			"CSS Fonts"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@font-feature-values"
	},
		"@import": {
		syntax: "@import [ <string> | <url> ] [ <media-query-list> ]?;",
		groups: [
			"Media Queries"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@import"
	},
		"@keyframes": {
		syntax: "@keyframes <keyframes-name> {\n  <keyframe-block-list>\n}",
		interfaces: [
			"CSSKeyframeRule",
			"CSSKeyframesRule"
		],
		groups: [
			"CSS Animations"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@keyframes"
	},
		"@media": {
		syntax: "@media <media-query-list> {\n  <group-rule-body>\n}",
		interfaces: [
			"CSSGroupingRule",
			"CSSConditionRule",
			"CSSMediaRule",
			"CSSCustomMediaRule"
		],
		groups: [
			"CSS Conditional Rules",
			"Media Queries"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@media"
	},
		"@namespace": {
		syntax: "@namespace <namespace-prefix>? [ <string> | <url> ];",
		groups: [
			"CSS Namespaces"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@namespace"
	},
		"@page": {
		syntax: "@page <page-selector-list> {\n  <page-body>\n}",
		interfaces: [
			"CSSPageRule"
		],
		groups: [
			"CSS Pages"
		],
		descriptors: {
			bleed: {
				syntax: "auto | <length>",
				media: [
					"visual",
					"paged"
				],
				initial: "auto",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "experimental"
			},
			marks: {
				syntax: "none | [ crop || cross ]",
				media: [
					"visual",
					"paged"
				],
				initial: "none",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "experimental"
			}
		},
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@page"
	},
		"@supports": {
		syntax: "@supports <supports-condition> {\n  <group-rule-body>\n}",
		interfaces: [
			"CSSGroupingRule",
			"CSSConditionRule",
			"CSSSupportsRule"
		],
		groups: [
			"CSS Conditional Rules"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@supports"
	},
		"@viewport": {
		syntax: "@viewport {\n  <group-rule-body>\n}",
		interfaces: [
			"CSSViewportRule"
		],
		groups: [
			"CSS Device Adaptation"
		],
		descriptors: {
			height: {
				syntax: "<viewport-length>{1,2}",
				media: [
					"visual",
					"continuous"
				],
				initial: [
					"min-height",
					"max-height"
				],
				percentages: [
					"min-height",
					"max-height"
				],
				computed: [
					"min-height",
					"max-height"
				],
				order: "orderOfAppearance",
				status: "standard"
			},
			"max-height": {
				syntax: "<viewport-length>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "referToHeightOfInitialViewport",
				computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
				order: "uniqueOrder",
				status: "standard"
			},
			"max-width": {
				syntax: "<viewport-length>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "referToWidthOfInitialViewport",
				computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
				order: "uniqueOrder",
				status: "standard"
			},
			"max-zoom": {
				syntax: "auto | <number> | <percentage>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "the zoom factor itself",
				computed: "autoNonNegativeOrPercentage",
				order: "uniqueOrder",
				status: "standard"
			},
			"min-height": {
				syntax: "<viewport-length>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "referToHeightOfInitialViewport",
				computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
				order: "uniqueOrder",
				status: "standard"
			},
			"min-width": {
				syntax: "<viewport-length>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "referToWidthOfInitialViewport",
				computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
				order: "uniqueOrder",
				status: "standard"
			},
			"min-zoom": {
				syntax: "auto | <number> | <percentage>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "the zoom factor itself",
				computed: "autoNonNegativeOrPercentage",
				order: "uniqueOrder",
				status: "standard"
			},
			orientation: {
				syntax: "auto | portrait | landscape",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "referToSizeOfBoundingBox",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			"user-zoom": {
				syntax: "zoom | fixed",
				media: [
					"visual",
					"continuous"
				],
				initial: "zoom",
				percentages: "referToSizeOfBoundingBox",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			width: {
				syntax: "<viewport-length>{1,2}",
				media: [
					"visual",
					"continuous"
				],
				initial: [
					"min-width",
					"max-width"
				],
				percentages: [
					"min-width",
					"max-width"
				],
				computed: [
					"min-width",
					"max-width"
				],
				order: "orderOfAppearance",
				status: "standard"
			},
			zoom: {
				syntax: "auto | <number> | <percentage>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "the zoom factor itself",
				computed: "autoNonNegativeOrPercentage",
				order: "uniqueOrder",
				status: "standard"
			}
		},
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@viewport"
	}
	};

	var atRules$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		'default': atRules
	});

	var all = {
		syntax: "initial | inherit | unset | revert",
		media: "noPracticalMedia",
		inherited: false,
		animationType: "eachOfShorthandPropertiesExceptUnicodeBiDiAndDirection",
		percentages: "no",
		groups: [
			"CSS Miscellaneous"
		],
		initial: "noPracticalInitialValue",
		appliesto: "allElements",
		computed: "asSpecifiedAppliesToEachProperty",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/all"
	};
	var animation = {
		syntax: "<single-animation>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: [
			"animation-name",
			"animation-duration",
			"animation-timing-function",
			"animation-delay",
			"animation-iteration-count",
			"animation-direction",
			"animation-fill-mode",
			"animation-play-state"
		],
		appliesto: "allElementsAndPseudos",
		computed: [
			"animation-name",
			"animation-duration",
			"animation-timing-function",
			"animation-delay",
			"animation-direction",
			"animation-iteration-count",
			"animation-fill-mode",
			"animation-play-state"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation"
	};
	var appearance = {
		syntax: "none | auto | button | textfield | <compat>",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-appearance"
	};
	var azimuth = {
		syntax: "<angle> | [ [ left-side | far-left | left | center-left | center | center-right | right | far-right | right-side ] || behind ] | leftwards | rightwards",
		media: "aural",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Speech"
		],
		initial: "center",
		appliesto: "allElements",
		computed: "normalizedAngle",
		order: "orderOfAppearance",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/azimuth"
	};
	var background = {
		syntax: "[ <bg-layer> , ]* <final-bg-layer>",
		media: "visual",
		inherited: false,
		animationType: [
			"background-color",
			"background-image",
			"background-clip",
			"background-position",
			"background-size",
			"background-repeat",
			"background-attachment"
		],
		percentages: [
			"background-position",
			"background-size"
		],
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"background-image",
			"background-position",
			"background-size",
			"background-repeat",
			"background-origin",
			"background-clip",
			"background-attachment",
			"background-color"
		],
		appliesto: "allElements",
		computed: [
			"background-image",
			"background-position",
			"background-size",
			"background-repeat",
			"background-origin",
			"background-clip",
			"background-attachment",
			"background-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background"
	};
	var border = {
		syntax: "<line-width> || <line-style> || <color>",
		media: "visual",
		inherited: false,
		animationType: [
			"border-color",
			"border-style",
			"border-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-width",
			"border-style",
			"border-color"
		],
		appliesto: "allElements",
		computed: [
			"border-width",
			"border-style",
			"border-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border"
	};
	var bottom = {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToContainingBlockHeight",
		groups: [
			"CSS Positioning"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/bottom"
	};
	var clear = {
		syntax: "none | left | right | both | inline-start | inline-end",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Positioning"
		],
		initial: "none",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/clear"
	};
	var clip = {
		syntax: "<shape> | auto",
		media: "visual",
		inherited: false,
		animationType: "rectangle",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "auto",
		appliesto: "absolutelyPositionedElements",
		computed: "autoOrRectangle",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/clip"
	};
	var color = {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Color"
		],
		initial: "variesFromBrowserToBrowser",
		appliesto: "allElements",
		computed: "translucentValuesRGBAOtherwiseRGB",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/color"
	};
	var columns = {
		syntax: "<'column-width'> || <'column-count'>",
		media: "visual",
		inherited: false,
		animationType: [
			"column-width",
			"column-count"
		],
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: [
			"column-width",
			"column-count"
		],
		appliesto: "blockContainersExceptTableWrappers",
		computed: [
			"column-width",
			"column-count"
		],
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/columns"
	};
	var contain = {
		syntax: "none | strict | content | [ size || layout || style || paint ]",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Containment"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/contain"
	};
	var content = {
		syntax: "normal | none | [ <content-replacement> | <content-list> ] [/ <string> ]?",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Generated Content"
		],
		initial: "normal",
		appliesto: "beforeAndAfterPseudos",
		computed: "normalOnElementsForPseudosNoneAbsoluteURIStringOrAsSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/content"
	};
	var cursor = {
		syntax: "[ [ <url> [ <x> <y> ]? , ]* [ auto | default | none | context-menu | help | pointer | progress | wait | cell | crosshair | text | vertical-text | alias | copy | move | no-drop | not-allowed | e-resize | n-resize | ne-resize | nw-resize | s-resize | se-resize | sw-resize | w-resize | ew-resize | ns-resize | nesw-resize | nwse-resize | col-resize | row-resize | all-scroll | zoom-in | zoom-out | grab | grabbing ] ]",
		media: [
			"visual",
			"interactive"
		],
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecifiedURLsAbsolute",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/cursor"
	};
	var direction = {
		syntax: "ltr | rtl",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Writing Modes"
		],
		initial: "ltr",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/direction"
	};
	var display = {
		syntax: "[ <display-outside> || <display-inside> ] | <display-listitem> | <display-internal> | <display-box> | <display-legacy>",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Display"
		],
		initial: "inline",
		appliesto: "allElements",
		computed: "asSpecifiedExceptPositionedFloatingAndRootElementsKeywordMaybeDifferent",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/display"
	};
	var filter = {
		syntax: "none | <filter-function-list>",
		media: "visual",
		inherited: false,
		animationType: "filterList",
		percentages: "no",
		groups: [
			"Filter Effects"
		],
		initial: "none",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/filter"
	};
	var flex = {
		syntax: "none | [ <'flex-grow'> <'flex-shrink'>? || <'flex-basis'> ]",
		media: "visual",
		inherited: false,
		animationType: [
			"flex-grow",
			"flex-shrink",
			"flex-basis"
		],
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: [
			"flex-grow",
			"flex-shrink",
			"flex-basis"
		],
		appliesto: "flexItemsAndInFlowPseudos",
		computed: [
			"flex-grow",
			"flex-shrink",
			"flex-basis"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex"
	};
	var float = {
		syntax: "left | right | none | inline-start | inline-end",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Positioning"
		],
		initial: "none",
		appliesto: "allElementsNoEffectIfDisplayNone",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/float"
	};
	var font = {
		syntax: "[ [ <'font-style'> || <font-variant-css21> || <'font-weight'> || <'font-stretch'> ]? <'font-size'> [ / <'line-height'> ]? <'font-family'> ] | caption | icon | menu | message-box | small-caption | status-bar",
		media: "visual",
		inherited: true,
		animationType: [
			"font-style",
			"font-variant",
			"font-weight",
			"font-stretch",
			"font-size",
			"line-height",
			"font-family"
		],
		percentages: [
			"font-size",
			"line-height"
		],
		groups: [
			"CSS Fonts"
		],
		initial: [
			"font-style",
			"font-variant",
			"font-weight",
			"font-stretch",
			"font-size",
			"line-height",
			"font-family"
		],
		appliesto: "allElements",
		computed: [
			"font-style",
			"font-variant",
			"font-weight",
			"font-stretch",
			"font-size",
			"line-height",
			"font-family"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font"
	};
	var gap = {
		syntax: "<'row-gap'> <'column-gap'>?",
		media: "visual",
		inherited: false,
		animationType: [
			"row-gap",
			"column-gap"
		],
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: [
			"row-gap",
			"column-gap"
		],
		appliesto: "gridContainers",
		computed: [
			"row-gap",
			"column-gap"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/gap"
	};
	var grid = {
		syntax: "<'grid-template'> | <'grid-template-rows'> / [ auto-flow && dense? ] <'grid-auto-columns'>? | [ auto-flow && dense? ] <'grid-auto-rows'>? / <'grid-template-columns'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: [
			"grid-template-rows",
			"grid-template-columns",
			"grid-auto-rows",
			"grid-auto-columns"
		],
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-template-rows",
			"grid-template-columns",
			"grid-template-areas",
			"grid-auto-rows",
			"grid-auto-columns",
			"grid-auto-flow",
			"grid-column-gap",
			"grid-row-gap",
			"column-gap",
			"row-gap"
		],
		appliesto: "gridContainers",
		computed: [
			"grid-template-rows",
			"grid-template-columns",
			"grid-template-areas",
			"grid-auto-rows",
			"grid-auto-columns",
			"grid-auto-flow",
			"grid-column-gap",
			"grid-row-gap",
			"column-gap",
			"row-gap"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid"
	};
	var height = {
		syntax: "[ <length> | <percentage> ] && [ border-box | content-box ]? | available | min-content | max-content | fit-content | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "regardingHeightOfGeneratedBoxContainingBlockPercentagesRelativeToContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "allElementsButNonReplacedAndTableColumns",
		computed: "percentageAutoOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/height"
	};
	var hyphens = {
		syntax: "none | manual | auto",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "manual",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/hyphens"
	};
	var inset = {
		syntax: "<'top'>{1,4}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalHeightOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset"
	};
	var isolation = {
		syntax: "auto | isolate",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Compositing and Blending"
		],
		initial: "auto",
		appliesto: "allElementsSVGContainerGraphicsAndGraphicsReferencingElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/isolation"
	};
	var left = {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Positioning"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/left"
	};
	var margin = {
		syntax: "[ <length> | <percentage> | auto ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: [
			"margin-bottom",
			"margin-left",
			"margin-right",
			"margin-top"
		],
		appliesto: "allElementsExceptTableDisplayTypes",
		computed: [
			"margin-bottom",
			"margin-left",
			"margin-right",
			"margin-top"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin"
	};
	var mask = {
		syntax: "<mask-layer>#",
		media: "visual",
		inherited: false,
		animationType: [
			"mask-image",
			"mask-mode",
			"mask-repeat",
			"mask-position",
			"mask-clip",
			"mask-origin",
			"mask-size",
			"mask-composite"
		],
		percentages: [
			"mask-position"
		],
		groups: [
			"CSS Masking"
		],
		initial: [
			"mask-image",
			"mask-mode",
			"mask-repeat",
			"mask-position",
			"mask-clip",
			"mask-origin",
			"mask-size",
			"mask-composite"
		],
		appliesto: "allElementsSVGContainerElements",
		computed: [
			"mask-image",
			"mask-mode",
			"mask-repeat",
			"mask-position",
			"mask-clip",
			"mask-origin",
			"mask-size",
			"mask-composite"
		],
		order: "perGrammar",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask"
	};
	var offset = {
		syntax: "[ <'offset-position'>? [ <'offset-path'> [ <'offset-distance'> || <'offset-rotate'> ]? ]? ]! [ / <'offset-anchor'> ]?",
		media: "visual",
		inherited: false,
		animationType: [
			"offset-position",
			"offset-path",
			"offset-distance",
			"offset-anchor",
			"offset-rotate"
		],
		percentages: [
			"offset-position",
			"offset-distance",
			"offset-anchor"
		],
		groups: [
			"CSS Motion Path"
		],
		initial: [
			"offset-position",
			"offset-path",
			"offset-distance",
			"offset-anchor",
			"offset-rotate"
		],
		appliesto: "transformableElements",
		computed: [
			"offset-position",
			"offset-path",
			"offset-distance",
			"offset-anchor",
			"offset-rotate"
		],
		order: "perGrammar",
		stacking: true,
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/offset"
	};
	var opacity = {
		syntax: "<alpha-value>",
		media: "visual",
		inherited: false,
		animationType: "number",
		percentages: "no",
		groups: [
			"CSS Color"
		],
		initial: "1.0",
		appliesto: "allElements",
		computed: "specifiedValueClipped0To1",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/opacity"
	};
	var order = {
		syntax: "<integer>",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "0",
		appliesto: "flexItemsAndAbsolutelyPositionedFlexContainerChildren",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/order"
	};
	var orphans = {
		syntax: "<integer>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "2",
		appliesto: "blockContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/orphans"
	};
	var outline = {
		syntax: "[ <'outline-color'> || <'outline-style'> || <'outline-width'> ]",
		media: [
			"visual",
			"interactive"
		],
		inherited: false,
		animationType: [
			"outline-color",
			"outline-width",
			"outline-style"
		],
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: [
			"outline-color",
			"outline-style",
			"outline-width"
		],
		appliesto: "allElements",
		computed: [
			"outline-color",
			"outline-width",
			"outline-style"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline"
	};
	var overflow = {
		syntax: "[ visible | hidden | clip | scroll | auto ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "visible",
		appliesto: "blockContainersFlexContainersGridContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow"
	};
	var padding = {
		syntax: "[ <length> | <percentage> ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: [
			"padding-bottom",
			"padding-left",
			"padding-right",
			"padding-top"
		],
		appliesto: "allElementsExceptInternalTableDisplayTypes",
		computed: [
			"padding-bottom",
			"padding-left",
			"padding-right",
			"padding-top"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding"
	};
	var perspective = {
		syntax: "none | <length>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "absoluteLengthOrNone",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/perspective"
	};
	var position = {
		syntax: "static | relative | absolute | sticky | fixed",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Positioning"
		],
		initial: "static",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/position"
	};
	var quotes = {
		syntax: "none | auto | [ <string> <string> ]+",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Generated Content"
		],
		initial: "dependsOnUserAgent",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/quotes"
	};
	var resize = {
		syntax: "none | both | horizontal | vertical | block | inline",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "none",
		appliesto: "elementsWithOverflowNotVisibleAndReplacedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/resize"
	};
	var right = {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Positioning"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/right"
	};
	var rotate = {
		syntax: "none | <angle> | [ x | y | z | <number>{3} ] && <angle>",
		media: "visual",
		inherited: false,
		animationType: "transform",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "perGrammar",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/rotate"
	};
	var scale = {
		syntax: "none | <number>{1,3}",
		media: "visual",
		inherited: false,
		animationType: "transform",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "perGrammar",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scale"
	};
	var top = {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToContainingBlockHeight",
		groups: [
			"CSS Positioning"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/top"
	};
	var transform = {
		syntax: "none | <transform-list>",
		media: "visual",
		inherited: false,
		animationType: "transform",
		percentages: "referToSizeOfBoundingBox",
		groups: [
			"CSS Transforms"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transform"
	};
	var transition = {
		syntax: "<single-transition>#",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transitions"
		],
		initial: [
			"transition-delay",
			"transition-duration",
			"transition-property",
			"transition-timing-function"
		],
		appliesto: "allElementsAndPseudos",
		computed: [
			"transition-delay",
			"transition-duration",
			"transition-property",
			"transition-timing-function"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition"
	};
	var translate = {
		syntax: "none | <length-percentage> [ <length-percentage> <length>? ]?",
		media: "visual",
		inherited: false,
		animationType: "transform",
		percentages: "referToSizeOfBoundingBox",
		groups: [
			"CSS Transforms"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "perGrammar",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/translate"
	};
	var visibility = {
		syntax: "visible | hidden | collapse",
		media: "visual",
		inherited: true,
		animationType: "visibility",
		percentages: "no",
		groups: [
			"CSS Box Model"
		],
		initial: "visible",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/visibility"
	};
	var widows = {
		syntax: "<integer>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "2",
		appliesto: "blockContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/widows"
	};
	var width = {
		syntax: "[ <length> | <percentage> ] && [ border-box | content-box ]? | available | min-content | max-content | fit-content | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "allElementsButNonReplacedAndTableRows",
		computed: "percentageAutoOrAbsoluteLength",
		order: "lengthOrPercentageBeforeKeywordIfBothPresent",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/width"
	};
	var zoom = {
		syntax: "normal | reset | <number> | <percentage>",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/zoom"
	};
	var properties$1 = {
		"--*": {
		syntax: "<declaration-value>",
		media: "all",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Variables"
		],
		initial: "seeProse",
		appliesto: "allElements",
		computed: "asSpecifiedWithVarsSubstituted",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/--*"
	},
		"-ms-accelerator": {
		syntax: "false | true",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "false",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-accelerator"
	},
		"-ms-block-progression": {
		syntax: "tb | rl | bt | lr",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "tb",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-block-progression"
	},
		"-ms-content-zoom-chaining": {
		syntax: "none | chained",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-chaining"
	},
		"-ms-content-zooming": {
		syntax: "none | zoom",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "zoomForTheTopLevelNoneForTheRest",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zooming"
	},
		"-ms-content-zoom-limit": {
		syntax: "<'-ms-content-zoom-limit-min'> <'-ms-content-zoom-limit-max'>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: [
			"-ms-content-zoom-limit-max",
			"-ms-content-zoom-limit-min"
		],
		groups: [
			"Microsoft Extensions"
		],
		initial: [
			"-ms-content-zoom-limit-max",
			"-ms-content-zoom-limit-min"
		],
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: [
			"-ms-content-zoom-limit-max",
			"-ms-content-zoom-limit-min"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-limit"
	},
		"-ms-content-zoom-limit-max": {
		syntax: "<percentage>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "maxZoomFactor",
		groups: [
			"Microsoft Extensions"
		],
		initial: "400%",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-limit-max"
	},
		"-ms-content-zoom-limit-min": {
		syntax: "<percentage>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "minZoomFactor",
		groups: [
			"Microsoft Extensions"
		],
		initial: "100%",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-limit-min"
	},
		"-ms-content-zoom-snap": {
		syntax: "<'-ms-content-zoom-snap-type'> || <'-ms-content-zoom-snap-points'>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: [
			"-ms-content-zoom-snap-type",
			"-ms-content-zoom-snap-points"
		],
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: [
			"-ms-content-zoom-snap-type",
			"-ms-content-zoom-snap-points"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-snap"
	},
		"-ms-content-zoom-snap-points": {
		syntax: "snapInterval( <percentage>, <percentage> ) | snapList( <percentage># )",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "snapInterval(0%, 100%)",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-snap-points"
	},
		"-ms-content-zoom-snap-type": {
		syntax: "none | proximity | mandatory",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-snap-type"
	},
		"-ms-filter": {
		syntax: "<string>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "\"\"",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-filter"
	},
		"-ms-flow-from": {
		syntax: "[ none | <custom-ident> ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "nonReplacedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-flow-from"
	},
		"-ms-flow-into": {
		syntax: "[ none | <custom-ident> ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "iframeElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-flow-into"
	},
		"-ms-high-contrast-adjust": {
		syntax: "auto | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-high-contrast-adjust"
	},
		"-ms-hyphenate-limit-chars": {
		syntax: "auto | <integer>{1,3}",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-hyphenate-limit-chars"
	},
		"-ms-hyphenate-limit-lines": {
		syntax: "no-limit | <integer>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "no-limit",
		appliesto: "blockContainerElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-hyphenate-limit-lines"
	},
		"-ms-hyphenate-limit-zone": {
		syntax: "<percentage> | <length>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "referToLineBoxWidth",
		groups: [
			"Microsoft Extensions"
		],
		initial: "0",
		appliesto: "blockContainerElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-hyphenate-limit-zone"
	},
		"-ms-ime-align": {
		syntax: "auto | after",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-ime-align"
	},
		"-ms-overflow-style": {
		syntax: "auto | none | scrollbar | -ms-autohiding-scrollbar",
		media: "interactive",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-overflow-style"
	},
		"-ms-scrollbar-3dlight-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "dependsOnUserAgent",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-3dlight-color"
	},
		"-ms-scrollbar-arrow-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "ButtonText",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-arrow-color"
	},
		"-ms-scrollbar-base-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "dependsOnUserAgent",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-base-color"
	},
		"-ms-scrollbar-darkshadow-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "ThreeDDarkShadow",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-darkshadow-color"
	},
		"-ms-scrollbar-face-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "ThreeDFace",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-face-color"
	},
		"-ms-scrollbar-highlight-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "ThreeDHighlight",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-highlight-color"
	},
		"-ms-scrollbar-shadow-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "ThreeDDarkShadow",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-shadow-color"
	},
		"-ms-scrollbar-track-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "Scrollbar",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-track-color"
	},
		"-ms-scroll-chaining": {
		syntax: "chained | none",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "chained",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-chaining"
	},
		"-ms-scroll-limit": {
		syntax: "<'-ms-scroll-limit-x-min'> <'-ms-scroll-limit-y-min'> <'-ms-scroll-limit-x-max'> <'-ms-scroll-limit-y-max'>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: [
			"-ms-scroll-limit-x-min",
			"-ms-scroll-limit-y-min",
			"-ms-scroll-limit-x-max",
			"-ms-scroll-limit-y-max"
		],
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: [
			"-ms-scroll-limit-x-min",
			"-ms-scroll-limit-y-min",
			"-ms-scroll-limit-x-max",
			"-ms-scroll-limit-y-max"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit"
	},
		"-ms-scroll-limit-x-max": {
		syntax: "auto | <length>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit-x-max"
	},
		"-ms-scroll-limit-x-min": {
		syntax: "<length>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "0",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit-x-min"
	},
		"-ms-scroll-limit-y-max": {
		syntax: "auto | <length>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit-y-max"
	},
		"-ms-scroll-limit-y-min": {
		syntax: "<length>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "0",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit-y-min"
	},
		"-ms-scroll-rails": {
		syntax: "none | railed",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "railed",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-rails"
	},
		"-ms-scroll-snap-points-x": {
		syntax: "snapInterval( <length-percentage>, <length-percentage> ) | snapList( <length-percentage># )",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "snapInterval(0px, 100%)",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-points-x"
	},
		"-ms-scroll-snap-points-y": {
		syntax: "snapInterval( <length-percentage>, <length-percentage> ) | snapList( <length-percentage># )",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "snapInterval(0px, 100%)",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-points-y"
	},
		"-ms-scroll-snap-type": {
		syntax: "none | proximity | mandatory",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-type"
	},
		"-ms-scroll-snap-x": {
		syntax: "<'-ms-scroll-snap-type'> <'-ms-scroll-snap-points-x'>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: [
			"-ms-scroll-snap-type",
			"-ms-scroll-snap-points-x"
		],
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: [
			"-ms-scroll-snap-type",
			"-ms-scroll-snap-points-x"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-x"
	},
		"-ms-scroll-snap-y": {
		syntax: "<'-ms-scroll-snap-type'> <'-ms-scroll-snap-points-y'>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: [
			"-ms-scroll-snap-type",
			"-ms-scroll-snap-points-y"
		],
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: [
			"-ms-scroll-snap-type",
			"-ms-scroll-snap-points-y"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-y"
	},
		"-ms-scroll-translation": {
		syntax: "none | vertical-to-horizontal",
		media: "interactive",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-translation"
	},
		"-ms-text-autospace": {
		syntax: "none | ideograph-alpha | ideograph-numeric | ideograph-parenthesis | ideograph-space",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-text-autospace"
	},
		"-ms-touch-select": {
		syntax: "grippers | none",
		media: "interactive",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "grippers",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-touch-select"
	},
		"-ms-user-select": {
		syntax: "none | element | text",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "text",
		appliesto: "nonReplacedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-user-select"
	},
		"-ms-wrap-flow": {
		syntax: "auto | both | start | end | maximum | clear",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-wrap-flow"
	},
		"-ms-wrap-margin": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "0",
		appliesto: "exclusionElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-wrap-margin"
	},
		"-ms-wrap-through": {
		syntax: "wrap | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "wrap",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-wrap-through"
	},
		"-moz-appearance": {
		syntax: "none | button | button-arrow-down | button-arrow-next | button-arrow-previous | button-arrow-up | button-bevel | button-focus | caret | checkbox | checkbox-container | checkbox-label | checkmenuitem | dualbutton | groupbox | listbox | listitem | menuarrow | menubar | menucheckbox | menuimage | menuitem | menuitemtext | menulist | menulist-button | menulist-text | menulist-textfield | menupopup | menuradio | menuseparator | meterbar | meterchunk | progressbar | progressbar-vertical | progresschunk | progresschunk-vertical | radio | radio-container | radio-label | radiomenuitem | range | range-thumb | resizer | resizerpanel | scale-horizontal | scalethumbend | scalethumb-horizontal | scalethumbstart | scalethumbtick | scalethumb-vertical | scale-vertical | scrollbarbutton-down | scrollbarbutton-left | scrollbarbutton-right | scrollbarbutton-up | scrollbarthumb-horizontal | scrollbarthumb-vertical | scrollbartrack-horizontal | scrollbartrack-vertical | searchfield | separator | sheet | spinner | spinner-downbutton | spinner-textfield | spinner-upbutton | splitter | statusbar | statusbarpanel | tab | tabpanel | tabpanels | tab-scroll-arrow-back | tab-scroll-arrow-forward | textfield | textfield-multiline | toolbar | toolbarbutton | toolbarbutton-dropdown | toolbargripper | toolbox | tooltip | treeheader | treeheadercell | treeheadersortarrow | treeitem | treeline | treetwisty | treetwistyopen | treeview | -moz-mac-unified-toolbar | -moz-win-borderless-glass | -moz-win-browsertabbar-toolbox | -moz-win-communicationstext | -moz-win-communications-toolbox | -moz-win-exclude-glass | -moz-win-glass | -moz-win-mediatext | -moz-win-media-toolbox | -moz-window-button-box | -moz-window-button-box-maximized | -moz-window-button-close | -moz-window-button-maximize | -moz-window-button-minimize | -moz-window-button-restore | -moz-window-frame-bottom | -moz-window-frame-left | -moz-window-frame-right | -moz-window-titlebar | -moz-window-titlebar-maximized",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "noneButOverriddenInUserAgentCSS",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-appearance"
	},
		"-moz-binding": {
		syntax: "<url> | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElementsExceptGeneratedContentOrPseudoElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-binding"
	},
		"-moz-border-bottom-colors": {
		syntax: "<color>+ | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-border-bottom-colors"
	},
		"-moz-border-left-colors": {
		syntax: "<color>+ | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-border-left-colors"
	},
		"-moz-border-right-colors": {
		syntax: "<color>+ | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-border-right-colors"
	},
		"-moz-border-top-colors": {
		syntax: "<color>+ | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-border-top-colors"
	},
		"-moz-context-properties": {
		syntax: "none | [ fill | fill-opacity | stroke | stroke-opacity ]#",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElementsThatCanReferenceImages",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-context-properties"
	},
		"-moz-float-edge": {
		syntax: "border-box | content-box | margin-box | padding-box",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "content-box",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-float-edge"
	},
		"-moz-force-broken-image-icon": {
		syntax: "<integer>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "0",
		appliesto: "images",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-force-broken-image-icon"
	},
		"-moz-image-region": {
		syntax: "<shape> | auto",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "auto",
		appliesto: "xulImageElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-image-region"
	},
		"-moz-orient": {
		syntax: "inline | block | horizontal | vertical",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "inline",
		appliesto: "anyElementEffectOnProgressAndMeter",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-orient"
	},
		"-moz-outline-radius": {
		syntax: "<outline-radius>{1,4} [ / <outline-radius>{1,4} ]?",
		media: "visual",
		inherited: false,
		animationType: [
			"-moz-outline-radius-topleft",
			"-moz-outline-radius-topright",
			"-moz-outline-radius-bottomright",
			"-moz-outline-radius-bottomleft"
		],
		percentages: [
			"-moz-outline-radius-topleft",
			"-moz-outline-radius-topright",
			"-moz-outline-radius-bottomright",
			"-moz-outline-radius-bottomleft"
		],
		groups: [
			"Mozilla Extensions"
		],
		initial: [
			"-moz-outline-radius-topleft",
			"-moz-outline-radius-topright",
			"-moz-outline-radius-bottomright",
			"-moz-outline-radius-bottomleft"
		],
		appliesto: "allElements",
		computed: [
			"-moz-outline-radius-topleft",
			"-moz-outline-radius-topright",
			"-moz-outline-radius-bottomright",
			"-moz-outline-radius-bottomleft"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius"
	},
		"-moz-outline-radius-bottomleft": {
		syntax: "<outline-radius>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"Mozilla Extensions"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius-bottomleft"
	},
		"-moz-outline-radius-bottomright": {
		syntax: "<outline-radius>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"Mozilla Extensions"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius-bottomright"
	},
		"-moz-outline-radius-topleft": {
		syntax: "<outline-radius>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"Mozilla Extensions"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius-topleft"
	},
		"-moz-outline-radius-topright": {
		syntax: "<outline-radius>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"Mozilla Extensions"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius-topright"
	},
		"-moz-stack-sizing": {
		syntax: "ignore | stretch-to-fit",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "stretch-to-fit",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-stack-sizing"
	},
		"-moz-text-blink": {
		syntax: "none | blink",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-text-blink"
	},
		"-moz-user-focus": {
		syntax: "ignore | normal | select-after | select-before | select-menu | select-same | select-all | none",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-user-focus"
	},
		"-moz-user-input": {
		syntax: "auto | none | enabled | disabled",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-user-input"
	},
		"-moz-user-modify": {
		syntax: "read-only | read-write | write-only",
		media: "interactive",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "read-only",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-user-modify"
	},
		"-moz-window-dragging": {
		syntax: "drag | no-drag",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "drag",
		appliesto: "allElementsCreatingNativeWindows",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-window-dragging"
	},
		"-moz-window-shadow": {
		syntax: "default | menu | tooltip | sheet | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "default",
		appliesto: "allElementsCreatingNativeWindows",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-window-shadow"
	},
		"-webkit-appearance": {
		syntax: "none | button | button-bevel | caret | checkbox | default-button | inner-spin-button | listbox | listitem | media-controls-background | media-controls-fullscreen-background | media-current-time-display | media-enter-fullscreen-button | media-exit-fullscreen-button | media-fullscreen-button | media-mute-button | media-overlay-play-button | media-play-button | media-seek-back-button | media-seek-forward-button | media-slider | media-sliderthumb | media-time-remaining-display | media-toggle-closed-captions-button | media-volume-slider | media-volume-slider-container | media-volume-sliderthumb | menulist | menulist-button | menulist-text | menulist-textfield | meter | progress-bar | progress-bar-value | push-button | radio | searchfield | searchfield-cancel-button | searchfield-decoration | searchfield-results-button | searchfield-results-decoration | slider-horizontal | slider-vertical | sliderthumb-horizontal | sliderthumb-vertical | square-button | textarea | textfield",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "noneButOverriddenInUserAgentCSS",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-appearance"
	},
		"-webkit-border-before": {
		syntax: "<'border-width'> || <'border-style'> || <'color'>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: [
			"-webkit-border-before-width"
		],
		groups: [
			"WebKit Extensions"
		],
		initial: [
			"border-width",
			"border-style",
			"color"
		],
		appliesto: "allElements",
		computed: [
			"border-width",
			"border-style",
			"color"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-border-before"
	},
		"-webkit-border-before-color": {
		syntax: "<'color'>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-webkit-border-before-style": {
		syntax: "<'border-style'>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-webkit-border-before-width": {
		syntax: "<'border-width'>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"WebKit Extensions"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-webkit-box-reflect": {
		syntax: "[ above | below | right | left ]? <length>? <image>?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-box-reflect"
	},
		"-webkit-line-clamp": {
		syntax: "none | <integer>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"WebKit Extensions",
			"CSS Overflow"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-line-clamp"
	},
		"-webkit-mask": {
		syntax: "[ <mask-reference> || <position> [ / <bg-size> ]? || <repeat-style> || [ <box> | border | padding | content | text ] || [ <box> | border | padding | content ] ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: [
			"-webkit-mask-image",
			"-webkit-mask-repeat",
			"-webkit-mask-attachment",
			"-webkit-mask-position",
			"-webkit-mask-origin",
			"-webkit-mask-clip"
		],
		appliesto: "allElements",
		computed: [
			"-webkit-mask-image",
			"-webkit-mask-repeat",
			"-webkit-mask-attachment",
			"-webkit-mask-position",
			"-webkit-mask-origin",
			"-webkit-mask-clip"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask"
	},
		"-webkit-mask-attachment": {
		syntax: "<attachment>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "scroll",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-attachment"
	},
		"-webkit-mask-clip": {
		syntax: "[ <box> | border | padding | content | text ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "border",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-clip"
	},
		"-webkit-mask-composite": {
		syntax: "<composite-style>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "source-over",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-composite"
	},
		"-webkit-mask-image": {
		syntax: "<mask-reference>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "absoluteURIOrNone",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-image"
	},
		"-webkit-mask-origin": {
		syntax: "[ <box> | border | padding | content ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "padding",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-origin"
	},
		"-webkit-mask-position": {
		syntax: "<position>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToSizeOfElement",
		groups: [
			"WebKit Extensions"
		],
		initial: "0% 0%",
		appliesto: "allElements",
		computed: "absoluteLengthOrPercentage",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-position"
	},
		"-webkit-mask-position-x": {
		syntax: "[ <length-percentage> | left | center | right ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToSizeOfElement",
		groups: [
			"WebKit Extensions"
		],
		initial: "0%",
		appliesto: "allElements",
		computed: "absoluteLengthOrPercentage",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-position-x"
	},
		"-webkit-mask-position-y": {
		syntax: "[ <length-percentage> | top | center | bottom ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToSizeOfElement",
		groups: [
			"WebKit Extensions"
		],
		initial: "0%",
		appliesto: "allElements",
		computed: "absoluteLengthOrPercentage",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-position-y"
	},
		"-webkit-mask-repeat": {
		syntax: "<repeat-style>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "repeat",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-repeat"
	},
		"-webkit-mask-repeat-x": {
		syntax: "repeat | no-repeat | space | round",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "repeat",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-repeat-x"
	},
		"-webkit-mask-repeat-y": {
		syntax: "repeat | no-repeat | space | round",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "repeat",
		appliesto: "allElements",
		computed: "absoluteLengthOrPercentage",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-repeat-y"
	},
		"-webkit-mask-size": {
		syntax: "<bg-size>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "relativeToBackgroundPositioningArea",
		groups: [
			"WebKit Extensions"
		],
		initial: "auto auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-size"
	},
		"-webkit-overflow-scrolling": {
		syntax: "auto | touch",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "auto",
		appliesto: "scrollingBoxes",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-overflow-scrolling"
	},
		"-webkit-tap-highlight-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "black",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-tap-highlight-color"
	},
		"-webkit-text-fill-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "color",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-text-fill-color"
	},
		"-webkit-text-stroke": {
		syntax: "<length> || <color>",
		media: "visual",
		inherited: true,
		animationType: [
			"-webkit-text-stroke-width",
			"-webkit-text-stroke-color"
		],
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: [
			"-webkit-text-stroke-width",
			"-webkit-text-stroke-color"
		],
		appliesto: "allElements",
		computed: [
			"-webkit-text-stroke-width",
			"-webkit-text-stroke-color"
		],
		order: "canonicalOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-text-stroke"
	},
		"-webkit-text-stroke-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "color",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-text-stroke-color"
	},
		"-webkit-text-stroke-width": {
		syntax: "<length>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "absoluteLength",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-text-stroke-width"
	},
		"-webkit-touch-callout": {
		syntax: "default | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "default",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-touch-callout"
	},
		"-webkit-user-modify": {
		syntax: "read-only | read-write | read-write-plaintext-only",
		media: "interactive",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "read-only",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"align-content": {
		syntax: "normal | <baseline-position> | <content-distribution> | <overflow-position>? <content-position>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "multilineFlexContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/align-content"
	},
		"align-items": {
		syntax: "normal | stretch | <baseline-position> | [ <overflow-position>? <self-position> ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/align-items"
	},
		"align-self": {
		syntax: "auto | normal | stretch | <baseline-position> | <overflow-position>? <self-position>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "auto",
		appliesto: "flexItemsGridItemsAndAbsolutelyPositionedBoxes",
		computed: "autoOnAbsolutelyPositionedElementsValueOfAlignItemsOnParent",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/align-self"
	},
		all: all,
		animation: animation,
		"animation-delay": {
		syntax: "<time>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "0s",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-delay"
	},
		"animation-direction": {
		syntax: "<single-animation-direction>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "normal",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-direction"
	},
		"animation-duration": {
		syntax: "<time>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "0s",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-duration"
	},
		"animation-fill-mode": {
		syntax: "<single-animation-fill-mode>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "none",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-fill-mode"
	},
		"animation-iteration-count": {
		syntax: "<single-animation-iteration-count>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "1",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-iteration-count"
	},
		"animation-name": {
		syntax: "[ none | <keyframes-name> ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "none",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-name"
	},
		"animation-play-state": {
		syntax: "<single-animation-play-state>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "running",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-play-state"
	},
		"animation-timing-function": {
		syntax: "<timing-function>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "ease",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-timing-function"
	},
		appearance: appearance,
		"aspect-ratio": {
		syntax: "auto | <ratio>",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "allElementsExceptInlineBoxesAndInternalRubyOrTableBoxes",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/aspect-ratio"
	},
		azimuth: azimuth,
		"backdrop-filter": {
		syntax: "none | <filter-function-list>",
		media: "visual",
		inherited: false,
		animationType: "filterList",
		percentages: "no",
		groups: [
			"Filter Effects"
		],
		initial: "none",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/backdrop-filter"
	},
		"backface-visibility": {
		syntax: "visible | hidden",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "visible",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/backface-visibility"
	},
		background: background,
		"background-attachment": {
		syntax: "<attachment>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "scroll",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-attachment"
	},
		"background-blend-mode": {
		syntax: "<blend-mode>#",
		media: "none",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Compositing and Blending"
		],
		initial: "normal",
		appliesto: "allElementsSVGContainerGraphicsAndGraphicsReferencingElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-blend-mode"
	},
		"background-clip": {
		syntax: "<box>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "border-box",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-clip"
	},
		"background-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "transparent",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-color"
	},
		"background-image": {
		syntax: "<bg-image>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecifiedURLsAbsolute",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-image"
	},
		"background-origin": {
		syntax: "<box>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "padding-box",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-origin"
	},
		"background-position": {
		syntax: "<bg-position>#",
		media: "visual",
		inherited: false,
		animationType: "repeatableListOfSimpleListOfLpc",
		percentages: "referToSizeOfBackgroundPositioningAreaMinusBackgroundImageSize",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0% 0%",
		appliesto: "allElements",
		computed: "listEachItemTwoKeywordsOriginOffsets",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-position"
	},
		"background-position-x": {
		syntax: "[ center | [ left | right | x-start | x-end ]? <length-percentage>? ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToWidthOfBackgroundPositioningAreaMinusBackgroundImageHeight",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "left",
		appliesto: "allElements",
		computed: "listEachItemConsistingOfAbsoluteLengthPercentageAndOrigin",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-position-x"
	},
		"background-position-y": {
		syntax: "[ center | [ top | bottom | y-start | y-end ]? <length-percentage>? ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToHeightOfBackgroundPositioningAreaMinusBackgroundImageHeight",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "top",
		appliesto: "allElements",
		computed: "listEachItemConsistingOfAbsoluteLengthPercentageAndOrigin",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-position-y"
	},
		"background-repeat": {
		syntax: "<repeat-style>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "repeat",
		appliesto: "allElements",
		computed: "listEachItemHasTwoKeywordsOnePerDimension",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-repeat"
	},
		"background-size": {
		syntax: "<bg-size>#",
		media: "visual",
		inherited: false,
		animationType: "repeatableListOfSimpleListOfLpc",
		percentages: "relativeToBackgroundPositioningArea",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "auto auto",
		appliesto: "allElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-size"
	},
		"block-overflow": {
		syntax: "clip | ellipsis | <string>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "clip",
		appliesto: "blockContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"block-size": {
		syntax: "<'width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "blockSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsWidthAndHeight",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/block-size"
	},
		border: border,
		"border-block": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		appliesto: "allElements",
		computed: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block"
	},
		"border-block-color": {
		syntax: "<'border-top-color'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-color"
	},
		"border-block-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-style"
	},
		"border-block-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-width"
	},
		"border-block-end": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		appliesto: "allElements",
		computed: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-end"
	},
		"border-block-end-color": {
		syntax: "<'border-top-color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-end-color"
	},
		"border-block-end-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-end-style"
	},
		"border-block-end-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-end-width"
	},
		"border-block-start": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-width",
			"border-style",
			"color"
		],
		appliesto: "allElements",
		computed: [
			"border-width",
			"border-style",
			"border-block-start-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-start"
	},
		"border-block-start-color": {
		syntax: "<'border-top-color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-start-color"
	},
		"border-block-start-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-start-style"
	},
		"border-block-start-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-start-width"
	},
		"border-bottom": {
		syntax: "<line-width> || <line-style> || <color>",
		media: "visual",
		inherited: false,
		animationType: [
			"border-bottom-color",
			"border-bottom-style",
			"border-bottom-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-bottom-width",
			"border-bottom-style",
			"border-bottom-color"
		],
		appliesto: "allElements",
		computed: [
			"border-bottom-width",
			"border-bottom-style",
			"border-bottom-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom"
	},
		"border-bottom-color": {
		syntax: "<'border-top-color'>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-color"
	},
		"border-bottom-left-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-left-radius"
	},
		"border-bottom-right-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-right-radius"
	},
		"border-bottom-style": {
		syntax: "<line-style>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-style"
	},
		"border-bottom-width": {
		syntax: "<line-width>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthOr0IfBorderBottomStyleNoneOrHidden",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-width"
	},
		"border-collapse": {
		syntax: "collapse | separate",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Table"
		],
		initial: "separate",
		appliesto: "tableElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-collapse"
	},
		"border-color": {
		syntax: "<color>{1,4}",
		media: "visual",
		inherited: false,
		animationType: [
			"border-bottom-color",
			"border-left-color",
			"border-right-color",
			"border-top-color"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-top-color",
			"border-right-color",
			"border-bottom-color",
			"border-left-color"
		],
		appliesto: "allElements",
		computed: [
			"border-bottom-color",
			"border-left-color",
			"border-right-color",
			"border-top-color"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-color"
	},
		"border-end-end-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-end-end-radius"
	},
		"border-end-start-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-end-start-radius"
	},
		"border-image": {
		syntax: "<'border-image-source'> || <'border-image-slice'> [ / <'border-image-width'> | / <'border-image-width'>? / <'border-image-outset'> ]? || <'border-image-repeat'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: [
			"border-image-slice",
			"border-image-width"
		],
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-image-source",
			"border-image-slice",
			"border-image-width",
			"border-image-outset",
			"border-image-repeat"
		],
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: [
			"border-image-outset",
			"border-image-repeat",
			"border-image-slice",
			"border-image-source",
			"border-image-width"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image"
	},
		"border-image-outset": {
		syntax: "[ <length> | <number> ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0",
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-outset"
	},
		"border-image-repeat": {
		syntax: "[ stretch | repeat | round | space ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "stretch",
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-repeat"
	},
		"border-image-slice": {
		syntax: "<number-percentage>{1,4} && fill?",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "referToSizeOfBorderImage",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "100%",
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: "oneToFourPercentagesOrAbsoluteLengthsPlusFill",
		order: "percentagesOrLengthsFollowedByFill",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-slice"
	},
		"border-image-source": {
		syntax: "none | <image>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: "noneOrImageWithAbsoluteURI",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-source"
	},
		"border-image-width": {
		syntax: "[ <length-percentage> | <number> | auto ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "referToWidthOrHeightOfBorderImageArea",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "1",
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-width"
	},
		"border-inline": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		appliesto: "allElements",
		computed: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline"
	},
		"border-inline-end": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-width",
			"border-style",
			"color"
		],
		appliesto: "allElements",
		computed: [
			"border-width",
			"border-style",
			"border-inline-end-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-end"
	},
		"border-inline-color": {
		syntax: "<'border-top-color'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-color"
	},
		"border-inline-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-style"
	},
		"border-inline-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-width"
	},
		"border-inline-end-color": {
		syntax: "<'border-top-color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-end-color"
	},
		"border-inline-end-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-end-style"
	},
		"border-inline-end-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-end-width"
	},
		"border-inline-start": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-width",
			"border-style",
			"color"
		],
		appliesto: "allElements",
		computed: [
			"border-width",
			"border-style",
			"border-inline-start-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-start"
	},
		"border-inline-start-color": {
		syntax: "<'border-top-color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-start-color"
	},
		"border-inline-start-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-start-style"
	},
		"border-inline-start-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-start-width"
	},
		"border-left": {
		syntax: "<line-width> || <line-style> || <color>",
		media: "visual",
		inherited: false,
		animationType: [
			"border-left-color",
			"border-left-style",
			"border-left-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-left-width",
			"border-left-style",
			"border-left-color"
		],
		appliesto: "allElements",
		computed: [
			"border-left-width",
			"border-left-style",
			"border-left-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-left"
	},
		"border-left-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-left-color"
	},
		"border-left-style": {
		syntax: "<line-style>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-left-style"
	},
		"border-left-width": {
		syntax: "<line-width>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthOr0IfBorderLeftStyleNoneOrHidden",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-left-width"
	},
		"border-radius": {
		syntax: "<length-percentage>{1,4} [ / <length-percentage>{1,4} ]?",
		media: "visual",
		inherited: false,
		animationType: [
			"border-top-left-radius",
			"border-top-right-radius",
			"border-bottom-right-radius",
			"border-bottom-left-radius"
		],
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-top-left-radius",
			"border-top-right-radius",
			"border-bottom-right-radius",
			"border-bottom-left-radius"
		],
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: [
			"border-bottom-left-radius",
			"border-bottom-right-radius",
			"border-top-left-radius",
			"border-top-right-radius"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-radius"
	},
		"border-right": {
		syntax: "<line-width> || <line-style> || <color>",
		media: "visual",
		inherited: false,
		animationType: [
			"border-right-color",
			"border-right-style",
			"border-right-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-right-width",
			"border-right-style",
			"border-right-color"
		],
		appliesto: "allElements",
		computed: [
			"border-right-width",
			"border-right-style",
			"border-right-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-right"
	},
		"border-right-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-right-color"
	},
		"border-right-style": {
		syntax: "<line-style>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-right-style"
	},
		"border-right-width": {
		syntax: "<line-width>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthOr0IfBorderRightStyleNoneOrHidden",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-right-width"
	},
		"border-spacing": {
		syntax: "<length> <length>?",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Table"
		],
		initial: "0",
		appliesto: "tableElements",
		computed: "twoAbsoluteLengths",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-spacing"
	},
		"border-start-end-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-start-end-radius"
	},
		"border-start-start-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-start-start-radius"
	},
		"border-style": {
		syntax: "<line-style>{1,4}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-top-style",
			"border-right-style",
			"border-bottom-style",
			"border-left-style"
		],
		appliesto: "allElements",
		computed: [
			"border-bottom-style",
			"border-left-style",
			"border-right-style",
			"border-top-style"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-style"
	},
		"border-top": {
		syntax: "<line-width> || <line-style> || <color>",
		media: "visual",
		inherited: false,
		animationType: [
			"border-top-color",
			"border-top-style",
			"border-top-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		appliesto: "allElements",
		computed: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top"
	},
		"border-top-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-color"
	},
		"border-top-left-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-left-radius"
	},
		"border-top-right-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-right-radius"
	},
		"border-top-style": {
		syntax: "<line-style>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-style"
	},
		"border-top-width": {
		syntax: "<line-width>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthOr0IfBorderTopStyleNoneOrHidden",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-width"
	},
		"border-width": {
		syntax: "<line-width>{1,4}",
		media: "visual",
		inherited: false,
		animationType: [
			"border-bottom-width",
			"border-left-width",
			"border-right-width",
			"border-top-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-top-width",
			"border-right-width",
			"border-bottom-width",
			"border-left-width"
		],
		appliesto: "allElements",
		computed: [
			"border-bottom-width",
			"border-left-width",
			"border-right-width",
			"border-top-width"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-width"
	},
		bottom: bottom,
		"box-align": {
		syntax: "start | center | end | baseline | stretch",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "stretch",
		appliesto: "elementsWithDisplayBoxOrInlineBox",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-align"
	},
		"box-decoration-break": {
		syntax: "slice | clone",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "slice",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-decoration-break"
	},
		"box-direction": {
		syntax: "normal | reverse | inherit",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "normal",
		appliesto: "elementsWithDisplayBoxOrInlineBox",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-direction"
	},
		"box-flex": {
		syntax: "<number>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "0",
		appliesto: "directChildrenOfElementsWithDisplayMozBoxMozInlineBox",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-flex"
	},
		"box-flex-group": {
		syntax: "<integer>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "1",
		appliesto: "inFlowChildrenOfBoxElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-flex-group"
	},
		"box-lines": {
		syntax: "single | multiple",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "single",
		appliesto: "boxElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-lines"
	},
		"box-ordinal-group": {
		syntax: "<integer>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "1",
		appliesto: "childrenOfBoxElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-ordinal-group"
	},
		"box-orient": {
		syntax: "horizontal | vertical | inline-axis | block-axis | inherit",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "inlineAxisHorizontalInXUL",
		appliesto: "elementsWithDisplayBoxOrInlineBox",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-orient"
	},
		"box-pack": {
		syntax: "start | center | end | justify",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "start",
		appliesto: "elementsWithDisplayMozBoxMozInlineBox",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-pack"
	},
		"box-shadow": {
		syntax: "none | <shadow>#",
		media: "visual",
		inherited: false,
		animationType: "shadowList",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "absoluteLengthsSpecifiedColorAsSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-shadow"
	},
		"box-sizing": {
		syntax: "content-box | border-box",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "content-box",
		appliesto: "allElementsAcceptingWidthOrHeight",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-sizing"
	},
		"break-after": {
		syntax: "auto | avoid | always | all | avoid-page | page | left | right | recto | verso | avoid-column | column | avoid-region | region",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "auto",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/break-after"
	},
		"break-before": {
		syntax: "auto | avoid | always | all | avoid-page | page | left | right | recto | verso | avoid-column | column | avoid-region | region",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "auto",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/break-before"
	},
		"break-inside": {
		syntax: "auto | avoid | avoid-page | avoid-column | avoid-region",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "auto",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/break-inside"
	},
		"caption-side": {
		syntax: "top | bottom | block-start | block-end | inline-start | inline-end",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Table"
		],
		initial: "top",
		appliesto: "tableCaptionElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/caption-side"
	},
		"caret-color": {
		syntax: "auto | <color>",
		media: "interactive",
		inherited: true,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asAutoOrColor",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/caret-color"
	},
		clear: clear,
		clip: clip,
		"clip-path": {
		syntax: "<clip-source> | [ <basic-shape> || <geometry-box> ] | none",
		media: "visual",
		inherited: false,
		animationType: "basicShapeOtherwiseNo",
		percentages: "referToReferenceBoxWhenSpecifiedOtherwiseBorderBox",
		groups: [
			"CSS Masking"
		],
		initial: "none",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedURLsAbsolute",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/clip-path"
	},
		color: color,
		"color-adjust": {
		syntax: "economy | exact",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Color"
		],
		initial: "economy",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/color-adjust"
	},
		"column-count": {
		syntax: "<integer> | auto",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "auto",
		appliesto: "blockContainersExceptTableWrappers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-count"
	},
		"column-fill": {
		syntax: "auto | balance | balance-all",
		media: "visualInContinuousMediaNoEffectInOverflowColumns",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "balance",
		appliesto: "multicolElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-fill"
	},
		"column-gap": {
		syntax: "normal | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "multiColumnElementsFlexContainersGridContainers",
		computed: "asSpecifiedWithLengthsAbsoluteAndNormalComputingToZeroExceptMultiColumn",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-gap"
	},
		"column-rule": {
		syntax: "<'column-rule-width'> || <'column-rule-style'> || <'column-rule-color'>",
		media: "visual",
		inherited: false,
		animationType: [
			"column-rule-color",
			"column-rule-style",
			"column-rule-width"
		],
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: [
			"column-rule-width",
			"column-rule-style",
			"column-rule-color"
		],
		appliesto: "multicolElements",
		computed: [
			"column-rule-color",
			"column-rule-style",
			"column-rule-width"
		],
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-rule"
	},
		"column-rule-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "currentcolor",
		appliesto: "multicolElements",
		computed: "computedColor",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-rule-color"
	},
		"column-rule-style": {
		syntax: "<'border-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "none",
		appliesto: "multicolElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-rule-style"
	},
		"column-rule-width": {
		syntax: "<'border-width'>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "medium",
		appliesto: "multicolElements",
		computed: "absoluteLength0IfColumnRuleStyleNoneOrHidden",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-rule-width"
	},
		"column-span": {
		syntax: "none | all",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "none",
		appliesto: "inFlowBlockLevelElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-span"
	},
		"column-width": {
		syntax: "<length> | auto",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "auto",
		appliesto: "blockContainersExceptTableWrappers",
		computed: "absoluteLengthZeroOrLarger",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-width"
	},
		columns: columns,
		contain: contain,
		content: content,
		"counter-increment": {
		syntax: "[ <custom-ident> <integer>? ]+ | none",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Counter Styles"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/counter-increment"
	},
		"counter-reset": {
		syntax: "[ <custom-ident> <integer>? ]+ | none",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Counter Styles"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/counter-reset"
	},
		"counter-set": {
		syntax: "[ <custom-ident> <integer>? ]+ | none",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Counter Styles"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/counter-set"
	},
		cursor: cursor,
		direction: direction,
		display: display,
		"empty-cells": {
		syntax: "show | hide",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Table"
		],
		initial: "show",
		appliesto: "tableCellElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/empty-cells"
	},
		filter: filter,
		flex: flex,
		"flex-basis": {
		syntax: "content | <'width'>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToFlexContainersInnerMainSize",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "auto",
		appliesto: "flexItemsAndInFlowPseudos",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "lengthOrPercentageBeforeKeywordIfBothPresent",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-basis"
	},
		"flex-direction": {
		syntax: "row | row-reverse | column | column-reverse",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "row",
		appliesto: "flexContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-direction"
	},
		"flex-flow": {
		syntax: "<'flex-direction'> || <'flex-wrap'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: [
			"flex-direction",
			"flex-wrap"
		],
		appliesto: "flexContainers",
		computed: [
			"flex-direction",
			"flex-wrap"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-flow"
	},
		"flex-grow": {
		syntax: "<number>",
		media: "visual",
		inherited: false,
		animationType: "number",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "0",
		appliesto: "flexItemsAndInFlowPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-grow"
	},
		"flex-shrink": {
		syntax: "<number>",
		media: "visual",
		inherited: false,
		animationType: "number",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "1",
		appliesto: "flexItemsAndInFlowPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-shrink"
	},
		"flex-wrap": {
		syntax: "nowrap | wrap | wrap-reverse",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "nowrap",
		appliesto: "flexContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-wrap"
	},
		float: float,
		font: font,
		"font-family": {
		syntax: "[ <family-name> | <generic-family> ]#",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "dependsOnUserAgent",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-family"
	},
		"font-feature-settings": {
		syntax: "normal | <feature-tag-value>#",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-feature-settings"
	},
		"font-kerning": {
		syntax: "auto | normal | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-kerning"
	},
		"font-language-override": {
		syntax: "normal | <string>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-language-override"
	},
		"font-optical-sizing": {
		syntax: "auto | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-optical-sizing"
	},
		"font-variation-settings": {
		syntax: "normal | [ <string> <number> ]#",
		media: "visual",
		inherited: true,
		animationType: "transform",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variation-settings"
	},
		"font-size": {
		syntax: "<absolute-size> | <relative-size> | <length-percentage>",
		media: "visual",
		inherited: true,
		animationType: "length",
		percentages: "referToParentElementsFontSize",
		groups: [
			"CSS Fonts"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-size"
	},
		"font-size-adjust": {
		syntax: "none | <number>",
		media: "visual",
		inherited: true,
		animationType: "number",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-size-adjust"
	},
		"font-stretch": {
		syntax: "<font-stretch-absolute>",
		media: "visual",
		inherited: true,
		animationType: "fontStretch",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-stretch"
	},
		"font-style": {
		syntax: "normal | italic | oblique <angle>?",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-style"
	},
		"font-synthesis": {
		syntax: "none | [ weight || style ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "weight style",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-synthesis"
	},
		"font-variant": {
		syntax: "normal | none | [ <common-lig-values> || <discretionary-lig-values> || <historical-lig-values> || <contextual-alt-values> || stylistic( <feature-value-name> ) || historical-forms || styleset( <feature-value-name># ) || character-variant( <feature-value-name># ) || swash( <feature-value-name> ) || ornaments( <feature-value-name> ) || annotation( <feature-value-name> ) || [ small-caps | all-small-caps | petite-caps | all-petite-caps | unicase | titling-caps ] || <numeric-figure-values> || <numeric-spacing-values> || <numeric-fraction-values> || ordinal || slashed-zero || <east-asian-variant-values> || <east-asian-width-values> || ruby ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant"
	},
		"font-variant-alternates": {
		syntax: "normal | [ stylistic( <feature-value-name> ) || historical-forms || styleset( <feature-value-name># ) || character-variant( <feature-value-name># ) || swash( <feature-value-name> ) || ornaments( <feature-value-name> ) || annotation( <feature-value-name> ) ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-alternates"
	},
		"font-variant-caps": {
		syntax: "normal | small-caps | all-small-caps | petite-caps | all-petite-caps | unicase | titling-caps",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-caps"
	},
		"font-variant-east-asian": {
		syntax: "normal | [ <east-asian-variant-values> || <east-asian-width-values> || ruby ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-east-asian"
	},
		"font-variant-ligatures": {
		syntax: "normal | none | [ <common-lig-values> || <discretionary-lig-values> || <historical-lig-values> || <contextual-alt-values> ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-ligatures"
	},
		"font-variant-numeric": {
		syntax: "normal | [ <numeric-figure-values> || <numeric-spacing-values> || <numeric-fraction-values> || ordinal || slashed-zero ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-numeric"
	},
		"font-variant-position": {
		syntax: "normal | sub | super",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-position"
	},
		"font-weight": {
		syntax: "<font-weight-absolute> | bolder | lighter",
		media: "visual",
		inherited: true,
		animationType: "fontWeight",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "keywordOrNumericalValueBolderLighterTransformedToRealValue",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-weight"
	},
		gap: gap,
		grid: grid,
		"grid-area": {
		syntax: "<grid-line> [ / <grid-line> ]{0,3}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-row-start",
			"grid-column-start",
			"grid-row-end",
			"grid-column-end"
		],
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: [
			"grid-row-start",
			"grid-column-start",
			"grid-row-end",
			"grid-column-end"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-area"
	},
		"grid-auto-columns": {
		syntax: "<track-size>+",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridContainers",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-auto-columns"
	},
		"grid-auto-flow": {
		syntax: "[ row | column ] || dense",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "row",
		appliesto: "gridContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-auto-flow"
	},
		"grid-auto-rows": {
		syntax: "<track-size>+",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridContainers",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-auto-rows"
	},
		"grid-column": {
		syntax: "<grid-line> [ / <grid-line> ]?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-column-start",
			"grid-column-end"
		],
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: [
			"grid-column-start",
			"grid-column-end"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-column"
	},
		"grid-column-end": {
		syntax: "<grid-line>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-column-end"
	},
		"grid-column-gap": {
		syntax: "<length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "0",
		appliesto: "gridContainers",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-gap"
	},
		"grid-column-start": {
		syntax: "<grid-line>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-column-start"
	},
		"grid-gap": {
		syntax: "<'grid-row-gap'> <'grid-column-gap'>?",
		media: "visual",
		inherited: false,
		animationType: [
			"grid-row-gap",
			"grid-column-gap"
		],
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-row-gap",
			"grid-column-gap"
		],
		appliesto: "gridContainers",
		computed: [
			"grid-row-gap",
			"grid-column-gap"
		],
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/gap"
	},
		"grid-row": {
		syntax: "<grid-line> [ / <grid-line> ]?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-row-start",
			"grid-row-end"
		],
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: [
			"grid-row-start",
			"grid-row-end"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-row"
	},
		"grid-row-end": {
		syntax: "<grid-line>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-row-end"
	},
		"grid-row-gap": {
		syntax: "<length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "0",
		appliesto: "gridContainers",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/row-gap"
	},
		"grid-row-start": {
		syntax: "<grid-line>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-row-start"
	},
		"grid-template": {
		syntax: "none | [ <'grid-template-rows'> / <'grid-template-columns'> ] | [ <line-names>? <string> <track-size>? <line-names>? ]+ [ / <explicit-track-list> ]?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: [
			"grid-template-columns",
			"grid-template-rows"
		],
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-template-columns",
			"grid-template-rows",
			"grid-template-areas"
		],
		appliesto: "gridContainers",
		computed: [
			"grid-template-columns",
			"grid-template-rows",
			"grid-template-areas"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-template"
	},
		"grid-template-areas": {
		syntax: "none | <string>+",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "none",
		appliesto: "gridContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-template-areas"
	},
		"grid-template-columns": {
		syntax: "none | <track-list> | <auto-track-list> | subgrid <line-name-list>?",
		media: "visual",
		inherited: false,
		animationType: "simpleListOfLpcDifferenceLpc",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "none",
		appliesto: "gridContainers",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-template-columns"
	},
		"grid-template-rows": {
		syntax: "none | <track-list> | <auto-track-list> | subgrid <line-name-list>?",
		media: "visual",
		inherited: false,
		animationType: "simpleListOfLpcDifferenceLpc",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "none",
		appliesto: "gridContainers",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-template-rows"
	},
		"hanging-punctuation": {
		syntax: "none | [ first || [ force-end | allow-end ] || last ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/hanging-punctuation"
	},
		height: height,
		hyphens: hyphens,
		"image-orientation": {
		syntax: "from-image | <angle> | [ <angle>? flip ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Images"
		],
		initial: "0deg",
		appliesto: "allElements",
		computed: "angleRoundedToNextQuarter",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/image-orientation"
	},
		"image-rendering": {
		syntax: "auto | crisp-edges | pixelated",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Images"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/image-rendering"
	},
		"image-resolution": {
		syntax: "[ from-image || <resolution> ] && snap?",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Images"
		],
		initial: "1dppx",
		appliesto: "allElements",
		computed: "asSpecifiedWithExceptionOfResolution",
		order: "uniqueOrder",
		status: "experimental"
	},
		"ime-mode": {
		syntax: "auto | normal | active | inactive | disabled",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "textFields",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/ime-mode"
	},
		"initial-letter": {
		syntax: "normal | [ <number> <integer>? ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Inline"
		],
		initial: "normal",
		appliesto: "firstLetterPseudoElementsAndInlineLevelFirstChildren",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/initial-letter"
	},
		"initial-letter-align": {
		syntax: "[ auto | alphabetic | hanging | ideographic ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Inline"
		],
		initial: "auto",
		appliesto: "firstLetterPseudoElementsAndInlineLevelFirstChildren",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/initial-letter-align"
	},
		"inline-size": {
		syntax: "<'width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "inlineSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsWidthAndHeight",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inline-size"
	},
		inset: inset,
		"inset-block": {
		syntax: "<'top'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalHeightOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-block"
	},
		"inset-block-end": {
		syntax: "<'top'>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalHeightOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-block-end"
	},
		"inset-block-start": {
		syntax: "<'top'>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalHeightOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-block-start"
	},
		"inset-inline": {
		syntax: "<'top'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-inline"
	},
		"inset-inline-end": {
		syntax: "<'top'>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-inline-end"
	},
		"inset-inline-start": {
		syntax: "<'top'>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-inline-start"
	},
		isolation: isolation,
		"justify-content": {
		syntax: "normal | <content-distribution> | <overflow-position>? [ <content-position> | left | right ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "flexContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/justify-content"
	},
		"justify-items": {
		syntax: "normal | stretch | <baseline-position> | <overflow-position>? [ <self-position> | left | right ] | legacy | legacy && [ left | right | center ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "legacy",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/justify-items"
	},
		"justify-self": {
		syntax: "auto | normal | stretch | <baseline-position> | <overflow-position>? [ <self-position> | left | right ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "auto",
		appliesto: "blockLevelBoxesAndAbsolutelyPositionedBoxesAndGridItems",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/justify-self"
	},
		left: left,
		"letter-spacing": {
		syntax: "normal | <length>",
		media: "visual",
		inherited: true,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "optimumValueOfAbsoluteLengthOrNormal",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/letter-spacing"
	},
		"line-break": {
		syntax: "auto | loose | normal | strict | anywhere",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/line-break"
	},
		"line-clamp": {
		syntax: "none | <integer>",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "none",
		appliesto: "blockContainersExceptMultiColumnContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"line-height": {
		syntax: "normal | <number> | <length> | <percentage>",
		media: "visual",
		inherited: true,
		animationType: "numberOrLength",
		percentages: "referToElementFontSize",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "absoluteLengthOrAsSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/line-height"
	},
		"line-height-step": {
		syntax: "<length>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "0",
		appliesto: "blockContainers",
		computed: "absoluteLength",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/line-height-step"
	},
		"list-style": {
		syntax: "<'list-style-type'> || <'list-style-position'> || <'list-style-image'>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Lists and Counters"
		],
		initial: [
			"list-style-type",
			"list-style-position",
			"list-style-image"
		],
		appliesto: "listItems",
		computed: [
			"list-style-image",
			"list-style-position",
			"list-style-type"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/list-style"
	},
		"list-style-image": {
		syntax: "<url> | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Lists and Counters"
		],
		initial: "none",
		appliesto: "listItems",
		computed: "noneOrImageWithAbsoluteURI",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/list-style-image"
	},
		"list-style-position": {
		syntax: "inside | outside",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Lists and Counters"
		],
		initial: "outside",
		appliesto: "listItems",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/list-style-position"
	},
		"list-style-type": {
		syntax: "<counter-style> | <string> | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Lists and Counters"
		],
		initial: "disc",
		appliesto: "listItems",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/list-style-type"
	},
		margin: margin,
		"margin-block": {
		syntax: "<'margin-left'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-block"
	},
		"margin-block-end": {
		syntax: "<'margin-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-block-end"
	},
		"margin-block-start": {
		syntax: "<'margin-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-block-start"
	},
		"margin-bottom": {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-bottom"
	},
		"margin-inline": {
		syntax: "<'margin-left'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-inline"
	},
		"margin-inline-end": {
		syntax: "<'margin-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-inline-end"
	},
		"margin-inline-start": {
		syntax: "<'margin-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-inline-start"
	},
		"margin-left": {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-left"
	},
		"margin-right": {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-right"
	},
		"margin-top": {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-top"
	},
		mask: mask,
		"mask-border": {
		syntax: "<'mask-border-source'> || <'mask-border-slice'> [ / <'mask-border-width'>? [ / <'mask-border-outset'> ]? ]? || <'mask-border-repeat'> || <'mask-border-mode'>",
		media: "visual",
		inherited: false,
		animationType: [
			"mask-border-mode",
			"mask-border-outset",
			"mask-border-repeat",
			"mask-border-slice",
			"mask-border-source",
			"mask-border-width"
		],
		percentages: [
			"mask-border-slice",
			"mask-border-width"
		],
		groups: [
			"CSS Masking"
		],
		initial: [
			"mask-border-mode",
			"mask-border-outset",
			"mask-border-repeat",
			"mask-border-slice",
			"mask-border-source",
			"mask-border-width"
		],
		appliesto: "allElementsSVGContainerElements",
		computed: [
			"mask-border-mode",
			"mask-border-outset",
			"mask-border-repeat",
			"mask-border-slice",
			"mask-border-source",
			"mask-border-width"
		],
		order: "perGrammar",
		stacking: true,
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border"
	},
		"mask-border-mode": {
		syntax: "luminance | alpha",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "alpha",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-mode"
	},
		"mask-border-outset": {
		syntax: "[ <length> | <number> ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "0",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-outset"
	},
		"mask-border-repeat": {
		syntax: "[ stretch | repeat | round | space ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "stretch",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-repeat"
	},
		"mask-border-slice": {
		syntax: "<number-percentage>{1,4} fill?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToSizeOfMaskBorderImage",
		groups: [
			"CSS Masking"
		],
		initial: "0",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-slice"
	},
		"mask-border-source": {
		syntax: "none | <image>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "none",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedURLsAbsolute",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-source"
	},
		"mask-border-width": {
		syntax: "[ <length-percentage> | <number> | auto ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "relativeToMaskBorderImageArea",
		groups: [
			"CSS Masking"
		],
		initial: "auto",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-width"
	},
		"mask-clip": {
		syntax: "[ <geometry-box> | no-clip ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "border-box",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-clip"
	},
		"mask-composite": {
		syntax: "<compositing-operator>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "add",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-composite"
	},
		"mask-image": {
		syntax: "<mask-reference>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "none",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedURLsAbsolute",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-image"
	},
		"mask-mode": {
		syntax: "<masking-mode>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "match-source",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-mode"
	},
		"mask-origin": {
		syntax: "<geometry-box>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "border-box",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-origin"
	},
		"mask-position": {
		syntax: "<position>#",
		media: "visual",
		inherited: false,
		animationType: "repeatableListOfSimpleListOfLpc",
		percentages: "referToSizeOfMaskPaintingArea",
		groups: [
			"CSS Masking"
		],
		initial: "center",
		appliesto: "allElementsSVGContainerElements",
		computed: "consistsOfTwoKeywordsForOriginAndOffsets",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-position"
	},
		"mask-repeat": {
		syntax: "<repeat-style>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "no-repeat",
		appliesto: "allElementsSVGContainerElements",
		computed: "consistsOfTwoDimensionKeywords",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-repeat"
	},
		"mask-size": {
		syntax: "<bg-size>#",
		media: "visual",
		inherited: false,
		animationType: "repeatableListOfSimpleListOfLpc",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "auto",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-size"
	},
		"mask-type": {
		syntax: "luminance | alpha",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "luminance",
		appliesto: "maskElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-type"
	},
		"max-block-size": {
		syntax: "<'max-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "blockSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsMaxWidthAndMaxHeight",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/max-block-size"
	},
		"max-height": {
		syntax: "<length> | <percentage> | none | max-content | min-content | fit-content | fill-available",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "regardingHeightOfGeneratedBoxContainingBlockPercentagesNone",
		groups: [
			"CSS Box Model"
		],
		initial: "none",
		appliesto: "allElementsButNonReplacedAndTableColumns",
		computed: "percentageAsSpecifiedAbsoluteLengthOrNone",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/max-height"
	},
		"max-inline-size": {
		syntax: "<'max-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "inlineSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsMaxWidthAndMaxHeight",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/max-inline-size"
	},
		"max-lines": {
		syntax: "none | <integer>",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "none",
		appliesto: "blockContainersExceptMultiColumnContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"max-width": {
		syntax: "<length> | <percentage> | none | max-content | min-content | fit-content | fill-available",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "none",
		appliesto: "allElementsButNonReplacedAndTableRows",
		computed: "percentageAsSpecifiedAbsoluteLengthOrNone",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/max-width"
	},
		"min-block-size": {
		syntax: "<'min-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "blockSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsMinWidthAndMinHeight",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/min-block-size"
	},
		"min-height": {
		syntax: "<length> | <percentage> | auto | max-content | min-content | fit-content | fill-available",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "regardingHeightOfGeneratedBoxContainingBlockPercentages0",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "allElementsButNonReplacedAndTableColumns",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/min-height"
	},
		"min-inline-size": {
		syntax: "<'min-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "inlineSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsMinWidthAndMinHeight",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/min-inline-size"
	},
		"min-width": {
		syntax: "<length> | <percentage> | auto | max-content | min-content | fit-content | fill-available",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "allElementsButNonReplacedAndTableRows",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/min-width"
	},
		"mix-blend-mode": {
		syntax: "<blend-mode>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Compositing and Blending"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mix-blend-mode"
	},
		"object-fit": {
		syntax: "fill | contain | cover | none | scale-down",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Images"
		],
		initial: "fill",
		appliesto: "replacedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/object-fit"
	},
		"object-position": {
		syntax: "<position>",
		media: "visual",
		inherited: true,
		animationType: "repeatableListOfSimpleListOfLpc",
		percentages: "referToWidthAndHeightOfElement",
		groups: [
			"CSS Images"
		],
		initial: "50% 50%",
		appliesto: "replacedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/object-position"
	},
		offset: offset,
		"offset-anchor": {
		syntax: "auto | <position>",
		media: "visual",
		inherited: false,
		animationType: "position",
		percentages: "relativeToWidthAndHeight",
		groups: [
			"CSS Motion Path"
		],
		initial: "auto",
		appliesto: "transformableElements",
		computed: "forLengthAbsoluteValueOtherwisePercentage",
		order: "perGrammar",
		status: "experimental"
	},
		"offset-distance": {
		syntax: "<length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToTotalPathLength",
		groups: [
			"CSS Motion Path"
		],
		initial: "0",
		appliesto: "transformableElements",
		computed: "forLengthAbsoluteValueOtherwisePercentage",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/offset-distance"
	},
		"offset-path": {
		syntax: "none | ray( [ <angle> && <size>? && contain? ] ) | <path()> | <url> | [ <basic-shape> || <geometry-box> ]",
		media: "visual",
		inherited: false,
		animationType: "angleOrBasicShapeOrPath",
		percentages: "no",
		groups: [
			"CSS Motion Path"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "perGrammar",
		stacking: true,
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/offset-path"
	},
		"offset-position": {
		syntax: "auto | <position>",
		media: "visual",
		inherited: false,
		animationType: "position",
		percentages: "referToSizeOfContainingBlock",
		groups: [
			"CSS Motion Path"
		],
		initial: "auto",
		appliesto: "transformableElements",
		computed: "forLengthAbsoluteValueOtherwisePercentage",
		order: "perGrammar",
		status: "experimental"
	},
		"offset-rotate": {
		syntax: "[ auto | reverse ] || <angle>",
		media: "visual",
		inherited: false,
		animationType: "angleOrBasicShapeOrPath",
		percentages: "no",
		groups: [
			"CSS Motion Path"
		],
		initial: "auto",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/offset-rotate"
	},
		opacity: opacity,
		order: order,
		orphans: orphans,
		outline: outline,
		"outline-color": {
		syntax: "<color> | invert",
		media: [
			"visual",
			"interactive"
		],
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "invertOrCurrentColor",
		appliesto: "allElements",
		computed: "invertForTranslucentColorRGBAOtherwiseRGB",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline-color"
	},
		"outline-offset": {
		syntax: "<length>",
		media: [
			"visual",
			"interactive"
		],
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline-offset"
	},
		"outline-style": {
		syntax: "auto | <'border-style'>",
		media: [
			"visual",
			"interactive"
		],
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline-style"
	},
		"outline-width": {
		syntax: "<line-width>",
		media: [
			"visual",
			"interactive"
		],
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLength0ForNone",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline-width"
	},
		overflow: overflow,
		"overflow-anchor": {
		syntax: "auto | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Anchoring"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"overflow-block": {
		syntax: "visible | hidden | clip | scroll | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "auto",
		appliesto: "blockContainersFlexContainersGridContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"overflow-clip-box": {
		syntax: "padding-box | content-box",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "padding-box",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Mozilla/CSS/overflow-clip-box"
	},
		"overflow-inline": {
		syntax: "visible | hidden | clip | scroll | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "auto",
		appliesto: "blockContainersFlexContainersGridContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"overflow-wrap": {
		syntax: "normal | break-word | anywhere",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "nonReplacedInlineElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow-wrap"
	},
		"overflow-x": {
		syntax: "visible | hidden | clip | scroll | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "visible",
		appliesto: "blockContainersFlexContainersGridContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow-x"
	},
		"overflow-y": {
		syntax: "visible | hidden | clip | scroll | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "visible",
		appliesto: "blockContainersFlexContainersGridContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow-y"
	},
		"overscroll-behavior": {
		syntax: "[ contain | none | auto ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overscroll-behavior"
	},
		"overscroll-behavior-x": {
		syntax: "contain | none | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overscroll-behavior-x"
	},
		"overscroll-behavior-y": {
		syntax: "contain | none | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overscroll-behavior-y"
	},
		padding: padding,
		"padding-block": {
		syntax: "<'padding-left'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-block"
	},
		"padding-block-end": {
		syntax: "<'padding-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-block-end"
	},
		"padding-block-start": {
		syntax: "<'padding-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-block-start"
	},
		"padding-bottom": {
		syntax: "<length> | <percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptInternalTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-bottom"
	},
		"padding-inline": {
		syntax: "<'padding-left'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-inline"
	},
		"padding-inline-end": {
		syntax: "<'padding-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-inline-end"
	},
		"padding-inline-start": {
		syntax: "<'padding-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-inline-start"
	},
		"padding-left": {
		syntax: "<length> | <percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptInternalTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-left"
	},
		"padding-right": {
		syntax: "<length> | <percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptInternalTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-right"
	},
		"padding-top": {
		syntax: "<length> | <percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptInternalTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-top"
	},
		"page-break-after": {
		syntax: "auto | always | avoid | left | right | recto | verso",
		media: [
			"visual",
			"paged"
		],
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Pages"
		],
		initial: "auto",
		appliesto: "blockElementsInNormalFlow",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/page-break-after"
	},
		"page-break-before": {
		syntax: "auto | always | avoid | left | right | recto | verso",
		media: [
			"visual",
			"paged"
		],
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Pages"
		],
		initial: "auto",
		appliesto: "blockElementsInNormalFlow",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/page-break-before"
	},
		"page-break-inside": {
		syntax: "auto | avoid",
		media: [
			"visual",
			"paged"
		],
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Pages"
		],
		initial: "auto",
		appliesto: "blockElementsInNormalFlow",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/page-break-inside"
	},
		"paint-order": {
		syntax: "normal | [ fill || stroke || markers ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "textElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/paint-order"
	},
		perspective: perspective,
		"perspective-origin": {
		syntax: "<position>",
		media: "visual",
		inherited: false,
		animationType: "simpleListOfLpc",
		percentages: "referToSizeOfBoundingBox",
		groups: [
			"CSS Transforms"
		],
		initial: "50% 50%",
		appliesto: "transformableElements",
		computed: "forLengthAbsoluteValueOtherwisePercentage",
		order: "oneOrTwoValuesLengthAbsoluteKeywordsPercentages",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/perspective-origin"
	},
		"place-content": {
		syntax: "<'align-content'> <'justify-content'>?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "multilineFlexContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/place-content"
	},
		"place-items": {
		syntax: "<'align-items'> <'justify-items'>?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: [
			"align-items",
			"justify-items"
		],
		appliesto: "allElements",
		computed: [
			"align-items",
			"justify-items"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/place-items"
	},
		"place-self": {
		syntax: "<'align-self'> <'justify-self'>?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: [
			"align-self",
			"justify-self"
		],
		appliesto: "blockLevelBoxesAndAbsolutelyPositionedBoxesAndGridItems",
		computed: [
			"align-self",
			"justify-self"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/place-self"
	},
		"pointer-events": {
		syntax: "auto | none | visiblePainted | visibleFill | visibleStroke | visible | painted | fill | stroke | all | inherit",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Pointer Events"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/pointer-events"
	},
		position: position,
		quotes: quotes,
		resize: resize,
		right: right,
		rotate: rotate,
		"row-gap": {
		syntax: "normal | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "multiColumnElementsFlexContainersGridContainers",
		computed: "asSpecifiedWithLengthsAbsoluteAndNormalComputingToZeroExceptMultiColumn",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/row-gap"
	},
		"ruby-align": {
		syntax: "start | center | space-between | space-around",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Ruby"
		],
		initial: "space-around",
		appliesto: "rubyBasesAnnotationsBaseAnnotationContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/ruby-align"
	},
		"ruby-merge": {
		syntax: "separate | collapse | auto",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Ruby"
		],
		initial: "separate",
		appliesto: "rubyAnnotationsContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental"
	},
		"ruby-position": {
		syntax: "over | under | inter-character",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Ruby"
		],
		initial: "over",
		appliesto: "rubyAnnotationsContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/ruby-position"
	},
		scale: scale,
		"scrollbar-color": {
		syntax: "auto | dark | light | <color>{2}",
		media: "visual",
		inherited: true,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Scrollbars"
		],
		initial: "auto",
		appliesto: "scrollingBoxes",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scrollbar-color"
	},
		"scrollbar-width": {
		syntax: "auto | thin | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scrollbars"
		],
		initial: "auto",
		appliesto: "scrollingBoxes",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scrollbar-width"
	},
		"scroll-behavior": {
		syntax: "auto | smooth",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSSOM View"
		],
		initial: "auto",
		appliesto: "scrollingBoxes",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-behavior"
	},
		"scroll-margin": {
		syntax: "<length>{1,4}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin"
	},
		"scroll-margin-block": {
		syntax: "<length>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-block"
	},
		"scroll-margin-block-start": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-block-start"
	},
		"scroll-margin-block-end": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-block-end"
	},
		"scroll-margin-bottom": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-bottom"
	},
		"scroll-margin-inline": {
		syntax: "<length>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-inline"
	},
		"scroll-margin-inline-start": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-inline-start"
	},
		"scroll-margin-inline-end": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-inline-end"
	},
		"scroll-margin-left": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-left"
	},
		"scroll-margin-right": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-right"
	},
		"scroll-margin-top": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-top"
	},
		"scroll-padding": {
		syntax: "[ auto | <length-percentage> ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding"
	},
		"scroll-padding-block": {
		syntax: "[ auto | <length-percentage> ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-block"
	},
		"scroll-padding-block-start": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-block-start"
	},
		"scroll-padding-block-end": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-block-end"
	},
		"scroll-padding-bottom": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-bottom"
	},
		"scroll-padding-inline": {
		syntax: "[ auto | <length-percentage> ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-inline"
	},
		"scroll-padding-inline-start": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-inline-start"
	},
		"scroll-padding-inline-end": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-inline-end"
	},
		"scroll-padding-left": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-left"
	},
		"scroll-padding-right": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-right"
	},
		"scroll-padding-top": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-top"
	},
		"scroll-snap-align": {
		syntax: "[ none | start | end | center ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-align"
	},
		"scroll-snap-coordinate": {
		syntax: "none | <position>#",
		media: "interactive",
		inherited: false,
		animationType: "position",
		percentages: "referToBorderBox",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-coordinate"
	},
		"scroll-snap-destination": {
		syntax: "<position>",
		media: "interactive",
		inherited: false,
		animationType: "position",
		percentages: "relativeToScrollContainerPaddingBoxAxis",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0px 0px",
		appliesto: "scrollContainers",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-destination"
	},
		"scroll-snap-points-x": {
		syntax: "none | repeat( <length-percentage> )",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "relativeToScrollContainerPaddingBoxAxis",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "scrollContainers",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-points-x"
	},
		"scroll-snap-points-y": {
		syntax: "none | repeat( <length-percentage> )",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "relativeToScrollContainerPaddingBoxAxis",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "scrollContainers",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-points-y"
	},
		"scroll-snap-stop": {
		syntax: "normal | always",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-stop"
	},
		"scroll-snap-type": {
		syntax: "none | [ x | y | block | inline | both ] [ mandatory | proximity ]?",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-type"
	},
		"scroll-snap-type-x": {
		syntax: "none | mandatory | proximity",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-type-x"
	},
		"scroll-snap-type-y": {
		syntax: "none | mandatory | proximity",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-type-y"
	},
		"shape-image-threshold": {
		syntax: "<alpha-value>",
		media: "visual",
		inherited: false,
		animationType: "number",
		percentages: "no",
		groups: [
			"CSS Shapes"
		],
		initial: "0.0",
		appliesto: "floats",
		computed: "specifiedValueNumberClipped0To1",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/shape-image-threshold"
	},
		"shape-margin": {
		syntax: "<length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Shapes"
		],
		initial: "0",
		appliesto: "floats",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/shape-margin"
	},
		"shape-outside": {
		syntax: "none | <shape-box> || <basic-shape> | <image>",
		media: "visual",
		inherited: false,
		animationType: "basicShapeOtherwiseNo",
		percentages: "no",
		groups: [
			"CSS Shapes"
		],
		initial: "none",
		appliesto: "floats",
		computed: "asDefinedForBasicShapeWithAbsoluteURIOtherwiseAsSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/shape-outside"
	},
		"tab-size": {
		syntax: "<integer> | <length>",
		media: "visual",
		inherited: true,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "8",
		appliesto: "blockContainers",
		computed: "specifiedIntegerOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/tab-size"
	},
		"table-layout": {
		syntax: "auto | fixed",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Table"
		],
		initial: "auto",
		appliesto: "tableElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/table-layout"
	},
		"text-align": {
		syntax: "start | end | left | right | center | justify | match-parent",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "startOrNamelessValueIfLTRRightIfRTL",
		appliesto: "blockContainers",
		computed: "asSpecifiedExceptMatchParent",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-align"
	},
		"text-align-last": {
		syntax: "auto | start | end | left | right | center | justify",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "auto",
		appliesto: "blockContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-align-last"
	},
		"text-combine-upright": {
		syntax: "none | all | [ digits <integer>? ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Writing Modes"
		],
		initial: "none",
		appliesto: "nonReplacedInlineElements",
		computed: "keywordPlusIntegerIfDigits",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-combine-upright"
	},
		"text-decoration": {
		syntax: "<'text-decoration-line'> || <'text-decoration-style'> || <'text-decoration-color'> || <'text-decoration-thickness'>",
		media: "visual",
		inherited: false,
		animationType: [
			"text-decoration-color",
			"text-decoration-style",
			"text-decoration-line",
			"text-decoration-thickness"
		],
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: [
			"text-decoration-color",
			"text-decoration-style",
			"text-decoration-line"
		],
		appliesto: "allElements",
		computed: [
			"text-decoration-line",
			"text-decoration-style",
			"text-decoration-color",
			"text-decoration-thickness"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration"
	},
		"text-decoration-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-color"
	},
		"text-decoration-line": {
		syntax: "none | [ underline || overline || line-through || blink ] | spelling-error | grammar-error",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-line"
	},
		"text-decoration-skip": {
		syntax: "none | [ objects || [ spaces | [ leading-spaces || trailing-spaces ] ] || edges || box-decoration ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "objects",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-skip"
	},
		"text-decoration-skip-ink": {
		syntax: "auto | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-skip-ink"
	},
		"text-decoration-style": {
		syntax: "solid | double | dotted | dashed | wavy",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "solid",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-style"
	},
		"text-decoration-thickness": {
		syntax: "auto | from-font | <length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-thickness"
	},
		"text-emphasis": {
		syntax: "<'text-emphasis-style'> || <'text-emphasis-color'>",
		media: "visual",
		inherited: false,
		animationType: [
			"text-emphasis-color",
			"text-emphasis-style"
		],
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: [
			"text-emphasis-style",
			"text-emphasis-color"
		],
		appliesto: "allElements",
		computed: [
			"text-emphasis-style",
			"text-emphasis-color"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-emphasis"
	},
		"text-emphasis-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-emphasis-color"
	},
		"text-emphasis-position": {
		syntax: "[ over | under ] && [ right | left ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "over right",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-emphasis-position"
	},
		"text-emphasis-style": {
		syntax: "none | [ [ filled | open ] || [ dot | circle | double-circle | triangle | sesame ] ] | <string>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-emphasis-style"
	},
		"text-indent": {
		syntax: "<length-percentage> && hanging? && each-line?",
		media: "visual",
		inherited: true,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Text"
		],
		initial: "0",
		appliesto: "blockContainers",
		computed: "percentageOrAbsoluteLengthPlusKeywords",
		order: "lengthOrPercentageBeforeKeywords",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-indent"
	},
		"text-justify": {
		syntax: "auto | inter-character | inter-word | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "auto",
		appliesto: "inlineLevelAndTableCellElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-justify"
	},
		"text-orientation": {
		syntax: "mixed | upright | sideways",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Writing Modes"
		],
		initial: "mixed",
		appliesto: "allElementsExceptTableRowGroupsRowsColumnGroupsAndColumns",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-orientation"
	},
		"text-overflow": {
		syntax: "[ clip | ellipsis | <string> ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "clip",
		appliesto: "blockContainerElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-overflow"
	},
		"text-rendering": {
		syntax: "auto | optimizeSpeed | optimizeLegibility | geometricPrecision",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Miscellaneous"
		],
		initial: "auto",
		appliesto: "textElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-rendering"
	},
		"text-shadow": {
		syntax: "none | <shadow-t>#",
		media: "visual",
		inherited: true,
		animationType: "shadowList",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "colorPlusThreeAbsoluteLengths",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-shadow"
	},
		"text-size-adjust": {
		syntax: "none | auto | <percentage>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "referToSizeOfFont",
		groups: [
			"CSS Text"
		],
		initial: "autoForSmartphoneBrowsersSupportingInflation",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-size-adjust"
	},
		"text-transform": {
		syntax: "none | capitalize | uppercase | lowercase | full-width | full-size-kana",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-transform"
	},
		"text-underline-offset": {
		syntax: "auto | from-font | <length>",
		media: "visual",
		inherited: true,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-underline-offset"
	},
		"text-underline-position": {
		syntax: "auto | [ under || [ left | right ] ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-underline-position"
	},
		top: top,
		"touch-action": {
		syntax: "auto | none | [ [ pan-x | pan-left | pan-right ] || [ pan-y | pan-up | pan-down ] || pinch-zoom ] | manipulation",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Pointer Events"
		],
		initial: "auto",
		appliesto: "allElementsExceptNonReplacedInlineElementsTableRowsColumnsRowColumnGroups",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/touch-action"
	},
		transform: transform,
		"transform-box": {
		syntax: "border-box | fill-box | view-box",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "border-box ",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transform-box"
	},
		"transform-origin": {
		syntax: "[ <length-percentage> | left | center | right | top | bottom ] | [ [ <length-percentage> | left | center | right ] && [ <length-percentage> | top | center | bottom ] ] <length>?",
		media: "visual",
		inherited: false,
		animationType: "simpleListOfLpc",
		percentages: "referToSizeOfBoundingBox",
		groups: [
			"CSS Transforms"
		],
		initial: "50% 50% 0",
		appliesto: "transformableElements",
		computed: "forLengthAbsoluteValueOtherwisePercentage",
		order: "oneOrTwoValuesLengthAbsoluteKeywordsPercentages",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transform-origin"
	},
		"transform-style": {
		syntax: "flat | preserve-3d",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "flat",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transform-style"
	},
		transition: transition,
		"transition-delay": {
		syntax: "<time>#",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transitions"
		],
		initial: "0s",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition-delay"
	},
		"transition-duration": {
		syntax: "<time>#",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transitions"
		],
		initial: "0s",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition-duration"
	},
		"transition-property": {
		syntax: "none | <single-transition-property>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transitions"
		],
		initial: "all",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition-property"
	},
		"transition-timing-function": {
		syntax: "<timing-function>#",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transitions"
		],
		initial: "ease",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition-timing-function"
	},
		translate: translate,
		"unicode-bidi": {
		syntax: "normal | embed | isolate | bidi-override | isolate-override | plaintext",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Writing Modes"
		],
		initial: "normal",
		appliesto: "allElementsSomeValuesNoEffectOnNonInlineElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/unicode-bidi"
	},
		"user-select": {
		syntax: "auto | text | none | contain | all",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/user-select"
	},
		"vertical-align": {
		syntax: "baseline | sub | super | text-top | text-bottom | middle | top | bottom | <percentage> | <length>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToLineHeight",
		groups: [
			"CSS Table"
		],
		initial: "baseline",
		appliesto: "inlineLevelAndTableCellElements",
		computed: "absoluteLengthOrKeyword",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/vertical-align"
	},
		visibility: visibility,
		"white-space": {
		syntax: "normal | pre | nowrap | pre-wrap | pre-line | break-spaces",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/white-space"
	},
		widows: widows,
		width: width,
		"will-change": {
		syntax: "auto | <animateable-feature>#",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Will Change"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/will-change"
	},
		"word-break": {
		syntax: "normal | break-all | keep-all | break-word",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/word-break"
	},
		"word-spacing": {
		syntax: "normal | <length-percentage>",
		media: "visual",
		inherited: true,
		animationType: "length",
		percentages: "referToWidthOfAffectedGlyph",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "optimumMinAndMaxValueOfAbsoluteLengthPercentageOrNormal",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/word-spacing"
	},
		"word-wrap": {
		syntax: "normal | break-word",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "nonReplacedInlineElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow-wrap"
	},
		"writing-mode": {
		syntax: "horizontal-tb | vertical-rl | vertical-lr | sideways-rl | sideways-lr",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Writing Modes"
		],
		initial: "horizontal-tb",
		appliesto: "allElementsExceptTableRowColumnGroupsTableRowsColumns",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/writing-mode"
	},
		"z-index": {
		syntax: "auto | <integer>",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"CSS Positioning"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/z-index"
	},
		zoom: zoom
	};

	var properties$2 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		all: all,
		animation: animation,
		appearance: appearance,
		azimuth: azimuth,
		background: background,
		border: border,
		bottom: bottom,
		clear: clear,
		clip: clip,
		color: color,
		columns: columns,
		contain: contain,
		content: content,
		cursor: cursor,
		direction: direction,
		display: display,
		filter: filter,
		flex: flex,
		float: float,
		font: font,
		gap: gap,
		grid: grid,
		height: height,
		hyphens: hyphens,
		inset: inset,
		isolation: isolation,
		left: left,
		margin: margin,
		mask: mask,
		offset: offset,
		opacity: opacity,
		order: order,
		orphans: orphans,
		outline: outline,
		overflow: overflow,
		padding: padding,
		perspective: perspective,
		position: position,
		quotes: quotes,
		resize: resize,
		right: right,
		rotate: rotate,
		scale: scale,
		top: top,
		transform: transform,
		transition: transition,
		translate: translate,
		visibility: visibility,
		widows: widows,
		width: width,
		zoom: zoom,
		'default': properties$1
	});

	var attachment = {
		syntax: "scroll | fixed | local"
	};
	var box = {
		syntax: "border-box | padding-box | content-box"
	};
	var color$1 = {
		syntax: "<rgb()> | <rgba()> | <hsl()> | <hsla()> | <hex-color> | <named-color> | currentcolor | <deprecated-system-color>"
	};
	var combinator = {
		syntax: "'>' | '+' | '~' | [ '||' ]"
	};
	var compat = {
		syntax: "searchfield | textarea | push-button | button-bevel | slider-horizontal | checkbox | radio | square-button | menulist | menulist-button | listbox | meter | progress-bar"
	};
	var gradient = {
		syntax: "<linear-gradient()> | <repeating-linear-gradient()> | <radial-gradient()> | <repeating-radial-gradient()> | <conic-gradient()>"
	};
	var hue = {
		syntax: "<number> | <angle>"
	};
	var image = {
		syntax: "<url> | <image()> | <image-set()> | <element()> | <paint()> | <cross-fade()> | <gradient>"
	};
	var nth = {
		syntax: "<an-plus-b> | even | odd"
	};
	var position$1 = {
		syntax: "[ [ left | center | right ] || [ top | center | bottom ] | [ left | center | right | <length-percentage> ] [ top | center | bottom | <length-percentage> ]? | [ [ left | right ] <length-percentage> ] && [ [ top | bottom ] <length-percentage> ] ]"
	};
	var quote = {
		syntax: "open-quote | close-quote | no-open-quote | no-close-quote"
	};
	var shadow = {
		syntax: "inset? && <length>{2,4} && <color>?"
	};
	var shape$1 = {
		syntax: "rect(<top>, <right>, <bottom>, <left>)"
	};
	var size = {
		syntax: "closest-side | farthest-side | closest-corner | farthest-corner | <length> | <length-percentage>{2}"
	};
	var symbol = {
		syntax: "<string> | <image> | <custom-ident>"
	};
	var target = {
		syntax: "<target-counter()> | <target-counters()> | <target-text()>"
	};
	var syntaxes = {
		"absolute-size": {
		syntax: "xx-small | x-small | small | medium | large | x-large | xx-large | xxx-large"
	},
		"alpha-value": {
		syntax: "<number> | <percentage>"
	},
		"angle-percentage": {
		syntax: "<angle> | <percentage>"
	},
		"angular-color-hint": {
		syntax: "<angle-percentage>"
	},
		"angular-color-stop": {
		syntax: "<color> && <color-stop-angle>?"
	},
		"angular-color-stop-list": {
		syntax: "[ <angular-color-stop> [, <angular-color-hint>]? ]# , <angular-color-stop>"
	},
		"animateable-feature": {
		syntax: "scroll-position | contents | <custom-ident>"
	},
		attachment: attachment,
		"attr()": {
		syntax: "attr( <attr-name> <type-or-unit>? [, <attr-fallback> ]? )"
	},
		"attr-matcher": {
		syntax: "[ '~' | '|' | '^' | '$' | '*' ]? '='"
	},
		"attr-modifier": {
		syntax: "i | s"
	},
		"attribute-selector": {
		syntax: "'[' <wq-name> ']' | '[' <wq-name> <attr-matcher> [ <string-token> | <ident-token> ] <attr-modifier>? ']'"
	},
		"auto-repeat": {
		syntax: "repeat( [ auto-fill | auto-fit ] , [ <line-names>? <fixed-size> ]+ <line-names>? )"
	},
		"auto-track-list": {
		syntax: "[ <line-names>? [ <fixed-size> | <fixed-repeat> ] ]* <line-names>? <auto-repeat>\n[ <line-names>? [ <fixed-size> | <fixed-repeat> ] ]* <line-names>?"
	},
		"baseline-position": {
		syntax: "[ first | last ]? baseline"
	},
		"basic-shape": {
		syntax: "<inset()> | <circle()> | <ellipse()> | <polygon()>"
	},
		"bg-image": {
		syntax: "none | <image>"
	},
		"bg-layer": {
		syntax: "<bg-image> || <bg-position> [ / <bg-size> ]? || <repeat-style> || <attachment> || <box> || <box>"
	},
		"bg-position": {
		syntax: "[ [ left | center | right | top | bottom | <length-percentage> ] | [ left | center | right | <length-percentage> ] [ top | center | bottom | <length-percentage> ] | [ center | [ left | right ] <length-percentage>? ] && [ center | [ top | bottom ] <length-percentage>? ] ]"
	},
		"bg-size": {
		syntax: "[ <length-percentage> | auto ]{1,2} | cover | contain"
	},
		"blur()": {
		syntax: "blur( <length> )"
	},
		"blend-mode": {
		syntax: "normal | multiply | screen | overlay | darken | lighten | color-dodge | color-burn | hard-light | soft-light | difference | exclusion | hue | saturation | color | luminosity"
	},
		box: box,
		"brightness()": {
		syntax: "brightness( <number-percentage> )"
	},
		"calc()": {
		syntax: "calc( <calc-sum> )"
	},
		"calc-sum": {
		syntax: "<calc-product> [ [ '+' | '-' ] <calc-product> ]*"
	},
		"calc-product": {
		syntax: "<calc-value> [ '*' <calc-value> | '/' <number> ]*"
	},
		"calc-value": {
		syntax: "<number> | <dimension> | <percentage> | ( <calc-sum> )"
	},
		"cf-final-image": {
		syntax: "<image> | <color>"
	},
		"cf-mixing-image": {
		syntax: "<percentage>? && <image>"
	},
		"circle()": {
		syntax: "circle( [ <shape-radius> ]? [ at <position> ]? )"
	},
		"clamp()": {
		syntax: "clamp( <calc-sum>#{3} )"
	},
		"class-selector": {
		syntax: "'.' <ident-token>"
	},
		"clip-source": {
		syntax: "<url>"
	},
		color: color$1,
		"color-stop": {
		syntax: "<color-stop-length> | <color-stop-angle>"
	},
		"color-stop-angle": {
		syntax: "<angle-percentage>{1,2}"
	},
		"color-stop-length": {
		syntax: "<length-percentage>{1,2}"
	},
		"color-stop-list": {
		syntax: "[ <linear-color-stop> [, <linear-color-hint>]? ]# , <linear-color-stop>"
	},
		combinator: combinator,
		"common-lig-values": {
		syntax: "[ common-ligatures | no-common-ligatures ]"
	},
		compat: compat,
		"composite-style": {
		syntax: "clear | copy | source-over | source-in | source-out | source-atop | destination-over | destination-in | destination-out | destination-atop | xor"
	},
		"compositing-operator": {
		syntax: "add | subtract | intersect | exclude"
	},
		"compound-selector": {
		syntax: "[ <type-selector>? <subclass-selector>* [ <pseudo-element-selector> <pseudo-class-selector>* ]* ]!"
	},
		"compound-selector-list": {
		syntax: "<compound-selector>#"
	},
		"complex-selector": {
		syntax: "<compound-selector> [ <combinator>? <compound-selector> ]*"
	},
		"complex-selector-list": {
		syntax: "<complex-selector>#"
	},
		"conic-gradient()": {
		syntax: "conic-gradient( [ from <angle> ]? [ at <position> ]?, <angular-color-stop-list> )"
	},
		"contextual-alt-values": {
		syntax: "[ contextual | no-contextual ]"
	},
		"content-distribution": {
		syntax: "space-between | space-around | space-evenly | stretch"
	},
		"content-list": {
		syntax: "[ <string> | contents | <image> | <quote> | <target> | <leader()> ]+"
	},
		"content-position": {
		syntax: "center | start | end | flex-start | flex-end"
	},
		"content-replacement": {
		syntax: "<image>"
	},
		"contrast()": {
		syntax: "contrast( [ <number-percentage> ] )"
	},
		"counter()": {
		syntax: "counter( <custom-ident>, <counter-style>? )"
	},
		"counter-style": {
		syntax: "<counter-style-name> | symbols()"
	},
		"counter-style-name": {
		syntax: "<custom-ident>"
	},
		"counters()": {
		syntax: "counters( <custom-ident>, <string>, <counter-style>? )"
	},
		"cross-fade()": {
		syntax: "cross-fade( <cf-mixing-image> , <cf-final-image>? )"
	},
		"cubic-bezier-timing-function": {
		syntax: "ease | ease-in | ease-out | ease-in-out | cubic-bezier(<number>, <number>, <number>, <number>)"
	},
		"deprecated-system-color": {
		syntax: "ActiveBorder | ActiveCaption | AppWorkspace | Background | ButtonFace | ButtonHighlight | ButtonShadow | ButtonText | CaptionText | GrayText | Highlight | HighlightText | InactiveBorder | InactiveCaption | InactiveCaptionText | InfoBackground | InfoText | Menu | MenuText | Scrollbar | ThreeDDarkShadow | ThreeDFace | ThreeDHighlight | ThreeDLightShadow | ThreeDShadow | Window | WindowFrame | WindowText"
	},
		"discretionary-lig-values": {
		syntax: "[ discretionary-ligatures | no-discretionary-ligatures ]"
	},
		"display-box": {
		syntax: "contents | none"
	},
		"display-inside": {
		syntax: "flow | flow-root | table | flex | grid | ruby"
	},
		"display-internal": {
		syntax: "table-row-group | table-header-group | table-footer-group | table-row | table-cell | table-column-group | table-column | table-caption | ruby-base | ruby-text | ruby-base-container | ruby-text-container"
	},
		"display-legacy": {
		syntax: "inline-block | inline-list-item | inline-table | inline-flex | inline-grid"
	},
		"display-listitem": {
		syntax: "<display-outside>? && [ flow | flow-root ]? && list-item"
	},
		"display-outside": {
		syntax: "block | inline | run-in"
	},
		"drop-shadow()": {
		syntax: "drop-shadow( <length>{2,3} <color>? )"
	},
		"east-asian-variant-values": {
		syntax: "[ jis78 | jis83 | jis90 | jis04 | simplified | traditional ]"
	},
		"east-asian-width-values": {
		syntax: "[ full-width | proportional-width ]"
	},
		"element()": {
		syntax: "element( <id-selector> )"
	},
		"ellipse()": {
		syntax: "ellipse( [ <shape-radius>{2} ]? [ at <position> ]? )"
	},
		"ending-shape": {
		syntax: "circle | ellipse"
	},
		"env()": {
		syntax: "env( <custom-ident> , <declaration-value>? )"
	},
		"explicit-track-list": {
		syntax: "[ <line-names>? <track-size> ]+ <line-names>?"
	},
		"family-name": {
		syntax: "<string> | <custom-ident>+"
	},
		"feature-tag-value": {
		syntax: "<string> [ <integer> | on | off ]?"
	},
		"feature-type": {
		syntax: "@stylistic | @historical-forms | @styleset | @character-variant | @swash | @ornaments | @annotation"
	},
		"feature-value-block": {
		syntax: "<feature-type> '{' <feature-value-declaration-list> '}'"
	},
		"feature-value-block-list": {
		syntax: "<feature-value-block>+"
	},
		"feature-value-declaration": {
		syntax: "<custom-ident>: <integer>+;"
	},
		"feature-value-declaration-list": {
		syntax: "<feature-value-declaration>"
	},
		"feature-value-name": {
		syntax: "<custom-ident>"
	},
		"fill-rule": {
		syntax: "nonzero | evenodd"
	},
		"filter-function": {
		syntax: "<blur()> | <brightness()> | <contrast()> | <drop-shadow()> | <grayscale()> | <hue-rotate()> | <invert()> | <opacity()> | <saturate()> | <sepia()>"
	},
		"filter-function-list": {
		syntax: "[ <filter-function> | <url> ]+"
	},
		"final-bg-layer": {
		syntax: "<'background-color'> || <bg-image> || <bg-position> [ / <bg-size> ]? || <repeat-style> || <attachment> || <box> || <box>"
	},
		"fit-content()": {
		syntax: "fit-content( [ <length> | <percentage> ] )"
	},
		"fixed-breadth": {
		syntax: "<length-percentage>"
	},
		"fixed-repeat": {
		syntax: "repeat( [ <positive-integer> ] , [ <line-names>? <fixed-size> ]+ <line-names>? )"
	},
		"fixed-size": {
		syntax: "<fixed-breadth> | minmax( <fixed-breadth> , <track-breadth> ) | minmax( <inflexible-breadth> , <fixed-breadth> )"
	},
		"font-stretch-absolute": {
		syntax: "normal | ultra-condensed | extra-condensed | condensed | semi-condensed | semi-expanded | expanded | extra-expanded | ultra-expanded | <percentage>"
	},
		"font-variant-css21": {
		syntax: "[ normal | small-caps ]"
	},
		"font-weight-absolute": {
		syntax: "normal | bold | <number>"
	},
		"frequency-percentage": {
		syntax: "<frequency> | <percentage>"
	},
		"general-enclosed": {
		syntax: "[ <function-token> <any-value> ) ] | ( <ident> <any-value> )"
	},
		"generic-family": {
		syntax: "serif | sans-serif | cursive | fantasy | monospace"
	},
		"generic-name": {
		syntax: "serif | sans-serif | cursive | fantasy | monospace"
	},
		"geometry-box": {
		syntax: "<shape-box> | fill-box | stroke-box | view-box"
	},
		gradient: gradient,
		"grayscale()": {
		syntax: "grayscale( <number-percentage> )"
	},
		"grid-line": {
		syntax: "auto | <custom-ident> | [ <integer> && <custom-ident>? ] | [ span && [ <integer> || <custom-ident> ] ]"
	},
		"historical-lig-values": {
		syntax: "[ historical-ligatures | no-historical-ligatures ]"
	},
		"hsl()": {
		syntax: "hsl( <hue> <percentage> <percentage> [ / <alpha-value> ]? ) | hsl( <hue>, <percentage>, <percentage>, <alpha-value>? )"
	},
		"hsla()": {
		syntax: "hsla( <hue> <percentage> <percentage> [ / <alpha-value> ]? ) | hsla( <hue>, <percentage>, <percentage>, <alpha-value>? )"
	},
		hue: hue,
		"hue-rotate()": {
		syntax: "hue-rotate( <angle> )"
	},
		"id-selector": {
		syntax: "<hash-token>"
	},
		image: image,
		"image()": {
		syntax: "image( <image-tags>? [ <image-src>? , <color>? ]! )"
	},
		"image-set()": {
		syntax: "image-set( <image-set-option># )"
	},
		"image-set-option": {
		syntax: "[ <image> | <string> ] <resolution>"
	},
		"image-src": {
		syntax: "<url> | <string>"
	},
		"image-tags": {
		syntax: "ltr | rtl"
	},
		"inflexible-breadth": {
		syntax: "<length> | <percentage> | min-content | max-content | auto"
	},
		"inset()": {
		syntax: "inset( <length-percentage>{1,4} [ round <'border-radius'> ]? )"
	},
		"invert()": {
		syntax: "invert( <number-percentage> )"
	},
		"keyframes-name": {
		syntax: "<custom-ident> | <string>"
	},
		"keyframe-block": {
		syntax: "<keyframe-selector># {\n  <declaration-list>\n}"
	},
		"keyframe-block-list": {
		syntax: "<keyframe-block>+"
	},
		"keyframe-selector": {
		syntax: "from | to | <percentage>"
	},
		"leader()": {
		syntax: "leader( <leader-type> )"
	},
		"leader-type": {
		syntax: "dotted | solid | space | <string>"
	},
		"length-percentage": {
		syntax: "<length> | <percentage>"
	},
		"line-names": {
		syntax: "'[' <custom-ident>* ']'"
	},
		"line-name-list": {
		syntax: "[ <line-names> | <name-repeat> ]+"
	},
		"line-style": {
		syntax: "none | hidden | dotted | dashed | solid | double | groove | ridge | inset | outset"
	},
		"line-width": {
		syntax: "<length> | thin | medium | thick"
	},
		"linear-color-hint": {
		syntax: "<length-percentage>"
	},
		"linear-color-stop": {
		syntax: "<color> <color-stop-length>?"
	},
		"linear-gradient()": {
		syntax: "linear-gradient( [ <angle> | to <side-or-corner> ]? , <color-stop-list> )"
	},
		"mask-layer": {
		syntax: "<mask-reference> || <position> [ / <bg-size> ]? || <repeat-style> || <geometry-box> || [ <geometry-box> | no-clip ] || <compositing-operator> || <masking-mode>"
	},
		"mask-position": {
		syntax: "[ <length-percentage> | left | center | right ] [ <length-percentage> | top | center | bottom ]?"
	},
		"mask-reference": {
		syntax: "none | <image> | <mask-source>"
	},
		"mask-source": {
		syntax: "<url>"
	},
		"masking-mode": {
		syntax: "alpha | luminance | match-source"
	},
		"matrix()": {
		syntax: "matrix( <number>#{6} )"
	},
		"matrix3d()": {
		syntax: "matrix3d( <number>#{16} )"
	},
		"max()": {
		syntax: "max( <calc-sum># )"
	},
		"media-and": {
		syntax: "<media-in-parens> [ and <media-in-parens> ]+"
	},
		"media-condition": {
		syntax: "<media-not> | <media-and> | <media-or> | <media-in-parens>"
	},
		"media-condition-without-or": {
		syntax: "<media-not> | <media-and> | <media-in-parens>"
	},
		"media-feature": {
		syntax: "( [ <mf-plain> | <mf-boolean> | <mf-range> ] )"
	},
		"media-in-parens": {
		syntax: "( <media-condition> ) | <media-feature> | <general-enclosed>"
	},
		"media-not": {
		syntax: "not <media-in-parens>"
	},
		"media-or": {
		syntax: "<media-in-parens> [ or <media-in-parens> ]+"
	},
		"media-query": {
		syntax: "<media-condition> | [ not | only ]? <media-type> [ and <media-condition-without-or> ]?"
	},
		"media-query-list": {
		syntax: "<media-query>#"
	},
		"media-type": {
		syntax: "<ident>"
	},
		"mf-boolean": {
		syntax: "<mf-name>"
	},
		"mf-name": {
		syntax: "<ident>"
	},
		"mf-plain": {
		syntax: "<mf-name> : <mf-value>"
	},
		"mf-range": {
		syntax: "<mf-name> [ '<' | '>' ]? '='? <mf-value>\n| <mf-value> [ '<' | '>' ]? '='? <mf-name>\n| <mf-value> '<' '='? <mf-name> '<' '='? <mf-value>\n| <mf-value> '>' '='? <mf-name> '>' '='? <mf-value>"
	},
		"mf-value": {
		syntax: "<number> | <dimension> | <ident> | <ratio>"
	},
		"min()": {
		syntax: "min( <calc-sum># )"
	},
		"minmax()": {
		syntax: "minmax( [ <length> | <percentage> | <flex> | min-content | max-content | auto ] , [ <length> | <percentage> | <flex> | min-content | max-content | auto ] )"
	},
		"named-color": {
		syntax: "transparent | aliceblue | antiquewhite | aqua | aquamarine | azure | beige | bisque | black | blanchedalmond | blue | blueviolet | brown | burlywood | cadetblue | chartreuse | chocolate | coral | cornflowerblue | cornsilk | crimson | cyan | darkblue | darkcyan | darkgoldenrod | darkgray | darkgreen | darkgrey | darkkhaki | darkmagenta | darkolivegreen | darkorange | darkorchid | darkred | darksalmon | darkseagreen | darkslateblue | darkslategray | darkslategrey | darkturquoise | darkviolet | deeppink | deepskyblue | dimgray | dimgrey | dodgerblue | firebrick | floralwhite | forestgreen | fuchsia | gainsboro | ghostwhite | gold | goldenrod | gray | green | greenyellow | grey | honeydew | hotpink | indianred | indigo | ivory | khaki | lavender | lavenderblush | lawngreen | lemonchiffon | lightblue | lightcoral | lightcyan | lightgoldenrodyellow | lightgray | lightgreen | lightgrey | lightpink | lightsalmon | lightseagreen | lightskyblue | lightslategray | lightslategrey | lightsteelblue | lightyellow | lime | limegreen | linen | magenta | maroon | mediumaquamarine | mediumblue | mediumorchid | mediumpurple | mediumseagreen | mediumslateblue | mediumspringgreen | mediumturquoise | mediumvioletred | midnightblue | mintcream | mistyrose | moccasin | navajowhite | navy | oldlace | olive | olivedrab | orange | orangered | orchid | palegoldenrod | palegreen | paleturquoise | palevioletred | papayawhip | peachpuff | peru | pink | plum | powderblue | purple | rebeccapurple | red | rosybrown | royalblue | saddlebrown | salmon | sandybrown | seagreen | seashell | sienna | silver | skyblue | slateblue | slategray | slategrey | snow | springgreen | steelblue | tan | teal | thistle | tomato | turquoise | violet | wheat | white | whitesmoke | yellow | yellowgreen"
	},
		"namespace-prefix": {
		syntax: "<ident>"
	},
		"ns-prefix": {
		syntax: "[ <ident-token> | '*' ]? '|'"
	},
		"number-percentage": {
		syntax: "<number> | <percentage>"
	},
		"numeric-figure-values": {
		syntax: "[ lining-nums | oldstyle-nums ]"
	},
		"numeric-fraction-values": {
		syntax: "[ diagonal-fractions | stacked-fractions ]"
	},
		"numeric-spacing-values": {
		syntax: "[ proportional-nums | tabular-nums ]"
	},
		nth: nth,
		"opacity()": {
		syntax: "opacity( [ <number-percentage> ] )"
	},
		"overflow-position": {
		syntax: "unsafe | safe"
	},
		"outline-radius": {
		syntax: "<length> | <percentage>"
	},
		"page-body": {
		syntax: "<declaration>? [ ; <page-body> ]? | <page-margin-box> <page-body>"
	},
		"page-margin-box": {
		syntax: "<page-margin-box-type> '{' <declaration-list> '}'"
	},
		"page-margin-box-type": {
		syntax: "@top-left-corner | @top-left | @top-center | @top-right | @top-right-corner | @bottom-left-corner | @bottom-left | @bottom-center | @bottom-right | @bottom-right-corner | @left-top | @left-middle | @left-bottom | @right-top | @right-middle | @right-bottom"
	},
		"page-selector-list": {
		syntax: "[ <page-selector># ]?"
	},
		"page-selector": {
		syntax: "<pseudo-page>+ | <ident> <pseudo-page>*"
	},
		"paint()": {
		syntax: "paint( <ident>, <declaration-value>? )"
	},
		"perspective()": {
		syntax: "perspective( <length> )"
	},
		"polygon()": {
		syntax: "polygon( <fill-rule>? , [ <length-percentage> <length-percentage> ]# )"
	},
		position: position$1,
		"pseudo-class-selector": {
		syntax: "':' <ident-token> | ':' <function-token> <any-value> ')'"
	},
		"pseudo-element-selector": {
		syntax: "':' <pseudo-class-selector>"
	},
		"pseudo-page": {
		syntax: ": [ left | right | first | blank ]"
	},
		quote: quote,
		"radial-gradient()": {
		syntax: "radial-gradient( [ <ending-shape> || <size> ]? [ at <position> ]? , <color-stop-list> )"
	},
		"relative-selector": {
		syntax: "<combinator>? <complex-selector>"
	},
		"relative-selector-list": {
		syntax: "<relative-selector>#"
	},
		"relative-size": {
		syntax: "larger | smaller"
	},
		"repeat-style": {
		syntax: "repeat-x | repeat-y | [ repeat | space | round | no-repeat ]{1,2}"
	},
		"repeating-linear-gradient()": {
		syntax: "repeating-linear-gradient( [ <angle> | to <side-or-corner> ]? , <color-stop-list> )"
	},
		"repeating-radial-gradient()": {
		syntax: "repeating-radial-gradient( [ <ending-shape> || <size> ]? [ at <position> ]? , <color-stop-list> )"
	},
		"rgb()": {
		syntax: "rgb( <percentage>{3} [ / <alpha-value> ]? ) | rgb( <number>{3} [ / <alpha-value> ]? ) | rgb( <percentage>#{3} , <alpha-value>? ) | rgb( <number>#{3} , <alpha-value>? )"
	},
		"rgba()": {
		syntax: "rgba( <percentage>{3} [ / <alpha-value> ]? ) | rgba( <number>{3} [ / <alpha-value> ]? ) | rgba( <percentage>#{3} , <alpha-value>? ) | rgba( <number>#{3} , <alpha-value>? )"
	},
		"rotate()": {
		syntax: "rotate( [ <angle> | <zero> ] )"
	},
		"rotate3d()": {
		syntax: "rotate3d( <number> , <number> , <number> , [ <angle> | <zero> ] )"
	},
		"rotateX()": {
		syntax: "rotateX( [ <angle> | <zero> ] )"
	},
		"rotateY()": {
		syntax: "rotateY( [ <angle> | <zero> ] )"
	},
		"rotateZ()": {
		syntax: "rotateZ( [ <angle> | <zero> ] )"
	},
		"saturate()": {
		syntax: "saturate( <number-percentage> )"
	},
		"scale()": {
		syntax: "scale( <number> , <number>? )"
	},
		"scale3d()": {
		syntax: "scale3d( <number> , <number> , <number> )"
	},
		"scaleX()": {
		syntax: "scaleX( <number> )"
	},
		"scaleY()": {
		syntax: "scaleY( <number> )"
	},
		"scaleZ()": {
		syntax: "scaleZ( <number> )"
	},
		"self-position": {
		syntax: "center | start | end | self-start | self-end | flex-start | flex-end"
	},
		"shape-radius": {
		syntax: "<length-percentage> | closest-side | farthest-side"
	},
		"skew()": {
		syntax: "skew( [ <angle> | <zero> ] , [ <angle> | <zero> ]? )"
	},
		"skewX()": {
		syntax: "skewX( [ <angle> | <zero> ] )"
	},
		"skewY()": {
		syntax: "skewY( [ <angle> | <zero> ] )"
	},
		"sepia()": {
		syntax: "sepia( <number-percentage> )"
	},
		shadow: shadow,
		"shadow-t": {
		syntax: "[ <length>{2,3} && <color>? ]"
	},
		shape: shape$1,
		"shape-box": {
		syntax: "<box> | margin-box"
	},
		"side-or-corner": {
		syntax: "[ left | right ] || [ top | bottom ]"
	},
		"single-animation": {
		syntax: "<time> || <timing-function> || <time> || <single-animation-iteration-count> || <single-animation-direction> || <single-animation-fill-mode> || <single-animation-play-state> || [ none | <keyframes-name> ]"
	},
		"single-animation-direction": {
		syntax: "normal | reverse | alternate | alternate-reverse"
	},
		"single-animation-fill-mode": {
		syntax: "none | forwards | backwards | both"
	},
		"single-animation-iteration-count": {
		syntax: "infinite | <number>"
	},
		"single-animation-play-state": {
		syntax: "running | paused"
	},
		"single-transition": {
		syntax: "[ none | <single-transition-property> ] || <time> || <timing-function> || <time>"
	},
		"single-transition-property": {
		syntax: "all | <custom-ident>"
	},
		size: size,
		"step-position": {
		syntax: "jump-start | jump-end | jump-none | jump-both | start | end"
	},
		"step-timing-function": {
		syntax: "step-start | step-end | steps(<integer>[, <step-position>]?)"
	},
		"subclass-selector": {
		syntax: "<id-selector> | <class-selector> | <attribute-selector> | <pseudo-class-selector>"
	},
		"supports-condition": {
		syntax: "not <supports-in-parens> | <supports-in-parens> [ and <supports-in-parens> ]* | <supports-in-parens> [ or <supports-in-parens> ]*"
	},
		"supports-in-parens": {
		syntax: "( <supports-condition> ) | <supports-feature> | <general-enclosed>"
	},
		"supports-feature": {
		syntax: "<supports-decl> | <supports-selector-fn>"
	},
		"supports-decl": {
		syntax: "( <declaration> )"
	},
		"supports-selector-fn": {
		syntax: "selector( <complex-selector> )"
	},
		symbol: symbol,
		target: target,
		"target-counter()": {
		syntax: "target-counter( [ <string> | <url> ] , <custom-ident> , <counter-style>? )"
	},
		"target-counters()": {
		syntax: "target-counters( [ <string> | <url> ] , <custom-ident> , <string> , <counter-style>? )"
	},
		"target-text()": {
		syntax: "target-text( [ <string> | <url> ] , [ content | before | after | first-letter ]? )"
	},
		"time-percentage": {
		syntax: "<time> | <percentage>"
	},
		"timing-function": {
		syntax: "linear | <cubic-bezier-timing-function> | <step-timing-function>"
	},
		"track-breadth": {
		syntax: "<length-percentage> | <flex> | min-content | max-content | auto"
	},
		"track-list": {
		syntax: "[ <line-names>? [ <track-size> | <track-repeat> ] ]+ <line-names>?"
	},
		"track-repeat": {
		syntax: "repeat( [ <positive-integer> ] , [ <line-names>? <track-size> ]+ <line-names>? )"
	},
		"track-size": {
		syntax: "<track-breadth> | minmax( <inflexible-breadth> , <track-breadth> ) | fit-content( [ <length> | <percentage> ] )"
	},
		"transform-function": {
		syntax: "<matrix()> | <translate()> | <translateX()> | <translateY()> | <scale()> | <scaleX()> | <scaleY()> | <rotate()> | <skew()> | <skewX()> | <skewY()> | <matrix3d()> | <translate3d()> | <translateZ()> | <scale3d()> | <scaleZ()> | <rotate3d()> | <rotateX()> | <rotateY()> | <rotateZ()> | <perspective()>"
	},
		"transform-list": {
		syntax: "<transform-function>+"
	},
		"translate()": {
		syntax: "translate( <length-percentage> , <length-percentage>? )"
	},
		"translate3d()": {
		syntax: "translate3d( <length-percentage> , <length-percentage> , <length> )"
	},
		"translateX()": {
		syntax: "translateX( <length-percentage> )"
	},
		"translateY()": {
		syntax: "translateY( <length-percentage> )"
	},
		"translateZ()": {
		syntax: "translateZ( <length> )"
	},
		"type-or-unit": {
		syntax: "string | color | url | integer | number | length | angle | time | frequency | cap | ch | em | ex | ic | lh | rlh | rem | vb | vi | vw | vh | vmin | vmax | mm | Q | cm | in | pt | pc | px | deg | grad | rad | turn | ms | s | Hz | kHz | %"
	},
		"type-selector": {
		syntax: "<wq-name> | <ns-prefix>? '*'"
	},
		"var()": {
		syntax: "var( <custom-property-name> , <declaration-value>? )"
	},
		"viewport-length": {
		syntax: "auto | <length-percentage>"
	},
		"wq-name": {
		syntax: "<ns-prefix>? <ident-token>"
	}
	};

	var syntaxes$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		attachment: attachment,
		box: box,
		color: color$1,
		combinator: combinator,
		compat: compat,
		gradient: gradient,
		hue: hue,
		image: image,
		nth: nth,
		position: position$1,
		quote: quote,
		shadow: shadow,
		shape: shape$1,
		size: size,
		symbol: symbol,
		target: target,
		'default': syntaxes
	});

	var properties$3 = {
		"-moz-background-clip": {
			comment: "deprecated syntax in old Firefox, https://developer.mozilla.org/en/docs/Web/CSS/background-clip",
			syntax: "padding | border"
		},
		"-moz-border-radius-bottomleft": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/border-bottom-left-radius",
			syntax: "<'border-bottom-left-radius'>"
		},
		"-moz-border-radius-bottomright": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/border-bottom-right-radius",
			syntax: "<'border-bottom-right-radius'>"
		},
		"-moz-border-radius-topleft": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/border-top-left-radius",
			syntax: "<'border-top-left-radius'>"
		},
		"-moz-border-radius-topright": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/border-bottom-right-radius",
			syntax: "<'border-bottom-right-radius'>"
		},
		"-moz-control-character-visibility": {
			comment: "firefox specific keywords, https://bugzilla.mozilla.org/show_bug.cgi?id=947588",
			syntax: "visible | hidden"
		},
		"-moz-osx-font-smoothing": {
			comment: "misssed old syntax https://developer.mozilla.org/en-US/docs/Web/CSS/font-smooth",
			syntax: "auto | grayscale"
		},
		"-moz-user-select": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/user-select",
			syntax: "none | text | all | -moz-none"
		},
		"-ms-flex-align": {
			comment: "misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-align",
			syntax: "start | end | center | baseline | stretch"
		},
		"-ms-flex-item-align": {
			comment: "misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-align",
			syntax: "auto | start | end | center | baseline | stretch"
		},
		"-ms-flex-line-pack": {
			comment: "misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-line-pack",
			syntax: "start | end | center | justify | distribute | stretch"
		},
		"-ms-flex-negative": {
			comment: "misssed old syntax implemented in IE; TODO: find references for comfirmation",
			syntax: "<'flex-shrink'>"
		},
		"-ms-flex-pack": {
			comment: "misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-pack",
			syntax: "start | end | center | justify | distribute"
		},
		"-ms-flex-order": {
			comment: "misssed old syntax implemented in IE; https://msdn.microsoft.com/en-us/library/jj127303(v=vs.85).aspx",
			syntax: "<integer>"
		},
		"-ms-flex-positive": {
			comment: "misssed old syntax implemented in IE; TODO: find references for comfirmation",
			syntax: "<'flex-grow'>"
		},
		"-ms-flex-preferred-size": {
			comment: "misssed old syntax implemented in IE; TODO: find references for comfirmation",
			syntax: "<'flex-basis'>"
		},
		"-ms-interpolation-mode": {
			comment: "https://msdn.microsoft.com/en-us/library/ff521095(v=vs.85).aspx",
			syntax: "nearest-neighbor | bicubic"
		},
		"-ms-grid-column-align": {
			comment: "add this property first since it uses as fallback for flexbox, https://msdn.microsoft.com/en-us/library/windows/apps/hh466338.aspx",
			syntax: "start | end | center | stretch"
		},
		"-ms-grid-columns": {
			comment: "misssed old syntax implemented in IE; https://www.w3.org/TR/2012/WD-css3-grid-layout-20120322/#grid-columns",
			syntax: "<track-list-v0>"
		},
		"-ms-grid-row-align": {
			comment: "add this property first since it uses as fallback for flexbox, https://msdn.microsoft.com/en-us/library/windows/apps/hh466348.aspx",
			syntax: "start | end | center | stretch"
		},
		"-ms-grid-rows": {
			comment: "misssed old syntax implemented in IE; https://www.w3.org/TR/2012/WD-css3-grid-layout-20120322/#grid-rows",
			syntax: "<track-list-v0>"
		},
		"-ms-hyphenate-limit-last": {
			comment: "misssed old syntax implemented in IE; https://www.w3.org/TR/css-text-4/#hyphenate-line-limits",
			syntax: "none | always | column | page | spread"
		},
		"-webkit-appearance": {
			comment: "webkit specific keywords",
			references: [
				"http://css-infos.net/property/-webkit-appearance"
			],
			syntax: "none | button | button-bevel | caps-lock-indicator | caret | checkbox | default-button | listbox | listitem | media-fullscreen-button | media-mute-button | media-play-button | media-seek-back-button | media-seek-forward-button | media-slider | media-sliderthumb | menulist | menulist-button | menulist-text | menulist-textfield | push-button | radio | scrollbarbutton-down | scrollbarbutton-left | scrollbarbutton-right | scrollbarbutton-up | scrollbargripper-horizontal | scrollbargripper-vertical | scrollbarthumb-horizontal | scrollbarthumb-vertical | scrollbartrack-horizontal | scrollbartrack-vertical | searchfield | searchfield-cancel-button | searchfield-decoration | searchfield-results-button | searchfield-results-decoration | slider-horizontal | slider-vertical | sliderthumb-horizontal | sliderthumb-vertical | square-button | textarea | textfield"
		},
		"-webkit-background-clip": {
			comment: "https://developer.mozilla.org/en/docs/Web/CSS/background-clip",
			syntax: "[ <box> | border | padding | content | text ]#"
		},
		"-webkit-column-break-after": {
			comment: "added, http://help.dottoro.com/lcrthhhv.php",
			syntax: "always | auto | avoid"
		},
		"-webkit-column-break-before": {
			comment: "added, http://help.dottoro.com/lcxquvkf.php",
			syntax: "always | auto | avoid"
		},
		"-webkit-column-break-inside": {
			comment: "added, http://help.dottoro.com/lclhnthl.php",
			syntax: "always | auto | avoid"
		},
		"-webkit-font-smoothing": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/font-smooth",
			syntax: "auto | none | antialiased | subpixel-antialiased"
		},
		"-webkit-mask-box-image": {
			comment: "missed; https://developer.mozilla.org/en-US/docs/Web/CSS/-webkit-mask-box-image",
			syntax: "[ <url> | <gradient> | none ] [ <length-percentage>{4} <-webkit-mask-box-repeat>{2} ]?"
		},
		"-webkit-print-color-adjust": {
			comment: "missed",
			references: [
				"https://developer.mozilla.org/en/docs/Web/CSS/-webkit-print-color-adjust"
			],
			syntax: "economy | exact"
		},
		"-webkit-text-security": {
			comment: "missed; http://help.dottoro.com/lcbkewgt.php",
			syntax: "none | circle | disc | square"
		},
		"-webkit-user-drag": {
			comment: "missed; http://help.dottoro.com/lcbixvwm.php",
			syntax: "none | element | auto"
		},
		"-webkit-user-select": {
			comment: "auto is supported by old webkit, https://developer.mozilla.org/en-US/docs/Web/CSS/user-select",
			syntax: "auto | none | text | all"
		},
		"alignment-baseline": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#AlignmentBaselineProperty"
			],
			syntax: "auto | baseline | before-edge | text-before-edge | middle | central | after-edge | text-after-edge | ideographic | alphabetic | hanging | mathematical"
		},
		"baseline-shift": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#BaselineShiftProperty"
			],
			syntax: "baseline | sub | super | <svg-length>"
		},
		behavior: {
			comment: "added old IE property https://msdn.microsoft.com/en-us/library/ms530723(v=vs.85).aspx",
			syntax: "<url>+"
		},
		"clip-rule": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/masking.html#ClipRuleProperty"
			],
			syntax: "nonzero | evenodd"
		},
		cue: {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<'cue-before'> <'cue-after'>?"
		},
		"cue-after": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<url> <decibel>? | none"
		},
		"cue-before": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<url> <decibel>? | none"
		},
		cursor: {
			comment: "added legacy keywords: hand, -webkit-grab. -webkit-grabbing, -webkit-zoom-in, -webkit-zoom-out, -moz-grab, -moz-grabbing, -moz-zoom-in, -moz-zoom-out",
			references: [
				"https://www.sitepoint.com/css3-cursor-styles/"
			],
			syntax: "[ [ <url> [ <x> <y> ]? , ]* [ auto | default | none | context-menu | help | pointer | progress | wait | cell | crosshair | text | vertical-text | alias | copy | move | no-drop | not-allowed | e-resize | n-resize | ne-resize | nw-resize | s-resize | se-resize | sw-resize | w-resize | ew-resize | ns-resize | nesw-resize | nwse-resize | col-resize | row-resize | all-scroll | zoom-in | zoom-out | grab | grabbing | hand | -webkit-grab | -webkit-grabbing | -webkit-zoom-in | -webkit-zoom-out | -moz-grab | -moz-grabbing | -moz-zoom-in | -moz-zoom-out ] ]"
		},
		display: {
			comment: "extended with -ms-flexbox",
			syntax: "block | contents | flex | flow | flow-root | grid | inline | inline-block | inline-flex | inline-grid | inline-list-item | inline-table | list-item | none | ruby | ruby-base | ruby-base-container | ruby-text | ruby-text-container | run-in | table | table-caption | table-cell | table-column | table-column-group | table-footer-group | table-header-group | table-row | table-row-group | -ms-flexbox | -ms-inline-flexbox | -ms-grid | -ms-inline-grid | -webkit-flex | -webkit-inline-flex | -webkit-box | -webkit-inline-box | -moz-inline-stack | -moz-box | -moz-inline-box"
		},
		position: {
			comment: "extended with -webkit-sticky",
			syntax: "static | relative | absolute | sticky | fixed | -webkit-sticky"
		},
		"dominant-baseline": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#DominantBaselineProperty"
			],
			syntax: "auto | use-script | no-change | reset-size | ideographic | alphabetic | hanging | mathematical | central | middle | text-after-edge | text-before-edge"
		},
		"image-rendering": {
			comment: "extended with <-non-standard-image-rendering>, added SVG keywords optimizeSpeed and optimizeQuality",
			references: [
				"https://developer.mozilla.org/en/docs/Web/CSS/image-rendering",
				"https://www.w3.org/TR/SVG/painting.html#ImageRenderingProperty"
			],
			syntax: "auto | crisp-edges | pixelated | optimizeSpeed | optimizeQuality | <-non-standard-image-rendering>"
		},
		fill: {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#FillProperty"
			],
			syntax: "<paint>"
		},
		"fill-opacity": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#FillProperty"
			],
			syntax: "<number-zero-one>"
		},
		"fill-rule": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#FillProperty"
			],
			syntax: "nonzero | evenodd"
		},
		filter: {
			comment: "extend with IE legacy syntaxes",
			syntax: "none | <filter-function-list> | <-ms-filter-function-list>"
		},
		"glyph-orientation-horizontal": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#GlyphOrientationHorizontalProperty"
			],
			syntax: "<angle>"
		},
		"glyph-orientation-vertical": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#GlyphOrientationVerticalProperty"
			],
			syntax: "<angle>"
		},
		kerning: {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#KerningProperty"
			],
			syntax: "auto | <svg-length>"
		},
		"letter-spacing": {
			comment: "fix syntax <length> -> <length-percentage>",
			references: [
				"https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/letter-spacing"
			],
			syntax: "normal | <length-percentage>"
		},
		marker: {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#MarkerProperties"
			],
			syntax: "none | <url>"
		},
		"marker-end": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#MarkerProperties"
			],
			syntax: "none | <url>"
		},
		"marker-mid": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#MarkerProperties"
			],
			syntax: "none | <url>"
		},
		"marker-start": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#MarkerProperties"
			],
			syntax: "none | <url>"
		},
		"max-width": {
			comment: "extend by non-standard width keywords https://developer.mozilla.org/en-US/docs/Web/CSS/max-width",
			syntax: "<length> | <percentage> | none | max-content | min-content | fit-content | fill-available | <-non-standard-width>"
		},
		"min-width": {
			comment: "extend by non-standard width keywords https://developer.mozilla.org/en-US/docs/Web/CSS/width",
			syntax: "<length> | <percentage> | auto | max-content | min-content | fit-content | fill-available | <-non-standard-width>"
		},
		opacity: {
			comment: "strict to 0..1 <number> -> <number-zero-one>",
			syntax: "<number-zero-one>"
		},
		overflow: {
			comment: "extend by vendor keywords https://developer.mozilla.org/en-US/docs/Web/CSS/overflow",
			syntax: "[ visible | hidden | clip | scroll | auto ]{1,2} | <-non-standard-overflow>"
		},
		pause: {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<'pause-before'> <'pause-after'>?"
		},
		"pause-after": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<time> | none | x-weak | weak | medium | strong | x-strong"
		},
		"pause-before": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<time> | none | x-weak | weak | medium | strong | x-strong"
		},
		rest: {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<'rest-before'> <'rest-after'>?"
		},
		"rest-after": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<time> | none | x-weak | weak | medium | strong | x-strong"
		},
		"rest-before": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<time> | none | x-weak | weak | medium | strong | x-strong"
		},
		"shape-rendering": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#ShapeRenderingPropert"
			],
			syntax: "auto | optimizeSpeed | crispEdges | geometricPrecision"
		},
		src: {
			comment: "added @font-face's src property https://developer.mozilla.org/en-US/docs/Web/CSS/@font-face/src",
			syntax: "[ <url> [ format( <string># ) ]? | local( <family-name> ) ]#"
		},
		speak: {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "auto | none | normal"
		},
		"speak-as": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "normal | spell-out || digits || [ literal-punctuation | no-punctuation ]"
		},
		stroke: {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "<paint>"
		},
		"stroke-dasharray": {
			comment: "added SVG property; a list of comma and/or white space separated <length>s and <percentage>s",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "none | [ <svg-length>+ ]#"
		},
		"stroke-dashoffset": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "<svg-length>"
		},
		"stroke-linecap": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "butt | round | square"
		},
		"stroke-linejoin": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "miter | round | bevel"
		},
		"stroke-miterlimit": {
			comment: "added SVG property (<miterlimit> = <number-one-or-greater>) ",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "<number-one-or-greater>"
		},
		"stroke-opacity": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "<number-zero-one>"
		},
		"stroke-width": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "<svg-length>"
		},
		"text-anchor": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#TextAlignmentProperties"
			],
			syntax: "start | middle | end"
		},
		"unicode-bidi": {
			comment: "added prefixed keywords https://developer.mozilla.org/en-US/docs/Web/CSS/unicode-bidi",
			syntax: "normal | embed | isolate | bidi-override | isolate-override | plaintext | -moz-isolate | -moz-isolate-override | -moz-plaintext | -webkit-isolate"
		},
		"unicode-range": {
			comment: "added missed property https://developer.mozilla.org/en-US/docs/Web/CSS/%40font-face/unicode-range",
			syntax: "<urange>#"
		},
		"voice-balance": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<number> | left | center | right | leftwards | rightwards"
		},
		"voice-duration": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "auto | <time>"
		},
		"voice-family": {
			comment: "<name> -> <family-name>, https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "[ [ <family-name> | <generic-voice> ] , ]* [ <family-name> | <generic-voice> ] | preserve"
		},
		"voice-pitch": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<frequency> && absolute | [ [ x-low | low | medium | high | x-high ] || [ <frequency> | <semitones> | <percentage> ] ]"
		},
		"voice-range": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<frequency> && absolute | [ [ x-low | low | medium | high | x-high ] || [ <frequency> | <semitones> | <percentage> ] ]"
		},
		"voice-rate": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "[ normal | x-slow | slow | medium | fast | x-fast ] || <percentage>"
		},
		"voice-stress": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "normal | strong | moderate | none | reduced"
		},
		"voice-volume": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "silent | [ [ x-soft | soft | medium | loud | x-loud ] || <decibel> ]"
		},
		"writing-mode": {
			comment: "extend with SVG keywords",
			syntax: "horizontal-tb | vertical-rl | vertical-lr | sideways-rl | sideways-lr | <svg-writing-mode>"
		}
	};
	var syntaxes$2 = {
		"-legacy-gradient": {
			comment: "added collection of legacy gradient syntaxes",
			syntax: "<-webkit-gradient()> | <-legacy-linear-gradient> | <-legacy-repeating-linear-gradient> | <-legacy-radial-gradient> | <-legacy-repeating-radial-gradient>"
		},
		"-legacy-linear-gradient": {
			comment: "like standard syntax but w/o `to` keyword https://developer.mozilla.org/en-US/docs/Web/CSS/linear-gradient",
			syntax: "-moz-linear-gradient( <-legacy-linear-gradient-arguments> ) | -webkit-linear-gradient( <-legacy-linear-gradient-arguments> ) | -o-linear-gradient( <-legacy-linear-gradient-arguments> )"
		},
		"-legacy-repeating-linear-gradient": {
			comment: "like standard syntax but w/o `to` keyword https://developer.mozilla.org/en-US/docs/Web/CSS/linear-gradient",
			syntax: "-moz-repeating-linear-gradient( <-legacy-linear-gradient-arguments> ) | -webkit-repeating-linear-gradient( <-legacy-linear-gradient-arguments> ) | -o-repeating-linear-gradient( <-legacy-linear-gradient-arguments> )"
		},
		"-legacy-linear-gradient-arguments": {
			comment: "like standard syntax but w/o `to` keyword https://developer.mozilla.org/en-US/docs/Web/CSS/linear-gradient",
			syntax: "[ <angle> | <side-or-corner> ]? , <color-stop-list>"
		},
		"-legacy-radial-gradient": {
			comment: "deprecated syntax that implemented by some browsers https://www.w3.org/TR/2011/WD-css3-images-20110908/#radial-gradients",
			syntax: "-moz-radial-gradient( <-legacy-radial-gradient-arguments> ) | -webkit-radial-gradient( <-legacy-radial-gradient-arguments> ) | -o-radial-gradient( <-legacy-radial-gradient-arguments> )"
		},
		"-legacy-repeating-radial-gradient": {
			comment: "deprecated syntax that implemented by some browsers https://www.w3.org/TR/2011/WD-css3-images-20110908/#radial-gradients",
			syntax: "-moz-repeating-radial-gradient( <-legacy-radial-gradient-arguments> ) | -webkit-repeating-radial-gradient( <-legacy-radial-gradient-arguments> ) | -o-repeating-radial-gradient( <-legacy-radial-gradient-arguments> )"
		},
		"-legacy-radial-gradient-arguments": {
			comment: "deprecated syntax that implemented by some browsers https://www.w3.org/TR/2011/WD-css3-images-20110908/#radial-gradients",
			syntax: "[ <position> , ]? [ [ [ <-legacy-radial-gradient-shape> || <-legacy-radial-gradient-size> ] | [ <length> | <percentage> ]{2} ] , ]? <color-stop-list>"
		},
		"-legacy-radial-gradient-size": {
			comment: "before a standard it contains 2 extra keywords (`contain` and `cover`) https://www.w3.org/TR/2011/WD-css3-images-20110908/#ltsize",
			syntax: "closest-side | closest-corner | farthest-side | farthest-corner | contain | cover"
		},
		"-legacy-radial-gradient-shape": {
			comment: "define to double sure it doesn't extends in future https://www.w3.org/TR/2011/WD-css3-images-20110908/#ltshape",
			syntax: "circle | ellipse"
		},
		"-non-standard-font": {
			comment: "non standard fonts",
			references: [
				"https://webkit.org/blog/3709/using-the-system-font-in-web-content/"
			],
			syntax: "-apple-system-body | -apple-system-headline | -apple-system-subheadline | -apple-system-caption1 | -apple-system-caption2 | -apple-system-footnote | -apple-system-short-body | -apple-system-short-headline | -apple-system-short-subheadline | -apple-system-short-caption1 | -apple-system-short-footnote | -apple-system-tall-body"
		},
		"-non-standard-color": {
			comment: "non standard colors",
			references: [
				"http://cssdot.ru/%D0%A1%D0%BF%D1%80%D0%B0%D0%B2%D0%BE%D1%87%D0%BD%D0%B8%D0%BA_CSS/color-i305.html",
				"https://developer.mozilla.org/en-US/docs/Web/CSS/color_value#Mozilla_Color_Preference_Extensions"
			],
			syntax: "-moz-ButtonDefault | -moz-ButtonHoverFace | -moz-ButtonHoverText | -moz-CellHighlight | -moz-CellHighlightText | -moz-Combobox | -moz-ComboboxText | -moz-Dialog | -moz-DialogText | -moz-dragtargetzone | -moz-EvenTreeRow | -moz-Field | -moz-FieldText | -moz-html-CellHighlight | -moz-html-CellHighlightText | -moz-mac-accentdarkestshadow | -moz-mac-accentdarkshadow | -moz-mac-accentface | -moz-mac-accentlightesthighlight | -moz-mac-accentlightshadow | -moz-mac-accentregularhighlight | -moz-mac-accentregularshadow | -moz-mac-chrome-active | -moz-mac-chrome-inactive | -moz-mac-focusring | -moz-mac-menuselect | -moz-mac-menushadow | -moz-mac-menutextselect | -moz-MenuHover | -moz-MenuHoverText | -moz-MenuBarText | -moz-MenuBarHoverText | -moz-nativehyperlinktext | -moz-OddTreeRow | -moz-win-communicationstext | -moz-win-mediatext | -moz-activehyperlinktext | -moz-default-background-color | -moz-default-color | -moz-hyperlinktext | -moz-visitedhyperlinktext | -webkit-activelink | -webkit-focus-ring-color | -webkit-link | -webkit-text"
		},
		"-non-standard-image-rendering": {
			comment: "non-standard keywords http://phrogz.net/tmp/canvas_image_zoom.html",
			syntax: "optimize-contrast | -moz-crisp-edges | -o-crisp-edges | -webkit-optimize-contrast"
		},
		"-non-standard-overflow": {
			comment: "non-standard keywords https://developer.mozilla.org/en-US/docs/Web/CSS/overflow",
			syntax: "-moz-scrollbars-none | -moz-scrollbars-horizontal | -moz-scrollbars-vertical | -moz-hidden-unscrollable"
		},
		"-non-standard-width": {
			comment: "non-standard keywords https://developer.mozilla.org/en-US/docs/Web/CSS/width",
			syntax: "min-intrinsic | intrinsic | -moz-min-content | -moz-max-content | -webkit-min-content | -webkit-max-content"
		},
		"-webkit-gradient()": {
			comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/ - TODO: simplify when after match algorithm improvement ( [, point, radius | , point] -> [, radius]? , point )",
			syntax: "-webkit-gradient( <-webkit-gradient-type>, <-webkit-gradient-point> [, <-webkit-gradient-point> | , <-webkit-gradient-radius>, <-webkit-gradient-point> ] [, <-webkit-gradient-radius>]? [, <-webkit-gradient-color-stop>]* )"
		},
		"-webkit-gradient-color-stop": {
			comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/",
			syntax: "from( <color> ) | color-stop( [ <number-zero-one> | <percentage> ] , <color> ) | to( <color> )"
		},
		"-webkit-gradient-point": {
			comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/",
			syntax: "[ left | center | right | <length-percentage> ] [ top | center | bottom | <length-percentage> ]"
		},
		"-webkit-gradient-radius": {
			comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/",
			syntax: "<length> | <percentage>"
		},
		"-webkit-gradient-type": {
			comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/",
			syntax: "linear | radial"
		},
		"-webkit-mask-box-repeat": {
			comment: "missed; https://developer.mozilla.org/en-US/docs/Web/CSS/-webkit-mask-box-image",
			syntax: "repeat | stretch | round"
		},
		"-webkit-mask-clip-style": {
			comment: "missed; there is no enough information about `-webkit-mask-clip` property, but looks like all those keywords are working",
			syntax: "border | border-box | padding | padding-box | content | content-box | text"
		},
		"-ms-filter-function-list": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter",
			syntax: "<-ms-filter-function>+"
		},
		"-ms-filter-function": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter",
			syntax: "<-ms-filter-function-progid> | <-ms-filter-function-legacy>"
		},
		"-ms-filter-function-progid": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter",
			syntax: "'progid:' [ <ident-token> '.' ]* [ <ident-token> | <function-token> <any-value>? ) ]"
		},
		"-ms-filter-function-legacy": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter",
			syntax: "<ident-token> | <function-token> <any-value>? )"
		},
		"-ms-filter": {
			syntax: "<string>"
		},
		age: {
			comment: "https://www.w3.org/TR/css3-speech/#voice-family",
			syntax: "child | young | old"
		},
		"attr-name": {
			syntax: "<wq-name>"
		},
		"attr-fallback": {
			syntax: "<any-value>"
		},
		"border-radius": {
			comment: "missed, https://drafts.csswg.org/css-backgrounds-3/#the-border-radius",
			syntax: "<length-percentage>{1,2}"
		},
		bottom: {
			comment: "missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect",
			syntax: "<length> | auto"
		},
		"content-list": {
			comment: "missed -> https://drafts.csswg.org/css-content/#typedef-content-list (document-url, <target> and leader() is omitted util stabilization)",
			syntax: "[ <string> | contents | <url> | <quote> | <attr()> | counter( <ident>, <'list-style-type'>? ) ]+"
		},
		"generic-voice": {
			comment: "https://www.w3.org/TR/css3-speech/#voice-family",
			syntax: "[ <age>? <gender> <integer>? ]"
		},
		gender: {
			comment: "https://www.w3.org/TR/css3-speech/#voice-family",
			syntax: "male | female | neutral"
		},
		"generic-family": {
			comment: "added -apple-system",
			references: [
				"https://webkit.org/blog/3709/using-the-system-font-in-web-content/"
			],
			syntax: "serif | sans-serif | cursive | fantasy | monospace | -apple-system"
		},
		gradient: {
			comment: "added legacy syntaxes support",
			syntax: "<linear-gradient()> | <repeating-linear-gradient()> | <radial-gradient()> | <repeating-radial-gradient()> | <conic-gradient()> | <-legacy-gradient>"
		},
		left: {
			comment: "missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect",
			syntax: "<length> | auto"
		},
		"mask-image": {
			comment: "missed; https://drafts.fxtf.org/css-masking-1/#the-mask-image",
			syntax: "<mask-reference>#"
		},
		"name-repeat": {
			comment: "missed, and looks like obsolete, keep it as is since other property syntaxes should be changed too; https://www.w3.org/TR/2015/WD-css-grid-1-20150917/#typedef-name-repeat",
			syntax: "repeat( [ <positive-integer> | auto-fill ], <line-names>+)"
		},
		"named-color": {
			comment: "added non standard color names",
			syntax: "transparent | aliceblue | antiquewhite | aqua | aquamarine | azure | beige | bisque | black | blanchedalmond | blue | blueviolet | brown | burlywood | cadetblue | chartreuse | chocolate | coral | cornflowerblue | cornsilk | crimson | cyan | darkblue | darkcyan | darkgoldenrod | darkgray | darkgreen | darkgrey | darkkhaki | darkmagenta | darkolivegreen | darkorange | darkorchid | darkred | darksalmon | darkseagreen | darkslateblue | darkslategray | darkslategrey | darkturquoise | darkviolet | deeppink | deepskyblue | dimgray | dimgrey | dodgerblue | firebrick | floralwhite | forestgreen | fuchsia | gainsboro | ghostwhite | gold | goldenrod | gray | green | greenyellow | grey | honeydew | hotpink | indianred | indigo | ivory | khaki | lavender | lavenderblush | lawngreen | lemonchiffon | lightblue | lightcoral | lightcyan | lightgoldenrodyellow | lightgray | lightgreen | lightgrey | lightpink | lightsalmon | lightseagreen | lightskyblue | lightslategray | lightslategrey | lightsteelblue | lightyellow | lime | limegreen | linen | magenta | maroon | mediumaquamarine | mediumblue | mediumorchid | mediumpurple | mediumseagreen | mediumslateblue | mediumspringgreen | mediumturquoise | mediumvioletred | midnightblue | mintcream | mistyrose | moccasin | navajowhite | navy | oldlace | olive | olivedrab | orange | orangered | orchid | palegoldenrod | palegreen | paleturquoise | palevioletred | papayawhip | peachpuff | peru | pink | plum | powderblue | purple | rebeccapurple | red | rosybrown | royalblue | saddlebrown | salmon | sandybrown | seagreen | seashell | sienna | silver | skyblue | slateblue | slategray | slategrey | snow | springgreen | steelblue | tan | teal | thistle | tomato | turquoise | violet | wheat | white | whitesmoke | yellow | yellowgreen | <-non-standard-color>"
		},
		paint: {
			comment: "used by SVG https://www.w3.org/TR/SVG/painting.html#SpecifyingPaint",
			syntax: "none | <color> | <url> [ none | <color> ]? | context-fill | context-stroke"
		},
		"path()": {
			comment: "missed, `motion` property was renamed, but left it as is for now; path() syntax was get from last draft https://drafts.fxtf.org/motion-1/#funcdef-offset-path-path",
			syntax: "path( <string> )"
		},
		ratio: {
			comment: "missed, https://drafts.csswg.org/mediaqueries-4/#typedef-ratio",
			syntax: "<integer> / <integer>"
		},
		right: {
			comment: "missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect",
			syntax: "<length> | auto"
		},
		shape: {
			comment: "missed spaces in function body and add backwards compatible syntax",
			syntax: "rect( <top>, <right>, <bottom>, <left> ) | rect( <top> <right> <bottom> <left> )"
		},
		"svg-length": {
			comment: "All coordinates and lengths in SVG can be specified with or without a unit identifier",
			references: [
				"https://www.w3.org/TR/SVG11/coords.html#Units"
			],
			syntax: "<percentage> | <length> | <number>"
		},
		"svg-writing-mode": {
			comment: "SVG specific keywords (deprecated for CSS)",
			references: [
				"https://developer.mozilla.org/en/docs/Web/CSS/writing-mode",
				"https://www.w3.org/TR/SVG/text.html#WritingModeProperty"
			],
			syntax: "lr-tb | rl-tb | tb-rl | lr | rl | tb"
		},
		top: {
			comment: "missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect",
			syntax: "<length> | auto"
		},
		"track-group": {
			comment: "used by old grid-columns and grid-rows syntax v0",
			syntax: "'(' [ <string>* <track-minmax> <string>* ]+ ')' [ '[' <positive-integer> ']' ]? | <track-minmax>"
		},
		"track-list-v0": {
			comment: "used by old grid-columns and grid-rows syntax v0",
			syntax: "[ <string>* <track-group> <string>* ]+ | none"
		},
		"track-minmax": {
			comment: "used by old grid-columns and grid-rows syntax v0",
			syntax: "minmax( <track-breadth> , <track-breadth> ) | auto | <track-breadth> | fit-content"
		},
		x: {
			comment: "missed; not sure we should add it, but no others except `cursor` is using it so it's ok for now; https://drafts.csswg.org/css-ui-3/#cursor",
			syntax: "<number>"
		},
		y: {
			comment: "missed; not sure we should add it, but no others except `cursor` is using so it's ok for now; https://drafts.csswg.org/css-ui-3/#cursor",
			syntax: "<number>"
		},
		declaration: {
			comment: "missed, restored by https://drafts.csswg.org/css-syntax",
			syntax: "<ident-token> : <declaration-value>? [ '!' important ]?"
		},
		"declaration-list": {
			comment: "missed, restored by https://drafts.csswg.org/css-syntax",
			syntax: "[ <declaration>? ';' ]* <declaration>?"
		},
		url: {
			comment: "https://drafts.csswg.org/css-values-4/#urls",
			syntax: "url( <string> <url-modifier>* ) | <url-token>"
		},
		"url-modifier": {
			comment: "https://drafts.csswg.org/css-values-4/#typedef-url-modifier",
			syntax: "<ident> | <function-token> <any-value> )"
		},
		"number-zero-one": {
			syntax: "<number [0,1]>"
		},
		"number-one-or-greater": {
			syntax: "<number [1,∞]>"
		},
		"positive-integer": {
			syntax: "<integer [0,∞]>"
		}
	};
	var patch = {
		properties: properties$3,
		syntaxes: syntaxes$2
	};

	var patch$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		properties: properties$3,
		syntaxes: syntaxes$2,
		'default': patch
	});

	var mdnAtrules = getCjsExportFromNamespace(atRules$1);

	var mdnProperties = getCjsExportFromNamespace(properties$2);

	var mdnSyntaxes = getCjsExportFromNamespace(syntaxes$1);

	var patch$2 = getCjsExportFromNamespace(patch$1);

	function preprocessAtrules(dict) {
	    var result = Object.create(null);

	    for (var atruleName in dict) {
	        var atrule = dict[atruleName];
	        var descriptors = null;

	        if (atrule.descriptors) {
	            descriptors = Object.create(null);

	            for (var descriptor in atrule.descriptors) {
	                descriptors[descriptor] = atrule.descriptors[descriptor].syntax;
	            }
	        }

	        result[atruleName.substr(1)] = {
	            prelude: atrule.syntax.trim().match(/^@\S+\s+([^;\{]*)/)[1].trim() || null,
	            descriptors
	        };
	    }

	    return result;
	}

	function buildDictionary(dict, patchDict) {
	    var result = {};

	    // copy all syntaxes for an original dict
	    for (var key in dict) {
	        result[key] = dict[key].syntax;
	    }

	    // apply a patch
	    for (var key in patchDict) {
	        if (key in dict) {
	            if (patchDict[key].syntax) {
	                result[key] = patchDict[key].syntax;
	            } else {
	                delete result[key];
	            }
	        } else {
	            if (patchDict[key].syntax) {
	                result[key] = patchDict[key].syntax;
	            }
	        }
	    }

	    return result;
	}

	var data = {
	    types: buildDictionary(mdnSyntaxes, patch$2.syntaxes),
	    atrules: preprocessAtrules(mdnAtrules),
	    properties: buildDictionary(mdnProperties, patch$2.properties)
	};

	var cmpChar$3 = tokenizer.cmpChar;
	var isDigit$4 = tokenizer.isDigit;
	var TYPE$9 = tokenizer.TYPE;

	var WHITESPACE$4 = TYPE$9.WhiteSpace;
	var COMMENT$3 = TYPE$9.Comment;
	var IDENT$3 = TYPE$9.Ident;
	var NUMBER$3 = TYPE$9.Number;
	var DIMENSION$2 = TYPE$9.Dimension;
	var PLUSSIGN$3 = 0x002B;    // U+002B PLUS SIGN (+)
	var HYPHENMINUS$3 = 0x002D; // U+002D HYPHEN-MINUS (-)
	var N$4 = 0x006E;           // U+006E LATIN SMALL LETTER N (n)
	var DISALLOW_SIGN$1 = true;
	var ALLOW_SIGN$1 = false;

	function checkInteger$1(offset, disallowSign) {
	    var pos = this.scanner.tokenStart + offset;
	    var code = this.scanner.source.charCodeAt(pos);

	    if (code === PLUSSIGN$3 || code === HYPHENMINUS$3) {
	        if (disallowSign) {
	            this.error('Number sign is not allowed');
	        }
	        pos++;
	    }

	    for (; pos < this.scanner.tokenEnd; pos++) {
	        if (!isDigit$4(this.scanner.source.charCodeAt(pos))) {
	            this.error('Integer is expected', pos);
	        }
	    }
	}

	function checkTokenIsInteger(disallowSign) {
	    return checkInteger$1.call(this, 0, disallowSign);
	}

	function expectCharCode(offset, code) {
	    if (!cmpChar$3(this.scanner.source, this.scanner.tokenStart + offset, code)) {
	        var msg = '';

	        switch (code) {
	            case N$4:
	                msg = 'N is expected';
	                break;
	            case HYPHENMINUS$3:
	                msg = 'HyphenMinus is expected';
	                break;
	        }

	        this.error(msg, this.scanner.tokenStart + offset);
	    }
	}

	// ... <signed-integer>
	// ... ['+' | '-'] <signless-integer>
	function consumeB$1() {
	    var offset = 0;
	    var sign = 0;
	    var type = this.scanner.tokenType;

	    while (type === WHITESPACE$4 || type === COMMENT$3) {
	        type = this.scanner.lookupType(++offset);
	    }

	    if (type !== NUMBER$3) {
	        if (this.scanner.isDelim(PLUSSIGN$3, offset) ||
	            this.scanner.isDelim(HYPHENMINUS$3, offset)) {
	            sign = this.scanner.isDelim(PLUSSIGN$3, offset) ? PLUSSIGN$3 : HYPHENMINUS$3;

	            do {
	                type = this.scanner.lookupType(++offset);
	            } while (type === WHITESPACE$4 || type === COMMENT$3);

	            if (type !== NUMBER$3) {
	                this.scanner.skip(offset);
	                checkTokenIsInteger.call(this, DISALLOW_SIGN$1);
	            }
	        } else {
	            return null;
	        }
	    }

	    if (offset > 0) {
	        this.scanner.skip(offset);
	    }

	    if (sign === 0) {
	        type = this.scanner.source.charCodeAt(this.scanner.tokenStart);
	        if (type !== PLUSSIGN$3 && type !== HYPHENMINUS$3) {
	            this.error('Number sign is expected');
	        }
	    }

	    checkTokenIsInteger.call(this, sign !== 0);
	    return sign === HYPHENMINUS$3 ? '-' + this.consume(NUMBER$3) : this.consume(NUMBER$3);
	}

	// An+B microsyntax https://www.w3.org/TR/css-syntax-3/#anb
	var AnPlusB = {
	    name: 'AnPlusB',
	    structure: {
	        a: [String, null],
	        b: [String, null]
	    },
	    parse: function() {
	        /* eslint-disable brace-style*/
	        var start = this.scanner.tokenStart;
	        var a = null;
	        var b = null;

	        // <integer>
	        if (this.scanner.tokenType === NUMBER$3) {
	            checkTokenIsInteger.call(this, ALLOW_SIGN$1);
	            b = this.consume(NUMBER$3);
	        }

	        // -n
	        // -n <signed-integer>
	        // -n ['+' | '-'] <signless-integer>
	        // -n- <signless-integer>
	        // <dashndashdigit-ident>
	        else if (this.scanner.tokenType === IDENT$3 && cmpChar$3(this.scanner.source, this.scanner.tokenStart, HYPHENMINUS$3)) {
	            a = '-1';

	            expectCharCode.call(this, 1, N$4);

	            switch (this.scanner.getTokenLength()) {
	                // -n
	                // -n <signed-integer>
	                // -n ['+' | '-'] <signless-integer>
	                case 2:
	                    this.scanner.next();
	                    b = consumeB$1.call(this);
	                    break;

	                // -n- <signless-integer>
	                case 3:
	                    expectCharCode.call(this, 2, HYPHENMINUS$3);

	                    this.scanner.next();
	                    this.scanner.skipSC();

	                    checkTokenIsInteger.call(this, DISALLOW_SIGN$1);

	                    b = '-' + this.consume(NUMBER$3);
	                    break;

	                // <dashndashdigit-ident>
	                default:
	                    expectCharCode.call(this, 2, HYPHENMINUS$3);
	                    checkInteger$1.call(this, 3, DISALLOW_SIGN$1);
	                    this.scanner.next();

	                    b = this.scanner.substrToCursor(start + 2);
	            }
	        }

	        // '+'? n
	        // '+'? n <signed-integer>
	        // '+'? n ['+' | '-'] <signless-integer>
	        // '+'? n- <signless-integer>
	        // '+'? <ndashdigit-ident>
	        else if (this.scanner.tokenType === IDENT$3 || (this.scanner.isDelim(PLUSSIGN$3) && this.scanner.lookupType(1) === IDENT$3)) {
	            var sign = 0;
	            a = '1';

	            // just ignore a plus
	            if (this.scanner.isDelim(PLUSSIGN$3)) {
	                sign = 1;
	                this.scanner.next();
	            }

	            expectCharCode.call(this, 0, N$4);

	            switch (this.scanner.getTokenLength()) {
	                // '+'? n
	                // '+'? n <signed-integer>
	                // '+'? n ['+' | '-'] <signless-integer>
	                case 1:
	                    this.scanner.next();
	                    b = consumeB$1.call(this);
	                    break;

	                // '+'? n- <signless-integer>
	                case 2:
	                    expectCharCode.call(this, 1, HYPHENMINUS$3);

	                    this.scanner.next();
	                    this.scanner.skipSC();

	                    checkTokenIsInteger.call(this, DISALLOW_SIGN$1);

	                    b = '-' + this.consume(NUMBER$3);
	                    break;

	                // '+'? <ndashdigit-ident>
	                default:
	                    expectCharCode.call(this, 1, HYPHENMINUS$3);
	                    checkInteger$1.call(this, 2, DISALLOW_SIGN$1);
	                    this.scanner.next();

	                    b = this.scanner.substrToCursor(start + sign + 1);
	            }
	        }

	        // <ndashdigit-dimension>
	        // <ndash-dimension> <signless-integer>
	        // <n-dimension>
	        // <n-dimension> <signed-integer>
	        // <n-dimension> ['+' | '-'] <signless-integer>
	        else if (this.scanner.tokenType === DIMENSION$2) {
	            var code = this.scanner.source.charCodeAt(this.scanner.tokenStart);
	            var sign = code === PLUSSIGN$3 || code === HYPHENMINUS$3;

	            for (var i = this.scanner.tokenStart + sign; i < this.scanner.tokenEnd; i++) {
	                if (!isDigit$4(this.scanner.source.charCodeAt(i))) {
	                    break;
	                }
	            }

	            if (i === this.scanner.tokenStart + sign) {
	                this.error('Integer is expected', this.scanner.tokenStart + sign);
	            }

	            expectCharCode.call(this, i - this.scanner.tokenStart, N$4);
	            a = this.scanner.source.substring(start, i);

	            // <n-dimension>
	            // <n-dimension> <signed-integer>
	            // <n-dimension> ['+' | '-'] <signless-integer>
	            if (i + 1 === this.scanner.tokenEnd) {
	                this.scanner.next();
	                b = consumeB$1.call(this);
	            } else {
	                expectCharCode.call(this, i - this.scanner.tokenStart + 1, HYPHENMINUS$3);

	                // <ndash-dimension> <signless-integer>
	                if (i + 2 === this.scanner.tokenEnd) {
	                    this.scanner.next();
	                    this.scanner.skipSC();
	                    checkTokenIsInteger.call(this, DISALLOW_SIGN$1);
	                    b = '-' + this.consume(NUMBER$3);
	                }
	                // <ndashdigit-dimension>
	                else {
	                    checkInteger$1.call(this, i - this.scanner.tokenStart + 2, DISALLOW_SIGN$1);
	                    this.scanner.next();
	                    b = this.scanner.substrToCursor(i + 1);
	                }
	            }
	        } else {
	            this.error();
	        }

	        if (a !== null && a.charCodeAt(0) === PLUSSIGN$3) {
	            a = a.substr(1);
	        }

	        if (b !== null && b.charCodeAt(0) === PLUSSIGN$3) {
	            b = b.substr(1);
	        }

	        return {
	            type: 'AnPlusB',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            a: a,
	            b: b
	        };
	    },
	    generate: function(node) {
	        var a = node.a !== null && node.a !== undefined;
	        var b = node.b !== null && node.b !== undefined;

	        if (a) {
	            this.chunk(
	                node.a === '+1' ? '+n' : // eslint-disable-line operator-linebreak, indent
	                node.a ===  '1' ?  'n' : // eslint-disable-line operator-linebreak, indent
	                node.a === '-1' ? '-n' : // eslint-disable-line operator-linebreak, indent
	                node.a + 'n'             // eslint-disable-line operator-linebreak, indent
	            );

	            if (b) {
	                b = String(node.b);
	                if (b.charAt(0) === '-' || b.charAt(0) === '+') {
	                    this.chunk(b.charAt(0));
	                    this.chunk(b.substr(1));
	                } else {
	                    this.chunk('+');
	                    this.chunk(b);
	                }
	            }
	        } else {
	            this.chunk(String(node.b));
	        }
	    }
	};

	var TYPE$a = tokenizer.TYPE;

	var WhiteSpace = TYPE$a.WhiteSpace;
	var Semicolon = TYPE$a.Semicolon;
	var LeftCurlyBracket = TYPE$a.LeftCurlyBracket;
	var Delim = TYPE$a.Delim;
	var EXCLAMATIONMARK$1 = 0x0021; // U+0021 EXCLAMATION MARK (!)

	function getOffsetExcludeWS() {
	    if (this.scanner.tokenIndex > 0) {
	        if (this.scanner.lookupType(-1) === WhiteSpace) {
	            return this.scanner.tokenIndex > 1
	                ? this.scanner.getTokenStart(this.scanner.tokenIndex - 1)
	                : this.scanner.firstCharOffset;
	        }
	    }

	    return this.scanner.tokenStart;
	}

	// 0, 0, false
	function balanceEnd() {
	    return 0;
	}

	// LEFTCURLYBRACKET, 0, false
	function leftCurlyBracket(tokenType) {
	    return tokenType === LeftCurlyBracket ? 1 : 0;
	}

	// LEFTCURLYBRACKET, SEMICOLON, false
	function leftCurlyBracketOrSemicolon(tokenType) {
	    return tokenType === LeftCurlyBracket || tokenType === Semicolon ? 1 : 0;
	}

	// EXCLAMATIONMARK, SEMICOLON, false
	function exclamationMarkOrSemicolon(tokenType, source, offset) {
	    if (tokenType === Delim && source.charCodeAt(offset) === EXCLAMATIONMARK$1) {
	        return 1;
	    }

	    return tokenType === Semicolon ? 1 : 0;
	}

	// 0, SEMICOLON, true
	function semicolonIncluded(tokenType) {
	    return tokenType === Semicolon ? 2 : 0;
	}

	var Raw = {
	    name: 'Raw',
	    structure: {
	        value: String
	    },
	    parse: function(startToken, mode, excludeWhiteSpace) {
	        var startOffset = this.scanner.getTokenStart(startToken);
	        var endOffset;

	        this.scanner.skip(
	            this.scanner.getRawLength(startToken, mode || balanceEnd)
	        );

	        if (excludeWhiteSpace && this.scanner.tokenStart > startOffset) {
	            endOffset = getOffsetExcludeWS.call(this);
	        } else {
	            endOffset = this.scanner.tokenStart;
	        }

	        return {
	            type: 'Raw',
	            loc: this.getLocation(startOffset, endOffset),
	            value: this.scanner.source.substring(startOffset, endOffset)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    },

	    mode: {
	        default: balanceEnd,
	        leftCurlyBracket: leftCurlyBracket,
	        leftCurlyBracketOrSemicolon: leftCurlyBracketOrSemicolon,
	        exclamationMarkOrSemicolon: exclamationMarkOrSemicolon,
	        semicolonIncluded: semicolonIncluded
	    }
	};

	var TYPE$b = tokenizer.TYPE;
	var rawMode = Raw.mode;

	var ATKEYWORD = TYPE$b.AtKeyword;
	var SEMICOLON = TYPE$b.Semicolon;
	var LEFTCURLYBRACKET$1 = TYPE$b.LeftCurlyBracket;
	var RIGHTCURLYBRACKET$1 = TYPE$b.RightCurlyBracket;

	function consumeRaw(startToken) {
	    return this.Raw(startToken, rawMode.leftCurlyBracketOrSemicolon, true);
	}

	function isDeclarationBlockAtrule() {
	    for (var offset = 1, type; type = this.scanner.lookupType(offset); offset++) {
	        if (type === RIGHTCURLYBRACKET$1) {
	            return true;
	        }

	        if (type === LEFTCURLYBRACKET$1 ||
	            type === ATKEYWORD) {
	            return false;
	        }
	    }

	    return false;
	}

	var Atrule = {
	    name: 'Atrule',
	    structure: {
	        name: String,
	        prelude: ['AtrulePrelude', 'Raw', null],
	        block: ['Block', null]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var name;
	        var nameLowerCase;
	        var prelude = null;
	        var block = null;

	        this.eat(ATKEYWORD);

	        name = this.scanner.substrToCursor(start + 1);
	        nameLowerCase = name.toLowerCase();
	        this.scanner.skipSC();

	        // parse prelude
	        if (this.scanner.eof === false &&
	            this.scanner.tokenType !== LEFTCURLYBRACKET$1 &&
	            this.scanner.tokenType !== SEMICOLON) {
	            if (this.parseAtrulePrelude) {
	                prelude = this.parseWithFallback(this.AtrulePrelude.bind(this, name), consumeRaw);

	                // turn empty AtrulePrelude into null
	                if (prelude.type === 'AtrulePrelude' && prelude.children.head === null) {
	                    prelude = null;
	                }
	            } else {
	                prelude = consumeRaw.call(this, this.scanner.tokenIndex);
	            }

	            this.scanner.skipSC();
	        }

	        switch (this.scanner.tokenType) {
	            case SEMICOLON:
	                this.scanner.next();
	                break;

	            case LEFTCURLYBRACKET$1:
	                if (this.atrule.hasOwnProperty(nameLowerCase) &&
	                    typeof this.atrule[nameLowerCase].block === 'function') {
	                    block = this.atrule[nameLowerCase].block.call(this);
	                } else {
	                    // TODO: should consume block content as Raw?
	                    block = this.Block(isDeclarationBlockAtrule.call(this));
	                }

	                break;
	        }

	        return {
	            type: 'Atrule',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            prelude: prelude,
	            block: block
	        };
	    },
	    generate: function(node) {
	        this.chunk('@');
	        this.chunk(node.name);

	        if (node.prelude !== null) {
	            this.chunk(' ');
	            this.node(node.prelude);
	        }

	        if (node.block) {
	            this.node(node.block);
	        } else {
	            this.chunk(';');
	        }
	    },
	    walkContext: 'atrule'
	};

	var TYPE$c = tokenizer.TYPE;

	var SEMICOLON$1 = TYPE$c.Semicolon;
	var LEFTCURLYBRACKET$2 = TYPE$c.LeftCurlyBracket;

	var AtrulePrelude = {
	    name: 'AtrulePrelude',
	    structure: {
	        children: [[]]
	    },
	    parse: function(name) {
	        var children = null;

	        if (name !== null) {
	            name = name.toLowerCase();
	        }

	        this.scanner.skipSC();

	        if (this.atrule.hasOwnProperty(name) &&
	            typeof this.atrule[name].prelude === 'function') {
	            // custom consumer
	            children = this.atrule[name].prelude.call(this);
	        } else {
	            // default consumer
	            children = this.readSequence(this.scope.AtrulePrelude);
	        }

	        this.scanner.skipSC();

	        if (this.scanner.eof !== true &&
	            this.scanner.tokenType !== LEFTCURLYBRACKET$2 &&
	            this.scanner.tokenType !== SEMICOLON$1) {
	            this.error('Semicolon or block is expected');
	        }

	        if (children === null) {
	            children = this.createList();
	        }

	        return {
	            type: 'AtrulePrelude',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node);
	    },
	    walkContext: 'atrulePrelude'
	};

	var TYPE$d = tokenizer.TYPE;

	var IDENT$4 = TYPE$d.Ident;
	var STRING = TYPE$d.String;
	var COLON = TYPE$d.Colon;
	var LEFTSQUAREBRACKET$1 = TYPE$d.LeftSquareBracket;
	var RIGHTSQUAREBRACKET$1 = TYPE$d.RightSquareBracket;
	var DOLLARSIGN = 0x0024;       // U+0024 DOLLAR SIGN ($)
	var ASTERISK$1 = 0x002A;         // U+002A ASTERISK (*)
	var EQUALSSIGN = 0x003D;       // U+003D EQUALS SIGN (=)
	var CIRCUMFLEXACCENT = 0x005E; // U+005E (^)
	var VERTICALLINE$1 = 0x007C;     // U+007C VERTICAL LINE (|)
	var TILDE = 0x007E;            // U+007E TILDE (~)

	function getAttributeName() {
	    if (this.scanner.eof) {
	        this.error('Unexpected end of input');
	    }

	    var start = this.scanner.tokenStart;
	    var expectIdent = false;
	    var checkColon = true;

	    if (this.scanner.isDelim(ASTERISK$1)) {
	        expectIdent = true;
	        checkColon = false;
	        this.scanner.next();
	    } else if (!this.scanner.isDelim(VERTICALLINE$1)) {
	        this.eat(IDENT$4);
	    }

	    if (this.scanner.isDelim(VERTICALLINE$1)) {
	        if (this.scanner.source.charCodeAt(this.scanner.tokenStart + 1) !== EQUALSSIGN) {
	            this.scanner.next();
	            this.eat(IDENT$4);
	        } else if (expectIdent) {
	            this.error('Identifier is expected', this.scanner.tokenEnd);
	        }
	    } else if (expectIdent) {
	        this.error('Vertical line is expected');
	    }

	    if (checkColon && this.scanner.tokenType === COLON) {
	        this.scanner.next();
	        this.eat(IDENT$4);
	    }

	    return {
	        type: 'Identifier',
	        loc: this.getLocation(start, this.scanner.tokenStart),
	        name: this.scanner.substrToCursor(start)
	    };
	}

	function getOperator() {
	    var start = this.scanner.tokenStart;
	    var code = this.scanner.source.charCodeAt(start);

	    if (code !== EQUALSSIGN &&        // =
	        code !== TILDE &&             // ~=
	        code !== CIRCUMFLEXACCENT &&  // ^=
	        code !== DOLLARSIGN &&        // $=
	        code !== ASTERISK$1 &&          // *=
	        code !== VERTICALLINE$1         // |=
	    ) {
	        this.error('Attribute selector (=, ~=, ^=, $=, *=, |=) is expected');
	    }

	    this.scanner.next();

	    if (code !== EQUALSSIGN) {
	        if (!this.scanner.isDelim(EQUALSSIGN)) {
	            this.error('Equal sign is expected');
	        }

	        this.scanner.next();
	    }

	    return this.scanner.substrToCursor(start);
	}

	// '[' <wq-name> ']'
	// '[' <wq-name> <attr-matcher> [ <string-token> | <ident-token> ] <attr-modifier>? ']'
	var AttributeSelector = {
	    name: 'AttributeSelector',
	    structure: {
	        name: 'Identifier',
	        matcher: [String, null],
	        value: ['String', 'Identifier', null],
	        flags: [String, null]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var name;
	        var matcher = null;
	        var value = null;
	        var flags = null;

	        this.eat(LEFTSQUAREBRACKET$1);
	        this.scanner.skipSC();

	        name = getAttributeName.call(this);
	        this.scanner.skipSC();

	        if (this.scanner.tokenType !== RIGHTSQUAREBRACKET$1) {
	            // avoid case `[name i]`
	            if (this.scanner.tokenType !== IDENT$4) {
	                matcher = getOperator.call(this);

	                this.scanner.skipSC();

	                value = this.scanner.tokenType === STRING
	                    ? this.String()
	                    : this.Identifier();

	                this.scanner.skipSC();
	            }

	            // attribute flags
	            if (this.scanner.tokenType === IDENT$4) {
	                flags = this.scanner.getTokenValue();
	                this.scanner.next();

	                this.scanner.skipSC();
	            }
	        }

	        this.eat(RIGHTSQUAREBRACKET$1);

	        return {
	            type: 'AttributeSelector',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            matcher: matcher,
	            value: value,
	            flags: flags
	        };
	    },
	    generate: function(node) {
	        var flagsPrefix = ' ';

	        this.chunk('[');
	        this.node(node.name);

	        if (node.matcher !== null) {
	            this.chunk(node.matcher);

	            if (node.value !== null) {
	                this.node(node.value);

	                // space between string and flags is not required
	                if (node.value.type === 'String') {
	                    flagsPrefix = '';
	                }
	            }
	        }

	        if (node.flags !== null) {
	            this.chunk(flagsPrefix);
	            this.chunk(node.flags);
	        }

	        this.chunk(']');
	    }
	};

	var TYPE$e = tokenizer.TYPE;
	var rawMode$1 = Raw.mode;

	var WHITESPACE$5 = TYPE$e.WhiteSpace;
	var COMMENT$4 = TYPE$e.Comment;
	var SEMICOLON$2 = TYPE$e.Semicolon;
	var ATKEYWORD$1 = TYPE$e.AtKeyword;
	var LEFTCURLYBRACKET$3 = TYPE$e.LeftCurlyBracket;
	var RIGHTCURLYBRACKET$2 = TYPE$e.RightCurlyBracket;

	function consumeRaw$1(startToken) {
	    return this.Raw(startToken, null, true);
	}
	function consumeRule() {
	    return this.parseWithFallback(this.Rule, consumeRaw$1);
	}
	function consumeRawDeclaration(startToken) {
	    return this.Raw(startToken, rawMode$1.semicolonIncluded, true);
	}
	function consumeDeclaration() {
	    if (this.scanner.tokenType === SEMICOLON$2) {
	        return consumeRawDeclaration.call(this, this.scanner.tokenIndex);
	    }

	    var node = this.parseWithFallback(this.Declaration, consumeRawDeclaration);

	    if (this.scanner.tokenType === SEMICOLON$2) {
	        this.scanner.next();
	    }

	    return node;
	}

	var Block = {
	    name: 'Block',
	    structure: {
	        children: [[
	            'Atrule',
	            'Rule',
	            'Declaration'
	        ]]
	    },
	    parse: function(isDeclaration) {
	        var consumer = isDeclaration ? consumeDeclaration : consumeRule;

	        var start = this.scanner.tokenStart;
	        var children = this.createList();

	        this.eat(LEFTCURLYBRACKET$3);

	        scan:
	        while (!this.scanner.eof) {
	            switch (this.scanner.tokenType) {
	                case RIGHTCURLYBRACKET$2:
	                    break scan;

	                case WHITESPACE$5:
	                case COMMENT$4:
	                    this.scanner.next();
	                    break;

	                case ATKEYWORD$1:
	                    children.push(this.parseWithFallback(this.Atrule, consumeRaw$1));
	                    break;

	                default:
	                    children.push(consumer.call(this));
	            }
	        }

	        if (!this.scanner.eof) {
	            this.eat(RIGHTCURLYBRACKET$2);
	        }

	        return {
	            type: 'Block',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk('{');
	        this.children(node, function(prev) {
	            if (prev.type === 'Declaration') {
	                this.chunk(';');
	            }
	        });
	        this.chunk('}');
	    },
	    walkContext: 'block'
	};

	var TYPE$f = tokenizer.TYPE;

	var LEFTSQUAREBRACKET$2 = TYPE$f.LeftSquareBracket;
	var RIGHTSQUAREBRACKET$2 = TYPE$f.RightSquareBracket;

	var Brackets = {
	    name: 'Brackets',
	    structure: {
	        children: [[]]
	    },
	    parse: function(readSequence, recognizer) {
	        var start = this.scanner.tokenStart;
	        var children = null;

	        this.eat(LEFTSQUAREBRACKET$2);

	        children = readSequence.call(this, recognizer);

	        if (!this.scanner.eof) {
	            this.eat(RIGHTSQUAREBRACKET$2);
	        }

	        return {
	            type: 'Brackets',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk('[');
	        this.children(node);
	        this.chunk(']');
	    }
	};

	var CDC = tokenizer.TYPE.CDC;

	var CDC_1 = {
	    name: 'CDC',
	    structure: [],
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        this.eat(CDC); // -->

	        return {
	            type: 'CDC',
	            loc: this.getLocation(start, this.scanner.tokenStart)
	        };
	    },
	    generate: function() {
	        this.chunk('-->');
	    }
	};

	var CDO = tokenizer.TYPE.CDO;

	var CDO_1 = {
	    name: 'CDO',
	    structure: [],
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        this.eat(CDO); // <!--

	        return {
	            type: 'CDO',
	            loc: this.getLocation(start, this.scanner.tokenStart)
	        };
	    },
	    generate: function() {
	        this.chunk('<!--');
	    }
	};

	var TYPE$g = tokenizer.TYPE;

	var IDENT$5 = TYPE$g.Ident;
	var FULLSTOP = 0x002E; // U+002E FULL STOP (.)

	// '.' ident
	var ClassSelector = {
	    name: 'ClassSelector',
	    structure: {
	        name: String
	    },
	    parse: function() {
	        if (!this.scanner.isDelim(FULLSTOP)) {
	            this.error('Full stop is expected');
	        }

	        this.scanner.next();

	        return {
	            type: 'ClassSelector',
	            loc: this.getLocation(this.scanner.tokenStart - 1, this.scanner.tokenEnd),
	            name: this.consume(IDENT$5)
	        };
	    },
	    generate: function(node) {
	        this.chunk('.');
	        this.chunk(node.name);
	    }
	};

	var TYPE$h = tokenizer.TYPE;

	var IDENT$6 = TYPE$h.Ident;
	var PLUSSIGN$4 = 0x002B;        // U+002B PLUS SIGN (+)
	var SOLIDUS = 0x002F;         // U+002F SOLIDUS (/)
	var GREATERTHANSIGN$1 = 0x003E; // U+003E GREATER-THAN SIGN (>)
	var TILDE$1 = 0x007E;           // U+007E TILDE (~)

	// + | > | ~ | /deep/
	var Combinator = {
	    name: 'Combinator',
	    structure: {
	        name: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var code = this.scanner.source.charCodeAt(this.scanner.tokenStart);

	        switch (code) {
	            case GREATERTHANSIGN$1:
	            case PLUSSIGN$4:
	            case TILDE$1:
	                this.scanner.next();
	                break;

	            case SOLIDUS:
	                this.scanner.next();

	                if (this.scanner.tokenType !== IDENT$6 || this.scanner.lookupValue(0, 'deep') === false) {
	                    this.error('Identifier `deep` is expected');
	                }

	                this.scanner.next();

	                if (!this.scanner.isDelim(SOLIDUS)) {
	                    this.error('Solidus is expected');
	                }

	                this.scanner.next();
	                break;

	            default:
	                this.error('Combinator is expected');
	        }

	        return {
	            type: 'Combinator',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: this.scanner.substrToCursor(start)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.name);
	    }
	};

	var TYPE$i = tokenizer.TYPE;

	var COMMENT$5 = TYPE$i.Comment;
	var ASTERISK$2 = 0x002A;        // U+002A ASTERISK (*)
	var SOLIDUS$1 = 0x002F;         // U+002F SOLIDUS (/)

	// '/*' .* '*/'
	var Comment = {
	    name: 'Comment',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var end = this.scanner.tokenEnd;

	        this.eat(COMMENT$5);

	        if ((end - start + 2) >= 2 &&
	            this.scanner.source.charCodeAt(end - 2) === ASTERISK$2 &&
	            this.scanner.source.charCodeAt(end - 1) === SOLIDUS$1) {
	            end -= 2;
	        }

	        return {
	            type: 'Comment',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.source.substring(start + 2, end)
	        };
	    },
	    generate: function(node) {
	        this.chunk('/*');
	        this.chunk(node.value);
	        this.chunk('*/');
	    }
	};

	var isCustomProperty$1 = names.isCustomProperty;
	var TYPE$j = tokenizer.TYPE;
	var rawMode$2 = Raw.mode;

	var IDENT$7 = TYPE$j.Ident;
	var HASH$1 = TYPE$j.Hash;
	var COLON$1 = TYPE$j.Colon;
	var SEMICOLON$3 = TYPE$j.Semicolon;
	var DELIM$2 = TYPE$j.Delim;
	var EXCLAMATIONMARK$2 = 0x0021; // U+0021 EXCLAMATION MARK (!)
	var NUMBERSIGN$2 = 0x0023;      // U+0023 NUMBER SIGN (#)
	var DOLLARSIGN$1 = 0x0024;      // U+0024 DOLLAR SIGN ($)
	var AMPERSAND$1 = 0x0026;       // U+0026 ANPERSAND (&)
	var ASTERISK$3 = 0x002A;        // U+002A ASTERISK (*)
	var PLUSSIGN$5 = 0x002B;        // U+002B PLUS SIGN (+)
	var SOLIDUS$2 = 0x002F;         // U+002F SOLIDUS (/)

	function consumeValueRaw(startToken) {
	    return this.Raw(startToken, rawMode$2.exclamationMarkOrSemicolon, true);
	}

	function consumeCustomPropertyRaw(startToken) {
	    return this.Raw(startToken, rawMode$2.exclamationMarkOrSemicolon, false);
	}

	function consumeValue() {
	    var startValueToken = this.scanner.tokenIndex;
	    var value = this.Value();

	    if (value.type !== 'Raw' &&
	        this.scanner.eof === false &&
	        this.scanner.tokenType !== SEMICOLON$3 &&
	        this.scanner.isDelim(EXCLAMATIONMARK$2) === false &&
	        this.scanner.isBalanceEdge(startValueToken) === false) {
	        this.error();
	    }

	    return value;
	}

	var Declaration = {
	    name: 'Declaration',
	    structure: {
	        important: [Boolean, String],
	        property: String,
	        value: ['Value', 'Raw']
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var startToken = this.scanner.tokenIndex;
	        var property = readProperty$1.call(this);
	        var customProperty = isCustomProperty$1(property);
	        var parseValue = customProperty ? this.parseCustomProperty : this.parseValue;
	        var consumeRaw = customProperty ? consumeCustomPropertyRaw : consumeValueRaw;
	        var important = false;
	        var value;

	        this.scanner.skipSC();
	        this.eat(COLON$1);

	        if (!customProperty) {
	            this.scanner.skipSC();
	        }

	        if (parseValue) {
	            value = this.parseWithFallback(consumeValue, consumeRaw);
	        } else {
	            value = consumeRaw.call(this, this.scanner.tokenIndex);
	        }

	        if (this.scanner.isDelim(EXCLAMATIONMARK$2)) {
	            important = getImportant.call(this);
	            this.scanner.skipSC();
	        }

	        // Do not include semicolon to range per spec
	        // https://drafts.csswg.org/css-syntax/#declaration-diagram

	        if (this.scanner.eof === false &&
	            this.scanner.tokenType !== SEMICOLON$3 &&
	            this.scanner.isBalanceEdge(startToken) === false) {
	            this.error();
	        }

	        return {
	            type: 'Declaration',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            important: important,
	            property: property,
	            value: value
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.property);
	        this.chunk(':');
	        this.node(node.value);

	        if (node.important) {
	            this.chunk(node.important === true ? '!important' : '!' + node.important);
	        }
	    },
	    walkContext: 'declaration'
	};

	function readProperty$1() {
	    var start = this.scanner.tokenStart;

	    // hacks
	    if (this.scanner.tokenType === DELIM$2) {
	        switch (this.scanner.source.charCodeAt(this.scanner.tokenStart)) {
	            case ASTERISK$3:
	            case DOLLARSIGN$1:
	            case PLUSSIGN$5:
	            case NUMBERSIGN$2:
	            case AMPERSAND$1:
	                this.scanner.next();
	                break;

	            // TODO: not sure we should support this hack
	            case SOLIDUS$2:
	                this.scanner.next();
	                if (this.scanner.isDelim(SOLIDUS$2)) {
	                    this.scanner.next();
	                }
	                break;
	        }
	    }

	    if (this.scanner.tokenType === HASH$1) {
	        this.eat(HASH$1);
	    } else {
	        this.eat(IDENT$7);
	    }

	    return this.scanner.substrToCursor(start);
	}

	// ! ws* important
	function getImportant() {
	    this.eat(DELIM$2);
	    this.scanner.skipSC();

	    var important = this.consume(IDENT$7);

	    // store original value in case it differ from `important`
	    // for better original source restoring and hacks like `!ie` support
	    return important === 'important' ? true : important;
	}

	var TYPE$k = tokenizer.TYPE;
	var rawMode$3 = Raw.mode;

	var WHITESPACE$6 = TYPE$k.WhiteSpace;
	var COMMENT$6 = TYPE$k.Comment;
	var SEMICOLON$4 = TYPE$k.Semicolon;

	function consumeRaw$2(startToken) {
	    return this.Raw(startToken, rawMode$3.semicolonIncluded, true);
	}

	var DeclarationList = {
	    name: 'DeclarationList',
	    structure: {
	        children: [[
	            'Declaration'
	        ]]
	    },
	    parse: function() {
	        var children = this.createList();

	        
	        while (!this.scanner.eof) {
	            switch (this.scanner.tokenType) {
	                case WHITESPACE$6:
	                case COMMENT$6:
	                case SEMICOLON$4:
	                    this.scanner.next();
	                    break;

	                default:
	                    children.push(this.parseWithFallback(this.Declaration, consumeRaw$2));
	            }
	        }

	        return {
	            type: 'DeclarationList',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node, function(prev) {
	            if (prev.type === 'Declaration') {
	                this.chunk(';');
	            }
	        });
	    }
	};

	var consumeNumber$3 = utils.consumeNumber;
	var TYPE$l = tokenizer.TYPE;

	var DIMENSION$3 = TYPE$l.Dimension;

	var Dimension = {
	    name: 'Dimension',
	    structure: {
	        value: String,
	        unit: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var numberEnd = consumeNumber$3(this.scanner.source, start);

	        this.eat(DIMENSION$3);

	        return {
	            type: 'Dimension',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.source.substring(start, numberEnd),
	            unit: this.scanner.source.substring(numberEnd, this.scanner.tokenStart)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	        this.chunk(node.unit);
	    }
	};

	var TYPE$m = tokenizer.TYPE;

	var RIGHTPARENTHESIS$2 = TYPE$m.RightParenthesis;

	// <function-token> <sequence> )
	var _Function = {
	    name: 'Function',
	    structure: {
	        name: String,
	        children: [[]]
	    },
	    parse: function(readSequence, recognizer) {
	        var start = this.scanner.tokenStart;
	        var name = this.consumeFunctionName();
	        var nameLowerCase = name.toLowerCase();
	        var children;

	        children = recognizer.hasOwnProperty(nameLowerCase)
	            ? recognizer[nameLowerCase].call(this, recognizer)
	            : readSequence.call(this, recognizer);

	        if (!this.scanner.eof) {
	            this.eat(RIGHTPARENTHESIS$2);
	        }

	        return {
	            type: 'Function',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.name);
	        this.chunk('(');
	        this.children(node);
	        this.chunk(')');
	    },
	    walkContext: 'function'
	};

	var TYPE$n = tokenizer.TYPE;

	var HASH$2 = TYPE$n.Hash;

	// '#' ident
	var HexColor = {
	    name: 'HexColor',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        this.eat(HASH$2);

	        return {
	            type: 'HexColor',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.substrToCursor(start + 1)
	        };
	    },
	    generate: function(node) {
	        this.chunk('#');
	        this.chunk(node.value);
	    }
	};

	var TYPE$o = tokenizer.TYPE;

	var IDENT$8 = TYPE$o.Ident;

	var Identifier = {
	    name: 'Identifier',
	    structure: {
	        name: String
	    },
	    parse: function() {
	        return {
	            type: 'Identifier',
	            loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
	            name: this.consume(IDENT$8)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.name);
	    }
	};

	var TYPE$p = tokenizer.TYPE;

	var HASH$3 = TYPE$p.Hash;

	// <hash-token>
	var IdSelector = {
	    name: 'IdSelector',
	    structure: {
	        name: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        // TODO: check value is an ident
	        this.eat(HASH$3);

	        return {
	            type: 'IdSelector',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: this.scanner.substrToCursor(start + 1)
	        };
	    },
	    generate: function(node) {
	        this.chunk('#');
	        this.chunk(node.name);
	    }
	};

	var TYPE$q = tokenizer.TYPE;

	var IDENT$9 = TYPE$q.Ident;
	var NUMBER$4 = TYPE$q.Number;
	var DIMENSION$4 = TYPE$q.Dimension;
	var LEFTPARENTHESIS$2 = TYPE$q.LeftParenthesis;
	var RIGHTPARENTHESIS$3 = TYPE$q.RightParenthesis;
	var COLON$2 = TYPE$q.Colon;
	var DELIM$3 = TYPE$q.Delim;

	var MediaFeature = {
	    name: 'MediaFeature',
	    structure: {
	        name: String,
	        value: ['Identifier', 'Number', 'Dimension', 'Ratio', null]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var name;
	        var value = null;

	        this.eat(LEFTPARENTHESIS$2);
	        this.scanner.skipSC();

	        name = this.consume(IDENT$9);
	        this.scanner.skipSC();

	        if (this.scanner.tokenType !== RIGHTPARENTHESIS$3) {
	            this.eat(COLON$2);
	            this.scanner.skipSC();

	            switch (this.scanner.tokenType) {
	                case NUMBER$4:
	                    if (this.lookupNonWSType(1) === DELIM$3) {
	                        value = this.Ratio();
	                    } else {
	                        value = this.Number();
	                    }

	                    break;

	                case DIMENSION$4:
	                    value = this.Dimension();
	                    break;

	                case IDENT$9:
	                    value = this.Identifier();

	                    break;

	                default:
	                    this.error('Number, dimension, ratio or identifier is expected');
	            }

	            this.scanner.skipSC();
	        }

	        this.eat(RIGHTPARENTHESIS$3);

	        return {
	            type: 'MediaFeature',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            value: value
	        };
	    },
	    generate: function(node) {
	        this.chunk('(');
	        this.chunk(node.name);
	        if (node.value !== null) {
	            this.chunk(':');
	            this.node(node.value);
	        }
	        this.chunk(')');
	    }
	};

	var TYPE$r = tokenizer.TYPE;

	var WHITESPACE$7 = TYPE$r.WhiteSpace;
	var COMMENT$7 = TYPE$r.Comment;
	var IDENT$a = TYPE$r.Ident;
	var LEFTPARENTHESIS$3 = TYPE$r.LeftParenthesis;

	var MediaQuery = {
	    name: 'MediaQuery',
	    structure: {
	        children: [[
	            'Identifier',
	            'MediaFeature',
	            'WhiteSpace'
	        ]]
	    },
	    parse: function() {
	        this.scanner.skipSC();

	        var children = this.createList();
	        var child = null;
	        var space = null;

	        scan:
	        while (!this.scanner.eof) {
	            switch (this.scanner.tokenType) {
	                case COMMENT$7:
	                    this.scanner.next();
	                    continue;

	                case WHITESPACE$7:
	                    space = this.WhiteSpace();
	                    continue;

	                case IDENT$a:
	                    child = this.Identifier();
	                    break;

	                case LEFTPARENTHESIS$3:
	                    child = this.MediaFeature();
	                    break;

	                default:
	                    break scan;
	            }

	            if (space !== null) {
	                children.push(space);
	                space = null;
	            }

	            children.push(child);
	        }

	        if (child === null) {
	            this.error('Identifier or parenthesis is expected');
	        }

	        return {
	            type: 'MediaQuery',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node);
	    }
	};

	var COMMA$1 = tokenizer.TYPE.Comma;

	var MediaQueryList = {
	    name: 'MediaQueryList',
	    structure: {
	        children: [[
	            'MediaQuery'
	        ]]
	    },
	    parse: function(relative) {
	        var children = this.createList();

	        this.scanner.skipSC();

	        while (!this.scanner.eof) {
	            children.push(this.MediaQuery(relative));

	            if (this.scanner.tokenType !== COMMA$1) {
	                break;
	            }

	            this.scanner.next();
	        }

	        return {
	            type: 'MediaQueryList',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node, function() {
	            this.chunk(',');
	        });
	    }
	};

	var Nth = {
	    name: 'Nth',
	    structure: {
	        nth: ['AnPlusB', 'Identifier'],
	        selector: ['SelectorList', null]
	    },
	    parse: function(allowOfClause) {
	        this.scanner.skipSC();

	        var start = this.scanner.tokenStart;
	        var end = start;
	        var selector = null;
	        var query;

	        if (this.scanner.lookupValue(0, 'odd') || this.scanner.lookupValue(0, 'even')) {
	            query = this.Identifier();
	        } else {
	            query = this.AnPlusB();
	        }

	        this.scanner.skipSC();

	        if (allowOfClause && this.scanner.lookupValue(0, 'of')) {
	            this.scanner.next();

	            selector = this.SelectorList();

	            if (this.needPositions) {
	                end = this.getLastListNode(selector.children).loc.end.offset;
	            }
	        } else {
	            if (this.needPositions) {
	                end = query.loc.end.offset;
	            }
	        }

	        return {
	            type: 'Nth',
	            loc: this.getLocation(start, end),
	            nth: query,
	            selector: selector
	        };
	    },
	    generate: function(node) {
	        this.node(node.nth);
	        if (node.selector !== null) {
	            this.chunk(' of ');
	            this.node(node.selector);
	        }
	    }
	};

	var NUMBER$5 = tokenizer.TYPE.Number;

	var _Number = {
	    name: 'Number',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        return {
	            type: 'Number',
	            loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
	            value: this.consume(NUMBER$5)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    }
	};

	// '/' | '*' | ',' | ':' | '+' | '-'
	var Operator = {
	    name: 'Operator',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        this.scanner.next();

	        return {
	            type: 'Operator',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.substrToCursor(start)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    }
	};

	var TYPE$s = tokenizer.TYPE;

	var LEFTPARENTHESIS$4 = TYPE$s.LeftParenthesis;
	var RIGHTPARENTHESIS$4 = TYPE$s.RightParenthesis;

	var Parentheses = {
	    name: 'Parentheses',
	    structure: {
	        children: [[]]
	    },
	    parse: function(readSequence, recognizer) {
	        var start = this.scanner.tokenStart;
	        var children = null;

	        this.eat(LEFTPARENTHESIS$4);

	        children = readSequence.call(this, recognizer);

	        if (!this.scanner.eof) {
	            this.eat(RIGHTPARENTHESIS$4);
	        }

	        return {
	            type: 'Parentheses',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk('(');
	        this.children(node);
	        this.chunk(')');
	    }
	};

	var consumeNumber$4 = utils.consumeNumber;
	var TYPE$t = tokenizer.TYPE;

	var PERCENTAGE$1 = TYPE$t.Percentage;

	var Percentage = {
	    name: 'Percentage',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var numberEnd = consumeNumber$4(this.scanner.source, start);

	        this.eat(PERCENTAGE$1);

	        return {
	            type: 'Percentage',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.source.substring(start, numberEnd)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	        this.chunk('%');
	    }
	};

	var TYPE$u = tokenizer.TYPE;

	var IDENT$b = TYPE$u.Ident;
	var FUNCTION$1 = TYPE$u.Function;
	var COLON$3 = TYPE$u.Colon;
	var RIGHTPARENTHESIS$5 = TYPE$u.RightParenthesis;

	// : [ <ident> | <function-token> <any-value>? ) ]
	var PseudoClassSelector = {
	    name: 'PseudoClassSelector',
	    structure: {
	        name: String,
	        children: [['Raw'], null]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var children = null;
	        var name;
	        var nameLowerCase;

	        this.eat(COLON$3);

	        if (this.scanner.tokenType === FUNCTION$1) {
	            name = this.consumeFunctionName();
	            nameLowerCase = name.toLowerCase();

	            if (this.pseudo.hasOwnProperty(nameLowerCase)) {
	                this.scanner.skipSC();
	                children = this.pseudo[nameLowerCase].call(this);
	                this.scanner.skipSC();
	            } else {
	                children = this.createList();
	                children.push(
	                    this.Raw(this.scanner.tokenIndex, null, false)
	                );
	            }

	            this.eat(RIGHTPARENTHESIS$5);
	        } else {
	            name = this.consume(IDENT$b);
	        }

	        return {
	            type: 'PseudoClassSelector',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk(':');
	        this.chunk(node.name);

	        if (node.children !== null) {
	            this.chunk('(');
	            this.children(node);
	            this.chunk(')');
	        }
	    },
	    walkContext: 'function'
	};

	var TYPE$v = tokenizer.TYPE;

	var IDENT$c = TYPE$v.Ident;
	var FUNCTION$2 = TYPE$v.Function;
	var COLON$4 = TYPE$v.Colon;
	var RIGHTPARENTHESIS$6 = TYPE$v.RightParenthesis;

	// :: [ <ident> | <function-token> <any-value>? ) ]
	var PseudoElementSelector = {
	    name: 'PseudoElementSelector',
	    structure: {
	        name: String,
	        children: [['Raw'], null]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var children = null;
	        var name;
	        var nameLowerCase;

	        this.eat(COLON$4);
	        this.eat(COLON$4);

	        if (this.scanner.tokenType === FUNCTION$2) {
	            name = this.consumeFunctionName();
	            nameLowerCase = name.toLowerCase();

	            if (this.pseudo.hasOwnProperty(nameLowerCase)) {
	                this.scanner.skipSC();
	                children = this.pseudo[nameLowerCase].call(this);
	                this.scanner.skipSC();
	            } else {
	                children = this.createList();
	                children.push(
	                    this.Raw(this.scanner.tokenIndex, null, false)
	                );
	            }

	            this.eat(RIGHTPARENTHESIS$6);
	        } else {
	            name = this.consume(IDENT$c);
	        }

	        return {
	            type: 'PseudoElementSelector',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk('::');
	        this.chunk(node.name);

	        if (node.children !== null) {
	            this.chunk('(');
	            this.children(node);
	            this.chunk(')');
	        }
	    },
	    walkContext: 'function'
	};

	var isDigit$5 = tokenizer.isDigit;
	var TYPE$w = tokenizer.TYPE;

	var NUMBER$6 = TYPE$w.Number;
	var DELIM$4 = TYPE$w.Delim;
	var SOLIDUS$3 = 0x002F;  // U+002F SOLIDUS (/)
	var FULLSTOP$1 = 0x002E; // U+002E FULL STOP (.)

	// Terms of <ratio> should be a positive numbers (not zero or negative)
	// (see https://drafts.csswg.org/mediaqueries-3/#values)
	// However, -o-min-device-pixel-ratio takes fractional values as a ratio's term
	// and this is using by various sites. Therefore we relax checking on parse
	// to test a term is unsigned number without an exponent part.
	// Additional checking may be applied on lexer validation.
	function consumeNumber$5() {
	    this.scanner.skipWS();

	    var value = this.consume(NUMBER$6);

	    for (var i = 0; i < value.length; i++) {
	        var code = value.charCodeAt(i);
	        if (!isDigit$5(code) && code !== FULLSTOP$1) {
	            this.error('Unsigned number is expected', this.scanner.tokenStart - value.length + i);
	        }
	    }

	    if (Number(value) === 0) {
	        this.error('Zero number is not allowed', this.scanner.tokenStart - value.length);
	    }

	    return value;
	}

	// <positive-integer> S* '/' S* <positive-integer>
	var Ratio = {
	    name: 'Ratio',
	    structure: {
	        left: String,
	        right: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var left = consumeNumber$5.call(this);
	        var right;

	        this.scanner.skipWS();

	        if (!this.scanner.isDelim(SOLIDUS$3)) {
	            this.error('Solidus is expected');
	        }
	        this.eat(DELIM$4);
	        right = consumeNumber$5.call(this);

	        return {
	            type: 'Ratio',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            left: left,
	            right: right
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.left);
	        this.chunk('/');
	        this.chunk(node.right);
	    }
	};

	var TYPE$x = tokenizer.TYPE;
	var rawMode$4 = Raw.mode;

	var LEFTCURLYBRACKET$4 = TYPE$x.LeftCurlyBracket;

	function consumeRaw$3(startToken) {
	    return this.Raw(startToken, rawMode$4.leftCurlyBracket, true);
	}

	function consumePrelude() {
	    var prelude = this.SelectorList();

	    if (prelude.type !== 'Raw' &&
	        this.scanner.eof === false &&
	        this.scanner.tokenType !== LEFTCURLYBRACKET$4) {
	        this.error();
	    }

	    return prelude;
	}

	var Rule = {
	    name: 'Rule',
	    structure: {
	        prelude: ['SelectorList', 'Raw'],
	        block: ['Block']
	    },
	    parse: function() {
	        var startToken = this.scanner.tokenIndex;
	        var startOffset = this.scanner.tokenStart;
	        var prelude;
	        var block;

	        if (this.parseRulePrelude) {
	            prelude = this.parseWithFallback(consumePrelude, consumeRaw$3);
	        } else {
	            prelude = consumeRaw$3.call(this, startToken);
	        }

	        block = this.Block(true);

	        return {
	            type: 'Rule',
	            loc: this.getLocation(startOffset, this.scanner.tokenStart),
	            prelude: prelude,
	            block: block
	        };
	    },
	    generate: function(node) {
	        this.node(node.prelude);
	        this.node(node.block);
	    },
	    walkContext: 'rule'
	};

	var Selector = {
	    name: 'Selector',
	    structure: {
	        children: [[
	            'TypeSelector',
	            'IdSelector',
	            'ClassSelector',
	            'AttributeSelector',
	            'PseudoClassSelector',
	            'PseudoElementSelector',
	            'Combinator',
	            'WhiteSpace'
	        ]]
	    },
	    parse: function() {
	        var children = this.readSequence(this.scope.Selector);

	        // nothing were consumed
	        if (this.getFirstListNode(children) === null) {
	            this.error('Selector is expected');
	        }

	        return {
	            type: 'Selector',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node);
	    }
	};

	var TYPE$y = tokenizer.TYPE;

	var COMMA$2 = TYPE$y.Comma;

	var SelectorList = {
	    name: 'SelectorList',
	    structure: {
	        children: [[
	            'Selector',
	            'Raw'
	        ]]
	    },
	    parse: function() {
	        var children = this.createList();

	        while (!this.scanner.eof) {
	            children.push(this.Selector());

	            if (this.scanner.tokenType === COMMA$2) {
	                this.scanner.next();
	                continue;
	            }

	            break;
	        }

	        return {
	            type: 'SelectorList',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node, function() {
	            this.chunk(',');
	        });
	    },
	    walkContext: 'selector'
	};

	var STRING$1 = tokenizer.TYPE.String;

	var _String = {
	    name: 'String',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        return {
	            type: 'String',
	            loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
	            value: this.consume(STRING$1)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    }
	};

	var TYPE$z = tokenizer.TYPE;

	var WHITESPACE$8 = TYPE$z.WhiteSpace;
	var COMMENT$8 = TYPE$z.Comment;
	var ATKEYWORD$2 = TYPE$z.AtKeyword;
	var CDO$1 = TYPE$z.CDO;
	var CDC$1 = TYPE$z.CDC;
	var EXCLAMATIONMARK$3 = 0x0021; // U+0021 EXCLAMATION MARK (!)

	function consumeRaw$4(startToken) {
	    return this.Raw(startToken, null, false);
	}

	var StyleSheet = {
	    name: 'StyleSheet',
	    structure: {
	        children: [[
	            'Comment',
	            'CDO',
	            'CDC',
	            'Atrule',
	            'Rule',
	            'Raw'
	        ]]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var children = this.createList();
	        var child;

	        
	        while (!this.scanner.eof) {
	            switch (this.scanner.tokenType) {
	                case WHITESPACE$8:
	                    this.scanner.next();
	                    continue;

	                case COMMENT$8:
	                    // ignore comments except exclamation comments (i.e. /*! .. */) on top level
	                    if (this.scanner.source.charCodeAt(this.scanner.tokenStart + 2) !== EXCLAMATIONMARK$3) {
	                        this.scanner.next();
	                        continue;
	                    }

	                    child = this.Comment();
	                    break;

	                case CDO$1: // <!--
	                    child = this.CDO();
	                    break;

	                case CDC$1: // -->
	                    child = this.CDC();
	                    break;

	                // CSS Syntax Module Level 3
	                // §2.2 Error handling
	                // At the "top level" of a stylesheet, an <at-keyword-token> starts an at-rule.
	                case ATKEYWORD$2:
	                    child = this.parseWithFallback(this.Atrule, consumeRaw$4);
	                    break;

	                // Anything else starts a qualified rule ...
	                default:
	                    child = this.parseWithFallback(this.Rule, consumeRaw$4);
	            }

	            children.push(child);
	        }

	        return {
	            type: 'StyleSheet',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node);
	    },
	    walkContext: 'stylesheet'
	};

	var TYPE$A = tokenizer.TYPE;

	var IDENT$d = TYPE$A.Ident;
	var ASTERISK$4 = 0x002A;     // U+002A ASTERISK (*)
	var VERTICALLINE$2 = 0x007C; // U+007C VERTICAL LINE (|)

	function eatIdentifierOrAsterisk() {
	    if (this.scanner.tokenType !== IDENT$d &&
	        this.scanner.isDelim(ASTERISK$4) === false) {
	        this.error('Identifier or asterisk is expected');
	    }

	    this.scanner.next();
	}

	// ident
	// ident|ident
	// ident|*
	// *
	// *|ident
	// *|*
	// |ident
	// |*
	var TypeSelector = {
	    name: 'TypeSelector',
	    structure: {
	        name: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        if (this.scanner.isDelim(VERTICALLINE$2)) {
	            this.scanner.next();
	            eatIdentifierOrAsterisk.call(this);
	        } else {
	            eatIdentifierOrAsterisk.call(this);

	            if (this.scanner.isDelim(VERTICALLINE$2)) {
	                this.scanner.next();
	                eatIdentifierOrAsterisk.call(this);
	            }
	        }

	        return {
	            type: 'TypeSelector',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: this.scanner.substrToCursor(start)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.name);
	    }
	};

	var isHexDigit$4 = tokenizer.isHexDigit;
	var cmpChar$4 = tokenizer.cmpChar;
	var TYPE$B = tokenizer.TYPE;
	var NAME$3 = tokenizer.NAME;

	var IDENT$e = TYPE$B.Ident;
	var NUMBER$7 = TYPE$B.Number;
	var DIMENSION$5 = TYPE$B.Dimension;
	var PLUSSIGN$6 = 0x002B;     // U+002B PLUS SIGN (+)
	var HYPHENMINUS$4 = 0x002D;  // U+002D HYPHEN-MINUS (-)
	var QUESTIONMARK$2 = 0x003F; // U+003F QUESTION MARK (?)
	var U$1 = 0x0075;            // U+0075 LATIN SMALL LETTER U (u)

	function eatHexSequence(offset, allowDash) {
	    for (var pos = this.scanner.tokenStart + offset, len = 0; pos < this.scanner.tokenEnd; pos++) {
	        var code = this.scanner.source.charCodeAt(pos);

	        if (code === HYPHENMINUS$4 && allowDash && len !== 0) {
	            if (eatHexSequence.call(this, offset + len + 1, false) === 0) {
	                this.error();
	            }

	            return -1;
	        }

	        if (!isHexDigit$4(code)) {
	            this.error(
	                allowDash && len !== 0
	                    ? 'HyphenMinus' + (len < 6 ? ' or hex digit' : '') + ' is expected'
	                    : (len < 6 ? 'Hex digit is expected' : 'Unexpected input'),
	                pos
	            );
	        }

	        if (++len > 6) {
	            this.error('Too many hex digits', pos);
	        }    }

	    this.scanner.next();
	    return len;
	}

	function eatQuestionMarkSequence(max) {
	    var count = 0;

	    while (this.scanner.isDelim(QUESTIONMARK$2)) {
	        if (++count > max) {
	            this.error('Too many question marks');
	        }

	        this.scanner.next();
	    }
	}

	function startsWith$1(code) {
	    if (this.scanner.source.charCodeAt(this.scanner.tokenStart) !== code) {
	        this.error(NAME$3[code] + ' is expected');
	    }
	}

	// https://drafts.csswg.org/css-syntax/#urange
	// Informally, the <urange> production has three forms:
	// U+0001
	//      Defines a range consisting of a single code point, in this case the code point "1".
	// U+0001-00ff
	//      Defines a range of codepoints between the first and the second value, in this case
	//      the range between "1" and "ff" (255 in decimal) inclusive.
	// U+00??
	//      Defines a range of codepoints where the "?" characters range over all hex digits,
	//      in this case defining the same as the value U+0000-00ff.
	// In each form, a maximum of 6 digits is allowed for each hexadecimal number (if you treat "?" as a hexadecimal digit).
	//
	// <urange> =
	//   u '+' <ident-token> '?'* |
	//   u <dimension-token> '?'* |
	//   u <number-token> '?'* |
	//   u <number-token> <dimension-token> |
	//   u <number-token> <number-token> |
	//   u '+' '?'+
	function scanUnicodeRange() {
	    var hexLength = 0;

	    // u '+' <ident-token> '?'*
	    // u '+' '?'+
	    if (this.scanner.isDelim(PLUSSIGN$6)) {
	        this.scanner.next();

	        if (this.scanner.tokenType === IDENT$e) {
	            hexLength = eatHexSequence.call(this, 0, true);
	            if (hexLength > 0) {
	                eatQuestionMarkSequence.call(this, 6 - hexLength);
	            }
	            return;
	        }

	        if (this.scanner.isDelim(QUESTIONMARK$2)) {
	            this.scanner.next();
	            eatQuestionMarkSequence.call(this, 5);
	            return;
	        }

	        this.error('Hex digit or question mark is expected');
	        return;
	    }

	    // u <number-token> '?'*
	    // u <number-token> <dimension-token>
	    // u <number-token> <number-token>
	    if (this.scanner.tokenType === NUMBER$7) {
	        startsWith$1.call(this, PLUSSIGN$6);
	        hexLength = eatHexSequence.call(this, 1, true);

	        if (this.scanner.isDelim(QUESTIONMARK$2)) {
	            eatQuestionMarkSequence.call(this, 6 - hexLength);
	            return;
	        }

	        if (this.scanner.tokenType === DIMENSION$5 ||
	            this.scanner.tokenType === NUMBER$7) {
	            startsWith$1.call(this, HYPHENMINUS$4);
	            eatHexSequence.call(this, 1, false);
	            return;
	        }

	        return;
	    }

	    // u <dimension-token> '?'*
	    if (this.scanner.tokenType === DIMENSION$5) {
	        startsWith$1.call(this, PLUSSIGN$6);
	        hexLength = eatHexSequence.call(this, 1, true);

	        if (hexLength > 0) {
	            eatQuestionMarkSequence.call(this, 6 - hexLength);
	        }

	        return;
	    }

	    this.error();
	}

	var UnicodeRange = {
	    name: 'UnicodeRange',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        // U or u
	        if (!cmpChar$4(this.scanner.source, start, U$1)) {
	            this.error('U is expected');
	        }

	        if (!cmpChar$4(this.scanner.source, start + 1, PLUSSIGN$6)) {
	            this.error('Plus sign is expected');
	        }

	        this.scanner.next();
	        scanUnicodeRange.call(this);

	        return {
	            type: 'UnicodeRange',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.substrToCursor(start)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    }
	};

	var isWhiteSpace$2 = tokenizer.isWhiteSpace;
	var cmpStr$4 = tokenizer.cmpStr;
	var TYPE$C = tokenizer.TYPE;

	var FUNCTION$3 = TYPE$C.Function;
	var URL$2 = TYPE$C.Url;
	var RIGHTPARENTHESIS$7 = TYPE$C.RightParenthesis;

	// <url-token> | <function-token> <string> )
	var Url = {
	    name: 'Url',
	    structure: {
	        value: ['String', 'Raw']
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var value;

	        switch (this.scanner.tokenType) {
	            case URL$2:
	                var rawStart = start + 4;
	                var rawEnd = this.scanner.tokenEnd - 1;

	                while (rawStart < rawEnd && isWhiteSpace$2(this.scanner.source.charCodeAt(rawStart))) {
	                    rawStart++;
	                }

	                while (rawStart < rawEnd && isWhiteSpace$2(this.scanner.source.charCodeAt(rawEnd - 1))) {
	                    rawEnd--;
	                }

	                value = {
	                    type: 'Raw',
	                    loc: this.getLocation(rawStart, rawEnd),
	                    value: this.scanner.source.substring(rawStart, rawEnd)
	                };

	                this.eat(URL$2);
	                break;

	            case FUNCTION$3:
	                if (!cmpStr$4(this.scanner.source, this.scanner.tokenStart, this.scanner.tokenEnd, 'url(')) {
	                    this.error('Function name must be `url`');
	                }

	                this.eat(FUNCTION$3);
	                this.scanner.skipSC();
	                value = this.String();
	                this.scanner.skipSC();
	                this.eat(RIGHTPARENTHESIS$7);
	                break;

	            default:
	                this.error('Url or Function is expected');
	        }

	        return {
	            type: 'Url',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: value
	        };
	    },
	    generate: function(node) {
	        this.chunk('url');
	        this.chunk('(');
	        this.node(node.value);
	        this.chunk(')');
	    }
	};

	var Value = {
	    name: 'Value',
	    structure: {
	        children: [[]]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var children = this.readSequence(this.scope.Value);

	        return {
	            type: 'Value',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node);
	    }
	};

	var WHITESPACE$9 = tokenizer.TYPE.WhiteSpace;
	var SPACE$2 = Object.freeze({
	    type: 'WhiteSpace',
	    loc: null,
	    value: ' '
	});

	var WhiteSpace$1 = {
	    name: 'WhiteSpace',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        this.eat(WHITESPACE$9);
	        return SPACE$2;

	        // return {
	        //     type: 'WhiteSpace',
	        //     loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
	        //     value: this.consume(WHITESPACE)
	        // };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    }
	};

	var node = {
	    AnPlusB: AnPlusB,
	    Atrule: Atrule,
	    AtrulePrelude: AtrulePrelude,
	    AttributeSelector: AttributeSelector,
	    Block: Block,
	    Brackets: Brackets,
	    CDC: CDC_1,
	    CDO: CDO_1,
	    ClassSelector: ClassSelector,
	    Combinator: Combinator,
	    Comment: Comment,
	    Declaration: Declaration,
	    DeclarationList: DeclarationList,
	    Dimension: Dimension,
	    Function: _Function,
	    HexColor: HexColor,
	    Identifier: Identifier,
	    IdSelector: IdSelector,
	    MediaFeature: MediaFeature,
	    MediaQuery: MediaQuery,
	    MediaQueryList: MediaQueryList,
	    Nth: Nth,
	    Number: _Number,
	    Operator: Operator,
	    Parentheses: Parentheses,
	    Percentage: Percentage,
	    PseudoClassSelector: PseudoClassSelector,
	    PseudoElementSelector: PseudoElementSelector,
	    Ratio: Ratio,
	    Raw: Raw,
	    Rule: Rule,
	    Selector: Selector,
	    SelectorList: SelectorList,
	    String: _String,
	    StyleSheet: StyleSheet,
	    TypeSelector: TypeSelector,
	    UnicodeRange: UnicodeRange,
	    Url: Url,
	    Value: Value,
	    WhiteSpace: WhiteSpace$1
	};

	var lexer = {
	    generic: true,
	    types: data.types,
	    atrules: data.atrules,
	    properties: data.properties,
	    node: node
	};

	var cmpChar$5 = tokenizer.cmpChar;
	var cmpStr$5 = tokenizer.cmpStr;
	var TYPE$D = tokenizer.TYPE;

	var IDENT$f = TYPE$D.Ident;
	var STRING$2 = TYPE$D.String;
	var NUMBER$8 = TYPE$D.Number;
	var FUNCTION$4 = TYPE$D.Function;
	var URL$3 = TYPE$D.Url;
	var HASH$4 = TYPE$D.Hash;
	var DIMENSION$6 = TYPE$D.Dimension;
	var PERCENTAGE$2 = TYPE$D.Percentage;
	var LEFTPARENTHESIS$5 = TYPE$D.LeftParenthesis;
	var LEFTSQUAREBRACKET$3 = TYPE$D.LeftSquareBracket;
	var COMMA$3 = TYPE$D.Comma;
	var DELIM$5 = TYPE$D.Delim;
	var NUMBERSIGN$3 = 0x0023;  // U+0023 NUMBER SIGN (#)
	var ASTERISK$5 = 0x002A;    // U+002A ASTERISK (*)
	var PLUSSIGN$7 = 0x002B;    // U+002B PLUS SIGN (+)
	var HYPHENMINUS$5 = 0x002D; // U+002D HYPHEN-MINUS (-)
	var SOLIDUS$4 = 0x002F;     // U+002F SOLIDUS (/)
	var U$2 = 0x0075;           // U+0075 LATIN SMALL LETTER U (u)

	var _default = function defaultRecognizer(context) {
	    switch (this.scanner.tokenType) {
	        case HASH$4:
	            return this.HexColor();

	        case COMMA$3:
	            context.space = null;
	            context.ignoreWSAfter = true;
	            return this.Operator();

	        case LEFTPARENTHESIS$5:
	            return this.Parentheses(this.readSequence, context.recognizer);

	        case LEFTSQUAREBRACKET$3:
	            return this.Brackets(this.readSequence, context.recognizer);

	        case STRING$2:
	            return this.String();

	        case DIMENSION$6:
	            return this.Dimension();

	        case PERCENTAGE$2:
	            return this.Percentage();

	        case NUMBER$8:
	            return this.Number();

	        case FUNCTION$4:
	            return cmpStr$5(this.scanner.source, this.scanner.tokenStart, this.scanner.tokenEnd, 'url(')
	                ? this.Url()
	                : this.Function(this.readSequence, context.recognizer);

	        case URL$3:
	            return this.Url();

	        case IDENT$f:
	            // check for unicode range, it should start with u+ or U+
	            if (cmpChar$5(this.scanner.source, this.scanner.tokenStart, U$2) &&
	                cmpChar$5(this.scanner.source, this.scanner.tokenStart + 1, PLUSSIGN$7)) {
	                return this.UnicodeRange();
	            } else {
	                return this.Identifier();
	            }

	        case DELIM$5:
	            var code = this.scanner.source.charCodeAt(this.scanner.tokenStart);

	            if (code === SOLIDUS$4 ||
	                code === ASTERISK$5 ||
	                code === PLUSSIGN$7 ||
	                code === HYPHENMINUS$5) {
	                return this.Operator(); // TODO: replace with Delim
	            }

	            // TODO: produce a node with Delim node type

	            if (code === NUMBERSIGN$3) {
	                this.error('Hex or identifier is expected', this.scanner.tokenStart + 1);
	            }

	            break;
	    }
	};

	var atrulePrelude = {
	    getNode: _default
	};

	var TYPE$E = tokenizer.TYPE;

	var DELIM$6 = TYPE$E.Delim;
	var IDENT$g = TYPE$E.Ident;
	var DIMENSION$7 = TYPE$E.Dimension;
	var PERCENTAGE$3 = TYPE$E.Percentage;
	var NUMBER$9 = TYPE$E.Number;
	var HASH$5 = TYPE$E.Hash;
	var COLON$5 = TYPE$E.Colon;
	var LEFTSQUAREBRACKET$4 = TYPE$E.LeftSquareBracket;
	var NUMBERSIGN$4 = 0x0023;      // U+0023 NUMBER SIGN (#)
	var ASTERISK$6 = 0x002A;        // U+002A ASTERISK (*)
	var PLUSSIGN$8 = 0x002B;        // U+002B PLUS SIGN (+)
	var SOLIDUS$5 = 0x002F;         // U+002F SOLIDUS (/)
	var FULLSTOP$2 = 0x002E;        // U+002E FULL STOP (.)
	var GREATERTHANSIGN$2 = 0x003E; // U+003E GREATER-THAN SIGN (>)
	var VERTICALLINE$3 = 0x007C;    // U+007C VERTICAL LINE (|)
	var TILDE$2 = 0x007E;           // U+007E TILDE (~)

	function getNode(context) {
	    switch (this.scanner.tokenType) {
	        case LEFTSQUAREBRACKET$4:
	            return this.AttributeSelector();

	        case HASH$5:
	            return this.IdSelector();

	        case COLON$5:
	            if (this.scanner.lookupType(1) === COLON$5) {
	                return this.PseudoElementSelector();
	            } else {
	                return this.PseudoClassSelector();
	            }

	        case IDENT$g:
	            return this.TypeSelector();

	        case NUMBER$9:
	        case PERCENTAGE$3:
	            return this.Percentage();

	        case DIMENSION$7:
	            // throws when .123ident
	            if (this.scanner.source.charCodeAt(this.scanner.tokenStart) === FULLSTOP$2) {
	                this.error('Identifier is expected', this.scanner.tokenStart + 1);
	            }
	            break;

	        case DELIM$6:
	            var code = this.scanner.source.charCodeAt(this.scanner.tokenStart);

	            switch (code) {
	                case PLUSSIGN$8:
	                case GREATERTHANSIGN$2:
	                case TILDE$2:
	                    context.space = null;
	                    context.ignoreWSAfter = true;
	                    return this.Combinator();

	                case SOLIDUS$5:  // /deep/
	                    return this.Combinator();

	                case FULLSTOP$2:
	                    return this.ClassSelector();

	                case ASTERISK$6:
	                case VERTICALLINE$3:
	                    return this.TypeSelector();

	                case NUMBERSIGN$4:
	                    return this.IdSelector();
	            }

	            break;
	    }
	}
	var selector = {
	    getNode: getNode
	};

	// https://drafts.csswg.org/css-images-4/#element-notation
	// https://developer.mozilla.org/en-US/docs/Web/CSS/element
	var element = function() {
	    this.scanner.skipSC();

	    var children = this.createSingleNodeList(
	        this.IdSelector()
	    );

	    this.scanner.skipSC();

	    return children;
	};

	// legacy IE function
	// expression( <any-value> )
	var expression = function() {
	    return this.createSingleNodeList(
	        this.Raw(this.scanner.tokenIndex, null, false)
	    );
	};

	var TYPE$F = tokenizer.TYPE;
	var rawMode$5 = Raw.mode;

	var COMMA$4 = TYPE$F.Comma;

	// var( <ident> , <value>? )
	var _var = function() {
	    var children = this.createList();

	    this.scanner.skipSC();

	    // NOTE: Don't check more than a first argument is an ident, rest checks are for lexer
	    children.push(this.Identifier());

	    this.scanner.skipSC();

	    if (this.scanner.tokenType === COMMA$4) {
	        children.push(this.Operator());
	        children.push(this.parseCustomProperty
	            ? this.Value(null)
	            : this.Raw(this.scanner.tokenIndex, rawMode$5.exclamationMarkOrSemicolon, false)
	        );
	    }

	    return children;
	};

	var value = {
	    getNode: _default,
	    '-moz-element': element,
	    'element': element,
	    'expression': expression,
	    'var': _var
	};

	var scope = {
	    AtrulePrelude: atrulePrelude,
	    Selector: selector,
	    Value: value
	};

	var fontFace = {
	    parse: {
	        prelude: null,
	        block: function() {
	            return this.Block(true);
	        }
	    }
	};

	var TYPE$G = tokenizer.TYPE;

	var STRING$3 = TYPE$G.String;
	var IDENT$h = TYPE$G.Ident;
	var URL$4 = TYPE$G.Url;
	var FUNCTION$5 = TYPE$G.Function;
	var LEFTPARENTHESIS$6 = TYPE$G.LeftParenthesis;

	var _import = {
	    parse: {
	        prelude: function() {
	            var children = this.createList();

	            this.scanner.skipSC();

	            switch (this.scanner.tokenType) {
	                case STRING$3:
	                    children.push(this.String());
	                    break;

	                case URL$4:
	                case FUNCTION$5:
	                    children.push(this.Url());
	                    break;

	                default:
	                    this.error('String or url() is expected');
	            }

	            if (this.lookupNonWSType(0) === IDENT$h ||
	                this.lookupNonWSType(0) === LEFTPARENTHESIS$6) {
	                children.push(this.WhiteSpace());
	                children.push(this.MediaQueryList());
	            }

	            return children;
	        },
	        block: null
	    }
	};

	var media = {
	    parse: {
	        prelude: function() {
	            return this.createSingleNodeList(
	                this.MediaQueryList()
	            );
	        },
	        block: function() {
	            return this.Block(false);
	        }
	    }
	};

	var page = {
	    parse: {
	        prelude: function() {
	            return this.createSingleNodeList(
	                this.SelectorList()
	            );
	        },
	        block: function() {
	            return this.Block(true);
	        }
	    }
	};

	var TYPE$H = tokenizer.TYPE;

	var WHITESPACE$a = TYPE$H.WhiteSpace;
	var COMMENT$9 = TYPE$H.Comment;
	var IDENT$i = TYPE$H.Ident;
	var FUNCTION$6 = TYPE$H.Function;
	var COLON$6 = TYPE$H.Colon;
	var LEFTPARENTHESIS$7 = TYPE$H.LeftParenthesis;

	function consumeRaw$5() {
	    return this.createSingleNodeList(
	        this.Raw(this.scanner.tokenIndex, null, false)
	    );
	}

	function parentheses() {
	    this.scanner.skipSC();

	    if (this.scanner.tokenType === IDENT$i &&
	        this.lookupNonWSType(1) === COLON$6) {
	        return this.createSingleNodeList(
	            this.Declaration()
	        );
	    }

	    return readSequence.call(this);
	}

	function readSequence() {
	    var children = this.createList();
	    var space = null;
	    var child;

	    this.scanner.skipSC();

	    scan:
	    while (!this.scanner.eof) {
	        switch (this.scanner.tokenType) {
	            case WHITESPACE$a:
	                space = this.WhiteSpace();
	                continue;

	            case COMMENT$9:
	                this.scanner.next();
	                continue;

	            case FUNCTION$6:
	                child = this.Function(consumeRaw$5, this.scope.AtrulePrelude);
	                break;

	            case IDENT$i:
	                child = this.Identifier();
	                break;

	            case LEFTPARENTHESIS$7:
	                child = this.Parentheses(parentheses, this.scope.AtrulePrelude);
	                break;

	            default:
	                break scan;
	        }

	        if (space !== null) {
	            children.push(space);
	            space = null;
	        }

	        children.push(child);
	    }

	    return children;
	}

	var supports = {
	    parse: {
	        prelude: function() {
	            var children = readSequence.call(this);

	            if (this.getFirstListNode(children) === null) {
	                this.error('Condition is expected');
	            }

	            return children;
	        },
	        block: function() {
	            return this.Block(false);
	        }
	    }
	};

	var atrule = {
	    'font-face': fontFace,
	    'import': _import,
	    'media': media,
	    'page': page,
	    'supports': supports
	};

	var dir = {
	    parse: function() {
	        return this.createSingleNodeList(
	            this.Identifier()
	        );
	    }
	};

	var has$1 = {
	    parse: function() {
	        return this.createSingleNodeList(
	            this.SelectorList()
	        );
	    }
	};

	var lang = {
	    parse: function() {
	        return this.createSingleNodeList(
	            this.Identifier()
	        );
	    }
	};

	var selectorList = {
	    parse: function selectorList() {
	        return this.createSingleNodeList(
	            this.SelectorList()
	        );
	    }
	};

	var matches = selectorList;

	var not = selectorList;

	var ALLOW_OF_CLAUSE = true;

	var nthWithOfClause = {
	    parse: function nthWithOfClause() {
	        return this.createSingleNodeList(
	            this.Nth(ALLOW_OF_CLAUSE)
	        );
	    }
	};

	var nthChild = nthWithOfClause;

	var nthLastChild = nthWithOfClause;

	var DISALLOW_OF_CLAUSE = false;

	var nth$1 = {
	    parse: function nth() {
	        return this.createSingleNodeList(
	            this.Nth(DISALLOW_OF_CLAUSE)
	        );
	    }
	};

	var nthLastOfType = nth$1;

	var nthOfType = nth$1;

	var slotted = {
	    parse: function compoundSelector() {
	        return this.createSingleNodeList(
	            this.Selector()
	        );
	    }
	};

	var pseudo = {
	    'dir': dir,
	    'has': has$1,
	    'lang': lang,
	    'matches': matches,
	    'not': not,
	    'nth-child': nthChild,
	    'nth-last-child': nthLastChild,
	    'nth-last-of-type': nthLastOfType,
	    'nth-of-type': nthOfType,
	    'slotted': slotted
	};

	var parser = {
	    parseContext: {
	        default: 'StyleSheet',
	        stylesheet: 'StyleSheet',
	        atrule: 'Atrule',
	        atrulePrelude: function(options) {
	            return this.AtrulePrelude(options.atrule ? String(options.atrule) : null);
	        },
	        mediaQueryList: 'MediaQueryList',
	        mediaQuery: 'MediaQuery',
	        rule: 'Rule',
	        selectorList: 'SelectorList',
	        selector: 'Selector',
	        block: function() {
	            return this.Block(true);
	        },
	        declarationList: 'DeclarationList',
	        declaration: 'Declaration',
	        value: 'Value'
	    },
	    scope: scope,
	    atrule: atrule,
	    pseudo: pseudo,
	    node: node
	};

	var walker = {
	    node: node
	};

	function merge() {
	    var dest = {};

	    for (var i = 0; i < arguments.length; i++) {
	        var src = arguments[i];
	        for (var key in src) {
	            dest[key] = src[key];
	        }
	    }

	    return dest;
	}

	var syntax = create$5.create(
	    merge(
	        lexer,
	        parser,
	        walker
	    )
	);

	var lib = syntax;

	class Sheet {
		constructor(url, hooks) {

			if (hooks) {
				this.hooks = hooks;
			} else {
				this.hooks = {};
				this.hooks.onUrl = new Hook(this);
				this.hooks.onAtPage = new Hook(this);
				this.hooks.onAtMedia = new Hook(this);
				this.hooks.onRule = new Hook(this);
				this.hooks.onDeclaration = new Hook(this);
				this.hooks.onSelector = new Hook(this);
				this.hooks.onPseudoSelector = new Hook(this);

				this.hooks.onContent = new Hook(this);
				this.hooks.onImport = new Hook(this);

				this.hooks.beforeTreeParse = new Hook(this);
				this.hooks.beforeTreeWalk = new Hook(this);
				this.hooks.afterTreeWalk = new Hook(this);
			}

			try {
				this.url = new URL(url, window.location.href);
			} catch (e) {
				this.url = new URL(window.location.href);
			}
		}



		// parse
		async parse(text) {
			this.text = text;

			await this.hooks.beforeTreeParse.trigger(this.text, this);

			// send to csstree
			this.ast = lib.parse(this._text);

			await this.hooks.beforeTreeWalk.trigger(this.ast);

			// Replace urls
			this.replaceUrls(this.ast);

			// Scope
			this.id = UUID();
			// this.addScope(this.ast, this.uuid);

			// Replace IDs with data-id
			this.replaceIds(this.ast);

			this.imported = [];

			// Trigger Hooks
			this.urls(this.ast);
			this.rules(this.ast);
			this.atrules(this.ast);

			await this.hooks.afterTreeWalk.trigger(this.ast, this);

			// return ast
			return this.ast;
		}



		insertRule(rule) {
			let inserted = this.ast.children.appendData(rule);
			inserted.forEach((item) => {
				this.declarations(item);
			});
		}

		urls(ast) {
			lib.walk(ast, {
				visit: "Url",
				enter: (node, item, list) => {
					this.hooks.onUrl.trigger(node, item, list);
				}
			});
		}

		atrules(ast) {
			lib.walk(ast, {
				visit: "Atrule",
				enter: (node, item, list) => {
					const basename = lib.keyword(node.name).basename;

					if (basename === "page") {
						this.hooks.onAtPage.trigger(node, item, list);
						this.declarations(node, item, list);
					}

					if (basename === "media") {
						this.hooks.onAtMedia.trigger(node, item, list);
						this.declarations(node, item, list);
					}

					if (basename === "import") {
						this.hooks.onImport.trigger(node, item, list);
						this.imports(node, item, list);
					}
				}
			});
		}


		rules(ast) {
			lib.walk(ast, {
				visit: "Rule",
				enter: (ruleNode, ruleItem, rulelist) => {
					// console.log("rule", ruleNode);

					this.hooks.onRule.trigger(ruleNode, ruleItem, rulelist);
					this.declarations(ruleNode, ruleItem, rulelist);
					this.onSelector(ruleNode, ruleItem, rulelist);

				}
			});
		}

		declarations(ruleNode, ruleItem, rulelist) {
			lib.walk(ruleNode, {
				visit: "Declaration",
				enter: (declarationNode, dItem, dList) => {
					// console.log(declarationNode);

					this.hooks.onDeclaration.trigger(declarationNode, dItem, dList, {ruleNode, ruleItem, rulelist});

					if (declarationNode.property === "content") {
						lib.walk(declarationNode, {
							visit: "Function",
							enter: (funcNode, fItem, fList) => {
								this.hooks.onContent.trigger(funcNode, fItem, fList, {declarationNode, dItem, dList}, {ruleNode, ruleItem, rulelist});
							}
						});
					}

				}
			});
		}

		// add pseudo elements to parser
		onSelector(ruleNode, ruleItem, rulelist) {
			lib.walk(ruleNode, {
				visit: "Selector",
				enter: (selectNode, selectItem, selectList) => {
					// console.log(selectNode);
					this.hooks.onSelector.trigger(selectNode, selectItem, selectList, {ruleNode, ruleItem, rulelist});

					if (selectNode.children.forEach(node => {if (node.type === "PseudoElementSelector") {
						lib.walk(node, {
							visit: "PseudoElementSelector",
							enter: (pseudoNode, pItem, pList) => {
								this.hooks.onPseudoSelector.trigger(pseudoNode, pItem, pList, {selectNode, selectItem, selectList}, {ruleNode, ruleItem, rulelist});
							}
						});
					}}));
					// else {
					// 	console.log("dommage");
					// }

				}
			});
		}

		replaceUrls(ast) {
			lib.walk(ast, {
				visit: "Url",
				enter: (node, item, list) => {
					let content = node.value.value;
					if ((node.value.type === "Raw" && content.startsWith("data:")) || (node.value.type === "String" && (content.startsWith("\"data:") || content.startsWith("'data:")))) ; else {
						let href = content.replace(/["']/g, "");
						let url = new URL(href, this.url);
						node.value.value = url.toString();
					}
				}
			});
		}

		addScope(ast, id) {
			// Get all selector lists
			// add an id
			lib.walk(ast, {
				visit: "Selector",
				enter: (node, item, list) => {
					let children = node.children;
					children.prepend(children.createItem({
						type: "WhiteSpace",
						value: " "
					}));
					children.prepend(children.createItem({
						type: "IdSelector",
						name: id,
						loc: null,
						children: null
					}));
				}
			});
		}

		getNamedPageSelectors(ast) {
			let namedPageSelectors = {};
			lib.walk(ast, {
				visit: "Rule",
				enter: (node, item, list) => {
					lib.walk(node, {
						visit: "Declaration",
						enter: (declaration, dItem, dList) => {
							if (declaration.property === "page") {
								let value = declaration.value.children.first();
								let name = value.name;
								let selector = lib.generate(node.prelude);
								namedPageSelectors[name] = {
									name: name,
									selector: selector
								};

								// dList.remove(dItem);

								// Add in page break
								declaration.property = "break-before";
								value.type = "Identifier";
								value.name = "always";

							}
						}
					});
				}
			});
			return namedPageSelectors;
		}

		replaceIds(ast) {
			lib.walk(ast, {
				visit: "Rule",
				enter: (node, item, list) => {

					lib.walk(node, {
						visit: "IdSelector",
						enter: (idNode, idItem, idList) => {
							let name = idNode.name;
							idNode.flags = null;
							idNode.matcher = "=";
							idNode.name = {type: "Identifier", loc: null, name: "data-id"};
							idNode.type = "AttributeSelector";
							idNode.value = {type: "String", loc: null, value: `"${name}"`};
						}
					});
				}
			});
		}

		imports(node, item, list) {
			// console.log("import", node, item, list);
			let queries = [];
			lib.walk(node, {
				visit: "MediaQuery",
				enter: (mqNode, mqItem, mqList) => {
					lib.walk(mqNode, {
						visit: "Identifier",
						enter: (identNode, identItem, identList) => {
							queries.push(identNode.name);
						}
					});
				}
			});

			// Just basic media query support for now
			let shouldNotApply = queries.some((query, index) => {
				let q = query;
				if (q === "not") {
					q = queries[index + 1];
					return !(q === "screen" || q === "speech");
				} else {
					return (q === "screen" || q === "speech");
				}
			});

			if (shouldNotApply) {
				return;
			}

			lib.walk(node, {
				visit: "String",
				enter: (urlNode, urlItem, urlList) => {
					let href = urlNode.value.replace(/["']/g, "");
					let url = new URL(href, this.url);
					let value = url.toString();

					this.imported.push(value);

					// Remove the original
					list.remove(item);
				}
			});
		}

		set text(t) {
			this._text = t;
		}

		get text() {
			return this._text;
		}

		// generate string
		toString(ast) {
			return lib.generate(ast || this.ast);
		}
	}

	var baseStyles = `
:root {
	--pagedjs-width: 8.5in;
	--pagedjs-height: 11in;
	--pagedjs-width-right: 8.5in;
	--pagedjs-height-right: 11in;
	--pagedjs-width-left: 8.5in;
	--pagedjs-height-left: 11in;
	--pagedjs-pagebox-width: 8.5in;
	--pagedjs-pagebox-height: 11in;
	--pagedjs-margin-top: 1in;
	--pagedjs-margin-right: 1in;
	--pagedjs-margin-bottom: 1in;
	--pagedjs-margin-left: 1in;
	--pagedjs-padding-top: 0mm;
	--pagedjs-padding-right: 0mm;
	--pagedjs-padding-bottom: 0mm;
	--pagedjs-padding-left: 0mm;
	--pagedjs-border-top: 0mm;
	--pagedjs-border-right: 0mm;
	--pagedjs-border-bottom: 0mm;
	--pagedjs-border-left: 0mm;
	--pagedjs-bleed-top: 0mm;
	--pagedjs-bleed-right: 0mm;
	--pagedjs-bleed-bottom: 0mm;
	--pagedjs-bleed-left: 0mm;
	--pagedjs-bleed-right-top: 0mm;
	--pagedjs-bleed-right-right: 0mm;
	--pagedjs-bleed-right-bottom: 0mm;
	--pagedjs-bleed-right-left: 0mm;
	--pagedjs-bleed-left-top: 0mm;
	--pagedjs-bleed-left-right: 0mm;
	--pagedjs-bleed-left-bottom: 0mm;
	--pagedjs-bleed-left-left: 0mm;
	--pagedjs-crop-color: black;
	--pagedjs-crop-offset: 2mm;
	--pagedjs-crop-stroke: 1px;
	--pagedjs-cross-size: 5mm;
	--pagedjs-mark-cross-display: none;
	--pagedjs-mark-crop-display: none;
	--pagedjs-page-count: 0;
	--pagedjs-page-counter-increment: 1;
}

@page {
	size: letter;
	margin: 0;
}

.pagedjs_sheet {
	box-sizing: border-box;
	width: var(--pagedjs-width);
	height: var(--pagedjs-height);
	overflow: hidden;
	position: relative;
	display: grid;
	grid-template-columns: [bleed-left] var(--pagedjs-bleed-left) [sheet-center] calc(var(--pagedjs-width) - var(--pagedjs-bleed-left) - var(--pagedjs-bleed-right)) [bleed-right] var(--pagedjs-bleed-right);
	grid-template-rows: [bleed-top] var(--pagedjs-bleed-top) [sheet-middle] calc(var(--pagedjs-height) - var(--pagedjs-bleed-top) - var(--pagedjs-bleed-bottom)) [bleed-bottom] var(--pagedjs-bleed-bottom);
}

.pagedjs_right_page .pagedjs_sheet {
	width: var(--pagedjs-width-right);
	height: var(--pagedjs-height-right);
	grid-template-columns: [bleed-left] var(--pagedjs-bleed-right-left) [sheet-center] calc(var(--pagedjs-width) - var(--pagedjs-bleed-right-left) - var(--pagedjs-bleed-right-right)) [bleed-right] var(--pagedjs-bleed-right-right);
	grid-template-rows: [bleed-top] var(--pagedjs-bleed-right-top) [sheet-middle] calc(var(--pagedjs-height) - var(--pagedjs-bleed-right-top) - var(--pagedjs-bleed-right-bottom)) [bleed-bottom] var(--pagedjs-bleed-right-bottom);
}

.pagedjs_left_page .pagedjs_sheet {
	width: var(--pagedjs-width-left);
	height: var(--pagedjs-height-left);
	grid-template-columns: [bleed-left] var(--pagedjs-bleed-left-left) [sheet-center] calc(var(--pagedjs-width) - var(--pagedjs-bleed-left-left) - var(--pagedjs-bleed-left-right)) [bleed-right] var(--pagedjs-bleed-left-right);
	grid-template-rows: [bleed-top] var(--pagedjs-bleed-left-top) [sheet-middle] calc(var(--pagedjs-height) - var(--pagedjs-bleed-left-top) - var(--pagedjs-bleed-left-bottom)) [bleed-bottom] var(--pagedjs-bleed-left-bottom);
}

.pagedjs_bleed {
	display: flex;
	align-items: center;
	justify-content: center;
	flex-wrap: nowrap;
	overflow: hidden;
}

.pagedjs_bleed-top {
	grid-column: bleed-left / -1;
	grid-row: bleed-top;
	flex-direction: row;
}

.pagedjs_bleed-bottom {
	grid-column: bleed-left / -1;
	grid-row: bleed-bottom;
	flex-direction: row;
}

.pagedjs_bleed-left {
	grid-column: bleed-left;
	grid-row: bleed-top / -1;
	flex-direction: column;
}

.pagedjs_bleed-right {
	grid-column: bleed-right;
	grid-row: bleed-top / -1;
	flex-direction: column;
}

.pagedjs_marks-crop {
	display: var(--pagedjs-mark-crop-display);
	flex-grow: 0;
	flex-shrink: 0;
	z-index: 9999999999;
}

.pagedjs_bleed-top .pagedjs_marks-crop:nth-child(1),
.pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(1) {
	width: calc(var(--pagedjs-bleed-left) - var(--pagedjs-crop-stroke));
	border-right: var(--pagedjs-crop-stroke) solid var(--pagedjs-crop-color);
}

.pagedjs_right_page .pagedjs_bleed-top .pagedjs_marks-crop:nth-child(1),
.pagedjs_right_page .pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(1) {
	width: calc(var(--pagedjs-bleed-right-left) - var(--pagedjs-crop-stroke));
}

.pagedjs_left_page .pagedjs_bleed-top .pagedjs_marks-crop:nth-child(1),
.pagedjs_left_page .pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(1) {
	width: calc(var(--pagedjs-bleed-left-left) - var(--pagedjs-crop-stroke));
}

.pagedjs_bleed-top .pagedjs_marks-crop:nth-child(3),
.pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(3) {
	width: calc(var(--pagedjs-bleed-right) - var(--pagedjs-crop-stroke));
	border-left: var(--pagedjs-crop-stroke) solid var(--pagedjs-crop-color);
}

.pagedjs_right_page .pagedjs_bleed-top .pagedjs_marks-crop:nth-child(3),
.pagedjs_right_page .pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(3) {
	width: calc(var(--pagedjs-bleed-right-right) - var(--pagedjs-crop-stroke));
}

.pagedjs_left_page .pagedjs_bleed-top .pagedjs_marks-crop:nth-child(3),
.pagedjs_left_page .pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(3) {
	width: calc(var(--pagedjs-bleed-left-right) - var(--pagedjs-crop-stroke));
}

.pagedjs_bleed-top .pagedjs_marks-crop {
	align-self: flex-start;
	height: calc(var(--pagedjs-bleed-top) - var(--pagedjs-crop-offset));
}

.pagedjs_right_page .pagedjs_bleed-top .pagedjs_marks-crop {
	height: calc(var(--pagedjs-bleed-right-top) - var(--pagedjs-crop-offset));
}

.pagedjs_left_page .pagedjs_bleed-top .pagedjs_marks-crop {
	height: calc(var(--pagedjs-bleed-left-top) - var(--pagedjs-crop-offset));
}

.pagedjs_bleed-bottom .pagedjs_marks-crop {
	align-self: flex-end;
	height: calc(var(--pagedjs-bleed-bottom) - var(--pagedjs-crop-offset));
}

.pagedjs_right_page .pagedjs_bleed-bottom .pagedjs_marks-crop {
	height: calc(var(--pagedjs-bleed-right-bottom) - var(--pagedjs-crop-offset));
}

.pagedjs_left_page .pagedjs_bleed-bottom .pagedjs_marks-crop {
	height: calc(var(--pagedjs-bleed-left-bottom) - var(--pagedjs-crop-offset));
}

.pagedjs_bleed-left .pagedjs_marks-crop:nth-child(1),
.pagedjs_bleed-right .pagedjs_marks-crop:nth-child(1) {
	height: calc(var(--pagedjs-bleed-top) - var(--pagedjs-crop-stroke));
	border-bottom: var(--pagedjs-crop-stroke) solid var(--pagedjs-crop-color);
}

.pagedjs_right_page .pagedjs_bleed-left .pagedjs_marks-crop:nth-child(1),
.pagedjs_right_page .pagedjs_bleed-right .pagedjs_marks-crop:nth-child(1) {
	height: calc(var(--pagedjs-bleed-right-top) - var(--pagedjs-crop-stroke));
}

.pagedjs_left_page .pagedjs_bleed-left .pagedjs_marks-crop:nth-child(1),
.pagedjs_left_page .pagedjs_bleed-right .pagedjs_marks-crop:nth-child(1) {
	height: calc(var(--pagedjs-bleed-left-top) - var(--pagedjs-crop-stroke));
}

.pagedjs_bleed-left .pagedjs_marks-crop:nth-child(3),
.pagedjs_bleed-right .pagedjs_marks-crop:nth-child(3) {
	height: calc(var(--pagedjs-bleed-bottom) - var(--pagedjs-crop-stroke));
	border-top: var(--pagedjs-crop-stroke) solid var(--pagedjs-crop-color);
}

.pagedjs_right_page .pagedjs_bleed-left .pagedjs_marks-crop:nth-child(3),
.pagedjs_right_page .pagedjs_bleed-right .pagedjs_marks-crop:nth-child(3) {
	height: calc(var(--pagedjs-bleed-right-bottom) - var(--pagedjs-crop-stroke));
}

.pagedjs_left_page .pagedjs_bleed-left .pagedjs_marks-crop:nth-child(3),
.pagedjs_left_page .pagedjs_bleed-right .pagedjs_marks-crop:nth-child(3) {
	height: calc(var(--pagedjs-bleed-left-bottom) - var(--pagedjs-crop-stroke));
}

.pagedjs_bleed-left .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-left) - var(--pagedjs-crop-offset));
	align-self: flex-start;
}

.pagedjs_right_page .pagedjs_bleed-left .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-right-left) - var(--pagedjs-crop-offset));
}

.pagedjs_left_page .pagedjs_bleed-left .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-left-left) - var(--pagedjs-crop-offset));
}

.pagedjs_bleed-right .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-right) - var(--pagedjs-crop-offset));
	align-self: flex-end;
}

.pagedjs_right_page .pagedjs_bleed-right .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-right-right) - var(--pagedjs-crop-offset));
}

.pagedjs_left_page .pagedjs_bleed-right .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-left-right) - var(--pagedjs-crop-offset));
}

.pagedjs_marks-middle {
	display: flex;
	flex-grow: 1;
	flex-shrink: 0;
	align-items: center;
	justify-content: center;
}

.pagedjs_marks-cross {
	display: var(--pagedjs-mark-cross-display);
	background-image: url(data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz48IURPQ1RZUEUgc3ZnIFBVQkxJQyAiLS8vVzNDLy9EVEQgU1ZHIDEuMS8vRU4iICJodHRwOi8vd3d3LnczLm9yZy9HcmFwaGljcy9TVkcvMS4xL0RURC9zdmcxMS5kdGQiPjxzdmcgdmVyc2lvbj0iMS4xIiBpZD0iTGF5ZXJfMSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgeD0iMHB4IiB5PSIwcHgiIHdpZHRoPSIzMi41MzdweCIgaGVpZ2h0PSIzMi41MzdweCIgdmlld0JveD0iMC4xMDQgMC4xMDQgMzIuNTM3IDMyLjUzNyIgZW5hYmxlLWJhY2tncm91bmQ9Im5ldyAwLjEwNCAwLjEwNCAzMi41MzcgMzIuNTM3IiB4bWw6c3BhY2U9InByZXNlcnZlIj48cGF0aCBmaWxsPSJub25lIiBzdHJva2U9IiNGRkZGRkYiIHN0cm9rZS13aWR0aD0iMy4zODkzIiBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiIGQ9Ik0yOS45MzEsMTYuMzczYzAsNy40ODktNi4wNjgsMTMuNTYtMTMuNTU4LDEzLjU2Yy03LjQ4MywwLTEzLjU1Ny02LjA3Mi0xMy41NTctMTMuNTZjMC03LjQ4Niw2LjA3NC0xMy41NTQsMTMuNTU3LTEzLjU1NEMyMy44NjIsMi44MTksMjkuOTMxLDguODg3LDI5LjkzMSwxNi4zNzN6Ii8+PGxpbmUgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjRkZGRkZGIiBzdHJva2Utd2lkdGg9IjMuMzg5MyIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiB4MT0iMC4xMDQiIHkxPSIxNi4zNzMiIHgyPSIzMi42NDIiIHkyPSIxNi4zNzMiLz48bGluZSBmaWxsPSJub25lIiBzdHJva2U9IiNGRkZGRkYiIHN0cm9rZS13aWR0aD0iMy4zODkzIiBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiIHgxPSIxNi4zNzMiIHkxPSIwLjEwNCIgeDI9IjE2LjM3MyIgeTI9IjMyLjY0MiIvPjxwYXRoIGZpbGw9Im5vbmUiIHN0cm9rZT0iI0ZGRkZGRiIgc3Ryb2tlLXdpZHRoPSIzLjM4OTMiIHN0cm9rZS1taXRlcmxpbWl0PSIxMCIgZD0iTTI0LjUwOCwxNi4zNzNjMCw0LjQ5Ni0zLjYzOCw4LjEzNS04LjEzNSw4LjEzNWMtNC40OTEsMC04LjEzNS0zLjYzOC04LjEzNS04LjEzNWMwLTQuNDg5LDMuNjQ0LTguMTM1LDguMTM1LTguMTM1QzIwLjg2OSw4LjIzOSwyNC41MDgsMTEuODg0LDI0LjUwOCwxNi4zNzN6Ii8+PHBhdGggZmlsbD0ibm9uZSIgc3Ryb2tlPSIjMDAwMDAwIiBzdHJva2Utd2lkdGg9IjAuNjc3OCIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiBkPSJNMjkuOTMxLDE2LjM3M2MwLDcuNDg5LTYuMDY4LDEzLjU2LTEzLjU1OCwxMy41NmMtNy40ODMsMC0xMy41NTctNi4wNzItMTMuNTU3LTEzLjU2YzAtNy40ODYsNi4wNzQtMTMuNTU0LDEzLjU1Ny0xMy41NTRDMjMuODYyLDIuODE5LDI5LjkzMSw4Ljg4NywyOS45MzEsMTYuMzczeiIvPjxsaW5lIGZpbGw9Im5vbmUiIHN0cm9rZT0iIzAwMDAwMCIgc3Ryb2tlLXdpZHRoPSIwLjY3NzgiIHN0cm9rZS1taXRlcmxpbWl0PSIxMCIgeDE9IjAuMTA0IiB5MT0iMTYuMzczIiB4Mj0iMzIuNjQyIiB5Mj0iMTYuMzczIi8+PGxpbmUgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjMDAwMDAwIiBzdHJva2Utd2lkdGg9IjAuNjc3OCIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiB4MT0iMTYuMzczIiB5MT0iMC4xMDQiIHgyPSIxNi4zNzMiIHkyPSIzMi42NDIiLz48cGF0aCBkPSJNMjQuNTA4LDE2LjM3M2MwLDQuNDk2LTMuNjM4LDguMTM1LTguMTM1LDguMTM1Yy00LjQ5MSwwLTguMTM1LTMuNjM4LTguMTM1LTguMTM1YzAtNC40ODksMy42NDQtOC4xMzUsOC4xMzUtOC4xMzVDMjAuODY5LDguMjM5LDI0LjUwOCwxMS44ODQsMjQuNTA4LDE2LjM3MyIvPjxsaW5lIGZpbGw9Im5vbmUiIHN0cm9rZT0iI0ZGRkZGRiIgc3Ryb2tlLXdpZHRoPSIwLjY3NzgiIHN0cm9rZS1taXRlcmxpbWl0PSIxMCIgeDE9IjguMjM5IiB5MT0iMTYuMzczIiB4Mj0iMjQuNTA4IiB5Mj0iMTYuMzczIi8+PGxpbmUgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjRkZGRkZGIiBzdHJva2Utd2lkdGg9IjAuNjc3OCIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiB4MT0iMTYuMzczIiB5MT0iOC4yMzkiIHgyPSIxNi4zNzMiIHkyPSIyNC41MDgiLz48L3N2Zz4=);
  background-repeat: no-repeat;
  background-position: 50% 50%;
  background-size: var(--pagedjs-cross-size);

  z-index: 2147483647;
	width: var(--pagedjs-cross-size);
	height: var(--pagedjs-cross-size);
}

.pagedjs_pagebox {
	box-sizing: border-box;
	width: var(--pagedjs-pagebox-width);
	height: var(--pagedjs-pagebox-height);
	position: relative;
	display: grid;
	grid-template-columns: [left] var(--pagedjs-margin-left) [center] calc(var(--pagedjs-pagebox-width) - var(--pagedjs-margin-left) - var(--pagedjs-margin-right)) [right] var(--pagedjs-margin-right);
	grid-template-rows: [header] var(--pagedjs-margin-top) [page] calc(var(--pagedjs-pagebox-height) - var(--pagedjs-margin-top) - var(--pagedjs-margin-bottom)) [footer] var(--pagedjs-margin-bottom);
	grid-column: sheet-center;
	grid-row: sheet-middle;
}

.pagedjs_pagebox * {
	box-sizing: border-box;
}

.pagedjs_margin-top {
	width: calc(var(--pagedjs-pagebox-width) - var(--pagedjs-margin-left) - var(--pagedjs-margin-right));
	height: var(--pagedjs-margin-top);
	grid-column: center;
	grid-row: header;
	flex-wrap: nowrap;
	display: grid;
	grid-template-columns: repeat(3, 1fr);
	grid-template-rows: 100%;
}

.pagedjs_margin-top-left-corner-holder {
	width: var(--pagedjs-margin-left);
	height: var(--pagedjs-margin-top);
	display: flex;
	grid-column: left;
	grid-row: header;
}

.pagedjs_margin-top-right-corner-holder {
	width: var(--pagedjs-margin-right);
	height: var(--pagedjs-margin-top);
	display: flex;
	grid-column: right;
	grid-row: header;
}

.pagedjs_margin-top-left-corner {
	width: var(--pagedjs-margin-left);
}

.pagedjs_margin-top-right-corner {
	width: var(--pagedjs-margin-right);
}

.pagedjs_margin-right {
	height: calc(var(--pagedjs-pagebox-height) - var(--pagedjs-margin-top) - var(--pagedjs-margin-bottom));
	width: var(--pagedjs-margin-right);
	right: 0;
	grid-column: right;
	grid-row: page;
	display: grid;
	grid-template-rows: repeat(3, 33.3333%);
	grid-template-columns: 100%;
}

.pagedjs_margin-bottom {
	width: calc(var(--pagedjs-pagebox-width) - var(--pagedjs-margin-left) - var(--pagedjs-margin-right));
	height: var(--pagedjs-margin-bottom);
	grid-column: center;
	grid-row: footer;
	display: grid;
	grid-template-columns: repeat(3, 1fr);
	grid-template-rows: 100%;
}

.pagedjs_margin-bottom-left-corner-holder {
	width: var(--pagedjs-margin-left);
	height: var(--pagedjs-margin-bottom);
	display: flex;
	grid-column: left;
	grid-row: footer;
}

.pagedjs_margin-bottom-right-corner-holder {
	width: var(--pagedjs-margin-right);
	height: var(--pagedjs-margin-bottom);
	display: flex;
	grid-column: right;
	grid-row: footer;
}

.pagedjs_margin-bottom-left-corner {
	width: var(--pagedjs-margin-left);
}

.pagedjs_margin-bottom-right-corner {
	width: var(--pagedjs-margin-right);
}



.pagedjs_margin-left {
	height: calc(var(--pagedjs-pagebox-height) - var(--pagedjs-margin-top) - var(--pagedjs-margin-bottom));
	width: var(--pagedjs-margin-left);
	grid-column: left;
	grid-row: page;
	display: grid;
	grid-template-rows: repeat(3, 33.33333%);
	grid-template-columns: 100%;
}

.pagedjs_pages .pagedjs_pagebox .pagedjs_margin:not(.hasContent) {
	visibility: hidden;
}

.pagedjs_pagebox > .pagedjs_area {
	grid-column: center;
	grid-row: page;
	width: 100%;
	height: 100%;
	padding: var(--pagedjs-padding-top) var(--pagedjs-padding-right) var(--pagedjs-padding-bottom) var(--pagedjs-padding-left);
	border-top: var(--pagedjs-border-top);
	border-right: var(--pagedjs-border-right);
	border-bottom: var(--pagedjs-border-bottom);
	border-left: var(--pagedjs-border-left);
}

.pagedjs_pagebox > .pagedjs_area > .pagedjs_page_content {
	width: 100%;
	height: 100%;
	position: relative;
	column-fill: auto;
}

.pagedjs_page {
	counter-increment: page var(--pagedjs-page-counter-increment);
	width: var(--pagedjs-width);
	height: var(--pagedjs-height);
}

.pagedjs_page.pagedjs_right_page {
	width: var(--pagedjs-width-right);
	height: var(--pagedjs-height-right);
}

.pagedjs_page.pagedjs_left_page {
	width: var(--pagedjs-width-left);
	height: var(--pagedjs-height-left);
}

.pagedjs_pages {
	counter-reset: pages var(--pagedjs-page-count);
}

.pagedjs_pagebox .pagedjs_margin-top-left-corner,
.pagedjs_pagebox .pagedjs_margin-top-right-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-left-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-right-corner,
.pagedjs_pagebox .pagedjs_margin-top-left,
.pagedjs_pagebox .pagedjs_margin-top-right,
.pagedjs_pagebox .pagedjs_margin-bottom-left,
.pagedjs_pagebox .pagedjs_margin-bottom-right,
.pagedjs_pagebox .pagedjs_margin-top-center,
.pagedjs_pagebox .pagedjs_margin-bottom-center,
.pagedjs_pagebox .pagedjs_margin-top-center,
.pagedjs_pagebox .pagedjs_margin-bottom-center,
.pagedjs_margin-right-middle,
.pagedjs_margin-left-middle  {
	display: flex;
	align-items: center;
}

.pagedjs_margin-right-top,
.pagedjs_margin-left-top  {
	display: flex;
	align-items: flex-top;
}


.pagedjs_margin-right-bottom,
.pagedjs_margin-left-bottom  {
	display: flex;
	align-items: flex-end;
}



/*
.pagedjs_pagebox .pagedjs_margin-top-center,
.pagedjs_pagebox .pagedjs_margin-bottom-center {
	height: 100%;
	display: none;
	align-items: center;
	flex: 1 0 33%;
	margin: 0 auto;
}

.pagedjs_pagebox .pagedjs_margin-top-left-corner,
.pagedjs_pagebox .pagedjs_margin-top-right-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-right-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-left-corner {
	display: none;
	align-items: center;
}

.pagedjs_pagebox .pagedjs_margin-left-top,
.pagedjs_pagebox .pagedjs_margin-right-top {
	display: none;
	align-items: flex-start;
}

.pagedjs_pagebox .pagedjs_margin-right-middle,
.pagedjs_pagebox .pagedjs_margin-left-middle {
	display: none;
	align-items: center;
}

.pagedjs_pagebox .pagedjs_margin-left-bottom,
.pagedjs_pagebox .pagedjs_margin-right-bottom {
	display: none;
	align-items: flex-end;
}
*/

.pagedjs_pagebox .pagedjs_margin-top-left,
.pagedjs_pagebox .pagedjs_margin-top-right-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-left,
.pagedjs_pagebox .pagedjs_margin-bottom-right-corner { text-align: left; }

.pagedjs_pagebox .pagedjs_margin-top-left-corner,
.pagedjs_pagebox .pagedjs_margin-top-right,
.pagedjs_pagebox .pagedjs_margin-bottom-left-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-right { text-align: right; }

.pagedjs_pagebox .pagedjs_margin-top-center,
.pagedjs_pagebox .pagedjs_margin-bottom-center,
.pagedjs_pagebox .pagedjs_margin-left-top,
.pagedjs_pagebox .pagedjs_margin-left-middle,
.pagedjs_pagebox .pagedjs_margin-left-bottom,
.pagedjs_pagebox .pagedjs_margin-right-top,
.pagedjs_pagebox .pagedjs_margin-right-middle,
.pagedjs_pagebox .pagedjs_margin-right-bottom { text-align: center; }

.pagedjs_pages .pagedjs_margin .pagedjs_margin-content {
	width: 100%;
}

.pagedjs_pages .pagedjs_margin-left .pagedjs_margin-content::after,
.pagedjs_pages .pagedjs_margin-top .pagedjs_margin-content::after,
.pagedjs_pages .pagedjs_margin-right .pagedjs_margin-content::after,
.pagedjs_pages .pagedjs_margin-bottom .pagedjs_margin-content::after {
	display: block;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-to] {
	margin-bottom: unset;
	padding-bottom: unset;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-from] {
	text-indent: unset;
	margin-top: unset;
	padding-top: unset;
	initial-letter: unset;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-from] > *::first-letter,
.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-from]::first-letter {
	color: unset;
	font-size: unset;
	font-weight: unset;
	font-family: unset;
	color: unset;
	line-height: unset;
	float: unset;
	padding: unset;
	margin: unset;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-to]:after,
.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-to]::after {
	content: unset;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-from]:before,
.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-from]::before {
	content: unset;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div li[data-split-from]:first-of-type {
	list-style: none;
}

/*
[data-page]:not([data-split-from]),
[data-break-before="page"]:not([data-split-from]),
[data-break-before="always"]:not([data-split-from]),
[data-break-before="left"]:not([data-split-from]),
[data-break-before="right"]:not([data-split-from]),
[data-break-before="recto"]:not([data-split-from]),
[data-break-before="verso"]:not([data-split-from])
{
	break-before: column;
}

[data-page]:not([data-split-to]),
[data-break-after="page"]:not([data-split-to]),
[data-break-after="always"]:not([data-split-to]),
[data-break-after="left"]:not([data-split-to]),
[data-break-after="right"]:not([data-split-to]),
[data-break-after="recto"]:not([data-split-to]),
[data-break-after="verso"]:not([data-split-to])
{
	break-after: column;
}
*/

.pagedjs_clear-after::after {
	content: none !important;
}

[data-align-last-split-element='justify'] {
	text-align-last: justify;
}


@media print {
	html {
		width: 100%;
		height: 100%;
	}
	body {
		margin: 0;
		padding: 0;
		width: 100% !important;
		height: 100% !important;
		min-width: 100%;
		max-width: 100%;
		min-height: 100%;
		max-height: 100%;
	}
	.pagedjs_pages {
		width: auto;
		display: block !important;
		transform: none !important;
		height: 100% !important;
		min-height: 100%;
		max-height: 100%;
		overflow: visible;
	}
	.pagedjs_page {
		margin: 0;
		padding: 0;
		max-height: 100%;
		min-height: 100%;
		height: 100% !important;
		page-break-after: always;
		break-after: page;
	}
	.pagedjs_sheet {
		margin: 0;
		padding: 0;
		max-height: 100%;
		min-height: 100%;
		height: 100% !important;
	}
}
`;

	async function request(url, options={}) {
		return new Promise(function(resolve, reject) {
			let request = new XMLHttpRequest();

			request.open(options.method || "get", url, true);

			for (let i in options.headers) {
				request.setRequestHeader(i, options.headers[i]);
			}

			request.withCredentials = options.credentials === "include";

			request.onload = () => {
				// Chrome returns a status code of 0 for local files
				const status = request.status === 0 && url.startsWith("file://") ? 200 : request.status;
				resolve(new Response(request.responseText, {status}));
			};

			request.onerror = reject;

			request.send(options.body || null);
		});
	}

	class Polisher {
		constructor(setup) {
			this.sheets = [];
			this.inserted = [];

			this.hooks = {};
			this.hooks.onUrl = new Hook(this);
			this.hooks.onAtPage = new Hook(this);
			this.hooks.onAtMedia = new Hook(this);
			this.hooks.onRule = new Hook(this);
			this.hooks.onDeclaration = new Hook(this);
			this.hooks.onContent = new Hook(this);
			this.hooks.onSelector = new Hook(this);
			this.hooks.onPseudoSelector = new Hook(this);

			this.hooks.onImport = new Hook(this);

			this.hooks.beforeTreeParse = new Hook(this);
			this.hooks.beforeTreeWalk = new Hook(this);
			this.hooks.afterTreeWalk = new Hook(this);

			if (setup !== false) {
				this.setup();
			}
		}

		setup() {
			this.base = this.insert(baseStyles);
			this.styleEl = document.createElement("style");
			document.head.appendChild(this.styleEl);
			this.styleSheet = this.styleEl.sheet;
			return this.styleSheet;
		}

		async add() {
			let fetched = [];
			let urls = [];

			for (var i = 0; i < arguments.length; i++) {
				let f;

				if (typeof arguments[i] === "object") {
					for (let url in arguments[i]) {
						let obj = arguments[i];
						f = new Promise(function(resolve, reject) {
							urls.push(url);
							resolve(obj[url]);
						});
					}
				} else {
					urls.push(arguments[i]);
					f = request(arguments[i]).then((response) => {
						return response.text();
					});
				}


				fetched.push(f);
			}

			return await Promise.all(fetched)
				.then(async (originals) => {
					let text = "";
					for (let index = 0; index < originals.length; index++) {
						text = await this.convertViaSheet(originals[index], urls[index]);
						this.insert(text);
					}
					return text;
				});
		}

		async convertViaSheet(cssStr, href) {
			let sheet = new Sheet(href, this.hooks);
			await sheet.parse(cssStr);

			// Insert the imported sheets first
			for (let url of sheet.imported) {
				let str = await request(url).then((response) => {
					return response.text();
				});
				let text = await this.convertViaSheet(str, url);
				this.insert(text);
			}

			this.sheets.push(sheet);

			if (typeof sheet.width !== "undefined") {
				this.width = sheet.width;
			}
			if (typeof sheet.height !== "undefined") {
				this.height = sheet.height;
			}
			if (typeof sheet.orientation !== "undefined") {
				this.orientation = sheet.orientation;
			}
			return sheet.toString();
		}

		insert(text){
			let head = document.querySelector("head");
			let style = document.createElement("style");
			style.type = "text/css";
			style.setAttribute("data-pagedjs-inserted-styles", "true");

			style.appendChild(document.createTextNode(text));

			head.appendChild(style);

			this.inserted.push(style);
			return style;
		}

		destroy() {
			this.styleEl.remove();
			this.inserted.forEach((s) => {
				s.remove();
			});
			this.sheets = [];
		}
	}

	class Handler {
		constructor(chunker, polisher, caller) {
			let hooks = Object.assign({}, chunker && chunker.hooks, polisher && polisher.hooks, caller && caller.hooks);
			this.chunker = chunker;
			this.polisher = polisher;
			this.caller = caller;

			for (let name in hooks) {
				if (name in this) {
					let hook = hooks[name];
					hook.register(this[name].bind(this));
				}
			}
		}
	}

	eventEmitter(Handler.prototype);

	// https://www.w3.org/TR/css3-page/#page-size-prop

	var pageSizes = {
		"A0": {
			width: {
				value: 841,
				unit: "mm"
			},
			height: {
				value: 1189,
				unit: "mm"
			}
		},
		"A1": {
			width: {
				value: 594,
				unit: "mm"
			},
			height: {
				value: 841,
				unit: "mm"
			}
		},
		"A2": {
			width: {
				value: 420,
				unit: "mm"
			},
			height: {
				value: 594,
				unit: "mm"
			}
		},
		"A3": {
			width: {
				value: 297,
				unit: "mm"
			},
			height: {
				value: 420,
				unit: "mm"
			}
		},
		"A4": {
			width: {
				value: 210,
				unit: "mm"
			},
			height: {
				value: 297,
				unit: "mm"
			}
		},
		"A5": {
			width: {
				value: 148,
				unit: "mm"
			},
			height: {
				value: 210,
				unit: "mm"
			}
		},
		"A6": {
			width: {
				value: 105,
				unit: "mm"
			},
			height: {
				value: 148,
				unit: "mm"
			}
		},
		"A7": {
			width: {
				value: 74,
				unit: "mm"
			},
			height: {
				value: 105,
				unit: "mm"
			}
		},
		"A8": {
			width: {
				value: 52,
				unit: "mm"
			},
			height: {
				value: 74,
				unit: "mm"
			}
		},
		"A9": {
			width: {
				value: 37,
				unit: "mm"
			},
			height: {
				value: 52,
				unit: "mm"
			}
		},
		"A10": {
			width: {
				value: 26,
				unit: "mm"
			},
			height: {
				value: 37,
				unit: "mm"
			}
		},
		"B4": {
			width: {
				value: 250,
				unit: "mm"
			},
			height: {
				value: 353,
				unit: "mm"
			}
		},
		"B5": {
			width: {
				value: 176,
				unit: "mm"
			},
			height: {
				value: 250,
				unit: "mm"
			}
		},
		"letter": {
			width: {
				value: 8.5,
				unit: "in"
			},
			height: {
				value: 11,
				unit: "in"
			}
		},
		"legal": {
			width: {
				value: 8.5,
				unit: "in"
			},
			height: {
				value: 14,
				unit: "in"
			}
		},
		"ledger": {
			width: {
				value: 11,
				unit: "in"
			},
			height: {
				value: 17,
				unit: "in"
			}
		}
	};

	class AtPage extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.pages = {};

			this.width = undefined;
			this.height = undefined;
			this.orientation = undefined;
			this.marginalia = {};
		}

		pageModel(selector) {
			return {
				selector: selector,
				name: undefined,
				psuedo: undefined,
				nth: undefined,
				marginalia: {},
				width: undefined,
				height: undefined,
				orientation: undefined,
				margin: {
					top: {},
					right: {},
					left: {},
					bottom: {}
				},
				padding: {
					top: {},
					right: {},
					left: {},
					bottom: {}
				},
				border: {
					top: {},
					right: {},
					left: {},
					bottom: {}
				},
				backgroundOrigin: undefined,
				block: {},
				marks: undefined
			};
		}

		// Find and Remove @page rules
		onAtPage(node, item, list) {
			let page, marginalia;
			let selector = "";
			let named, psuedo, nth;
			let needsMerge = false;

			if (node.prelude) {
				named = this.getTypeSelector(node);
				psuedo = this.getPsuedoSelector(node);
				nth = this.getNthSelector(node);
				selector = lib.generate(node.prelude);
			} else {
				selector = "*";
			}

			if (selector in this.pages) {
				// this.pages[selector] = Object.assign(this.pages[selector], page);
				// console.log("after", selector, this.pages[selector]);

				// this.pages[selector].added = false;
				page = this.pages[selector];
				marginalia = this.replaceMarginalia(node);
				needsMerge = true;
			} else {
				page = this.pageModel(selector);
				marginalia = this.replaceMarginalia(node);
				this.pages[selector] = page;
			}

			page.name = named;
			page.psuedo = psuedo;
			page.nth = nth;

			if (needsMerge) {
				page.marginalia = Object.assign(page.marginalia, marginalia);
			} else {
				page.marginalia = marginalia;
			}

			let declarations = this.replaceDeclarations(node);

			if (declarations.size) {
				page.size = declarations.size;
				page.width = declarations.size.width;
				page.height = declarations.size.height;
				page.orientation = declarations.size.orientation;
				page.format = declarations.size.format;
			}

			if (declarations.bleed && declarations.bleed[0] != "auto") {
				switch (declarations.bleed.length) {
					case 4: // top right bottom left
						page.bleed = {
							top: declarations.bleed[0],
							right: declarations.bleed[1],
							bottom: declarations.bleed[2],
							left: declarations.bleed[3]
						};
						break;
					case 3: // top right bottom right
						page.bleed = {
							top: declarations.bleed[0],
							right: declarations.bleed[1],
							bottom: declarations.bleed[2],
							left: declarations.bleed[1]
						};
						break;
					case 2: // top right top right
						page.bleed = {
							top: declarations.bleed[0],
							right: declarations.bleed[1],
							bottom: declarations.bleed[0],
							left: declarations.bleed[1]
						};
						break;
					default:
						page.bleed = {
							top: declarations.bleed[0],
							right: declarations.bleed[0],
							bottom: declarations.bleed[0],
							left: declarations.bleed[0]
						};
				}
			}

			if (declarations.marks) {
				if (!declarations.bleed || declarations.bleed && declarations.bleed[0] === "auto") {
					// Spec say 6pt, but needs more space for marks
					page.bleed = {
						top: { value: 6, unit: "mm" },
						right: { value: 6, unit: "mm" },
						bottom: { value: 6, unit: "mm" },
						left: { value: 6, unit: "mm" }
					};
				}

				page.marks = declarations.marks;
			}

			if (declarations.margin) {
				page.margin = declarations.margin;
			}
			if (declarations.padding) {
				page.padding = declarations.padding;
			}

			if (declarations.border) {
				page.border = declarations.border;
			}

			if (declarations.marks) {
				page.marks = declarations.marks;
			}

			if (needsMerge) {
				page.block.children.appendList(node.block.children);
			} else {
				page.block = node.block;
			}

			// Remove the rule
			list.remove(item);
		}

		/* Handled in breaks */
		/*
		afterParsed(parsed) {
			for (let b in this.named) {
				// Find elements
				let elements = parsed.querySelectorAll(b);
				// Add break data
				for (var i = 0; i < elements.length; i++) {
					elements[i].setAttribute("data-page", this.named[b]);
				}
			}
		}
		*/

		afterTreeWalk(ast, sheet) {
			this.addPageClasses(this.pages, ast, sheet);

			if ("*" in this.pages) {
				let width = this.pages["*"].width;
				let height = this.pages["*"].height;
				let format = this.pages["*"].format;
				let orientation = this.pages["*"].orientation;
				let bleed = this.pages["*"].bleed;
				let marks = this.pages["*"].marks;
				let bleedverso = undefined;
				let bleedrecto = undefined;

				if (":left" in this.pages) {
					bleedverso = this.pages[":left"].bleed;
				}

				if (":right" in this.pages) {
					bleedrecto = this.pages[":right"].bleed;
				}

				if ((width && height) &&
					(this.width !== width || this.height !== height)) {
					this.width = width;
					this.height = height;
					this.format = format;
					this.orientation = orientation;

					this.addRootVars(ast, width, height, orientation, bleed, bleedrecto, bleedverso, marks);
					this.addRootPage(ast, this.pages["*"].size, bleed, bleedrecto, bleedverso);

					this.emit("size", { width, height, orientation, format, bleed });
					this.emit("atpages", this.pages);
				}

			}
		}

		getTypeSelector(ast) {
			// Find page name
			let name;

			lib.walk(ast, {
				visit: "TypeSelector",
				enter: (node, item, list) => {
					name = node.name;
				}
			});

			return name;
		}

		getPsuedoSelector(ast) {
			// Find if it has :left & :right & :black & :first
			let name;
			lib.walk(ast, {
				visit: "PseudoClassSelector",
				enter: (node, item, list) => {
					if (node.name !== "nth") {
						name = node.name;
					}
				}
			});

			return name;
		}

		getNthSelector(ast) {
			// Find if it has :nth
			let nth;
			lib.walk(ast, {
				visit: "PseudoClassSelector",
				enter: (node, item, list) => {
					if (node.name === "nth" && node.children) {
						let raw = node.children.first();
						nth = raw.value;
					}
				}
			});

			return nth;
		}

		replaceMarginalia(ast) {
			let parsed = {};

			lib.walk(ast.block, {
				visit: "Atrule",
				enter: (node, item, list) => {
					let name = node.name;
					if (name === "top") {
						name = "top-center";
					}
					if (name === "right") {
						name = "right-middle";
					}
					if (name === "left") {
						name = "left-middle";
					}
					if (name === "bottom") {
						name = "bottom-center";
					}
					parsed[name] = node.block;
					list.remove(item);
				}
			});

			return parsed;
		}

		replaceDeclarations(ast) {
			let parsed = {};

			lib.walk(ast.block, {
				visit: "Declaration",
				enter: (declaration, dItem, dList) => {
					let prop = lib.property(declaration.property).name;
					// let value = declaration.value;

					if (prop === "marks") {
						parsed.marks = [];
						lib.walk(declaration, {
							visit: "Identifier",
							enter: (ident) => {
								parsed.marks.push(ident.name);
							}
						});
						dList.remove(dItem);
					} else if (prop === "margin") {
						parsed.margin = this.getMargins(declaration);
						dList.remove(dItem);

					} else if (prop.indexOf("margin-") === 0) {
						let m = prop.substring("margin-".length);
						if (!parsed.margin) {
							parsed.margin = {
								top: {},
								right: {},
								left: {},
								bottom: {}
							};
						}
						parsed.margin[m] = declaration.value.children.first();
						dList.remove(dItem);

					} else if (prop === "padding") {
						parsed.padding = this.getPaddings(declaration.value);
						dList.remove(dItem);

					} else if (prop.indexOf("padding-") === 0) {
						let p = prop.substring("padding-".length);
						if (!parsed.padding) {
							parsed.padding = {
								top: {},
								right: {},
								left: {},
								bottom: {}
							};
						}
						parsed.padding[p] = declaration.value.children.first();
						dList.remove(dItem);
					}

					else if (prop === "border") {
						if (!parsed.border) {
							parsed.border = {
								top: {},
								right: {},
								left: {},
								bottom: {}
							};
						}
						parsed.border.top = lib.generate(declaration.value);
						parsed.border.right = lib.generate(declaration.value);
						parsed.border.left = lib.generate(declaration.value);
						parsed.border.bottom = lib.generate(declaration.value);

						dList.remove(dItem);

					}

					else if (prop.indexOf("border-") === 0) {
						if (!parsed.border) {
							parsed.border = {
								top: {},
								right: {},
								left: {},
								bottom: {}
							};
						}
						let p = prop.substring("border-".length);

						parsed.border[p] = lib.generate(declaration.value);
						dList.remove(dItem);

					}

					else if (prop === "size") {
						parsed.size = this.getSize(declaration);
						dList.remove(dItem);
					} else if (prop === "bleed") {
						parsed.bleed = [];

						lib.walk(declaration, {
							enter: (subNode) => {
								switch (subNode.type) {
									case "String": // bleed: "auto"
										if (subNode.value.indexOf("auto") > -1) {
											parsed.bleed.push("auto");
										}
										break;
									case "Dimension": // bleed: 1in 2in, bleed: 20px ect.
										parsed.bleed.push({
											value: subNode.value,
											unit: subNode.unit
										});
										break;
									case "Number":
										parsed.bleed.push({
											value: subNode.value,
											unit: "px"
										});
										break;
									// ignore
								}

							}
						});

						dList.remove(dItem);
					}

				}
			});

			return parsed;

		}
		getSize(declaration) {
			let width, height, orientation, format;

			// Get size: Xmm Ymm
			lib.walk(declaration, {
				visit: "Dimension",
				enter: (node, item, list) => {
					let { value, unit } = node;
					if (typeof width === "undefined") {
						width = { value, unit };
					} else if (typeof height === "undefined") {
						height = { value, unit };
					}
				}
			});

			// Get size: "A4"
			lib.walk(declaration, {
				visit: "String",
				enter: (node, item, list) => {
					let name = node.value.replace(/["|']/g, "");
					let s = pageSizes[name];
					if (s) {
						width = s.width;
						height = s.height;
					}
				}
			});

			// Get Format or Landscape or Portrait
			lib.walk(declaration, {
				visit: "Identifier",
				enter: (node, item, list) => {
					let name = node.name;
					if (name === "landscape" || name === "portrait") {
						orientation = node.name;
					} else if (name !== "auto") {
						let s = pageSizes[name];
						if (s) {
							width = s.width;
							height = s.height;
						}
						format = name;
					}
				}
			});

			return {
				width,
				height,
				orientation,
				format
			};
		}

		getMargins(declaration) {
			let margins = [];
			let margin = {
				top: {},
				right: {},
				left: {},
				bottom: {}
			};

			lib.walk(declaration, {
				enter: (node) => {
					switch (node.type) {
						case "Dimension": // margin: 1in 2in, margin: 20px, etc...
							margins.push(node);
							break;
						case "Number": // margin: 0
							margins.push({value: node.value, unit: "px"});
							break;
						// ignore
					}
				}
			});

			if (margins.length === 1) {
				for (let m in margin) {
					margin[m] = margins[0];
				}
			} else if (margins.length === 2) {
				margin.top = margins[0];
				margin.right = margins[1];
				margin.bottom = margins[0];
				margin.left = margins[1];
			} else if (margins.length === 3) {
				margin.top = margins[0];
				margin.right = margins[1];
				margin.bottom = margins[2];
				margin.left = margins[1];
			} else if (margins.length === 4) {
				margin.top = margins[0];
				margin.right = margins[1];
				margin.bottom = margins[2];
				margin.left = margins[3];
			}

			return margin;
		}

		getPaddings(declaration) {
			let paddings = [];
			let padding = {
				top: {},
				right: {},
				left: {},
				bottom: {}
			};

			lib.walk(declaration, {
				enter: (node) => {
					switch (node.type) {
						case "Dimension": // padding: 1in 2in, padding: 20px, etc...
							paddings.push(node);
							break;
						case "Number": // padding: 0
							paddings.push({value: node.value, unit: "px"});
							break;
						// ignore
					}
				}
			});
			if (paddings.length === 1) {
				for (let p in padding) {
					padding[p] = paddings[0];
				}
			} else if (paddings.length === 2) {

				padding.top = paddings[0];
				padding.right = paddings[1];
				padding.bottom = paddings[0];
				padding.left = paddings[1];
			} else if (paddings.length === 3) {

				padding.top = paddings[0];
				padding.right = paddings[1];
				padding.bottom = paddings[2];
				padding.left = paddings[1];
			} else if (paddings.length === 4) {

				padding.top = paddings[0];
				padding.right = paddings[1];
				padding.bottom = paddings[2];
				padding.left = paddings[3];
			}
			return padding;
		}

		// get values for the border on the @page to pass them to the element with the .pagedjs_area class
		getBorders(declaration) {
			let border = {
				top: {},
				right: {},
				left: {},
				bottom: {}
			};

			if (declaration.prop == "border") {
				border.top = lib.generate(declaration.value);
				border.right = lib.generate(declaration.value);
				border.bottom = lib.generate(declaration.value);
				border.left = lib.generate(declaration.value);

			}
			else if (declaration.prop == "border-top") {
				border.top = lib.generate(declaration.value);
			}
			else if (declaration.prop == "border-right") {
				border.right = lib.generate(declaration.value);

			}
			else if (declaration.prop == "border-bottom") {
				border.bottom = lib.generate(declaration.value);

			}
			else if (declaration.prop == "border-left") {
				border.left = lib.generate(declaration.value);
			}

			return border;
		}


		addPageClasses(pages, ast, sheet) {
			// First add * page
			if ("*" in pages) {
				let p = this.createPage(pages["*"], ast.children, sheet);
				sheet.insertRule(p);
			}
			// Add :left & :right
			if (":left" in pages) {
				let left = this.createPage(pages[":left"], ast.children, sheet);
				sheet.insertRule(left);
			}
			if (":right" in pages) {
				let right = this.createPage(pages[":right"], ast.children, sheet);
				sheet.insertRule(right);
			}
			// Add :first & :blank
			if (":first" in pages) {
				let first = this.createPage(pages[":first"], ast.children, sheet);
				sheet.insertRule(first);
			}
			if (":blank" in pages) {
				let blank = this.createPage(pages[":blank"], ast.children, sheet);
				sheet.insertRule(blank);
			}
			// Add nth pages
			for (let pg in pages) {
				if (pages[pg].nth) {
					let nth = this.createPage(pages[pg], ast.children, sheet);
					sheet.insertRule(nth);
				}
			}

			// Add named pages
			for (let pg in pages) {
				if (pages[pg].name) {
					let named = this.createPage(pages[pg], ast.children, sheet);
					sheet.insertRule(named);
				}
			}

		}

		createPage(page, ruleList, sheet) {

			let selectors = this.selectorsForPage(page);
			let children = page.block.children.copy();
			let block = {
				type: "Block",
				loc: 0,
				children: children
			};


			let rule = this.createRule(selectors, block);

			this.addMarginVars(page.margin, children, children.first());
			this.addPaddingVars(page.padding, children, children.first());
			this.addBorderVars(page.border, children, children.first());


			if (page.width) {
				this.addDimensions(page.width, page.height, page.orientation, children, children.first());
			}

			if (page.marginalia) {
				this.addMarginaliaStyles(page, ruleList, rule, sheet);
				this.addMarginaliaContent(page, ruleList, rule, sheet);
			}
			return rule;
		}

		addMarginVars(margin, list, item) {
			// variables for margins
			for (let m in margin) {
				if (typeof margin[m].value !== "undefined") {
					let value = margin[m].value + (margin[m].unit || "");
					let mVar = list.createItem({
						type: "Declaration",
						property: "--pagedjs-margin-" + m,
						value: {
							type: "Raw",
							value: value
						}
					});
					list.append(mVar, item);

				}
			}
		}

		addPaddingVars(padding, list, item) {
			// variables for padding
			for (let p in padding) {

				if (typeof padding[p].value !== "undefined") {
					let value = padding[p].value + (padding[p].unit || "");
					let pVar = list.createItem({
						type: "Declaration",
						property: "--pagedjs-padding-" + p,
						value: {
							type: "Raw",
							value: value
						}
					});

					list.append(pVar, item);
				}

			}
		}

		addBorderVars(border, list, item) {
			// variables for borders
			for (let b in border) {
				if (typeof border[b] !== "undefined") {
					let value = border[b];
					let bVar = list.createItem({
						type: "Declaration",
						property: "--pagedjs-border-" + b,
						value: {
							type: "Raw",
							value: value
						}
					});
					list.append(bVar, item);
				}

			}
		}

		addDimensions(width, height, orientation, list, item) {
			let widthString, heightString;

			widthString = CSSValueToString(width);
			heightString = CSSValueToString(height);

			if (orientation && orientation !== "portrait") {
				// reverse for orientation
				[widthString, heightString] = [heightString, widthString];
			}

			// width variable
			let wVar = this.createVariable("--pagedjs-pagebox-width", widthString);
			list.appendData(wVar);

			// height variable
			let hVar = this.createVariable("--pagedjs-pagebox-height", heightString);
			list.appendData(hVar);

			// let w = this.createDimension("width", width);
			// let h = this.createDimension("height", height);
			// list.appendData(w);
			// list.appendData(h);
		}

		addMarginaliaStyles(page, list, item, sheet) {
			for (let loc in page.marginalia) {
				let block = lib.clone(page.marginalia[loc]);
				let hasContent = false;

				if (block.children.isEmpty()) {
					continue;
				}

				lib.walk(block, {
					visit: "Declaration",
					enter: (node, item, list) => {
						if (node.property === "content") {
							if (node.value.children && node.value.children.first().name === "none") {
								hasContent = false;
							} else {
								hasContent = true;
							}
							list.remove(item);
						}
						if (node.property === "vertical-align") {
							lib.walk(node, {
								visit: "Identifier",
								enter: (identNode, identItem, identlist) => {
									let name = identNode.name;
									if (name === "top") {
										identNode.name = "flex-start";
									} else if (name === "middle") {
										identNode.name = "center";
									} else if (name === "bottom") {
										identNode.name = "flex-end";
									}
								}
							});
							node.property = "align-items";
						}

						if (node.property === "width" &&
							(loc === "top-left" ||
								loc === "top-center" ||
								loc === "top-right" ||
								loc === "bottom-left" ||
								loc === "bottom-center" ||
								loc === "bottom-right")) {
							let c = lib.clone(node);
							c.property = "max-width";
							list.appendData(c);
						}

						if (node.property === "height" &&
							(loc === "left-top" ||
								loc === "left-middle" ||
								loc === "left-bottom" ||
								loc === "right-top" ||
								loc === "right-middle" ||
								loc === "right-bottom")) {
							let c = lib.clone(node);
							c.property = "max-height";
							list.appendData(c);
						}
					}
				});

				let marginSelectors = this.selectorsForPageMargin(page, loc);
				let marginRule = this.createRule(marginSelectors, block);

				list.appendData(marginRule);

				let sel = lib.generate({
					type: "Selector",
					children: marginSelectors
				});

				this.marginalia[sel] = {
					page: page,
					selector: sel,
					block: page.marginalia[loc],
					hasContent: hasContent
				};

			}
		}

		addMarginaliaContent(page, list, item, sheet) {
			let displayNone;
			// Just content
			for (let loc in page.marginalia) {
				let content = lib.clone(page.marginalia[loc]);
				lib.walk(content, {
					visit: "Declaration",
					enter: (node, item, list) => {
						if (node.property !== "content") {
							list.remove(item);
						}

						if (node.value.children && node.value.children.first().name === "none") {
							displayNone = true;
						}
					}
				});

				if (content.children.isEmpty()) {
					continue;
				}

				let displaySelectors = this.selectorsForPageMargin(page, loc);
				let displayDeclaration;

				displaySelectors.insertData({
					type: "Combinator",
					name: ">"
				});

				displaySelectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_margin-content"
				});

				displaySelectors.insertData({
					type: "Combinator",
					name: ">"
				});

				displaySelectors.insertData({
					type: "TypeSelector",
					name: "*"
				});

				if (displayNone) {
					displayDeclaration = this.createDeclaration("display", "none");
				} else {
					displayDeclaration = this.createDeclaration("display", "block");
				}

				let displayRule = this.createRule(displaySelectors, [displayDeclaration]);
				sheet.insertRule(displayRule);

				// insert content rule
				let contentSelectors = this.selectorsForPageMargin(page, loc);

				contentSelectors.insertData({
					type: "Combinator",
					name: ">"
				});

				contentSelectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_margin-content"
				});

				contentSelectors.insertData({
					type: "PseudoElementSelector",
					name: "after",
					children: null
				});

				let contentRule = this.createRule(contentSelectors, content);
				sheet.insertRule(contentRule);
			}
		}

		addRootVars(ast, width, height, orientation, bleed, bleedrecto, bleedverso, marks) {
			let rules = [];
			let selectors = new lib.List();
			selectors.insertData({
				type: "PseudoClassSelector",
				name: "root",
				children: null
			});

			let widthString, heightString;
			let widthStringRight, heightStringRight;
			let widthStringLeft, heightStringLeft;

			if (!bleed) {
				widthString = CSSValueToString(width);
				heightString = CSSValueToString(height);
				widthStringRight = CSSValueToString(width);
				heightStringRight = CSSValueToString(height);
				widthStringLeft = CSSValueToString(width);
				heightStringLeft = CSSValueToString(height);
			} else {
				widthString = `calc( ${CSSValueToString(width)} + ${CSSValueToString(bleed.left)} + ${CSSValueToString(bleed.right)} )`;
				heightString = `calc( ${CSSValueToString(height)} + ${CSSValueToString(bleed.top)} + ${CSSValueToString(bleed.bottom)} )`;

				widthStringRight = `calc( ${CSSValueToString(width)} + ${CSSValueToString(bleed.left)} + ${CSSValueToString(bleed.right)} )`;
				heightStringRight = `calc( ${CSSValueToString(height)} + ${CSSValueToString(bleed.top)} + ${CSSValueToString(bleed.bottom)} )`;

				widthStringLeft = `calc( ${CSSValueToString(width)} + ${CSSValueToString(bleed.left)} + ${CSSValueToString(bleed.right)} )`;
				heightStringLeft = `calc( ${CSSValueToString(height)} + ${CSSValueToString(bleed.top)} + ${CSSValueToString(bleed.bottom)} )`;

				let bleedTop = this.createVariable("--pagedjs-bleed-top", CSSValueToString(bleed.top));
				let bleedRight = this.createVariable("--pagedjs-bleed-right", CSSValueToString(bleed.right));
				let bleedBottom = this.createVariable("--pagedjs-bleed-bottom", CSSValueToString(bleed.bottom));
				let bleedLeft = this.createVariable("--pagedjs-bleed-left", CSSValueToString(bleed.left));

				let bleedTopRecto = this.createVariable("--pagedjs-bleed-right-top", CSSValueToString(bleed.top));
				let bleedRightRecto = this.createVariable("--pagedjs-bleed-right-right", CSSValueToString(bleed.right));
				let bleedBottomRecto = this.createVariable("--pagedjs-bleed-right-bottom", CSSValueToString(bleed.bottom));
				let bleedLeftRecto = this.createVariable("--pagedjs-bleed-right-left", CSSValueToString(bleed.left));

				let bleedTopVerso = this.createVariable("--pagedjs-bleed-left-top", CSSValueToString(bleed.top));
				let bleedRightVerso = this.createVariable("--pagedjs-bleed-left-right", CSSValueToString(bleed.right));
				let bleedBottomVerso = this.createVariable("--pagedjs-bleed-left-bottom", CSSValueToString(bleed.bottom));
				let bleedLeftVerso = this.createVariable("--pagedjs-bleed-left-left", CSSValueToString(bleed.left));

				if (bleedrecto) {
					bleedTopRecto = this.createVariable("--pagedjs-bleed-right-top", CSSValueToString(bleedrecto.top));
					bleedRightRecto = this.createVariable("--pagedjs-bleed-right-right", CSSValueToString(bleedrecto.right));
					bleedBottomRecto = this.createVariable("--pagedjs-bleed-right-bottom", CSSValueToString(bleedrecto.bottom));
					bleedLeftRecto = this.createVariable("--pagedjs-bleed-right-left", CSSValueToString(bleedrecto.left));

					widthStringRight = `calc( ${CSSValueToString(width)} + ${CSSValueToString(bleedrecto.left)} + ${CSSValueToString(bleedrecto.right)} )`;
					heightStringRight = `calc( ${CSSValueToString(height)} + ${CSSValueToString(bleedrecto.top)} + ${CSSValueToString(bleedrecto.bottom)} )`;
				}
				if (bleedverso) {
					bleedTopVerso = this.createVariable("--pagedjs-bleed-left-top", CSSValueToString(bleedverso.top));
					bleedRightVerso = this.createVariable("--pagedjs-bleed-left-right", CSSValueToString(bleedverso.right));
					bleedBottomVerso = this.createVariable("--pagedjs-bleed-left-bottom", CSSValueToString(bleedverso.bottom));
					bleedLeftVerso = this.createVariable("--pagedjs-bleed-left-left", CSSValueToString(bleedverso.left));

					widthStringLeft = `calc( ${CSSValueToString(width)} + ${CSSValueToString(bleedverso.left)} + ${CSSValueToString(bleedverso.right)} )`;
					heightStringLeft = `calc( ${CSSValueToString(height)} + ${CSSValueToString(bleedverso.top)} + ${CSSValueToString(bleedverso.bottom)} )`;
				}

				let pageWidthVar = this.createVariable("--pagedjs-width", CSSValueToString(width));
				let pageHeightVar = this.createVariable("--pagedjs-height", CSSValueToString(height));

				rules.push(
					bleedTop,
					bleedRight,
					bleedBottom,
					bleedLeft,
					bleedTopRecto,
					bleedRightRecto,
					bleedBottomRecto,
					bleedLeftRecto,
					bleedTopVerso,
					bleedRightVerso,
					bleedBottomVerso,
					bleedLeftVerso,
					pageWidthVar,
					pageHeightVar
				);
			}

			if (marks) {
				marks.forEach((mark) => {
					let markDisplay = this.createVariable("--pagedjs-mark-" + mark + "-display", "block");
					rules.push(markDisplay);
				});
			}

			// orientation variable
			if (orientation) {
				let oVar = this.createVariable("--pagedjs-orientation", orientation);
				rules.push(oVar);

				if (orientation !== "portrait") {
					// reverse for orientation
					[widthString, heightString] = [heightString, widthString];
					[widthStringRight, heightStringRight] = [heightStringRight, widthStringRight];
					[widthStringLeft, heightStringLeft] = [heightStringLeft, widthStringLeft];
				}
			}

			let wVar = this.createVariable("--pagedjs-width", widthString);
			let hVar = this.createVariable("--pagedjs-height", heightString);

			let wVarR = this.createVariable("--pagedjs-width-right", widthStringRight);
			let hVarR = this.createVariable("--pagedjs-height-right", heightStringRight);

			let wVarL = this.createVariable("--pagedjs-width-left", widthStringLeft);
			let hVarL = this.createVariable("--pagedjs-height-left", heightStringLeft);

			rules.push(wVar, hVar, wVarR, hVarR, wVarL, hVarL);

			let rule = this.createRule(selectors, rules);

			ast.children.appendData(rule);
		}

		/*
		@page {
			size: var(--pagedjs-width) var(--pagedjs-height);
			margin: 0;
			padding: 0;
		}
		*/
		addRootPage(ast, size, bleed, bleedrecto, bleedverso) {
			let { width, height, orientation, format } = size;
			let children = new lib.List();
			let childrenLeft = new lib.List();
			let childrenRight = new lib.List();
			let dimensions = new lib.List();
			let dimensionsLeft = new lib.List();
			let dimensionsRight = new lib.List();

			if (bleed) {
				let widthCalculations = new lib.List();
				let heightCalculations = new lib.List();

				// width
				widthCalculations.appendData({
					type: "Dimension",
					unit: width.unit,
					value: width.value
				});

				widthCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculations.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculations.appendData({
					type: "Dimension",
					unit: bleed.left.unit,
					value: bleed.left.value
				});

				widthCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculations.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculations.appendData({
					type: "Dimension",
					unit: bleed.right.unit,
					value: bleed.right.value
				});

				// height
				heightCalculations.appendData({
					type: "Dimension",
					unit: height.unit,
					value: height.value
				});

				heightCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculations.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculations.appendData({
					type: "Dimension",
					unit: bleed.top.unit,
					value: bleed.top.value
				});

				heightCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculations.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculations.appendData({
					type: "Dimension",
					unit: bleed.bottom.unit,
					value: bleed.bottom.value
				});

				dimensions.appendData({
					type: "Function",
					name: "calc",
					children: widthCalculations
				});

				dimensions.appendData({
					type: "WhiteSpace",
					value: " "
				});

				dimensions.appendData({
					type: "Function",
					name: "calc",
					children: heightCalculations
				});

			} else if (format) {
				dimensions.appendData({
					type: "Identifier",
					name: format
				});

				if (orientation) {
					dimensions.appendData({
						type: "WhiteSpace",
						value: " "
					});

					dimensions.appendData({
						type: "Identifier",
						name: orientation
					});
				}
			} else {
				dimensions.appendData({
					type: "Dimension",
					unit: width.unit,
					value: width.value
				});

				dimensions.appendData({
					type: "WhiteSpace",
					value: " "
				});

				dimensions.appendData({
					type: "Dimension",
					unit: height.unit,
					value: height.value
				});
			}

			children.appendData({
				type: "Declaration",
				property: "size",
				loc: null,
				value: {
					type: "Value",
					children: dimensions
				}
			});

			children.appendData({
				type: "Declaration",
				property: "margin",
				loc: null,
				value: {
					type: "Value",
					children: [{
						type: "Dimension",
						unit: "px",
						value: 0
					}]
				}
			});

			children.appendData({
				type: "Declaration",
				property: "padding",
				loc: null,
				value: {
					type: "Value",
					children: [{
						type: "Dimension",
						unit: "px",
						value: 0
					}]
				}
			});

			children.appendData({
				type: "Declaration",
				property: "padding",
				loc: null,
				value: {
					type: "Value",
					children: [{
						type: "Dimension",
						unit: "px",
						value: 0
					}]
				}
			});

			let rule = ast.children.createItem({
				type: "Atrule",
				prelude: null,
				name: "page",
				block: {
					type: "Block",
					loc: null,
					children: children
				}
			});

			ast.children.append(rule);

			if (bleedverso) {
				let widthCalculationsLeft = new lib.List();
				let heightCalculationsLeft = new lib.List();

				// width
				widthCalculationsLeft.appendData({
					type: "Dimension",
					unit: width.unit,
					value: width.value
				});

				widthCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsLeft.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsLeft.appendData({
					type: "Dimension",
					unit: bleedverso.left.unit,
					value: bleedverso.left.value
				});

				widthCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsLeft.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsLeft.appendData({
					type: "Dimension",
					unit: bleedverso.right.unit,
					value: bleedverso.right.value
				});

				// height
				heightCalculationsLeft.appendData({
					type: "Dimension",
					unit: height.unit,
					value: height.value
				});

				heightCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsLeft.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsLeft.appendData({
					type: "Dimension",
					unit: bleedverso.top.unit,
					value: bleedverso.top.value
				});

				heightCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsLeft.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsLeft.appendData({
					type: "Dimension",
					unit: bleedverso.bottom.unit,
					value: bleedverso.bottom.value
				});

				dimensionsLeft.appendData({
					type: "Function",
					name: "calc",
					children: widthCalculationsLeft
				});

				dimensionsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				dimensionsLeft.appendData({
					type: "Function",
					name: "calc",
					children: heightCalculationsLeft
				});

				childrenLeft.appendData({
					type: "Declaration",
					property: "size",
					loc: null,
					value: {
						type: "Value",
						children: dimensionsLeft
					}
				});

				let ruleLeft = ast.children.createItem({
					type: "Atrule",
					prelude: null,
					name: "page :left",
					block: {
						type: "Block",
						loc: null,
						children: childrenLeft
					}
				});

				ast.children.append(ruleLeft);

			}

			if (bleedrecto) {
				let widthCalculationsRight = new lib.List();
				let heightCalculationsRight = new lib.List();

				// width
				widthCalculationsRight.appendData({
					type: "Dimension",
					unit: width.unit,
					value: width.value
				});

				widthCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsRight.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsRight.appendData({
					type: "Dimension",
					unit: bleedrecto.left.unit,
					value: bleedrecto.left.value
				});

				widthCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsRight.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsRight.appendData({
					type: "Dimension",
					unit: bleedrecto.right.unit,
					value: bleedrecto.right.value
				});

				// height
				heightCalculationsRight.appendData({
					type: "Dimension",
					unit: height.unit,
					value: height.value
				});

				heightCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsRight.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsRight.appendData({
					type: "Dimension",
					unit: bleedrecto.top.unit,
					value: bleedrecto.top.value
				});

				heightCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsRight.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsRight.appendData({
					type: "Dimension",
					unit: bleedrecto.bottom.unit,
					value: bleedrecto.bottom.value
				});

				dimensionsRight.appendData({
					type: "Function",
					name: "calc",
					children: widthCalculationsRight
				});

				dimensionsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				dimensionsRight.appendData({
					type: "Function",
					name: "calc",
					children: heightCalculationsRight
				});

				childrenRight.appendData({
					type: "Declaration",
					property: "size",
					loc: null,
					value: {
						type: "Value",
						children: dimensionsRight
					}
				});

				let ruleRight = ast.children.createItem({
					type: "Atrule",
					prelude: null,
					name: "page :right",
					block: {
						type: "Block",
						loc: null,
						children: childrenRight
					}
				});

				ast.children.append(ruleRight);

			}
		}

		getNth(nth) {
			let n = nth.indexOf("n");
			let plus = nth.indexOf("+");
			let splitN = nth.split("n");
			let splitP = nth.split("+");
			let a = null;
			let b = null;
			if (n > -1) {
				a = splitN[0];
				if (plus > -1) {
					b = splitP[1];
				}
			} else {
				b = nth;
			}

			return {
				type: "Nth",
				loc: null,
				selector: null,
				nth: {
					type: "AnPlusB",
					loc: null,
					a: a,
					b: b
				}
			};
		}

		addPageAttributes(page, start, pages) {
			let named = start.dataset.page;

			if (named) {
				page.name = named;
				page.element.classList.add("pagedjs_named_page");
				page.element.classList.add("pagedjs_" + named + "_page");

				if (!start.dataset.splitFrom) {
					page.element.classList.add("pagedjs_" + named + "_first_page");
				}
			}
		}

		getStartElement(content, breakToken) {
			let node = breakToken && breakToken.node;

			if (!content && !breakToken) {
				return;
			}

			// No break
			if (!node) {
				return content.children[0];
			}

			// Top level element
			if (node.nodeType === 1 && node.parentNode.nodeType === 11) {
				return node;
			}

			// Named page
			if (node.nodeType === 1 && node.dataset.page) {
				return node;
			}

			// Get top level Named parent
			let fragment = rebuildAncestors(node);
			let pages = fragment.querySelectorAll("[data-page]");

			if (pages.length) {
				return pages[pages.length - 1];
			} else {
				return fragment.children[0];
			}
		}

		beforePageLayout(page, contents, breakToken, chunker) {
			let start = this.getStartElement(contents, breakToken);
			if (start) {
				this.addPageAttributes(page, start, chunker.pages);
			}
			// page.element.querySelector('.paged_area').style.color = red;
		}

		afterPageLayout(fragment, page, breakToken, chunker) {
			for (let m in this.marginalia) {
				let margin = this.marginalia[m];
				let sels = m.split(" ");

				let content;
				if (page.element.matches(sels[0]) && margin.hasContent) {
					content = page.element.querySelector(sels[1]);
					content.classList.add("hasContent");
				}
			}

			// check center
			["top", "bottom"].forEach((loc) => {
				let marginGroup = page.element.querySelector(".pagedjs_margin-" + loc);
				let center = page.element.querySelector(".pagedjs_margin-" + loc + "-center");
				let left = page.element.querySelector(".pagedjs_margin-" + loc + "-left");
				let right = page.element.querySelector(".pagedjs_margin-" + loc + "-right");

				let centerContent = center.classList.contains("hasContent");
				let leftContent = left.classList.contains("hasContent");
				let rightContent = right.classList.contains("hasContent");
				let centerWidth, leftWidth, rightWidth;

				if (leftContent) {
					leftWidth = window.getComputedStyle(left)["max-width"];
				}

				if (rightContent) {
					rightWidth = window.getComputedStyle(right)["max-width"];
				}


				if (centerContent) {
					centerWidth = window.getComputedStyle(center)["max-width"];

					if (centerWidth === "none" || centerWidth === "auto") {
						if (!leftContent && !rightContent) {
							marginGroup.style["grid-template-columns"] = "0 1fr 0";
						} else if (leftContent) {
							if (!rightContent) {
								if (leftWidth !== "none" && leftWidth !== "auto") {
									marginGroup.style["grid-template-columns"] = leftWidth + " 1fr " + leftWidth;
								} else {
									marginGroup.style["grid-template-columns"] = "auto auto 1fr";
									left.style["white-space"] = "nowrap";
									center.style["white-space"] = "nowrap";
									let leftOuterWidth = left.offsetWidth;
									let centerOuterWidth = center.offsetWidth;
									let outerwidths = leftOuterWidth + centerOuterWidth;
									let newcenterWidth = centerOuterWidth * 100 / outerwidths;
									marginGroup.style["grid-template-columns"] = "minmax(16.66%, 1fr) minmax(33%, " + newcenterWidth + "%) minmax(16.66%, 1fr)";
									left.style["white-space"] = "normal";
									center.style["white-space"] = "normal";
								}
							} else {
								if (leftWidth !== "none" && leftWidth !== "auto") {
									if (rightWidth !== "none" && rightWidth !== "auto") {
										marginGroup.style["grid-template-columns"] = leftWidth + " 1fr " + rightWidth;
									} else {
										marginGroup.style["grid-template-columns"] = leftWidth + " 1fr " + leftWidth;
									}
								} else {
									if (rightWidth !== "none" && rightWidth !== "auto") {
										marginGroup.style["grid-template-columns"] = rightWidth + " 1fr " + rightWidth;
									} else {
										marginGroup.style["grid-template-columns"] = "auto auto 1fr";
										left.style["white-space"] = "nowrap";
										center.style["white-space"] = "nowrap";
										right.style["white-space"] = "nowrap";
										let leftOuterWidth = left.offsetWidth;
										let centerOuterWidth = center.offsetWidth;
										let rightOuterWidth = right.offsetWidth;
										let outerwidths = leftOuterWidth + centerOuterWidth + rightOuterWidth;
										let newcenterWidth = centerOuterWidth * 100 / outerwidths;
										if (newcenterWidth > 40) {
											marginGroup.style["grid-template-columns"] = "minmax(16.66%, 1fr) minmax(33%, " + newcenterWidth + "%) minmax(16.66%, 1fr)";
										} else {
											marginGroup.style["grid-template-columns"] = "repeat(3, 1fr)";
										}
										left.style["white-space"] = "normal";
										center.style["white-space"] = "normal";
										right.style["white-space"] = "normal";
									}
								}
							}
						} else {
							if (rightWidth !== "none" && rightWidth !== "auto") {
								marginGroup.style["grid-template-columns"] = rightWidth + " 1fr " + rightWidth;
							} else {
								marginGroup.style["grid-template-columns"] = "auto auto 1fr";
								right.style["white-space"] = "nowrap";
								center.style["white-space"] = "nowrap";
								let rightOuterWidth = right.offsetWidth;
								let centerOuterWidth = center.offsetWidth;
								let outerwidths = rightOuterWidth + centerOuterWidth;
								let newcenterWidth = centerOuterWidth * 100 / outerwidths;
								marginGroup.style["grid-template-columns"] = "minmax(16.66%, 1fr) minmax(33%, " + newcenterWidth + "%) minmax(16.66%, 1fr)";
								right.style["white-space"] = "normal";
								center.style["white-space"] = "normal";
							}
						}
					} else if (centerWidth !== "none" && centerWidth !== "auto") {
						if (leftContent && leftWidth !== "none" && leftWidth !== "auto") {
							marginGroup.style["grid-template-columns"] = leftWidth + " " + centerWidth + " 1fr";
						} else if (rightContent && rightWidth !== "none" && rightWidth !== "auto") {
							marginGroup.style["grid-template-columns"] = "1fr " + centerWidth + " " + rightWidth;
						} else {
							marginGroup.style["grid-template-columns"] = "1fr " + centerWidth + " 1fr";
						}

					}

				} else {
					if (leftContent) {
						if (!rightContent) {
							marginGroup.style["grid-template-columns"] = "1fr 0 0";
						} else {
							if (leftWidth !== "none" && leftWidth !== "auto") {
								if (rightWidth !== "none" && rightWidth !== "auto") {
									marginGroup.style["grid-template-columns"] = leftWidth + " 1fr " + rightWidth;
								} else {
									marginGroup.style["grid-template-columns"] = leftWidth + " 0 1fr";
								}
							} else {
								if (rightWidth !== "none" && rightWidth !== "auto") {
									marginGroup.style["grid-template-columns"] = "1fr 0 " + rightWidth;
								} else {
									marginGroup.style["grid-template-columns"] = "auto 1fr auto";
									left.style["white-space"] = "nowrap";
									right.style["white-space"] = "nowrap";
									let leftOuterWidth = left.offsetWidth;
									let rightOuterWidth = right.offsetWidth;
									let outerwidths = leftOuterWidth + rightOuterWidth;
									let newLeftWidth = leftOuterWidth * 100 / outerwidths;
									marginGroup.style["grid-template-columns"] = "minmax(16.66%, " + newLeftWidth + "%) 0 1fr";
									left.style["white-space"] = "normal";
									right.style["white-space"] = "normal";
								}
							}
						}
					} else {
						if (rightWidth !== "none" && rightWidth !== "auto") {
							marginGroup.style["grid-template-columns"] = "1fr 0 " + rightWidth;
						} else {
							marginGroup.style["grid-template-columns"] = "0 0 1fr";
						}
					}
				}
			});

			// check middle
			["left", "right"].forEach((loc) => {
				let middle = page.element.querySelector(".pagedjs_margin-" + loc + "-middle.hasContent");
				let marginGroup = page.element.querySelector(".pagedjs_margin-" + loc);
				let top = page.element.querySelector(".pagedjs_margin-" + loc + "-top");
				let bottom = page.element.querySelector(".pagedjs_margin-" + loc + "-bottom");
				let topContent = top.classList.contains("hasContent");
				let bottomContent = bottom.classList.contains("hasContent");
				let middleHeight, topHeight, bottomHeight;

				if (topContent) {
					topHeight = window.getComputedStyle(top)["max-height"];
				}

				if (bottomContent) {
					bottomHeight = window.getComputedStyle(bottom)["max-height"];
				}

				if (middle) {
					middleHeight = window.getComputedStyle(middle)["max-height"];

					if (middleHeight === "none" || middleHeight === "auto") {
						if (!topContent && !bottomContent) {
							marginGroup.style["grid-template-rows"] = "0 1fr 0";
						} else if (topContent) {
							if (!bottomContent) {
								if (topHeight !== "none" && topHeight !== "auto") {
									marginGroup.style["grid-template-rows"] = topHeight + " calc(100% - " + topHeight + "*2) " + topHeight;
								}
							} else {
								if (topHeight !== "none" && topHeight !== "auto") {
									if (bottomHeight !== "none" && bottomHeight !== "auto") {
										marginGroup.style["grid-template-rows"] = topHeight + " calc(100% - " + topHeight + " - " + bottomHeight + ") " + bottomHeight;
									} else {
										marginGroup.style["grid-template-rows"] = topHeight + " calc(100% - " + topHeight + "*2) " + topHeight;
									}
								} else {
									if (bottomHeight !== "none" && bottomHeight !== "auto") {
										marginGroup.style["grid-template-rows"] = bottomHeight + " calc(100% - " + bottomHeight + "*2) " + bottomHeight;
									}
								}
							}
						} else {
							if (bottomHeight !== "none" && bottomHeight !== "auto") {
								marginGroup.style["grid-template-rows"] = bottomHeight + " calc(100% - " + bottomHeight + "*2) " + bottomHeight;
							}
						}
					} else {
						if (topContent && topHeight !== "none" && topHeight !== "auto") {
							marginGroup.style["grid-template-rows"] = topHeight + " " + middleHeight + " calc(100% - (" + topHeight + " + " + middleHeight + "))";
						} else if (bottomContent && bottomHeight !== "none" && bottomHeight !== "auto") {
							marginGroup.style["grid-template-rows"] = "1fr " + middleHeight + " " + bottomHeight;
						} else {
							marginGroup.style["grid-template-rows"] = "calc((100% - " + middleHeight + ")/2) " + middleHeight + " calc((100% - " + middleHeight + ")/2)";
						}

					}

				} else {
					if (topContent) {
						if (!bottomContent) {
							marginGroup.style["grid-template-rows"] = "1fr 0 0";
						} else {
							if (topHeight !== "none" && topHeight !== "auto") {
								if (bottomHeight !== "none" && bottomHeight !== "auto") {
									marginGroup.style["grid-template-rows"] = topHeight + " 1fr " + bottomHeight;
								} else {
									marginGroup.style["grid-template-rows"] = topHeight + " 0 1fr";
								}
							} else {
								if (bottomHeight !== "none" && bottomHeight !== "auto") {
									marginGroup.style["grid-template-rows"] = "1fr 0 " + bottomHeight;
								} else {
									marginGroup.style["grid-template-rows"] = "1fr 0 1fr";
								}
							}
						}
					} else {
						if (bottomHeight !== "none" && bottomHeight !== "auto") {
							marginGroup.style["grid-template-rows"] = "1fr 0 " + bottomHeight;
						} else {
							marginGroup.style["grid-template-rows"] = "0 0 1fr";
						}
					}
				}



			});

		}

		// CSS Tree Helpers

		selectorsForPage(page) {
			let nthlist;
			let nth;

			let selectors = new lib.List();

			selectors.insertData({
				type: "ClassSelector",
				name: "pagedjs_page"
			});

			// Named page
			if (page.name) {
				selectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_named_page"
				});

				selectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_" + page.name + "_page"
				});
			}

			// PsuedoSelector
			if (page.psuedo && !(page.name && page.psuedo === "first")) {
				selectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_" + page.psuedo + "_page"
				});
			}

			if (page.name && page.psuedo === "first") {
				selectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_" + page.name + "_" + page.psuedo + "_page"
				});
			}

			// Nth
			if (page.nth) {
				nthlist = new lib.List();
				nth = this.getNth(page.nth);

				nthlist.insertData(nth);

				selectors.insertData({
					type: "PseudoClassSelector",
					name: "nth-of-type",
					children: nthlist
				});
			}

			return selectors;
		}

		selectorsForPageMargin(page, margin) {
			let selectors = this.selectorsForPage(page);

			selectors.insertData({
				type: "Combinator",
				name: " "
			});

			selectors.insertData({
				type: "ClassSelector",
				name: "pagedjs_margin-" + margin
			});

			return selectors;
		}

		createDeclaration(property, value, important) {
			let children = new lib.List();

			children.insertData({
				type: "Identifier",
				loc: null,
				name: value
			});

			return {
				type: "Declaration",
				loc: null,
				important: important,
				property: property,
				value: {
					type: "Value",
					loc: null,
					children: children
				}
			};
		}

		createVariable(property, value) {
			return {
				type: "Declaration",
				loc: null,
				property: property,
				value: {
					type: "Raw",
					value: value
				}
			};
		}

		createCalculatedDimension(property, items, important, operator = "+") {
			let children = new lib.List();
			let calculations = new lib.List();

			items.forEach((item, index) => {
				calculations.appendData({
					type: "Dimension",
					unit: item.unit,
					value: item.value
				});

				calculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				if (index + 1 < items.length) {
					calculations.appendData({
						type: "Operator",
						value: operator
					});

					calculations.appendData({
						type: "WhiteSpace",
						value: " "
					});
				}
			});

			children.insertData({
				type: "Function",
				loc: null,
				name: "calc",
				children: calculations
			});

			return {
				type: "Declaration",
				loc: null,
				important: important,
				property: property,
				value: {
					type: "Value",
					loc: null,
					children: children
				}
			};
		}

		createDimension(property, cssValue, important) {
			let children = new lib.List();

			children.insertData({
				type: "Dimension",
				loc: null,
				value: cssValue.value,
				unit: cssValue.unit
			});

			return {
				type: "Declaration",
				loc: null,
				important: important,
				property: property,
				value: {
					type: "Value",
					loc: null,
					children: children
				}
			};
		}

		createBlock(declarations) {
			let block = new lib.List();

			declarations.forEach((declaration) => {
				block.insertData(declaration);
			});

			return {
				type: "Block",
				loc: null,
				children: block
			};
		}

		createRule(selectors, block) {
			let selectorList = new lib.List();
			selectorList.insertData({
				type: "Selector",
				children: selectors
			});

			if (Array.isArray(block)) {
				block = this.createBlock(block);
			}

			return {
				type: "Rule",
				prelude: {
					type: "SelectorList",
					children: selectorList
				},
				block: block
			};
		}

	}

	class Breaks extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.breaks = {};
		}

		onDeclaration(declaration, dItem, dList, rule) {
			let property = declaration.property;

			if (property === "page") {
				let children = declaration.value.children.first();
				let value = children.name;
				let selector = lib.generate(rule.ruleNode.prelude);
				let name = value;

				let breaker = {
					property: property,
					value: value,
					selector: selector,
					name: name
				};

				selector.split(",").forEach((s) => {
					if (!this.breaks[s]) {
						this.breaks[s] = [breaker];
					} else {
						this.breaks[s].push(breaker);
					}
				});

				dList.remove(dItem);
			}

			if (property === "break-before" ||
					property === "break-after" ||
					property === "page-break-before" ||
					property === "page-break-after"
			) {
				let child = declaration.value.children.first();
				let value = child.name;
				let selector = lib.generate(rule.ruleNode.prelude);

				if (property === "page-break-before") {
					property = "break-before";
				} else if (property === "page-break-after") {
					property = "break-after";
				}

				let breaker = {
					property: property,
					value: value,
					selector: selector
				};

				selector.split(",").forEach((s) => {
					if (!this.breaks[s]) {
						this.breaks[s] = [breaker];
					} else {
						this.breaks[s].push(breaker);
					}
				});

				// Remove from CSS -- handle right / left in module
				dList.remove(dItem);
			}
		}

		afterParsed(parsed) {
			this.processBreaks(parsed, this.breaks);
		}

		processBreaks(parsed, breaks) {
			for (let b in breaks) {
				// Find elements
				let elements = parsed.querySelectorAll(b);
				// Add break data
				for (var i = 0; i < elements.length; i++) {
					for (let prop of breaks[b]) {

						if (prop.property === "break-after") {
							let nodeAfter = displayedElementAfter(elements[i], parsed);

							elements[i].setAttribute("data-break-after", prop.value);

							if (nodeAfter) {
								nodeAfter.setAttribute("data-previous-break-after", prop.value);
							}
						} else if (prop.property === "break-before") {
							let nodeBefore = displayedElementBefore(elements[i], parsed);

							// Breaks are only allowed between siblings, not between a box and its container.
							// If we cannot find a node before we should not break!
							// https://drafts.csswg.org/css-break-3/#break-propagation
							if (nodeBefore) {
								if (prop.value === "page" && needsPageBreak(elements[i], nodeBefore)) {
									// we ignore this explicit page break because an implicit page break is already needed
									continue;
								}
								elements[i].setAttribute("data-break-before", prop.value);
								nodeBefore.setAttribute("data-next-break-before", prop.value);
							}
						} else if (prop.property === "page") {
							elements[i].setAttribute("data-page", prop.value);

							let nodeAfter = displayedElementAfter(elements[i], parsed);

							if (nodeAfter) {
								nodeAfter.setAttribute("data-after-page", prop.value);
							}
						} else {
							elements[i].setAttribute("data-" + prop.property, prop.value);
						}
					}
				}
			}
		}

		mergeBreaks(pageBreaks, newBreaks) {
			for (let b in newBreaks) {
				if (b in pageBreaks) {
					pageBreaks[b] = pageBreaks[b].concat(newBreaks[b]);
				} else {
					pageBreaks[b] = newBreaks[b];
				}
			}
			return pageBreaks;
		}

		addBreakAttributes(pageElement, page) {
			let before = pageElement.querySelector("[data-break-before]");
			let after = pageElement.querySelector("[data-break-after]");
			let previousBreakAfter = pageElement.querySelector("[data-previous-break-after]");

			if (before) {
				if (before.dataset.splitFrom) {
					page.splitFrom = before.dataset.splitFrom;
					pageElement.setAttribute("data-split-from", before.dataset.splitFrom);
				} else if (before.dataset.breakBefore && before.dataset.breakBefore !== "avoid") {
					page.breakBefore = before.dataset.breakBefore;
					pageElement.setAttribute("data-break-before", before.dataset.breakBefore);
				}
			}

			if (after && after.dataset) {
				if (after.dataset.splitTo) {
					page.splitTo = after.dataset.splitTo;
					pageElement.setAttribute("data-split-to", after.dataset.splitTo);
				} else if (after.dataset.breakAfter && after.dataset.breakAfter !== "avoid") {
					page.breakAfter = after.dataset.breakAfter;
					pageElement.setAttribute("data-break-after", after.dataset.breakAfter);
				}
			}

			if (previousBreakAfter && previousBreakAfter.dataset) {
				if (previousBreakAfter.dataset.previousBreakAfter && previousBreakAfter.dataset.previousBreakAfter !== "avoid") {
					page.previousBreakAfter = previousBreakAfter.dataset.previousBreakAfter;
				}
			}
		}

		afterPageLayout(pageElement, page) {
			this.addBreakAttributes(pageElement, page);
		}
	}

	class PrintMedia extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}

		onAtMedia(node, item, list) {
			let media = this.getMediaName(node);
			let rules;

			if (media === "print") {
				rules = node.block.children;

				// Remove rules from the @media block
				node.block.children = new lib.List();

				// Append rules to the end of main rules list
				list.appendList(rules);
			}

		}

		getMediaName(node) {
			let media = "";

			if (typeof node.prelude === "undefined" ||
					node.prelude.type !== "AtrulePrelude" ) {
				return;
			}

			lib.walk(node.prelude, {
				visit: "Identifier",
				enter: (identNode, iItem, iList) => {
					media = identNode.name;
				}
			});
			return media;
		}


	}

	class Splits extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}

		afterPageLayout(pageElement, page, breakToken, chunker) {
			let splits = Array.from(pageElement.querySelectorAll("[data-split-from]"));
			let pages = pageElement.parentNode;
			let index = Array.prototype.indexOf.call(pages.children, pageElement);
			let prevPage;

			if (index === 0) {
				return;
			}

			prevPage = pages.children[index - 1];

			let from; // Capture the last from element
			splits.forEach((split) => {
				let ref = split.dataset.ref;
				from = prevPage.querySelector("[data-ref='"+ ref +"']:not([data-split-to])");

				if (from) {
					from.dataset.splitTo = ref;

					if (!from.dataset.splitFrom) {
						from.dataset.splitOriginal = true;
					}
				}
			});

			// Fix alignment on the deepest split element
			if (from) {
				this.handleAlignment(from);
			}
		}

		handleAlignment(node) {
			let styles = window.getComputedStyle(node);
			let align = styles["text-align"];
			let alignLast = styles["text-align-last"];
			node.dataset.lastSplitElement = "true";
			if (align === "justify" && alignLast === "auto") {
				node.dataset.alignLastSplitElement = "justify";
			} else {
				node.dataset.alignLastSplitElement = alignLast;
			}
		}

	}

	class Counters extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;
			this.counters = {};
			this.resetCountersMap = new Map();
		}

		onDeclaration(declaration, dItem, dList, rule) {
			let property = declaration.property;

			if (property === "counter-increment") {
				let inc = this.handleIncrement(declaration, rule);
				if (inc) {
					dList.remove(dItem);
				}
			} else if (property === "counter-reset") {
				let reset = this.handleReset(declaration, rule);
				if (reset) {
					dList.remove(dItem);
				}
			}
		}

		onContent(funcNode, fItem, fList, declaration, rule) {
			if (funcNode.name === "counter") ;
		}

		afterParsed(parsed) {
			this.processCounters(parsed, this.counters);
			this.scopeCounters(this.counters);
		}

		addCounter(name) {
			if (name in this.counters) {
				return this.counters[name];
			}

			this.counters[name] = {
				name: name,
				increments: {},
				resets: {}
			};

			return this.counters[name];
		}

		handleIncrement(declaration, rule) {
			const identifier = declaration.value.children.first();
			const number = declaration.value.children.getSize() > 1 ? declaration.value.children.last().value : 1;
			const name = identifier && identifier.name;

			if (name === "page" || name.indexOf("target-counter-") === 0) {
				return;
			}

			let selector = lib.generate(rule.ruleNode.prelude);

			let counter;
			if (!(name in this.counters)) {
				counter = this.addCounter(name);
			} else {
				counter = this.counters[name];
			}

			return counter.increments[selector] = {
				selector: selector,
				number
			};
		}

		handleReset(declaration, rule) {
			let identifier = declaration.value.children.first();
			let number = declaration.value.children.getSize() > 1
								&& declaration.value.children.last().value;
			let name = identifier && identifier.name;
			let selector = lib.generate(rule.ruleNode.prelude);
			let counter;

			if (!(name in this.counters)) {
				counter = this.addCounter(name);
			} else {
				counter = this.counters[name];
			}

			return counter.resets[selector] = {
				selector: selector,
				number: number || 0
			};
		}

		processCounters(parsed, counters) {
			let counter;
			for (let c in counters) {
				counter = this.counters[c];
				this.processCounterIncrements(parsed, counter);
				this.processCounterResets(parsed, counter);
				if (c !== "page") {
					this.addCounterValues(parsed, counter);
				}
			}
		}

		scopeCounters(counters) {
			let countersArray = [];
			for (let c in counters) {
				if(c !== "page") {
					countersArray.push(`${counters[c].name} 0`);
				}
			}
			// Add to pages to allow cross page scope
			this.insertRule(`.pagedjs_pages { counter-reset: ${countersArray.join(" ")} page 0 pages var(--pagedjs-page-count)}`);
		}

		insertRule(rule) {
			this.styleSheet.insertRule(rule, this.styleSheet.cssRules.length);
		}

		processCounterIncrements(parsed, counter) {
			let increment;
			for (let inc in counter.increments) {
				increment = counter.increments[inc];
				// Find elements for increments
				let incrementElements = parsed.querySelectorAll(increment.selector);
				// Add counter data
				for (let i = 0; i < incrementElements.length; i++) {
					incrementElements[i].setAttribute("data-counter-"+ counter.name +"-increment", increment.number);
					incrementElements[i].setAttribute("data-counter-increment", counter.name);
				}
			}
		}

		processCounterResets(parsed, counter) {
			let reset;
			for (let r in counter.resets) {
				reset = counter.resets[r];
				// Find elements for resets
				let resetElements = parsed.querySelectorAll(reset.selector);
				// Add counter data
				for (var i = 0; i < resetElements.length; i++) {
					resetElements[i].setAttribute("data-counter-"+ counter.name +"-reset", reset.number);
					resetElements[i].setAttribute("data-counter-reset", counter.name);
				}
			}
		}

		addCounterValues(parsed, counter) {
			const counterName = counter.name;
			const elements = parsed.querySelectorAll("[data-counter-"+ counterName +"-reset], [data-counter-"+ counterName +"-increment]");

			let count = 0;
			let element;
			let increment, reset;
			let resetValue, incrementValue, resetDelta;
			let incrementArray;

			for (let i = 0; i < elements.length; i++) {
				element = elements[i];
				resetDelta = 0;
				incrementArray = [];

				if (element.hasAttribute("data-counter-"+ counterName +"-reset")) {
					reset = element.getAttribute("data-counter-"+ counterName +"-reset");
					resetValue = parseInt(reset);

					// Use negative increment value inplace of reset
					resetDelta = resetValue - count;
					incrementArray.push(`${counterName} ${resetDelta}`);

					count = resetValue;
				}

				if (element.hasAttribute("data-counter-"+ counterName +"-increment")) {

					increment = element.getAttribute("data-counter-"+ counterName +"-increment");
					incrementValue = parseInt(increment);

					count += incrementValue;

					element.setAttribute("data-counter-"+counterName+"-value", count);

					incrementArray.push(`${counterName} ${incrementValue}`);
				}

				if (incrementArray.length > 0) {
					this.incrementCounterForElement(element, incrementArray);
				}

			}
		}

		incrementCounterForElement(element, incrementArray) {
			if (!element || !incrementArray || incrementArray.length === 0) return;

			const ref = element.dataset.ref;
			const prevIncrements = Array.from(this.styleSheet.cssRules).filter((rule) => {
				return rule.selectorText === `[data-ref="${element.dataset.ref}"]:not([data-split-from])`
							 && rule.style[0] === "counter-increment";
			});

			const increments = [];
			for (let styleRule of prevIncrements) {
				let values = styleRule.style.counterIncrement.split(" ");
				for (let i = 0; i < values.length; i+=2) {
					increments.push(values[i] + " " + values[i+1]);
				}
			}

			Array.prototype.push.apply(increments, incrementArray);

			this.insertRule(`[data-ref="${ref}"]:not([data-split-from]) { counter-increment: ${increments.join(" ")} }`);
		}

		afterPageLayout(pageElement, page) {
			let pgreset = pageElement.querySelectorAll("[data-counter-page-reset]");
			pgreset.forEach((reset) => {
				const ref = reset.dataset && reset.dataset.ref;
				if (ref && this.resetCountersMap.has(ref)) ; else {
					if (ref) {
						this.resetCountersMap.set(ref, "");
					}
					let value = reset.dataset.counterPageReset;
					this.styleSheet.insertRule(`[data-page-number="${pageElement.dataset.pageNumber}"] { counter-increment: none; counter-reset: page ${value}; }`, this.styleSheet.cssRules.length);
				}
			});
		}

	}

	class Lists extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}
		afterParsed(content) {
			const orderedLists = content.querySelectorAll("ol");

			for (var list of orderedLists) {
				this.addDataNumbers(list);
			}
		}

		afterPageLayout(pageElement, page, breakToken, chunker) {
			var orderedLists = pageElement.getElementsByTagName("ol");
			for (var list of orderedLists) {
				if (list.hasChildNodes()) {
					list.start = list.firstElementChild.dataset.itemNum;
				}
				else {
					list.parentNode.removeChild(list);
				}
			}
		}

		addDataNumbers(list) {
			let start = 1;
			if (list.hasAttribute("start")) {
				start = parseInt(list.getAttribute("start"), 10);
				if (isNaN(start)) {
					start = 1;
				}
			}
			let items = list.children;
			for (var i = 0; i < items.length; i++) {
				items[i].setAttribute("data-item-num", i + start);
			}
		}

	}

	class PositionFixed extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
			this.styleSheet = polisher.styleSheet;
			this.fixedElementsSelector = [];
			this.fixedElements = [];
		}

		onDeclaration(declaration, dItem, dList, rule) {
			if (declaration.property === "position" && declaration.value.children.first().name === "fixed") {
				let selector = lib.generate(rule.ruleNode.prelude);
				this.fixedElementsSelector.push(selector);
				dList.remove(dItem);
			}
		}

		afterParsed(fragment) {
			this.fixedElementsSelector.forEach(fixedEl => {
				fragment.querySelectorAll(`${fixedEl}`).forEach(el => {
					el.style.setProperty("position", "absolute");
					this.fixedElements.push(el);
					el.remove();
				});
			});
		}

		afterPageLayout(pageElement, page, breakToken) {
			this.fixedElements.forEach(el => {
				const clone = el.cloneNode(true);
				pageElement.querySelector(".pagedjs_pagebox").insertAdjacentElement("afterbegin", clone);
			});
		}
	}

	class PageCounterIncrement extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;
			this.pageCounter = {
				name: "page",
				increments: {},
				resets: {}
			};
		}

		onDeclaration(declaration, dItem, dList, rule) {
			const property = declaration.property;

			if (property === "counter-increment") {
				let inc = this.handleIncrement(declaration, rule);
				if (inc) {
					dList.remove(dItem);
				}
			}
		}

		afterParsed(_) {
			for (const inc in this.pageCounter.increments) {
				const increment = this.pageCounter.increments[inc];
				this.insertRule(`${increment.selector} { --pagedjs-page-counter-increment: ${increment.number} }`);
			}
		}

		handleIncrement(declaration, rule) {
			const identifier = declaration.value.children.first();
			const number = declaration.value.children.getSize() > 1 ? declaration.value.children.last().value : 1;
			const name = identifier && identifier.name;

			if (name.indexOf("target-counter-") === 0) {
				return;
			}
			// A counter named page is automatically created and incremented by 1 on every page of the document,
			// unless the counter-increment property in the page context explicitly specifies a different increment for the page counter.
			// https://www.w3.org/TR/css-page-3/#page-based-counters
			if (name !== "page") {
				return;
			}
			// the counter-increment property is not defined on the page context (i.e. @page rule), ignoring...
			if (rule.ruleNode.name === "page" && rule.ruleNode.type === "Atrule") {
				return;
			}
			const selector = lib.generate(rule.ruleNode.prelude);
			return this.pageCounter.increments[selector] = {
				selector: selector,
				number
			};
		}

		insertRule(rule) {
			this.styleSheet.insertRule(rule, this.styleSheet.cssRules.length);
		}
	}

	class NthOfType extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;
			this.selectors = {};
		}

		onRule(ruleNode, ruleItem, rulelist) {
			let selector = lib.generate(ruleNode.prelude);
			if (selector.match(/:(first|last|nth)-of-type/)) {
				
				let declarations = lib.generate(ruleNode.block);
				declarations = declarations.replace(/[{}]/g,"");

				let uuid = "nth-of-type-" + UUID();

				selector.split(",").forEach((s) => {
					if (!this.selectors[s]) {
						this.selectors[s] = [uuid, declarations];
					} else {
						this.selectors[s][1] = `${this.selectors[s][1]};${declarations}` ;
					}
				});

				rulelist.remove(ruleItem);
			}
		}

		afterParsed(parsed) {
			this.processSelectors(parsed, this.selectors);
		}

		processSelectors(parsed, selectors) {
			// add the new attributes to matching elements
			for (let s in selectors) {
				let elements = parsed.querySelectorAll(s);

				for (var i = 0; i < elements.length; i++) {
					let dataNthOfType = elements[i].getAttribute("data-nth-of-type");

					if (dataNthOfType && dataNthOfType != "") {
						dataNthOfType = `${dataNthOfType},${selectors[s][0]}`;
						elements[i].setAttribute("data-nth-of-type", dataNthOfType);
					} else {
						elements[i].setAttribute("data-nth-of-type", selectors[s][0]);
					}
				}

				let rule = `*[data-nth-of-type*='${selectors[s][0]}'] { ${selectors[s][1]}; }`;
				this.styleSheet.insertRule(rule, this.styleSheet.cssRules.length);
			}
		}
	}

	class Following extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;
			this.selectors = {};
		}

		onRule(ruleNode, ruleItem, rulelist) {
			let selector = lib.generate(ruleNode.prelude);
			if (selector.match(/\+/)) {
				
				let declarations = lib.generate(ruleNode.block);
				declarations = declarations.replace(/[{}]/g,"");

				let uuid = "following-" + UUID();

				selector.split(",").forEach((s) => {
					if (!this.selectors[s]) {
						this.selectors[s] = [uuid, declarations];
					} else {
						this.selectors[s][1] = `${this.selectors[s][1]};${declarations}` ;
					}
				});

				rulelist.remove(ruleItem);
			}
		}

		afterParsed(parsed) {
			this.processSelectors(parsed, this.selectors);
		}

		processSelectors(parsed, selectors) {
			// add the new attributes to matching elements
			for (let s in selectors) {
				let elements = parsed.querySelectorAll(s);

				for (var i = 0; i < elements.length; i++) {
					let dataFollowing = elements[i].getAttribute("data-following");

					if (dataFollowing && dataFollowing != "") {
						dataFollowing = `${dataFollowing},${selectors[s][0]}`;
						elements[i].setAttribute("data-following", dataFollowing);
					} else {
						elements[i].setAttribute("data-following", selectors[s][0]);
					}
				}

				let rule = `*[data-following*='${selectors[s][0]}'] { ${selectors[s][1]}; }`;
				this.styleSheet.insertRule(rule, this.styleSheet.cssRules.length);
			}
		}
	}

	var pagedMediaHandlers = [
		AtPage,
		Breaks,
		PrintMedia,
		Splits,
		Counters,
		Lists,
		PositionFixed,
		PageCounterIncrement,
		NthOfType,
		Following
	];

	class RunningHeaders extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.runningSelectors = {};
			this.elements = {};
		}

		onDeclaration(declaration, dItem, dList, rule) {
			if (declaration.property === "position") {
				let selector = lib.generate(rule.ruleNode.prelude);
				let identifier = declaration.value.children.first().name;

				if (identifier === "running") {
					let value;
					lib.walk(declaration, {
						visit: "Function",
						enter: (node, item, list) => {
							value = node.children.first().name;
						}
					});

					this.runningSelectors[value] = {
						identifier: identifier,
						value: value,
						selector: selector
					};
				}
			}

			if (declaration.property === "content") {

				lib.walk(declaration, {
					visit: "Function",
					enter: (funcNode, fItem, fList) => {

						if (funcNode.name.indexOf("element") > -1) {

							let selector = lib.generate(rule.ruleNode.prelude);

							let func = funcNode.name;

							let value = funcNode.children.first().name;

							let args = [value];

							// we only handle first for now
							let style = "first";

							selector.split(",").forEach((s) => {
								// remove before / after
								s = s.replace(/::after|::before/, "");

								this.elements[s] = {
									func: func,
									args: args,
									value: value,
									style: style ,
									selector: s,
									fullSelector: selector
								};
							});
						}

					}
				});
			}
		}

		afterParsed(fragment) {
			for (let name of Object.keys(this.runningSelectors)) {
				let set = this.runningSelectors[name];
				let selected = Array.from(fragment.querySelectorAll(set.selector));

				if (set.identifier === "running") {
					for (let header of selected) {
						header.style.display = "none";
					}
				}

			}
		}

		afterPageLayout(fragment) {
			for (let name of Object.keys(this.runningSelectors)) {
				let set = this.runningSelectors[name];
				let selected = fragment.querySelector(set.selector);
				if (selected) {
					// let cssVar;
					if (set.identifier === "running") {
						// cssVar = selected.textContent.replace(/\\([\s\S])|(["|'])/g,"\\$1$2");
						// this.styleSheet.insertRule(`:root { --string-${name}: "${cssVar}"; }`, this.styleSheet.cssRules.length);
						// fragment.style.setProperty(`--string-${name}`, `"${cssVar}"`);
						set.first = selected;
					} else {
						console.warn(set.value + "needs css replacement");
					}
				}
			}

			// move elements
			if (!this.orderedSelectors) {
				this.orderedSelectors = this.orderSelectors(this.elements);
			}

			for (let selector of this.orderedSelectors) {
				if (selector) {

					let el = this.elements[selector];
					let selected = fragment.querySelector(selector);
					if (selected) {
						let running = this.runningSelectors[el.args[0]];
						if (running && running.first) {
							selected.innerHTML = ""; // Clear node
							// selected.classList.add("pagedjs_clear-after"); // Clear ::after
							let clone = running.first.cloneNode(true);
							clone.style.display = null;
							selected.appendChild(clone);
						}
					}
				}
			}
		}

		/**
		* Assign a weight to @page selector classes
		* 1) page
		* 2) left & right
		* 3) blank
		* 4) first & nth
		* 5) named page
		* 6) named left & right
		* 7) named first & nth
		* @param {string} [s] selector string
		* @return {int} weight
		*/
		pageWeight(s) {
			let weight = 1;
			let selector = s.split(" ");
			let parts = selector.length && selector[0].split(".");

			parts.shift(); // remove empty first part

			switch (parts.length) {
				case 4:
					if (parts[3] === "pagedjs_first_page") {
						weight = 7;
					} else if (parts[3] === "pagedjs_left_page" || parts[3] === "pagedjs_right_page") {
						weight = 6;
					}
					break;
				case 3:
					if (parts[1] === "pagedjs_named_page") {
						if (parts[2].indexOf(":nth-of-type") > -1) {
							weight = 7;
						} else {
							weight = 5;
						}
					}
					break;
				case 2:
					if (parts[1] === "pagedjs_first_page") {
						weight = 4;
					} else if (parts[1] === "pagedjs_blank_page") {
						weight = 3;
					} else if (parts[1] === "pagedjs_left_page" || parts[1] === "pagedjs_right_page") {
						weight = 2;
					}
					break;
				default:
					if (parts[0].indexOf(":nth-of-type") > -1) {
						weight = 4;
					} else {
						weight = 1;
					}
			}

			return weight;
		}

		/**
		* Orders the selectors based on weight
		*
		* Does not try to deduplicate base on specifity of the selector
		* Previous matched selector will just be overwritten
		* @param {obj} [obj] selectors object
		* @return {Array} orderedSelectors
		*/
		orderSelectors(obj) {
			let selectors = Object.keys(obj);
			let weighted = {
				1: [],
				2: [],
				3: [],
				4: [],
				5: [],
				6: [],
				7: []
			};

			let orderedSelectors = [];

			for (let s of selectors) {
				let w = this.pageWeight(s);
				weighted[w].unshift(s);
			}

			for (var i = 1; i <= 7; i++) {
				orderedSelectors = orderedSelectors.concat(weighted[i]);
			}

			return orderedSelectors;
		}

		beforeTreeParse(text, sheet) {
			// element(x) is parsed as image element selector, so update element to element-ident
			sheet.text = text.replace(/element[\s]*\(([^|^#)]*)\)/g, "element-ident($1)");
		}
	}

	function cleanPseudoContent(el, trim = "\"' ") {
		if(el == null) return;
		return el
			.replace(new RegExp(`^[${trim}]+`), "")
			.replace(new RegExp(`[${trim}]+$`), "")
			.replace(/["']/g, match => {
				return "\\" + match;
			})
			.replace(/[\n]/g, match => {
				return "\\00000A";
			});
	}

	function cleanSelector(el) {
		if(el == null) return;
		return el
			.replace(new RegExp("::footnote-call", "g"), "")
			.replace(new RegExp("::footnote-marker", "g"), "");
	}

	class StringSets extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.stringSetSelectors = {};
			this.type;
			// pageLastString = last string variable defined on the page 
			this.pageLastString;

		}
		
		onDeclaration(declaration, dItem, dList, rule) {
			if (declaration.property === "string-set") {
				let selector = lib.generate(rule.ruleNode.prelude);

				let identifier = declaration.value.children.first().name;

				let value;
				lib.walk(declaration, {
					visit: "Function",
					enter: (node, item, list) => {
						value = lib.generate(node);
					}
				});

				this.stringSetSelectors[identifier] = {
					identifier,
					value,
					selector
				};
			}
		}

		onContent(funcNode, fItem, fList, declaration, rule) {

			if (funcNode.name === "string") {
				let identifier = funcNode.children && funcNode.children.first().name;
				this.type = funcNode.children.last().name;
				funcNode.name = "var";
				funcNode.children = new lib.List();

	 
				if(this.type === "first" || this.type === "last" || this.type === "start" || this.type === "first-except"){
					funcNode.children.append(
						funcNode.children.createItem({
							type: "Identifier",
							loc: null,
							name: "--pagedjs-string-" + this.type + "-" + identifier
						})
					);
				}else {
					funcNode.children.append(
						funcNode.children.createItem({
							type: "Identifier",
							loc: null,
							name: "--pagedjs-string-first-" + identifier
						})
					);
				}
			}
		}

		afterPageLayout(fragment) {

		
			if ( this.pageLastString === undefined )
			{
				this.pageLastString = {};
			}
		
			
			for (let name of Object.keys(this.stringSetSelectors)) {
		
				let set = this.stringSetSelectors[name];
				let selected = fragment.querySelectorAll(set.selector);

				// Get the last found string for the current identifier
				let stringPrevPage = ( name in this.pageLastString ) ? this.pageLastString[name] : "";

				let varFirst, varLast, varStart, varFirstExcept;

				if(selected.length == 0){
					// if there is no sel. on the page
					varFirst = stringPrevPage;
					varLast = stringPrevPage;
					varStart = stringPrevPage;
					varFirstExcept = stringPrevPage;
				}else {

					selected.forEach((sel) => {
						// push each content into the array to define in the variable the first and the last element of the page.
						this.pageLastString[name] = selected[selected.length - 1].textContent;
					
					});	

					/* FIRST */
		
					varFirst = selected[0].textContent;


					/* LAST */

					varLast = selected[selected.length - 1].textContent;


					/* START */

					// Hack to find if the sel. is the first elem of the page / find a better way 
					let selTop = selected[0].getBoundingClientRect().top;
					let pageContent = selected[0].closest(".pagedjs_page_content");
					let pageContentTop = pageContent.getBoundingClientRect().top;

					if(selTop == pageContentTop){
						varStart = varFirst;
					}else {
						varStart = stringPrevPage;
					}

					/* FIRST EXCEPT */

					varFirstExcept = "";
					
				}

				fragment.style.setProperty(`--pagedjs-string-first-${name}`, `"${cleanPseudoContent(varFirst)}`);
				fragment.style.setProperty(`--pagedjs-string-last-${name}`, `"${cleanPseudoContent(varLast)}`);
				fragment.style.setProperty(`--pagedjs-string-start-${name}`, `"${cleanPseudoContent(varStart)}`);
				fragment.style.setProperty(`--pagedjs-string-first-except-${name}`, `"${cleanPseudoContent(varFirstExcept)}`);
				
		
			}
		}
		

	}

	class TargetCounters extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;

			this.counterTargets = {};
		}

		onContent(funcNode, fItem, fList, declaration, rule) {
			if (funcNode.name === "target-counter") {
				let selector = lib.generate(rule.ruleNode.prelude);

				let first = funcNode.children.first();
				let func = first.name;

				let value = lib.generate(funcNode);

				let args = [];

				first.children.forEach((child) => {
					if (child.type === "Identifier") {

						args.push(child.name);
					}
				});

				let counter;
				let style;
				let styleIdentifier;

				funcNode.children.forEach((child) => {
					if (child.type === "Identifier") {
						if (!counter) {
							counter = child.name;
						} else if (!style) {
							styleIdentifier = lib.clone(child);
							style = child.name;
						}
					}
				});

				let variable = "target-counter-" + UUID();

				selector.split(",").forEach((s) => {
					this.counterTargets[s] = {
						func: func,
						args: args,
						value: value,
						counter: counter,
						style: style,
						selector: s,
						fullSelector: selector,
						variable: variable
					};
				});

				// Replace with counter
				funcNode.name = "counter";
				funcNode.children = new lib.List();
				funcNode.children.appendData({
					type: "Identifier",
					loc: 0,
					name: variable
				});

				if (styleIdentifier) {
					funcNode.children.appendData({type: "Operator", loc: null, value: ","});
					funcNode.children.appendData(styleIdentifier);
				}
			}
		}

		afterPageLayout(fragment, page, breakToken, chunker) {
			Object.keys(this.counterTargets).forEach((name) => {
				let target = this.counterTargets[name];
				let split = target.selector.split("::");
				let query = split[0];

				let queried = chunker.pagesArea.querySelectorAll(query + ":not([data-" + target.variable + "])");

				queried.forEach((selected, index) => {
					// TODO: handle func other than attr
					if (target.func !== "attr") {
						return;
					}
					let val = attr(selected, target.args);
					let element = chunker.pagesArea.querySelector(querySelectorEscape(val));

					if (element) {
						let selector = UUID();
						selected.setAttribute("data-" + target.variable, selector);
						// TODO: handle other counter types (by query)
						let pseudo = "";
						if (split.length > 1) {
							pseudo += "::" + split[1];
						}
						if (target.counter === "page") {
							let pages = chunker.pagesArea.querySelectorAll(".pagedjs_page");
							let pg = 0;
							for (let i = 0; i < pages.length; i++) {
								let styles = window.getComputedStyle(pages[i]);
								let reset = styles["counter-reset"].replace("page", "").trim();
								let increment = styles["counter-increment"].replace("page", "").trim();

								if (reset !== "none") {
									pg = parseInt(reset);
								}
								if (increment !== "none") {
									pg += parseInt(increment);
								}

								if (pages[i].contains(element)) {
									break;
								}
							}

							this.styleSheet.insertRule(`[data-${target.variable}="${selector}"]${pseudo} { counter-reset: ${target.variable} ${pg}; }`, this.styleSheet.cssRules.length);
						} else {
							let value = element.getAttribute(`data-counter-${target.counter}-value`);
							if (value) {
								this.styleSheet.insertRule(`[data-${target.variable}="${selector}"]${pseudo} { counter-reset: ${target.variable} ${target.variable} ${parseInt(value)}; }`, this.styleSheet.cssRules.length);
							}
						}
					}
				});
			});
		}
	}

	// import { nodeAfter } from "../../utils/dom";

	class TargetText extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;
			this.textTargets = {};
			this.beforeContent = "";
			this.afterContent = "";
			this.selector = {};
		}

		onContent(funcNode, fItem, fList, declaration, rule) {
			if (funcNode.name === "target-text") {
				this.selector = lib.generate(rule.ruleNode.prelude);
				let first = funcNode.children.first();
				let last = funcNode.children.last();
				let func = first.name;

				let value = lib.generate(funcNode);

				let args = [];

				first.children.forEach(child => {
					if (child.type === "Identifier") {
						args.push(child.name);
					}
				});

				let style;
				if (last !== first) {
					style = last.name;
				}

				let variable = "--pagedjs-" + UUID();

				this.selector.split(",").forEach(s => {
					this.textTargets[s] = {
						func: func,
						args: args,
						value: value,
						style: style || "content",
						selector: s,
						fullSelector: this.selector,
						variable: variable
					};
				});

				// Replace with variable
				funcNode.name = "var";
				funcNode.children = new lib.List();
				funcNode.children.appendData({
					type: "Identifier",
					loc: 0,
					name: variable
				});
			}
		}

		//   parse this on the ONCONTENT : get all before and after and replace the value with a variable
		onPseudoSelector(pseudoNode, pItem, pList, selector, rule) {
			// console.log(pseudoNode);
			// console.log(rule);

			rule.ruleNode.block.children.forEach(properties => {
				if (pseudoNode.name === "before" && properties.property === "content") {
					// let beforeVariable = "--pagedjs-" + UUID();

					let contenu = properties.value.children;
					contenu.forEach(prop => {
						if (prop.type === "String") {
							this.beforeContent = prop.value;
						}
					});
				} else if (pseudoNode.name === "after" && properties.property === "content") {
					properties.value.children.forEach(prop => {
						if (prop.type === "String") {
							this.afterContent = prop.value;
						}
					});
				}
			});
		}

		afterParsed(fragment) {
			Object.keys(this.textTargets).forEach(name => {
				let target = this.textTargets[name];
				let split = target.selector.split("::");
				let query = split[0];
				let queried = fragment.querySelectorAll(query);
				let textContent;
				queried.forEach((selected, index) => {
					let val = attr(selected, target.args);
					let element = fragment.querySelector(querySelectorEscape(val));
					if (element) {
						// content & first-letter & before & after refactorized
						if (target.style) {
							this.selector = UUID();
							selected.setAttribute("data-target-text", this.selector);

							let psuedo = "";
							if (split.length > 1) {
								psuedo += "::" + split[1];
							}
							
							if (target.style === "before" || target.style === "after") {
								const pseudoType = `${target.style}Content`;
								textContent = cleanPseudoContent(this[pseudoType]);
							} else {
								textContent = cleanPseudoContent(element.textContent, " ");
							}
							textContent = target.style === "first-letter" ? textContent.charAt(0) : textContent;
							this.styleSheet.insertRule(`[data-target-text="${this.selector}"]${psuedo} { ${target.variable}: "${textContent}" }`);
						} else {
							console.warn("missed target", val);
						}
					}
				});
			});
		}
	}

	var generatedContentHandlers = [
		RunningHeaders,
		StringSets,
		TargetCounters,
		TargetText
	];

	class WhiteSpaceFilter extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}

		filter(content) {

			filterTree(content, (node) => {
				return this.filterEmpty(node);
			}, NodeFilter.SHOW_TEXT);

		}

		filterEmpty(node) {
			if (node.textContent.length > 1 && isIgnorable(node)) {

				// Do not touch the content if text is pre-formatted
				let parent = node.parentNode;
				let pre = isElement(parent) && parent.closest("pre");
				if (pre) {
					return NodeFilter.FILTER_REJECT;
				}

				const previousSibling = previousSignificantNode(node);
				const nextSibling = nextSignificantNode(node);

				if (nextSibling === null && previousSibling === null) {
					// we should not remove a Node that does not have any siblings.
					node.textContent = " ";
					return NodeFilter.FILTER_REJECT;
				}
				if (nextSibling === null) {
					// we can safely remove this node
					return NodeFilter.FILTER_ACCEPT;
				}
				if (previousSibling === null) {
					// we can safely remove this node
					return NodeFilter.FILTER_ACCEPT;
				}

				// replace the content with a single space
				node.textContent = " ";

				// TODO: we also need to preserve sequences of white spaces when the parent has "white-space" rule:
				// pre
				// Sequences of white space are preserved. Lines are only broken at newline characters in the source and at <br> elements.
				//
				// pre-wrap
				// Sequences of white space are preserved. Lines are broken at newline characters, at <br>, and as necessary to fill line boxes.
				//
				// pre-line
				// Sequences of white space are collapsed. Lines are broken at newline characters, at <br>, and as necessary to fill line boxes.
				//
				// break-spaces
				// The behavior is identical to that of pre-wrap, except that:
				// - Any sequence of preserved white space always takes up space, including at the end of the line.
				// - A line breaking opportunity exists after every preserved white space character, including between white space characters.
				// - Such preserved spaces take up space and do not hang, and thus affect the box’s intrinsic sizes (min-content size and max-content size).
				//
				// See: https://developer.mozilla.org/en-US/docs/Web/CSS/white-space#Values

				return NodeFilter.FILTER_REJECT;
			} else {
				return NodeFilter.FILTER_REJECT;
			}
		}

	}

	class CommentsFilter extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}

		filter(content) {
			filterTree(content, null, NodeFilter.SHOW_COMMENT);
		}

	}

	class ScriptsFilter extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}

		filter(content) {
			content.querySelectorAll("script").forEach( script => { script.remove(); });
		}

	}

	var clearCut = createCommonjsModule(function (module, exports) {
	/**
	 * Originally ported from https://github.com/keeganstreet/specificity/blob/866bf7ab4e7f62a7179c15b13a95af4e1c7b1afa/specificity.js
	 *
	 * Calculates the specificity of CSS selectors
	 * http://www.w3.org/TR/css3-selectors/#specificity
	 *
	 * Returns a selector integer value
	 */

	// The following regular expressions assume that selectors matching the preceding regular expressions have been removed
	var attributeRegex = /(\[[^\]]+\])/g;
	var idRegex = /(#[^\s\+>~\.\[:]+)/g;
	var classRegex = /(\.[^\s\+>~\.\[:]+)/g;
	var pseudoElementRegex = /(::[^\s\+>~\.\[:]+|:first-line|:first-letter|:before|:after)/g;
	var pseudoClassRegex = /(:[^\s\+>~\.\[:]+)/g;
	var elementRegex = /([^\s\+>~\.\[:]+)/g;
	var notRegex = /:not\(([^\)]*)\)/g;
	var ruleRegex = /\{[^]*/gm;
	var separatorRegex = /[\*\s\+>~]/g;
	var straysRegex = /[#\.]/g;

	// Find matches for a regular expression in a string and push their details to parts
	// Type is "a" for IDs, "b" for classes, attributes and pseudo-classes and "c" for elements and pseudo-elements
	var findMatch = function(regex, type, types, selector) {
	  var matches = selector.match(regex);
	  if (matches) {
	    for (var i = 0; i < matches.length; i++) {
	      types[type]++;
	      // Replace this simple selector with whitespace so it won't be counted in further simple selectors
	      selector = selector.replace(matches[i], ' ');
	    }
	  }

	  return selector;
	};

	// Calculate the specificity for a selector by dividing it into simple selectors and counting them
	var calculate = function(selector) {
	  var commaIndex = selector.indexOf(',');
	  if (commaIndex !== -1) {
	    selector = selector.substring(0, commaIndex);
	  }

	  var  types = {
	    a: 0,
	    b: 0,
	    c: 0
	  };

	  // Remove the negation psuedo-class (:not) but leave its argument because specificity is calculated on its argument
	  selector = selector.replace(notRegex, ' $1 ');

	  // Remove anything after a left brace in case a user has pasted in a rule, not just a selector
	  selector = selector.replace(ruleRegex, ' ');

	  // Add attribute selectors to parts collection (type b)
	  selector = findMatch(attributeRegex, 'b', types, selector);

	  // Add ID selectors to parts collection (type a)
	  selector = findMatch(idRegex, 'a', types, selector);

	  // Add class selectors to parts collection (type b)
	  selector = findMatch(classRegex, 'b', types, selector);

	  // Add pseudo-element selectors to parts collection (type c)
	  selector = findMatch(pseudoElementRegex, 'c', types, selector);

	  // Add pseudo-class selectors to parts collection (type b)
	  selector = findMatch(pseudoClassRegex, 'b', types, selector);

	  // Remove universal selector and separator characters
	  selector = selector.replace(separatorRegex, ' ');

	  // Remove any stray dots or hashes which aren't attached to words
	  // These may be present if the user is live-editing this selector
	  selector = selector.replace(straysRegex, ' ');

	  // The only things left should be element selectors (type c)
	  findMatch(elementRegex, 'c', types, selector);

	  return (types.a * 100) + (types.b * 10) + (types.c * 1);
	};

	var specificityCache = {};

	exports.calculateSpecificity = function(selector) {
	  var specificity = specificityCache[selector];
	  if (specificity === undefined) {
	    specificity = calculate(selector);
	    specificityCache[selector] = specificity;
	  }
	  return specificity;
	};

	var validSelectorCache = {};
	var testSelectorElement = null;

	exports.isSelectorValid = function(selector) {
	  var valid = validSelectorCache[selector];
	  if (valid === undefined) {
	    if (testSelectorElement == null) {
	      testSelectorElement = document.createElement('div');
	    }

	    try {
	      testSelectorElement.querySelector(selector);
	      valid = true;
	    } catch (error) {
	      valid = false;
	    }
	    validSelectorCache[selector] = valid;
	  }
	  return valid;
	};

	exports.validateSelector = function(selector) {
	  if (!exports.isSelectorValid(selector)) {
	    var error = new SyntaxError(selector + ' is not a valid selector');
	    error.code = 'EBADSELECTOR';
	    throw error;
	  }
	};
	});
	var clearCut_1 = clearCut.calculateSpecificity;
	var clearCut_2 = clearCut.isSelectorValid;
	var clearCut_3 = clearCut.validateSelector;

	class UndisplayedFilter extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
			this.displayRules = {};
		}

		onDeclaration(declaration, dItem, dList, rule) {
			if (declaration.property === "display") {
				let selector = lib.generate(rule.ruleNode.prelude);
				let value = declaration.value.children.first().name;

				selector.split(",").forEach((s) => {
					this.displayRules[s] = {
						value: value,
						selector: s,
						specificity: clearCut_1(s),
						important: declaration.important
					};
				});
			}
		}

		filter(content) {
			let { matches, selectors } = this.sortDisplayedSelectors(content, this.displayRules);

			// Find matching elements that have display styles
			for (let i = 0; i < matches.length; i++) {
				let element = matches[i];
				let selector = selectors[i];
				let displayValue = selector[selector.length-1].value;
				if(this.removable(element) && displayValue === "none") {
					element.dataset.undisplayed = "undisplayed";
				}
			}

			// Find elements that have inline styles
			let styledElements = content.querySelectorAll("[style]");
			for (let i = 0; i < styledElements.length; i++) {
				let element = styledElements[i];
				if (this.removable(element)) {
					element.dataset.undisplayed = "undisplayed";
				}
			}
		}

		sorter(a, b) {
			if (a.important && !b.important) {
				return 1;
			}

			if (b.important && !a.important) {
				return -1;
			}

			return a.specificity - b.specificity;
		}

		sortDisplayedSelectors(content, displayRules=[]) {
			let matches = [];
			let selectors = [];
			for (let d in displayRules) {
				let displayItem = displayRules[d];
				let selector = displayItem.selector;
				let query = [];
				try {
					try {
						query = content.querySelectorAll(selector);
					} catch (e) {
						query = content.querySelectorAll(cleanSelector(selector));
					}
				} catch (e) {
					query = [];
				}
				let elements = Array.from(query);
				for (let e of elements) {
					if (matches.includes(e)) {
						let index = matches.indexOf(e);
						selectors[index].push(displayItem);
						selectors[index] = selectors[index].sort(this.sorter);
					} else {
						matches.push(e);
						selectors.push([displayItem]);
					}
				}
			}

			return { matches, selectors };
		}

		removable(element) {
			if (element.style &&
					element.style.display !== "" &&
					element.style.display !== "none") {
				return false;
			}

			return true;
		}
	}

	var filters = [
		WhiteSpaceFilter,
		CommentsFilter,
		ScriptsFilter,
		UndisplayedFilter
	];

	var isImplemented$3 = function () {
		var from = Array.from, arr, result;
		if (typeof from !== "function") return false;
		arr = ["raz", "dwa"];
		result = from(arr);
		return Boolean(result && (result !== arr) && (result[1] === "dwa"));
	};

	var validTypes = { object: true, symbol: true };

	var isImplemented$4 = function () {
		var symbol;
		if (typeof Symbol !== 'function') return false;
		symbol = Symbol('test symbol');
		try { String(symbol); } catch (e) { return false; }

		// Return 'true' also for polyfills
		if (!validTypes[typeof Symbol.iterator]) return false;
		if (!validTypes[typeof Symbol.toPrimitive]) return false;
		if (!validTypes[typeof Symbol.toStringTag]) return false;

		return true;
	};

	var isSymbol = function (x) {
		if (!x) return false;
		if (typeof x === 'symbol') return true;
		if (!x.constructor) return false;
		if (x.constructor.name !== 'Symbol') return false;
		return (x[x.constructor.toStringTag] === 'Symbol');
	};

	var validateSymbol = function (value) {
		if (!isSymbol(value)) throw new TypeError(value + " is not a symbol");
		return value;
	};

	var create$6 = Object.create, defineProperties = Object.defineProperties
	  , defineProperty = Object.defineProperty, objPrototype = Object.prototype
	  , NativeSymbol, SymbolPolyfill, HiddenSymbol, globalSymbols = create$6(null)
	  , isNativeSafe;

	if (typeof Symbol === 'function') {
		NativeSymbol = Symbol;
		try {
			String(NativeSymbol());
			isNativeSafe = true;
		} catch (ignore) {}
	}

	var generateName = (function () {
		var created = create$6(null);
		return function (desc) {
			var postfix = 0, name, ie11BugWorkaround;
			while (created[desc + (postfix || '')]) ++postfix;
			desc += (postfix || '');
			created[desc] = true;
			name = '@@' + desc;
			defineProperty(objPrototype, name, d_1.gs(null, function (value) {
				// For IE11 issue see:
				// https://connect.microsoft.com/IE/feedbackdetail/view/1928508/
				//    ie11-broken-getters-on-dom-objects
				// https://github.com/medikoo/es6-symbol/issues/12
				if (ie11BugWorkaround) return;
				ie11BugWorkaround = true;
				defineProperty(this, name, d_1(value));
				ie11BugWorkaround = false;
			}));
			return name;
		};
	}());

	// Internal constructor (not one exposed) for creating Symbol instances.
	// This one is used to ensure that `someSymbol instanceof Symbol` always return false
	HiddenSymbol = function Symbol(description) {
		if (this instanceof HiddenSymbol) throw new TypeError('Symbol is not a constructor');
		return SymbolPolyfill(description);
	};

	// Exposed `Symbol` constructor
	// (returns instances of HiddenSymbol)
	var polyfill = SymbolPolyfill = function Symbol(description) {
		var symbol;
		if (this instanceof Symbol) throw new TypeError('Symbol is not a constructor');
		if (isNativeSafe) return NativeSymbol(description);
		symbol = create$6(HiddenSymbol.prototype);
		description = (description === undefined ? '' : String(description));
		return defineProperties(symbol, {
			__description__: d_1('', description),
			__name__: d_1('', generateName(description))
		});
	};
	defineProperties(SymbolPolyfill, {
		for: d_1(function (key) {
			if (globalSymbols[key]) return globalSymbols[key];
			return (globalSymbols[key] = SymbolPolyfill(String(key)));
		}),
		keyFor: d_1(function (s) {
			var key;
			validateSymbol(s);
			for (key in globalSymbols) if (globalSymbols[key] === s) return key;
		}),

		// To ensure proper interoperability with other native functions (e.g. Array.from)
		// fallback to eventual native implementation of given symbol
		hasInstance: d_1('', (NativeSymbol && NativeSymbol.hasInstance) || SymbolPolyfill('hasInstance')),
		isConcatSpreadable: d_1('', (NativeSymbol && NativeSymbol.isConcatSpreadable) ||
			SymbolPolyfill('isConcatSpreadable')),
		iterator: d_1('', (NativeSymbol && NativeSymbol.iterator) || SymbolPolyfill('iterator')),
		match: d_1('', (NativeSymbol && NativeSymbol.match) || SymbolPolyfill('match')),
		replace: d_1('', (NativeSymbol && NativeSymbol.replace) || SymbolPolyfill('replace')),
		search: d_1('', (NativeSymbol && NativeSymbol.search) || SymbolPolyfill('search')),
		species: d_1('', (NativeSymbol && NativeSymbol.species) || SymbolPolyfill('species')),
		split: d_1('', (NativeSymbol && NativeSymbol.split) || SymbolPolyfill('split')),
		toPrimitive: d_1('', (NativeSymbol && NativeSymbol.toPrimitive) || SymbolPolyfill('toPrimitive')),
		toStringTag: d_1('', (NativeSymbol && NativeSymbol.toStringTag) || SymbolPolyfill('toStringTag')),
		unscopables: d_1('', (NativeSymbol && NativeSymbol.unscopables) || SymbolPolyfill('unscopables'))
	});

	// Internal tweaks for real symbol producer
	defineProperties(HiddenSymbol.prototype, {
		constructor: d_1(SymbolPolyfill),
		toString: d_1('', function () { return this.__name__; })
	});

	// Proper implementation of methods exposed on Symbol.prototype
	// They won't be accessible on produced symbol instances as they derive from HiddenSymbol.prototype
	defineProperties(SymbolPolyfill.prototype, {
		toString: d_1(function () { return 'Symbol (' + validateSymbol(this).__description__ + ')'; }),
		valueOf: d_1(function () { return validateSymbol(this); })
	});
	defineProperty(SymbolPolyfill.prototype, SymbolPolyfill.toPrimitive, d_1('', function () {
		var symbol = validateSymbol(this);
		if (typeof symbol === 'symbol') return symbol;
		return symbol.toString();
	}));
	defineProperty(SymbolPolyfill.prototype, SymbolPolyfill.toStringTag, d_1('c', 'Symbol'));

	// Proper implementaton of toPrimitive and toStringTag for returned symbol instances
	defineProperty(HiddenSymbol.prototype, SymbolPolyfill.toStringTag,
		d_1('c', SymbolPolyfill.prototype[SymbolPolyfill.toStringTag]));

	// Note: It's important to define `toPrimitive` as last one, as some implementations
	// implement `toPrimitive` natively without implementing `toStringTag` (or other specified symbols)
	// And that may invoke error in definition flow:
	// See: https://github.com/medikoo/es6-symbol/issues/13#issuecomment-164146149
	defineProperty(HiddenSymbol.prototype, SymbolPolyfill.toPrimitive,
		d_1('c', SymbolPolyfill.prototype[SymbolPolyfill.toPrimitive]));

	var es6Symbol = isImplemented$4() ? Symbol : polyfill;

	var objToString = Object.prototype.toString
	  , id = objToString.call(
		(function () {
			return arguments;
		})()
	);

	var isArguments = function (value) {
		return objToString.call(value) === id;
	};

	var objToString$1 = Object.prototype.toString, id$1 = objToString$1.call(noop);

	var isFunction = function (value) {
		return typeof value === "function" && objToString$1.call(value) === id$1;
	};

	var isImplemented$5 = function () {
		var sign = Math.sign;
		if (typeof sign !== "function") return false;
		return (sign(10) === 1) && (sign(-20) === -1);
	};

	var shim$3 = function (value) {
		value = Number(value);
		if (isNaN(value) || (value === 0)) return value;
		return value > 0 ? 1 : -1;
	};

	var sign = isImplemented$5()
		? Math.sign
		: shim$3;

	var abs = Math.abs, floor = Math.floor;

	var toInteger = function (value) {
		if (isNaN(value)) return 0;
		value = Number(value);
		if ((value === 0) || !isFinite(value)) return value;
		return sign(value) * floor(abs(value));
	};

	var max$1 = Math.max;

	var toPosInteger = function (value) {
	 return max$1(0, toInteger(value));
	};

	var objToString$2 = Object.prototype.toString, id$2 = objToString$2.call("");

	var isString = function (value) {
		return (
			typeof value === "string" ||
			(value &&
				typeof value === "object" &&
				(value instanceof String || objToString$2.call(value) === id$2)) ||
			false
		);
	};

	var iteratorSymbol = es6Symbol.iterator
	  , isArray        = Array.isArray
	  , call           = Function.prototype.call
	  , desc           = { configurable: true, enumerable: true, writable: true, value: null }
	  , defineProperty$1 = Object.defineProperty;

	// eslint-disable-next-line complexity
	var shim$4 = function (arrayLike /*, mapFn, thisArg*/) {
		var mapFn = arguments[1]
		  , thisArg = arguments[2]
		  , Context
		  , i
		  , j
		  , arr
		  , length
		  , code
		  , iterator
		  , result
		  , getIterator
		  , value;

		arrayLike = Object(validValue(arrayLike));

		if (isValue(mapFn)) validCallable(mapFn);
		if (!this || this === Array || !isFunction(this)) {
			// Result: Plain array
			if (!mapFn) {
				if (isArguments(arrayLike)) {
					// Source: Arguments
					length = arrayLike.length;
					if (length !== 1) return Array.apply(null, arrayLike);
					arr = new Array(1);
					arr[0] = arrayLike[0];
					return arr;
				}
				if (isArray(arrayLike)) {
					// Source: Array
					arr = new Array(length = arrayLike.length);
					for (i = 0; i < length; ++i) arr[i] = arrayLike[i];
					return arr;
				}
			}
			arr = [];
		} else {
			// Result: Non plain array
			Context = this;
		}

		if (!isArray(arrayLike)) {
			if ((getIterator = arrayLike[iteratorSymbol]) !== undefined) {
				// Source: Iterator
				iterator = validCallable(getIterator).call(arrayLike);
				if (Context) arr = new Context();
				result = iterator.next();
				i = 0;
				while (!result.done) {
					value = mapFn ? call.call(mapFn, thisArg, result.value, i) : result.value;
					if (Context) {
						desc.value = value;
						defineProperty$1(arr, i, desc);
					} else {
						arr[i] = value;
					}
					result = iterator.next();
					++i;
				}
				length = i;
			} else if (isString(arrayLike)) {
				// Source: String
				length = arrayLike.length;
				if (Context) arr = new Context();
				for (i = 0, j = 0; i < length; ++i) {
					value = arrayLike[i];
					if (i + 1 < length) {
						code = value.charCodeAt(0);
						// eslint-disable-next-line max-depth
						if (code >= 0xd800 && code <= 0xdbff) value += arrayLike[++i];
					}
					value = mapFn ? call.call(mapFn, thisArg, value, j) : value;
					if (Context) {
						desc.value = value;
						defineProperty$1(arr, j, desc);
					} else {
						arr[j] = value;
					}
					++j;
				}
				length = j;
			}
		}
		if (length === undefined) {
			// Source: array or array-like
			length = toPosInteger(arrayLike.length);
			if (Context) arr = new Context(length);
			for (i = 0; i < length; ++i) {
				value = mapFn ? call.call(mapFn, thisArg, arrayLike[i], i) : arrayLike[i];
				if (Context) {
					desc.value = value;
					defineProperty$1(arr, i, desc);
				} else {
					arr[i] = value;
				}
			}
		}
		if (Context) {
			desc.value = null;
			arr.length = length;
		}
		return arr;
	};

	var from_1 = isImplemented$3()
		? Array.from
		: shim$4;

	var isImplemented$6 = function () {
		var numberIsNaN = Number.isNaN;
		if (typeof numberIsNaN !== "function") return false;
		return !numberIsNaN({}) && numberIsNaN(NaN) && !numberIsNaN(34);
	};

	var shim$5 = function (value) {
		// eslint-disable-next-line no-self-compare
		return value !== value;
	};

	var isNan = isImplemented$6()
		? Number.isNaN
		: shim$5;

	var indexOf$2           = Array.prototype.indexOf
	  , objHasOwnProperty = Object.prototype.hasOwnProperty
	  , abs$1               = Math.abs
	  , floor$1             = Math.floor;

	var eIndexOf = function (searchElement /*, fromIndex*/) {
		var i, length, fromIndex, val;
		if (!isNan(searchElement)) return indexOf$2.apply(this, arguments);

		length = toPosInteger(validValue(this).length);
		fromIndex = arguments[1];
		if (isNaN(fromIndex)) fromIndex = 0;
		else if (fromIndex >= 0) fromIndex = floor$1(fromIndex);
		else fromIndex = toPosInteger(this.length) - floor$1(abs$1(fromIndex));

		for (i = fromIndex; i < length; ++i) {
			if (objHasOwnProperty.call(this, i)) {
				val = this[i];
				if (isNan(val)) return i; // Jslint: ignore
			}
		}
		return -1;
	};

	var forEach$1 = Array.prototype.forEach
	  , splice  = Array.prototype.splice;

	// eslint-disable-next-line no-unused-vars
	var remove = function (itemToRemove /*, …item*/) {
		forEach$1.call(
			arguments,
			function (item) {
				var index = eIndexOf.call(this, item);
				if (index !== -1) splice.call(this, index, 1);
			},
			this
		);
	};

	var map = { function: true, object: true };

	var isObject$1 = function (value) {
		return (isValue(value) && map[typeof value]) || false;
	};

	var validObject = function (value) {
		if (!isObject$1(value)) throw new TypeError(value + " is not an Object");
		return value;
	};

	var emit           = eventEmitter.methods.emit

	  , defineProperty$2 = Object.defineProperty
	  , hasOwnProperty$6 = Object.prototype.hasOwnProperty
	  , getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;

	var pipe = function (e1, e2/*, name*/) {
		var pipes, pipe, desc, name;

		(validObject(e1) && validObject(e2));
		name = arguments[2];
		if (name === undefined) name = 'emit';

		pipe = {
			close: function () { remove.call(pipes, e2); }
		};
		if (hasOwnProperty$6.call(e1, '__eePipes__')) {
			(pipes = e1.__eePipes__).push(e2);
			return pipe;
		}
		defineProperty$2(e1, '__eePipes__', d_1('c', pipes = [e2]));
		desc = getOwnPropertyDescriptor(e1, name);
		if (!desc) {
			desc = d_1('c', undefined);
		} else {
			delete desc.get;
			delete desc.set;
		}
		desc.value = function () {
			var i, emitter, data = from_1(pipes);
			emit.apply(this, arguments);
			for (i = 0; (emitter = data[i]); ++i) emit.apply(emitter, arguments);
		};
		defineProperty$2(e1, name, desc);
		return pipe;
	};

	let registeredHandlers = [...pagedMediaHandlers, ...generatedContentHandlers, ...filters];

	class Handlers {
		constructor(chunker, polisher, caller) {

			registeredHandlers.forEach((Handler) => {
				let handler = new Handler(chunker, polisher, caller);
				pipe(handler, this);
			});
		}
	}

	eventEmitter(Handlers.prototype);

	function registerHandlers() {
		for (var i = 0; i < arguments.length; i++) {
			registeredHandlers.push(arguments[i]);
		}
	}

	function initializeHandlers(chunker, polisher, caller) {
		let handlers = new Handlers(chunker, polisher, caller);
		return handlers;
	}

	class Previewer {
		constructor(options) {
			// this.preview = this.getParams("preview") !== "false";

			this.settings = options || {};

			// Process styles
			this.polisher = new Polisher(false);

			// Chunk contents
			this.chunker = new Chunker(undefined, undefined, this.settings);

			// Hooks
			this.hooks = {};
			this.hooks.beforePreview = new Hook(this);
			this.hooks.afterPreview = new Hook(this);

			// default size
			this.size = {
				width: {
					value: 8.5,
					unit: "in"
				},
				height: {
					value: 11,
					unit: "in"
				},
				format: undefined,
				orientation: undefined
			};

			this.chunker.on("page", (page) => {
				this.emit("page", page);
			});

			this.chunker.on("rendering", () => {
				this.emit("rendering", this.chunker);
			});
		}

		initializeHandlers() {
			let handlers = initializeHandlers(this.chunker, this.polisher, this);

			handlers.on("size", (size) => {
				this.size = size;
				this.emit("size", size);
			});

			handlers.on("atpages", (pages) => {
				this.atpages = pages;
				this.emit("atpages", pages);
			});

			return handlers;
		}

		registerHandlers() {
			return registerHandlers.apply(registerHandlers, arguments);
		}

		getParams(name) {
			let param;
			let url = new URL(window.location);
			let params = new URLSearchParams(url.search);
			for(var pair of params.entries()) {
				if(pair[0] === name) {
					param = pair[1];
				}
			}

			return param;
		}

		wrapContent() {
			// Wrap body in template tag
			let body = document.querySelector("body");

			// Check if a template exists
			let template;
			template = body.querySelector(":scope > template[data-ref='pagedjs-content']");

			if (!template) {
				// Otherwise create one
				template = document.createElement("template");
				template.dataset.ref = "pagedjs-content";
				template.innerHTML = body.innerHTML;
				body.innerHTML = "";
				body.appendChild(template);
			}

			return template.content;
		}

		removeStyles(doc=document) {
			// Get all stylesheets
			let stylesheets = Array.from(doc.querySelectorAll("link[rel='stylesheet']"));
			let hrefs = stylesheets.map((sheet) => {
				sheet.remove();
				return sheet.href;
			});

			// Get inline styles
			let inlineStyles = Array.from(doc.querySelectorAll("style:not([data-pagedjs-inserted-styles])"));
			inlineStyles.forEach((inlineStyle) => {
				let obj = {};
				obj[window.location.href] = inlineStyle.textContent;
				hrefs.push(obj);
				inlineStyle.remove();
			});

			return hrefs;
		}

		async preview(content, stylesheets, renderTo) {

			await this.hooks.beforePreview.trigger(content, renderTo);

			if (!content) {
				content = this.wrapContent();
			}

			if (!stylesheets) {
				stylesheets = this.removeStyles();
			}

			this.polisher.setup();

			this.handlers = this.initializeHandlers();

			await this.polisher.add(...stylesheets);

			let startTime = performance.now();

			// Render flow
			let flow = await this.chunker.flow(content, renderTo);

			let endTime = performance.now();

			flow.performance = (endTime - startTime);
			flow.size = this.size;

			this.emit("rendered", flow);

			await this.hooks.afterPreview.trigger(flow.pages);

			return flow;
		}
	}

	eventEmitter(Previewer.prototype);

	var Paged = /*#__PURE__*/Object.freeze({
		__proto__: null,
		Chunker: Chunker,
		Polisher: Polisher,
		Previewer: Previewer,
		Handler: Handler,
		registerHandlers: registerHandlers,
		initializeHandlers: initializeHandlers
	});

	window.Paged = Paged;

	let ready = new Promise(function(resolve, reject){
		if (document.readyState === "interactive" || document.readyState === "complete") {
			resolve(document.readyState);
			return;
		}

		document.onreadystatechange = function ($) {
			if (document.readyState === "interactive") {
				resolve(document.readyState);
			}
		};
	});

	let config = window.PagedConfig || {
		auto: true,
		before: undefined,
		after: undefined,
		content: undefined,
		stylesheets: undefined,
		renderTo: undefined,
		settings: undefined
	};

	let previewer = new Previewer(config.settings);

	ready.then(async function () {
		let done;
		if (config.before) {
			await config.before();
		}

		if(config.auto !== false) {
			done = await previewer.preview(config.content, config.stylesheets, config.renderTo);
		}


		if (config.after) {
			await config.after(done);
		}
	});

	return previewer;

})));
</script>
<script>// Hooks for paged.js
{
  // Utils
  let pandocMeta, pandocMetaToString;
  {
    let el = document.getElementById('pandoc-meta');
    pandocMeta = el ? JSON.parse(el.firstChild.data) : {};
  }

  pandocMetaToString = meta => {
    let el = document.createElement('div');
    el.innerHTML = meta;
    return el.innerText;
  };

  let isString = value => {
    return typeof value === 'string' || value instanceof String;
  };

  let isArray = value => {
    return value && typeof value === 'object' && value.constructor === Array;
  };

  // This hook is an attempt to fix https://github.com/rstudio/pagedown/issues/131
  // Sometimes, the {break-after: avoid;} declaration applied on headers
  // lead to duplicated headers. I hate this bug.
  // This is linked to the way the HTML source is written
  // When we have the \n character like this: <div>\n<h1>...</h1>
  // the header may be duplicated.
  // But, if we have <div><h1>...</h1> without any \n, the problem disappear
  // I think this handler can fix most of cases
  // Obviously, we cannot suppress all the \n in the HTML document
  // because carriage returns are important in <pre> elements.
  // Tested with Chrome 76.0.3809.100/Windows
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
      this.carriageReturn = String.fromCharCode(10);
    }

    checkNode(node) {
      if (!node) return;
      if (node.nodeType !== 3) return;
      if (node.textContent === this.carriageReturn) {
        node.remove();
      }
    }

    afterParsed(parsed) {
      let template = document.querySelector('template').content;
      const breakAfterAvoidElements = template.querySelectorAll('[data-break-after="avoid"], [data-break-before="avoid"]');
      for (let el of breakAfterAvoidElements) {
        this.checkNode(el.previousSibling);
        this.checkNode(el.nextSibling);
      }
    }
  });

  // This hook creates a list of abbreviations
  // Note: we also could implement this feature using a Pandoc filter
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }
    beforeParsed(content) {
      // Find the abbreviation nodes
      const abbrNodeList = content.querySelectorAll('abbr');

      // Return early if there is no abbreviation
      if (abbrNodeList.length === 0) return;

      // Store unique values of abbreviations, see https://github.com/rstudio/pagedown/issues/218
      let abbreviations = [];
      for (const {title, innerHTML} of abbrNodeList.values()) {
        if (abbreviations.find(el => el.title === title && el.innerHTML === innerHTML)) {
          continue;
        }
        abbreviations.push({title: title, innerHTML: innerHTML});
      }

      const loaTitle = pandocMeta['loa-title'] ? pandocMetaToString(pandocMeta['loa-title']) : 'List of Abbreviations';
      const loaId = 'LOA';
      const tocList = content.querySelector('.toc ul');
      let listOfAbbreviations = document.createElement('div');
      let descriptionList = document.createElement('dl');
      content.appendChild(listOfAbbreviations);
      listOfAbbreviations.id = loaId;
      listOfAbbreviations.classList.add('section', 'front-matter', 'level1', 'loa');
      listOfAbbreviations.innerHTML = '<h1>' + loaTitle + '</h1>';
      listOfAbbreviations.appendChild(descriptionList);
      for(let abbr of abbreviations) {
        if(!abbr.title) continue;
        let term = document.createElement('dt');
        let definition = document.createElement('dd');
        descriptionList.appendChild(term);
        descriptionList.appendChild(definition);
        term.innerHTML = abbr.innerHTML;
        definition.innerText = abbr.title;
      }
      if (tocList) {
        const loaTOCItem = document.createElement('li');
        loaTOCItem.innerHTML = '<a href="#' + loaId + '">' + loaTitle + '</a>';
        tocList.appendChild(loaTOCItem);
      }
    }
  });

  // This hook moves the sections of class front-matter in the div.front-matter-container
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }

    beforeParsed(content) {
      const frontMatter = content.querySelector('.front-matter-container');
      if (!frontMatter) return;

      // move front matter sections in the front matter container
      const frontMatterSections = content.querySelectorAll('.level1.front-matter');
      for (const section of frontMatterSections) {
        frontMatter.appendChild(section);
      }

      // add the class front-matter-ref to any <a></a> element
      // referring to an entry in the front matter
      const anchors = content.querySelectorAll('a[href^="#"]:not([href*=":"])');
      for (const a of anchors) {
        const ref = a.getAttribute('href').replace(/^#/, '');
        const element = content.getElementById(ref);
        if (frontMatter.contains(element)) a.classList.add('front-matter-ref');
      }

      // update the toc, lof and lot for front matter sections
      const frontMatterSectionsLinks = content.querySelectorAll('.toc .front-matter-ref, .lof .front-matter-ref, .lot .front-matter-ref');
      for (let i = frontMatterSectionsLinks.length - 1; i >= 0; i--) {
        const listItem = frontMatterSectionsLinks[i].parentNode;
        const list = listItem.parentNode;
        list.insertBefore(listItem, list.firstChild);
      }
    }
  });

  // This hook expands the links in the lists of figures and tables
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }

    beforeParsed(content) {
      const items = content.querySelectorAll('.lof li, .lot li');
      for (const item of items) {
        const anchor = item.firstChild;
        anchor.innerText = item.innerText;
        item.innerText = '';
        item.append(anchor);
      }
    }
  });

  // This hook adds spans for leading symbols
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }

    beforeParsed(content) {
      const anchors = content.querySelectorAll('.toc a, .lof a, .lot a');
      for (const a of anchors) {
        a.innerHTML = a.innerHTML + '<span class="leaders"></span>';
      }
    }
  });

  // This hook appends short titles spans
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }

    beforeParsed(content) {
    /* A factory returning a function that appends short titles spans.
       The text content of these spans are reused for running titles (see default.css).
       Argument: level - An integer between 1 and 6.
    */
    function appendShortTitleSpans(level) {
      return () => {
        const divs = Array.from(content.querySelectorAll('.level' + level));

        function addSpan(div) {
          const mainHeader = div.getElementsByTagName('h' + level)[0];
          if (!mainHeader) return;
          const mainTitle = mainHeader.textContent;
          const spanSectionNumber = mainHeader.getElementsByClassName('header-section-number')[0];
          const mainNumber = !!spanSectionNumber ? spanSectionNumber.textContent : '';
          const runningTitle = 'shortTitle' in div.dataset ? mainNumber + ' ' + div.dataset.shortTitle : mainTitle;
          const span = document.createElement('span');
          span.className = 'shorttitle' + level;
          span.innerText = runningTitle;
          span.style.display = "none";
          mainHeader.appendChild(span);
          if (level == 1 && div.querySelector('.level2') === null) {
            let span2 = document.createElement('span');
            span2.className = 'shorttitle2';
            span2.innerText = ' ';
            span2.style.display = "none";
            span.insertAdjacentElement('afterend', span2);
          }
        }

        for (const div of divs) {
          addSpan(div);
        }
      };
    }

    appendShortTitleSpans(1)();
    appendShortTitleSpans(2)();
    }
  });

  // Footnotes support
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);

      this.splittedParagraphRefs = [];
    }

    beforeParsed(content) {
      // remove footnotes in toc, lof, lot
      // see https://github.com/rstudio/pagedown/issues/54
      let removeThese = content.querySelectorAll('.toc .footnote, .lof .footnote, .lot .footnote');
      for (const el of removeThese) {
        el.remove();
      }

      let footnotes = content.querySelectorAll('.footnote');

      for (let footnote of footnotes) {
        let parentElement = footnote.parentElement;
        let footnoteCall = document.createElement('a');
        let footnoteNumber = footnote.dataset.pagedownFootnoteNumber;

        footnoteCall.className = 'footnote-ref'; // same class as Pandoc
        footnoteCall.setAttribute('id', 'fnref' + footnoteNumber); // same notation as Pandoc
        footnoteCall.setAttribute('href', '#' + footnote.id);
        footnoteCall.innerHTML = '<sup>' + footnoteNumber +'</sup>';
        parentElement.insertBefore(footnoteCall, footnote);

        // Here comes a hack. Fortunately, it works with Chrome and FF.
        let handler = document.createElement('p');
        handler.className = 'footnoteHandler';
        parentElement.insertBefore(handler, footnote);
        handler.appendChild(footnote);
        handler.style.display = 'inline-block';
        handler.style.width = '100%';
        handler.style.float = 'right';
        handler.style.pageBreakInside = 'avoid';
      }
    }

    afterPageLayout(pageFragment, page, breakToken) {
      function hasItemParent(node) {
        if (node.parentElement === null) {
          return false;
        } else {
          if (node.parentElement.tagName === 'LI') {
            return true;
          } else {
            return hasItemParent(node.parentElement);
          }
        }
      }
      // If a li item is broken, we store the reference of the p child element
      // see https://github.com/rstudio/pagedown/issues/23#issue-376548000
      if (breakToken !== undefined) {
        if (breakToken.node.nodeName === "#text" && hasItemParent(breakToken.node)) {
          this.splittedParagraphRefs.push(breakToken.node.parentElement.dataset.ref);
        }
      }
    }

    afterRendered(pages) {
      for (let page of pages) {
        const footnotes = page.element.querySelectorAll('.footnote');
        if (footnotes.length === 0) {
          continue;
        }

        const pageContent = page.element.querySelector('.pagedjs_page_content');
        let hr = document.createElement('hr');
        let footnoteArea = document.createElement('div');

        pageContent.style.display = 'flex';
        pageContent.style.flexDirection = 'column';

        hr.className = 'footnote-break';
        hr.style.marginTop = 'auto';
        hr.style.marginBottom = 0;
        hr.style.marginLeft = 0;
        hr.style.marginRight = 'auto';
        pageContent.appendChild(hr);

        footnoteArea.className = 'footnote-area';
        pageContent.appendChild(footnoteArea);

        for (let footnote of footnotes) {
          let handler = footnote.parentElement;

          footnoteArea.appendChild(footnote);
          handler.parentNode.removeChild(handler);

          footnote.innerHTML = '<sup>' + footnote.dataset.pagedownFootnoteNumber + '</sup>' + footnote.innerHTML;
          footnote.style.fontSize = 'x-small';
          footnote.style.marginTop = 0;
          footnote.style.marginBottom = 0;
          footnote.style.paddingTop = 0;
          footnote.style.paddingBottom = 0;
          footnote.style.display = 'block';
        }
      }

      for (let ref of this.splittedParagraphRefs) {
        let paragraphFirstPage = document.querySelector('[data-split-to="' + ref + '"]');
        // We test whether the paragraph is empty
        // see https://github.com/rstudio/pagedown/issues/23#issue-376548000
        if (paragraphFirstPage.innerText === "") {
          paragraphFirstPage.parentElement.style.display = "none";
          let paragraphSecondPage = document.querySelector('[data-split-from="' + ref + '"]');
          paragraphSecondPage.parentElement.style.setProperty('list-style', 'inherit', 'important');
        }
      }
    }
  });

  // Support for "Chapter " label on section with class `.chapter`
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);

      this.options = pandocMeta['chapter_name'];

      let styles;
      if (isString(this.options)) {
        this.options = pandocMetaToString(this.options);
        styles = `
        :root {
          --chapter-name-before: "${this.options}";
        }
        `;
      }
      if (isArray(this.options)) {
        this.options = this.options.map(pandocMetaToString);
        styles = `
        :root {
          --chapter-name-before: "${this.options[0]}";
          --chapter-name-after: "${this.options[1]}";
        }
        `;
      }
      if (styles) polisher.insert(styles);
    }

    beforeParsed(content) {
      const tocAnchors = content.querySelectorAll('.toc a[href^="#"]:not([href*=":"]');
      for (const anchor of tocAnchors) {
        const ref = anchor.getAttribute('href').replace(/^#/, '');
        const element = content.getElementById(ref);
        if (element.classList.contains('chapter')) {
          anchor.classList.add('chapter-ref');
        }
      }
    }
  });

  // Main text line numbering,
  // see https://github.com/rstudio/pagedown/issues/115
  // Original idea: Julien Taquet, thanks!
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);

      // get the number-lines option from Pandoc metavariables
      this.options = pandocMeta['number-lines'];
      // quit early if the "number-lines" option is false or missing
      if (!this.options) return;
      // retrieve the selector if provided, otherwise use the default selector
      this.selector = this.options.selector ? pandocMetaToString(this.options.selector) : '.level1:not(.front-matter) h1, .level1 h2, .level1 h3, .level1 p';

      const styles = `
      :root {
        --line-numbers-padding-right: 10px;
        --line-numbers-font-size: 8pt;
      }
      .pagedown-linenumbers-container {
        position: absolute;
        margin-top: var(--pagedjs-margin-top);
        right: calc(var(--pagedjs-width) - var(--pagedjs-margin-left));
      }
      .maintextlinenumbers {
        position: absolute;
        right: 0;
        text-align: right;
        padding-right: var(--line-numbers-padding-right);
        font-size: var(--line-numbers-font-size);
      }
      `;
      polisher.insert(styles);

      this.resetLinesCounter();
    }

    appendLineNumbersContainer(page) {
      const pagebox = page.element.querySelector('.pagedjs_pagebox');
      const lineNumbersContainer = document.createElement('div');
      lineNumbersContainer.classList.add('pagedown-linenumbers-container');

      return pagebox.appendChild(lineNumbersContainer);
    }

    lineHeight(element) {
      // If the document stylesheet does not define a value for line-height,
      // Blink returns "normal". Therefore, parseInt may return NaN.
      return parseInt(getComputedStyle(element).lineHeight);
    }

    innerHeight(element) {
      let outerHeight = element.getBoundingClientRect().height;
      let {borderTopWidth,
           borderBottomWidth,
           paddingTop,
           paddingBottom} = getComputedStyle(element);

      borderTopWidth = parseFloat(borderTopWidth);
      borderBottomWidth = parseFloat(borderBottomWidth);
      paddingTop = parseFloat(paddingTop);
      paddingBottom = parseFloat(paddingBottom);

      return Math.round(outerHeight - borderTopWidth - borderBottomWidth - paddingTop - paddingBottom);
    }

    arrayOfInt(from, length) {
      // adapted from https://stackoverflow.com/a/50234108/6500804
      return Array.from(Array(length).keys(), n => n + from);
    }

    incrementLinesCounter(value) {
      this.linesCounter = this.linesCounter + value;
    }

    resetLinesCounter() {
      this.linesCounter = 0;
    }

    isDisplayMath(element) {
      const nodes = element.childNodes;
      if (nodes.length != 1) return false;
      return (nodes[0].nodeName === 'SPAN') && (nodes[0].classList.value === 'math display');
    }

    afterRendered(pages) {
      if (!this.options) return;

      for (let page of pages) {
        const lineNumbersContainer = this.appendLineNumbersContainer(page);
        const pageAreaY = page.area.getBoundingClientRect().y;
        let elementsToNumber = page.area.querySelectorAll(this.selector);

        for (let element of elementsToNumber) {
          // Do not add line numbers for display math environment
          if (this.isDisplayMath(element)) continue;

          // Try to retrieve line height
          const lineHeight = this.lineHeight(element);
          // Test against lineHeight method returns NaN
          if (!lineHeight) {
            console.warn('Failed to compute line height value on "' + page.id + '".');
            continue;
          }

          const innerHeight = this.innerHeight(element);

          // Number of lines estimation
          // There is no built-in method to detect the number of lines in a block.
          // The main caveat is that an actual line height can differ from
          // the line-height CSS property.
          // Mixed fonts, subscripts, superscripts, inline math... can increase
          // the actual line height.
          // Here, we divide the inner height of the block by the line-height
          // computed property and round to the floor to take into account that
          // sometimes the actual line height is greater than its property value.
          // This is far from perfect and can be easily broken especially by
          // inline math.
          const nLines = Math.floor(innerHeight / lineHeight);

          // do not add line numbers for void paragraphs
          if (nLines <= 0) continue;

          const linenumbers = document.createElement('div');
          lineNumbersContainer.appendChild(linenumbers);
          linenumbers.classList.add('maintextlinenumbers');

          const elementY = element.getBoundingClientRect().y;
          linenumbers.style.top = (elementY - pageAreaY) + 'px';

          const cs = getComputedStyle(element);
          const paddingTop = parseFloat(cs.paddingTop) + parseFloat(cs.borderTopWidth);
          linenumbers.style.paddingTop = paddingTop + 'px';

          linenumbers.style.lineHeight = cs.lineHeight;

          linenumbers.innerHTML = this.arrayOfInt(this.linesCounter + 1, nLines)
                                      .reduce((t, v) => t + '<br />' + v);
          this.incrementLinesCounter(nLines);
        }

        if (this.options['reset-page']) {
          this.resetLinesCounter();
        }
      }
    }
  });

  // Clean links to avoid impossible line breaking of long urls in a justified text
  // Author: Julien Taquet (Paged.js core team)
  // see https://github.com/spyrales/gouvdown/issues/37
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }
    beforeParsed(content) {
      // add wbr to / in links
      const links = content.querySelectorAll('a[href^="http"], a[href^="www"]');
      links.forEach(link => {
        // Rerun to avoid large spaces.
        // Break after a colon or a double slash (//)
        // or before a single slash (/), a tilde (~), a period, a comma, a hyphen,
        // an underline (_), a question mark, a number sign, or a percent symbol.
        const content = link.textContent;
        if (!(link.childElementCount === 0 && content.match(/^http|^www/))) return;
        let printableUrl = content.replace(/\/\//g, "//\u003Cwbr\u003E");
        printableUrl = printableUrl.replace(/\,/g, ",\u003Cwbr\u003E");
        // put wbr around everything.
        printableUrl = printableUrl.replace(
          /(\/|\~|\-|\.|\,|\_|\?|\#|\%)/g,
          "\u003Cwbr\u003E$1"
        );
        // turn hyphen in non breaking hyphen
        printableUrl = printableUrl.replace(/\-/g, "\u003Cwbr\u003E&#x2011;");
        link.setAttribute("data-print-url", printableUrl);
        link.innerHTML = printableUrl;
      });
    }
  });

  // Repeat table headers on multiple pages
  // Authors: Julien Taquet, Lucas Maciuga and Tafael Caixeta, see https://gitlab.coko.foundation/pagedjs/pagedjs/-/issues/84
  // TODO: remove this hook when Paged.js integrates this feature
  Paged.registerHandlers(class RepeatingTableHeadersHandler extends Paged.Handler {

    constructor(chunker, polisher, caller) {
        super(chunker, polisher, caller);
        this.splitTablesRefs = [];
    }

    afterPageLayout(pageElement, page, breakToken, chunker) {
        this.chunker = chunker;
        this.splitTablesRefs = [];

        if (breakToken) {
            const node = breakToken.node;
            const tables = this.findAllAncestors(node, "table");
            if (node.tagName === "TABLE") {
                tables.push(node);
            }

            if (tables.length > 0) {
                this.splitTablesRefs = tables.map(t => t.dataset.ref);

                //checks if split inside thead and if so, set breakToken to next sibling element
                let thead = node.tagName === "THEAD" ? node : this.findFirstAncestor(node, "thead");
                if (thead) {
                    let lastTheadNode = thead.hasChildNodes() ? thead.lastChild : thead;
                    breakToken.node = this.nodeAfter(lastTheadNode, chunker.source);
                }

                this.hideEmptyTables(pageElement, node);
            }
        }
    }

    hideEmptyTables(pageElement, breakTokenNode) {
        this.splitTablesRefs.forEach(ref => {
            let table = pageElement.querySelector("[data-ref='" + ref + "']");
            if (table) {
                let sourceBody = table.querySelector("tbody > tr");
                if (!sourceBody || this.refEquals(sourceBody.firstElementChild, breakTokenNode)) {
                    table.style.visibility = "hidden";
                    table.style.position = "absolute";
                    let lineSpacer = table.nextSibling;
                    if (lineSpacer) {
                        lineSpacer.style.visibility = "hidden";
                        lineSpacer.style.position = "absolute";
                    }
                }
            }
        });
    }

    refEquals(a, b) {
        return a && a.dataset && b && b.dataset && a.dataset.ref === b.dataset.ref;
    }

    findFirstAncestor(element, selector) {
        while (element.parentNode && element.parentNode.nodeType === 1) {
            if (element.parentNode.matches(selector)) {
                return element.parentNode;
            }
            element = element.parentNode;
        }
        return null;
    }

    findAllAncestors(element, selector) {
        const ancestors = [];
        while (element.parentNode && element.parentNode.nodeType === 1) {
            if (element.parentNode.matches(selector)) {
                ancestors.unshift(element.parentNode);
            }
            element = element.parentNode;
        }
        return ancestors;
    }

    // The addition of repeating Table Headers is done here because this hook is triggered before overflow handling
    layout(rendered, layout) {
        this.splitTablesRefs.forEach(ref => {
            const renderedTable = rendered.querySelector("[data-ref='" + ref + "']");
            if (renderedTable && renderedTable.hasAttribute("data-split-from")) {
                // this event can be triggered multiple times
                // added a flag repeated-headers to control when table headers already repeated in current page.
                if (!renderedTable.getAttribute("repeated-headers")) {
                    const sourceTable = this.chunker.source.querySelector("[data-ref='" + ref + "']");
                    this.repeatColgroup(sourceTable, renderedTable);
                    this.repeatTHead(sourceTable, renderedTable);
                    renderedTable.setAttribute("repeated-headers", true);
                }
            }
        });
    }

    repeatColgroup(sourceTable, renderedTable) {
        let colgroup = sourceTable.querySelectorAll("colgroup");
        let firstChild = renderedTable.firstChild;
        colgroup.forEach((colgroup) => {
            let clonedColgroup = colgroup.cloneNode(true);
            renderedTable.insertBefore(clonedColgroup, firstChild);
        });
    }

    repeatTHead(sourceTable, renderedTable) {
        let thead = sourceTable.querySelector("thead");
        if (thead) {
            let clonedThead = thead.cloneNode(true);
            renderedTable.insertBefore(clonedThead, renderedTable.firstChild);
        }
    }

    // the functions below are from pagedjs utils/dom.js
    nodeAfter(node, limiter) {
        if (limiter && node === limiter) {
            return;
        }
        let significantNode = this.nextSignificantNode(node);
        if (significantNode) {
            return significantNode;
        }
        if (node.parentNode) {
            while ((node = node.parentNode)) {
                if (limiter && node === limiter) {
                    return;
                }
                significantNode = this.nextSignificantNode(node);
                if (significantNode) {
                    return significantNode;
                }
            }
        }
    }

    nextSignificantNode(sib) {
        while ((sib = sib.nextSibling)) {
            if (!this.isIgnorable(sib)) return sib;
        }
        return null;
    }

    isIgnorable(node) {
        return (node.nodeType === 8) || // A comment node
            ((node.nodeType === 3) && this.isAllWhitespace(node)); // a text node, all whitespace
    }

    isAllWhitespace(node) {
        return !(/[^\t\n\r ]/.test(node.textContent));
    }
  });

}
</script>




<style type="text/css">#title-block-header, h1.title, .title { display: none !important; }
@page { size: 11in 8.5in; margin: 0; }
html, body { width: 11in; height: 8.5in; margin: 0; padding: 0; }
#sheet { width: 11in; height: 8.5in; margin: 0; padding: 0; box-sizing: border-box; }

#sheet .inner {
width: 10.75in;
height: 8.25in;
margin: 0.1in;
display: grid;
grid-template-columns: repeat(4, minmax(0, 1fr));
grid-template-rows: repeat(2, 1fr);
gap: 0.1in;
box-sizing: border-box;
break-inside: avoid;
page-break-inside: avoid;
font-family: -apple-system, system-ui, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
}
.cell { position: relative; overflow: hidden; break-inside: avoid; }
.cell.rotated > .panel { transform: rotate(180deg); transform-origin: center center; }
.panel {
border: 0.75pt solid #666;
padding: 0.22in;
height: 100%;
display: flex;
flex-direction: column;
justify-content: space-between;
line-height: 1.3;
font-size: 6pt;
}
.panel h2 h3 { margin: 0 0 0.12in 0; font-size: 16pt; }

.panel .body { overflow-wrap: anywhere; word-break: normal; hyphens: auto; }
.panel .body img { max-width: 100%; height: auto; display: block; margin-top: 0.1in; }

.panel::before, .panel::after {
content: "";
position: absolute;
left: 50%; transform: translateX(-50%);
width: 0.25in; height: 0; border-top: 1px dashed #666;
}
.panel::before { top: -0.07in; }
.panel::after { bottom: -0.07in; }
.pagedjs_pages, .pagedjs_page, .pagedjs_area, .pagedjs_page_content { margin: 0 !important; padding: 0 !important; }
* { box-sizing: border-box; }
</style>

</head>

<body>

<div class="running-h1-title"></div>

<div class="running-h2-title"></div>



<div class="front-page">
</div>

<div class="front-matter-container">
</div>

<div class="main">
<!-- Edit your panel content directly in the HTML below. You can use text and <img> tags. -->
<div id="sheet">
  <div class="inner">

    <!-- Top row (rotated 180°): [Page 3] [Page 4] [Page 5] [Page 6] -->
    <div class="cell rotated">
      <div class="panel">
        <h3>(6)</h3>
        <div class="body">TBD</div>
      </div>
    </div>
    
    <div class="cell rotated">
      <div class="panel">
        <h3>10 Triumphant Tracks</h3>
        <div class="body">Oppressive worlds inspire triumphant sounds. 10 songs to get through the day, feelings courtesy of deep emotional synths and explosive grooves. Some on the list instantly smack, like Galaxy Band. Others slow burn for minutes, like Isaac Hayes&#39;s cover of a Jimmy Webb song first made popular by Rhinestone Cowboy Glenn Campbell<br><br><br><br> <div class="body" style="text-align:center;">
  🪩  🪩  🪩 <strong>HANDS RAISED</strong> 🪩  🪩  🪩 <br><br>
</div> 
      <ol>
        <li>Reggio—The Light</li>
        <li>Galaxy Band—Gosh</li>
        <li>Solange—Losing You</li>
        <li>Bob Dylan—No Time To Think</li>
        <li>John David—On The Mountain ⛰</li>
        <li>Josette Martial—Let&#39;s Be Winners</li>
        <li>The Temper Trap—Sweet Disposition</li>
        <li>Jerry Garcia Band—Rubin and Cherise</li>
        <li>Phish—What&#39;s Going Through Your Mind</li>
        <li>Isaac Hayes—By The Time I Get To Phoenix (18-minute version)</li>
      </ol>
      </div>
      </div>
    </div>
    
    
    <div class="cell rotated">
       <div class="panel">
      </div>
    </div>
    
    
    <div class="cell rotated">
      <div class="panel">
        <h3>(3) How Many Times Did Trey Say &quot;Mind&quot;?</h3>
        <div class="body"><img role="img" aria-label="phish-logo" src="data:image/jpeg;base64,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AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAB/8QAFAEBAAAAAAAAAAAAAAAAAAAAAP/aAAgBAhAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/xAAUAQEAAAAAAAAAAAAAAAAAAAAA/9oACAEDEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA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" alt="phish-logo" style="width:100%;max-height:2.5in;object-fit:contain;display:block;margin:0.1in auto 0.1in;"></div>
        <br>
        <div class="body">Phish&#39;s &quot;What&#39;s Going Through Your Mind&quot; begins as guitarist Trey Anastasio vamps with a James Gang &quot;Walkaway&quot; crunch. A mesmerizing chorus hits a somber tone: <br><br>To the years we&#39;ve suffered most<br>From things we&#39;ve never spoken<br>Still I think you know<br>If looks could kill, we&#39;d both be broken<br>Though after all this time it seems<br>We&#39;re not each other&#39;s kind<br>Never think that I don&#39;t know<br>What&#39;s going through your mind<br><br>The word &quot;mind&quot; repeats 28x per chorus. We count 122 &quot;mind&quot;s in 12/31/2024&#39;s techno epic</div>
      </div>
    </div>

    <!-- Bottom row (upright): [Back Cover] [Front Cover] [Page 1] [Page 2] -->
    <div class="cell">
      <div class="panel">
       <h3>What&#39;s Going Through Your Mind</h3>
       <h1>mind mind mind mind mind mind mind mind mind mind mind mind mind mind mind mind mind mind mind mind mind mind mind mind mind mind mind mind mind mind mind mind mind mind mind mind mind mind mind mind mind mind mind mind mind mind mind mind mind mind mind mind mind mind mind mind mind mind mind mind </h1>
      </div>
    </div>

    <div class="cell">
      <div class="panel">
        <h3>GRID Magazine<br>Issue 1</h3>
<img role="img" aria-label="agnes" src="data:image/jpeg;base64,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" alt="agnes" style="width:140%;max-height:4in;object-fit:contain;display:block;margin:0.05in auto 0.1;">
        <div class="body"><br>Agnes Martin, Untitled, 1973</div>
      </div>
    </div>

    <div class="cell">
      <div class="panel">
        <h3>GRID Magazine</h3>
        <h1>The Light That Shines</h1>
        <div class="body"><strong>GRID </strong> is grooves, research, ideas, data<br>
        <strong>GRID </strong>is the anti-dystopian&#39;s favorite rag<br><strong>GRID </strong>to navigate our complex modern existence<br><strong>GRID </strong> to grow your optimism and sense of grace</div>
      </div>
    </div>
    <div class="cell">
      <div class="panel">
        <h3>Who Invented the Disco Ball?</h3>
        <div class="body">The patent application for the disco ball, or &quot;myriad reflector,&quot; was filed in 1916 by Louis Bernard Woeste of Kentucky. Woeste&#39;s invention, he wrote, &quot;aims to produce a myriad reflector reflecting surfaces, the same to be arranged in such a manner that the several reflections shall be projected at varying angles, the device itself being arranged so that it may be rotated or otherwise moved so that the reflections may [produce a] spectacular effect.&quot; If you find yourself mesmerized by a disco ball&#39;s shining light, thank Louis Bernard Woeste for his spectacular vision</div>
        <div class="body"><br><img role="img" aria-label="disco" src="data:image/png;base64,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" alt="disco" style="width:60%;max-height:2.75in;object-fit:contain;display:block;margin:0.05in auto 0.05in;"></div>
        </div>
    </div>

  </div>
</div>
</div>



<script>
// when the page is about to reload via servr, remember the scroll position
document.addEventListener('servr:reload', function(e) {
  sessionStorage.setItem('pagedown-scroll', window.scrollY);
});
</script>
</body>
</html>
