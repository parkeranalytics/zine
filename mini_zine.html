<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">

<head>

<meta charset="utf-8">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="pandoc" />
<meta name="viewport" content="width=device-width">
<meta property="og:title" content="Zine" />






<meta name="description" content="Zine">

<script id="pandoc-meta" type="application/json">
{"newpage_html_class":"page-break-after","output":{"pagedown::html_paged":{"css":["zine.css","default-page","default"],"pandoc_args":["–quiet"],"self_contained":true,"toc":false}},"pagetitle":"Zine","title":""}
</script>

<title>Zine</title>


<style type="text/css">
@page {
size: 6in 9in; 
}
@page :blank {
}

.shorttitle1 {
string-set: h1-text content(text);
}
.shorttitle2 {
string-set: h2-text content(text);
}

.running-h1-title {
position: running(runningH1Title);
width: var(--running-title-width);
text-overflow: ellipsis;
overflow: hidden;
}
.running-h1-title:before {
content: string(h1-text);
}
@page chapter:left {
@top-left {
content: counter(page);
}
@top-right {
content: element(runningH1Title);
white-space: nowrap !important;
}
}

.running-h2-title {
position: running(runningH2Title);
width: var(--running-title-width);
text-overflow: ellipsis;
overflow: hidden;
}
.running-h2-title:before {



content: string(h2-text);
}
@page chapter:right {
@top-right {
content: counter(page);
}
@top-left {
content: element(runningH2Title);
white-space: nowrap !important;
}
}

@page chapter:first {
@top-left {
content: none;
}
@top-right {
content: none;
}
@bottom-right {
content: counter(page);
}
}
@page :first {
@top-left {
content: none;
}
@top-right {
content: none;
}
@bottom-right {
content: none !important;
}
background-image: var(--front-cover);
background-position: center;
background-size: contain;
background-repeat: no-repeat;
}

.front-cover {
break-after: recto;
}

.front-page {
counter-reset: page 1;
}

@page frontmatter:left {
@top-left {
content: counter(page, lower-roman);
}
@top-right {
content: element(runningH1Title);
white-space: nowrap !important;
}
}
@page frontmatter:right {
@top-right {
content: counter(page, lower-roman);
}
@top-left {
content: element(runningH1Title);
white-space: nowrap !important;
}
}
@page frontmatter:first {
@top-left {
content: none;
}
@top-right {
content: none;
}
@bottom-right {
content: counter(page, lower-roman);
}
}

.back-cover {
break-before: verso;
}
.pagedjs_page:nth-last-of-type(1) {
background-image: var(--back-cover);
background-position: center;
background-size: contain;
background-repeat: no-repeat;
}

.level1 {
break-before: recto;
page: chapter;
}
.front-matter-container .level1 {
page: frontmatter;
}
.section > h1, .section > h2, .section > h3, .section > h4, .section > h5, .section > h6 {
break-after: avoid;
}
.footenotes {
break-before: always;
break-after: always;
}
.figure {
break-inside: avoid;
}

.main .level1:first-child h1 {
counter-reset: page 1;
}

caption {
break-inside: avoid;
break-after: avoid;
}
</style>
<style type="text/css">:root {
--background: whitesmoke;
--pagedjs-width: 6in;
--pagedjs-height: 9in;
--color-paper: white;
--color-mbox: rgba(0, 0, 0, 0.2);
--running-title-width: 2.5in;
--screen-pages-spacing: 5mm;
}
html {
line-height: 1.3;
}

a[href^="http"]:not([class="uri"])::after {
content: " (" attr(href) ")";
font-size: 90%;
hyphens: none;
word-break: break-all;
}
.references a[href^=http]:not([class=uri])::after {
content: none;
}
.main a[href^="#"]:not([class^="footnote-"]):not([href*=":"])::after {
content: " (page " target-counter(attr(href), page) ")";
}
.main a.front-matter-ref[href^="#"]:not([class^="footnote-"]):not([href*=":"])::after {
content: " (page " target-counter(attr(href), page, lower-roman) ")";
}

.sourceCode a[href^="#"]:not([class^="footnote-"]):not([href*=":"])::after,
.sourceCode a.front-matter-ref[href^="#"]:not([class^="footnote-"]):not([href*=":"])::after {
content: unset;
}

.toc ul, .lot ul, .lof ul {
list-style: none;
padding-left: 0;
overflow-x: clip;
}
.toc li li {
padding-left: 1em;
}
.toc a, .lot a, .lof a {
text-decoration: none;
background: white;
padding-right: .33em;
}
.toc a::after, .lot a::after, .lof a::after {

content: target-counter(attr(href), page);
float: right;
background: white;
}
.toc a.front-matter-ref::after, .lot a.front-matter-ref::after, .lof a.front-matter-ref::after {

content: target-counter(attr(href), page, lower-roman);
}
.toc .leaders::before, .lot .leaders::before, .lof .leaders::before {
float: left;
width: 0;
white-space: nowrap;
content: ". . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . ";
}

.chapter > h1 > .header-section-number::before, .chapter-ref > .toc-section-number::before {
content: var(--chapter-name-before, "Chapter ");
}
.chapter > h1 > .header-section-number::after, .chapter-ref > .toc-section-number::after {
content: var(--chapter-name-after, "");
}

.subtitle span {
font-size: .9em;
}
img {
max-width: 100%;
}
pre {
padding: 1em;
white-space: pre-wrap;
}
pre[class] {
background: #f9f9f9;
}
abbr {
text-decoration: none;
}
@media screen {
div.sourceCode {
overflow: visible !important;
}
a.sourceLine::before {
text-decoration: unset !important;
}
}
pre.numberSource a.sourceLine {
left: 0 !important;
text-indent: -5em
}
pre.numberSource {
margin-left: 0 !important;
}
table {
margin: auto;
border-top: 1px solid #666;
border-bottom: 1px solid #666;
}
table thead th {
border-bottom: 1px solid #ddd;
}
thead, tfoot, tr:nth-child(even) {
background: #eee;
}

.kable_wrapper > tbody > tr > td {
vertical-align: top;
}
.footnotes {
font-size: 90%;
}
.footnotes hr::before {
content: "Footnotes:";
}
.footnotes hr {
border: none;
}
.footnote-break {
width: 1in;
}
body {
hyphens: auto;
}
code {
hyphens: none;
}

@media screen {
body {
background-color: var(--background);
margin: var(--screen-pages-spacing) auto 0 auto;
}
.pagedjs_pages {
display: flex;
max-width: calc(var(--pagedjs-width) * 2);
flex: 0;
flex-wrap: wrap;
margin: 0 auto;
}
.pagedjs_page {
background-color: var(--color-paper);
box-shadow: 0 0 0 1px var(--color-mbox);
flex-shrink: 0;
flex-grow: 0;
margin: auto auto var(--screen-pages-spacing) auto;
}
}

@media screen and (min-width: 12.32in) {
.pagedjs_page {
margin: auto 0 var(--screen-pages-spacing) 0;
}
.pagedjs_first_page {
margin-left: var(--pagedjs-width);
}
}

@media screen and (max-width:1180px) {
body {
width: calc(var(--pagedjs-width) + 2 * var(--screen-pages-spacing));
}
}
</style>
<script>// Configuration script for paged.js

(function() {
  // Retrieve previous config object if defined
  window.PagedConfig = window.PagedConfig || {};
  const {before: beforePaged, after: afterPaged} = window.PagedConfig;

  // utils
  const insertCSS = text => {
    let style = document.createElement('style');
		style.type = 'text/css';
		style.appendChild(document.createTextNode(text));
    document.head.appendChild(style);
  };

  // Util function for front and back covers images
  const insertCSSForCover = type => {
    const links = document.querySelectorAll('link[id^=' + type + ']');
    if (!links.length) return;
    const re = new RegExp(type + '-\\d+');
    let text = ':root {--' + type + ': var(--' + type + '-1);';
    for (const link of links) {
      text += '--' + re.exec(link.id)[0] + ': url("' + link.href + '");';
    }
    text += '}';
    insertCSS(text);
  };

  const insertPageBreaksCSS = () => {
    insertCSS(`
    .page-break-after {break-after: page;}
    .page-break-before {break-before: page;}
    `);
  };

  window.PagedConfig.before = async () => {
    // Front and back covers support
    let frontCover = document.querySelector('.front-cover');
    let backCover = document.querySelector('.back-cover');
    if (frontCover) document.body.prepend(frontCover);
    if (backCover) document.body.append(backCover);
    insertCSSForCover('front-cover');
    insertCSSForCover('back-cover');
    insertPageBreaksCSS();

    if (beforePaged) await beforePaged();
  };

  // from https://stackoverflow.com/q/21647928
  const toUTF16BE = x => {
    let res = '';
    for (i=0; i < x.length; i++) {
      let hex = x.charCodeAt(i).toString(16);
      hex = ('000' + hex).slice(-4);
      res += hex
    }
    res = 'feff' + res ;
    return res;
  }

  const findPage = el => {
    while (el.parentElement) {
      el = el.parentElement;
      if (el.getAttribute('data-page-number')) {
        return parseInt(el.getAttribute('data-page-number'));
      }
    }
    return null;
  };

  const tocEntriesInfos = ul => {
    let result = []; // where we store the results
    // if there is no element, return an empty array
    if (!ul) {
      return result;
    }
    const tocEntries = ul.children; // tocEntries are 'li' elements

    for (const li of tocEntries) {
      // Since parts entries in TOC have no anchor,
      // do not use them in the PDF outline.
      if (li.classList.contains('part')) {
        continue;
      }

      // get the title and encode it in UTF16BE (pdfmark is encoded in UTF16BE with BOM)
      const title = toUTF16BE(li.querySelector('a').textContent);

      // get the page number
      const href = li.querySelector('a').getAttribute('href');
      const el = document.getElementById(href.substring(1));
      const page = findPage(el);

      // get the children
      children = tocEntriesInfos(li.querySelector('ul'));

      result.push({
        title: title,
        page: page,
        children: children
      });
    }

    return result;
  };
  window.PagedConfig.after = (flow) => {
    // force redraw, see https://github.com/rstudio/pagedown/issues/35#issuecomment-475905361
    // and https://stackoverflow.com/a/24753578/6500804
    document.body.style.display = 'none';
    document.body.offsetHeight;
    document.body.style.display = '';

    // run previous PagedConfig.after function if defined
    if (afterPaged) afterPaged(flow);

    // pagedownListener is a binding added by the chrome_print function
    // this binding exists only when chrome_print opens the html file
    if (window.pagedownListener) {
      // the html file is opened for printing
      // call the binding to signal to the R session that Paged.js has finished
      const tocList = flow.source.querySelector('.toc > ul');
      const tocInfos = tocEntriesInfos(tocList);
      pagedownListener(JSON.stringify({
        pagedjs: true,
        pages: flow.total,
        elapsedtime: flow.performance,
        tocInfos: tocInfos
      }));
      return;
    }
    if (sessionStorage.getItem('pagedown-scroll')) {
      // scroll to the last position before the page is reloaded
      window.scrollTo(0, sessionStorage.getItem('pagedown-scroll'));
      return;
    }
    if (window.location.hash) {
      const id = decodeURIComponent(window.location.hash).replace(/^#/, '');
      document.getElementById(id).scrollIntoView({behavior: 'smooth'});
    }
  };
})();
</script>
<script>/**
 * @license Paged.js v0.1.43 | MIT | https://gitlab.pagedmedia.org/tools/pagedjs
 */

(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
	typeof define === 'function' && define.amd ? define(factory) :
	(global = global || self, global.PagedPolyfill = factory());
}(this, (function () { 'use strict';

	function createCommonjsModule(fn, module) {
		return module = { exports: {} }, fn(module, module.exports), module.exports;
	}

	function getCjsExportFromNamespace (n) {
		return n && n['default'] || n;
	}

	var isImplemented = function () {
		var assign = Object.assign, obj;
		if (typeof assign !== "function") return false;
		obj = { foo: "raz" };
		assign(obj, { bar: "dwa" }, { trzy: "trzy" });
		return (obj.foo + obj.bar + obj.trzy) === "razdwatrzy";
	};

	var isImplemented$1 = function () {
		try {
			Object.keys("primitive");
			return true;
		} catch (e) {
	 return false;
	}
	};

	// eslint-disable-next-line no-empty-function
	var noop = function () {};

	var _undefined = noop(); // Support ES3 engines

	var isValue = function (val) {
	 return (val !== _undefined) && (val !== null);
	};

	var keys = Object.keys;

	var shim = function (object) {
		return keys(isValue(object) ? Object(object) : object);
	};

	var keys$1 = isImplemented$1()
		? Object.keys
		: shim;

	var validValue = function (value) {
		if (!isValue(value)) throw new TypeError("Cannot use null or undefined");
		return value;
	};

	var max   = Math.max;

	var shim$1 = function (dest, src /*, …srcn*/) {
		var error, i, length = max(arguments.length, 2), assign;
		dest = Object(validValue(dest));
		assign = function (key) {
			try {
				dest[key] = src[key];
			} catch (e) {
				if (!error) error = e;
			}
		};
		for (i = 1; i < length; ++i) {
			src = arguments[i];
			keys$1(src).forEach(assign);
		}
		if (error !== undefined) throw error;
		return dest;
	};

	var assign = isImplemented()
		? Object.assign
		: shim$1;

	var forEach = Array.prototype.forEach, create = Object.create;

	var process = function (src, obj) {
		var key;
		for (key in src) obj[key] = src[key];
	};

	// eslint-disable-next-line no-unused-vars
	var normalizeOptions = function (opts1 /*, …options*/) {
		var result = create(null);
		forEach.call(arguments, function (options) {
			if (!isValue(options)) return;
			process(Object(options), result);
		});
		return result;
	};

	// Deprecated

	var isCallable = function (obj) {
	 return typeof obj === "function";
	};

	var str = "razdwatrzy";

	var isImplemented$2 = function () {
		if (typeof str.contains !== "function") return false;
		return (str.contains("dwa") === true) && (str.contains("foo") === false);
	};

	var indexOf = String.prototype.indexOf;

	var shim$2 = function (searchString/*, position*/) {
		return indexOf.call(this, searchString, arguments[1]) > -1;
	};

	var contains = isImplemented$2()
		? String.prototype.contains
		: shim$2;

	var d_1 = createCommonjsModule(function (module) {

	var d;

	d = module.exports = function (dscr, value/*, options*/) {
		var c, e, w, options, desc;
		if ((arguments.length < 2) || (typeof dscr !== 'string')) {
			options = value;
			value = dscr;
			dscr = null;
		} else {
			options = arguments[2];
		}
		if (dscr == null) {
			c = w = true;
			e = false;
		} else {
			c = contains.call(dscr, 'c');
			e = contains.call(dscr, 'e');
			w = contains.call(dscr, 'w');
		}

		desc = { value: value, configurable: c, enumerable: e, writable: w };
		return !options ? desc : assign(normalizeOptions(options), desc);
	};

	d.gs = function (dscr, get, set/*, options*/) {
		var c, e, options, desc;
		if (typeof dscr !== 'string') {
			options = set;
			set = get;
			get = dscr;
			dscr = null;
		} else {
			options = arguments[3];
		}
		if (get == null) {
			get = undefined;
		} else if (!isCallable(get)) {
			options = get;
			get = set = undefined;
		} else if (set == null) {
			set = undefined;
		} else if (!isCallable(set)) {
			options = set;
			set = undefined;
		}
		if (dscr == null) {
			c = true;
			e = false;
		} else {
			c = contains.call(dscr, 'c');
			e = contains.call(dscr, 'e');
		}

		desc = { get: get, set: set, configurable: c, enumerable: e };
		return !options ? desc : assign(normalizeOptions(options), desc);
	};
	});

	var validCallable = function (fn) {
		if (typeof fn !== "function") throw new TypeError(fn + " is not a function");
		return fn;
	};

	var eventEmitter = createCommonjsModule(function (module, exports) {

	var apply = Function.prototype.apply, call = Function.prototype.call
	  , create = Object.create, defineProperty = Object.defineProperty
	  , defineProperties = Object.defineProperties
	  , hasOwnProperty = Object.prototype.hasOwnProperty
	  , descriptor = { configurable: true, enumerable: false, writable: true }

	  , on, once, off, emit, methods, descriptors, base;

	on = function (type, listener) {
		var data;

		validCallable(listener);

		if (!hasOwnProperty.call(this, '__ee__')) {
			data = descriptor.value = create(null);
			defineProperty(this, '__ee__', descriptor);
			descriptor.value = null;
		} else {
			data = this.__ee__;
		}
		if (!data[type]) data[type] = listener;
		else if (typeof data[type] === 'object') data[type].push(listener);
		else data[type] = [data[type], listener];

		return this;
	};

	once = function (type, listener) {
		var once, self;

		validCallable(listener);
		self = this;
		on.call(this, type, once = function () {
			off.call(self, type, once);
			apply.call(listener, this, arguments);
		});

		once.__eeOnceListener__ = listener;
		return this;
	};

	off = function (type, listener) {
		var data, listeners, candidate, i;

		validCallable(listener);

		if (!hasOwnProperty.call(this, '__ee__')) return this;
		data = this.__ee__;
		if (!data[type]) return this;
		listeners = data[type];

		if (typeof listeners === 'object') {
			for (i = 0; (candidate = listeners[i]); ++i) {
				if ((candidate === listener) ||
						(candidate.__eeOnceListener__ === listener)) {
					if (listeners.length === 2) data[type] = listeners[i ? 0 : 1];
					else listeners.splice(i, 1);
				}
			}
		} else {
			if ((listeners === listener) ||
					(listeners.__eeOnceListener__ === listener)) {
				delete data[type];
			}
		}

		return this;
	};

	emit = function (type) {
		var i, l, listener, listeners, args;

		if (!hasOwnProperty.call(this, '__ee__')) return;
		listeners = this.__ee__[type];
		if (!listeners) return;

		if (typeof listeners === 'object') {
			l = arguments.length;
			args = new Array(l - 1);
			for (i = 1; i < l; ++i) args[i - 1] = arguments[i];

			listeners = listeners.slice();
			for (i = 0; (listener = listeners[i]); ++i) {
				apply.call(listener, this, args);
			}
		} else {
			switch (arguments.length) {
			case 1:
				call.call(listeners, this);
				break;
			case 2:
				call.call(listeners, this, arguments[1]);
				break;
			case 3:
				call.call(listeners, this, arguments[1], arguments[2]);
				break;
			default:
				l = arguments.length;
				args = new Array(l - 1);
				for (i = 1; i < l; ++i) {
					args[i - 1] = arguments[i];
				}
				apply.call(listeners, this, args);
			}
		}
	};

	methods = {
		on: on,
		once: once,
		off: off,
		emit: emit
	};

	descriptors = {
		on: d_1(on),
		once: d_1(once),
		off: d_1(off),
		emit: d_1(emit)
	};

	base = defineProperties({}, descriptors);

	module.exports = exports = function (o) {
		return (o == null) ? create(base) : defineProperties(Object(o), descriptors);
	};
	exports.methods = methods;
	});
	var eventEmitter_1 = eventEmitter.methods;

	/**
	 * Hooks allow for injecting functions that must all complete in order before finishing
	 * They will execute in parallel but all must finish before continuing
	 * Functions may return a promise if they are asycn.
	 * From epubjs/src/utils/hooks
	 * @param {any} context scope of this
	 * @example this.content = new Hook(this);
	 */
	class Hook {
		constructor(context){
			this.context = context || this;
			this.hooks = [];
		}

		/**
		 * Adds a function to be run before a hook completes
		 * @example this.content.register(function(){...});
		 * @return {undefined} void
		 */
		register(){
			for(var i = 0; i < arguments.length; ++i) {
				if (typeof arguments[i]  === "function") {
					this.hooks.push(arguments[i]);
				} else {
					// unpack array
					for(var j = 0; j < arguments[i].length; ++j) {
						this.hooks.push(arguments[i][j]);
					}
				}
			}
		}

		/**
		 * Triggers a hook to run all functions
		 * @example this.content.trigger(args).then(function(){...});
		 * @return {Promise} results
		 */
		trigger(){
			var args = arguments;
			var context = this.context;
			var promises = [];

			this.hooks.forEach(function(task) {
				var executing = task.apply(context, args);

				if(executing && typeof executing["then"] === "function") {
					// Task is a function that returns a promise
					promises.push(executing);
				}
				// Otherwise Task resolves immediately, add resolved promise with result
				promises.push(new Promise((resolve, reject) => {
					resolve(executing);
				}));
			});


			return Promise.all(promises);
		}

		/**
	   * Triggers a hook to run all functions synchronously
	   * @example this.content.trigger(args).then(function(){...});
	   * @return {Array} results
	   */
		triggerSync(){
			var args = arguments;
			var context = this.context;
			var results = [];

			this.hooks.forEach(function(task) {
				var executing = task.apply(context, args);

				results.push(executing);
			});


			return results;
		}

		// Adds a function to be run before a hook completes
		list(){
			return this.hooks;
		}

		clear(){
			return this.hooks = [];
		}
	}

	function getBoundingClientRect(element) {
		if (!element) {
			return;
		}
		let rect;
		if (typeof element.getBoundingClientRect !== "undefined") {
			rect = element.getBoundingClientRect();
		} else {
			let range = document.createRange();
			range.selectNode(element);
			rect = range.getBoundingClientRect();
		}
		return rect;
	}

	function getClientRects(element) {
		if (!element) {
			return;
		}
		let rect;
		if (typeof element.getClientRects !== "undefined") {
			rect = element.getClientRects();
		} else {
			let range = document.createRange();
			range.selectNode(element);
			rect = range.getClientRects();
		}
		return rect;
	}

	/**
	 * Generates a UUID
	 * based on: http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript
	 * @returns {string} uuid
	 */
	function UUID() {
		var d = new Date().getTime();
		if (typeof performance !== "undefined" && typeof performance.now === "function") {
			d += performance.now(); //use high-precision timer if available
		}
		return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function (c) {
			var r = (d + Math.random() * 16) % 16 | 0;
			d = Math.floor(d / 16);
			return (c === "x" ? r : (r & 0x3 | 0x8)).toString(16);
		});
	}

	function attr(element, attributes) {
		for (var i = 0; i < attributes.length; i++) {
			if (element.hasAttribute(attributes[i])) {
				return element.getAttribute(attributes[i]);
			}
		}
	}

	/* Based on by https://mths.be/cssescape v1.5.1 by @mathias | MIT license
	 * Allows # and .
	 */
	function querySelectorEscape(value) {
		if (arguments.length == 0) {
			throw new TypeError("`CSS.escape` requires an argument.");
		}
		var string = String(value);

		var length = string.length;
		var index = -1;
		var codeUnit;
		var result = "";
		var firstCodeUnit = string.charCodeAt(0);
		while (++index < length) {
			codeUnit = string.charCodeAt(index);



			// Note: there’s no need to special-case astral symbols, surrogate
			// pairs, or lone surrogates.

			// If the character is NULL (U+0000), then the REPLACEMENT CHARACTER
			// (U+FFFD).
			if (codeUnit == 0x0000) {
				result += "\uFFFD";
				continue;
			}

			if (
				// If the character is in the range [\1-\1F] (U+0001 to U+001F) or is
				// U+007F, […]
				(codeUnit >= 0x0001 && codeUnit <= 0x001F) || codeUnit == 0x007F ||
				// If the character is the first character and is in the range [0-9]
				// (U+0030 to U+0039), […]
				(index == 0 && codeUnit >= 0x0030 && codeUnit <= 0x0039) ||
				// If the character is the second character and is in the range [0-9]
				// (U+0030 to U+0039) and the first character is a `-` (U+002D), […]
				(
					index == 1 &&
					codeUnit >= 0x0030 && codeUnit <= 0x0039 &&
					firstCodeUnit == 0x002D
				)
			) {
				// https://drafts.csswg.org/cssom/#escape-a-character-as-code-point
				result += "\\" + codeUnit.toString(16) + " ";
				continue;
			}

			if (
				// If the character is the first character and is a `-` (U+002D), and
				// there is no second character, […]
				index == 0 &&
				length == 1 &&
				codeUnit == 0x002D
			) {
				result += "\\" + string.charAt(index);
				continue;
			}

			// support for period character in id
			if (codeUnit == 0x002E) {
				if (string.charAt(0) == "#") {
					result += "\\.";
					continue;
				}
			}


			// If the character is not handled by one of the above rules and is
			// greater than or equal to U+0080, is `-` (U+002D) or `_` (U+005F), or
			// is in one of the ranges [0-9] (U+0030 to U+0039), [A-Z] (U+0041 to
			// U+005A), or [a-z] (U+0061 to U+007A), […]
			if (
				codeUnit >= 0x0080 ||
				codeUnit == 0x002D ||
				codeUnit == 0x005F ||
				codeUnit == 35 || // Allow #
				codeUnit == 46 || // Allow .
				codeUnit >= 0x0030 && codeUnit <= 0x0039 ||
				codeUnit >= 0x0041 && codeUnit <= 0x005A ||
				codeUnit >= 0x0061 && codeUnit <= 0x007A
			) {
				// the character itself
				result += string.charAt(index);
				continue;
			}

			// Otherwise, the escaped character.
			// https://drafts.csswg.org/cssom/#escape-a-character
			result += "\\" + string.charAt(index);

		}
		return result;
	}

	/**
	 * Creates a new pending promise and provides methods to resolve or reject it.
	 * From: https://developer.mozilla.org/en-US/docs/Mozilla/JavaScript_code_modules/Promise.jsm/Deferred#backwards_forwards_compatible
	 * @returns {object} defered
	 */
	function defer() {
		this.resolve = null;

		this.reject = null;

		this.id = UUID();

		this.promise = new Promise((resolve, reject) => {
			this.resolve = resolve;
			this.reject = reject;
		});
		Object.freeze(this);
	}

	const requestIdleCallback = typeof window !== "undefined" && ("requestIdleCallback" in window ? window.requestIdleCallback : window.requestAnimationFrame);

	function CSSValueToString(obj) {
		return obj.value + (obj.unit || "");
	}

	function isElement(node) {
		return node && node.nodeType === 1;
	}

	function isText(node) {
		return node && node.nodeType === 3;
	}

	function *walk(start, limiter) {
		let node = start;

		while (node) {

			yield node;

			if (node.childNodes.length) {
				node = node.firstChild;
			} else if (node.nextSibling) {
				if (limiter && node === limiter) {
					node = undefined;
					break;
				}
				node = node.nextSibling;
			} else {
				while (node) {
					node = node.parentNode;
					if (limiter && node === limiter) {
						node = undefined;
						break;
					}
					if (node && node.nextSibling) {
						node = node.nextSibling;
						break;
					}

				}
			}
		}
	}

	function nodeAfter(node, limiter) {
		if (limiter && node === limiter) {
			return;
		}
		let significantNode = nextSignificantNode(node);
		if (significantNode) {
			return significantNode;
		}
		if (node.parentNode) {
			while ((node = node.parentNode)) {
				if (limiter && node === limiter) {
					return;
				}
				significantNode = nextSignificantNode(node);
				if (significantNode) {
					return significantNode;
				}
			}
		}
	}

	function nodeBefore(node, limiter) {
		if (limiter && node === limiter) {
			return;
		}
		let significantNode = previousSignificantNode(node);
		if (significantNode) {
			return significantNode;
		}
		if (node.parentNode) {
			while ((node = node.parentNode)) {
				if (limiter && node === limiter) {
					return;
				}
				significantNode = previousSignificantNode(node);
				if (significantNode) {
					return significantNode;
				}
			}
		}
	}

	function elementAfter(node, limiter) {
		let after = nodeAfter(node, limiter);

		while (after && after.nodeType !== 1) {
			after = nodeAfter(after, limiter);
		}

		return after;
	}

	function elementBefore(node, limiter) {
		let before = nodeBefore(node, limiter);

		while (before && before.nodeType !== 1) {
			before = nodeBefore(before, limiter);
		}

		return before;
	}

	function displayedElementAfter(node, limiter) {
		let after = elementAfter(node, limiter);

		while (after && after.dataset.undisplayed) {
			after = elementAfter(after);
		}

		return after;
	}

	function displayedElementBefore(node, limiter) {
		let before = elementBefore(node, limiter);

		while (before && before.dataset.undisplayed) {
			before = elementBefore(before);
		}

		return before;
	}

	function rebuildAncestors(node) {
		let parent, ancestor;
		let ancestors = [];
		let added = [];

		let fragment = document.createDocumentFragment();

		// Gather all ancestors
		let element = node;
		while(element.parentNode && element.parentNode.nodeType === 1) {
			ancestors.unshift(element.parentNode);
			element = element.parentNode;
		}

		for (var i = 0; i < ancestors.length; i++) {
			ancestor = ancestors[i];
			parent = ancestor.cloneNode(false);

			parent.setAttribute("data-split-from", parent.getAttribute("data-ref"));
			// ancestor.setAttribute("data-split-to", parent.getAttribute("data-ref"));

			if (parent.hasAttribute("id")) {
				let dataID = parent.getAttribute("id");
				parent.setAttribute("data-id", dataID);
				parent.removeAttribute("id");
			}

			// This is handled by css :not, but also tidied up here
			if (parent.hasAttribute("data-break-before")) {
				parent.removeAttribute("data-break-before");
			}

			if (parent.hasAttribute("data-previous-break-after")) {
				parent.removeAttribute("data-previous-break-after");
			}

			if (added.length) {
				let container = added[added.length-1];
				container.appendChild(parent);
			} else {
				fragment.appendChild(parent);
			}
			added.push(parent);
		}

		added = undefined;
		return fragment;
	}

	/*
	export function split(bound, cutElement, breakAfter) {
			let needsRemoval = [];
			let index = indexOf(cutElement);

			if (!breakAfter && index === 0) {
				return;
			}

			if (breakAfter && index === (cutElement.parentNode.children.length - 1)) {
				return;
			}

			// Create a fragment with rebuilt ancestors
			let fragment = rebuildAncestors(cutElement);

			// Clone cut
			if (!breakAfter) {
				let clone = cutElement.cloneNode(true);
				let ref = cutElement.parentNode.getAttribute('data-ref');
				let parent = fragment.querySelector("[data-ref='" + ref + "']");
				parent.appendChild(clone);
				needsRemoval.push(cutElement);
			}

			// Remove all after cut
			let next = nodeAfter(cutElement, bound);
			while (next) {
				let clone = next.cloneNode(true);
				let ref = next.parentNode.getAttribute('data-ref');
				let parent = fragment.querySelector("[data-ref='" + ref + "']");
				parent.appendChild(clone);
				needsRemoval.push(next);
				next = nodeAfter(next, bound);
			}

			// Remove originals
			needsRemoval.forEach((node) => {
				if (node) {
					node.remove();
				}
			});

			// Insert after bounds
			bound.parentNode.insertBefore(fragment, bound.nextSibling);
			return [bound, bound.nextSibling];
	}
	*/

	function needsBreakBefore(node) {
		if( typeof node !== "undefined" &&
				typeof node.dataset !== "undefined" &&
				typeof node.dataset.breakBefore !== "undefined" &&
				(node.dataset.breakBefore === "always" ||
				 node.dataset.breakBefore === "page" ||
				 node.dataset.breakBefore === "left" ||
				 node.dataset.breakBefore === "right" ||
				 node.dataset.breakBefore === "recto" ||
				 node.dataset.breakBefore === "verso")
			 ) {
			return true;
		}

		return false;
	}

	function needsPreviousBreakAfter(node) {
		if( typeof node !== "undefined" &&
				typeof node.dataset !== "undefined" &&
				typeof node.dataset.previousBreakAfter !== "undefined" &&
				(node.dataset.previousBreakAfter === "always" ||
				 node.dataset.previousBreakAfter === "page" ||
				 node.dataset.previousBreakAfter === "left" ||
				 node.dataset.previousBreakAfter === "right" ||
				 node.dataset.previousBreakAfter === "recto" ||
				 node.dataset.previousBreakAfter === "verso")
			 ) {
			return true;
		}

		return false;
	}

	function needsPageBreak(node, previousSignificantNode) {
		if (typeof node === "undefined" || !previousSignificantNode || isIgnorable(node)) {
			return false;
		}
		if (node.dataset && node.dataset.undisplayed) {
			return false;
		}
		const previousSignificantNodePage = previousSignificantNode.dataset ? previousSignificantNode.dataset.page : undefined;
		const currentNodePage = node.dataset ? node.dataset.page : undefined;
		return currentNodePage !== previousSignificantNodePage;
	}

	function *words(node) {
		let currentText = node.nodeValue;
		let max = currentText.length;
		let currentOffset = 0;
		let currentLetter;

		let range;

		while(currentOffset < max) {
			currentLetter = currentText[currentOffset];
			if (/^[\S\u202F\u00A0]$/.test(currentLetter)) {
				if (!range) {
					range = document.createRange();
					range.setStart(node, currentOffset);
				}
			} else {
				if (range) {
					range.setEnd(node, currentOffset);
					yield range;
					range = undefined;
				}
			}

			currentOffset += 1;
		}

		if (range) {
			range.setEnd(node, currentOffset);
			yield range;
			range = undefined;
		}
	}

	function *letters(wordRange) {
		let currentText = wordRange.startContainer;
		let max = currentText.length;
		let currentOffset = wordRange.startOffset;
		// let currentLetter;

		let range;

		while(currentOffset < max) {
			 // currentLetter = currentText[currentOffset];
			 range = document.createRange();
			 range.setStart(currentText, currentOffset);
			 range.setEnd(currentText, currentOffset+1);

			 yield range;

			 currentOffset += 1;
		}
	}

	function isContainer(node) {
		let container;

		if (typeof node.tagName === "undefined") {
			return true;
		}

		if (node.style && node.style.display === "none") {
			return false;
		}

		switch (node.tagName) {
			// Inline
			case "A":
			case "ABBR":
			case "ACRONYM":
			case "B":
			case "BDO":
			case "BIG":
			case "BR":
			case "BUTTON":
			case "CITE":
			case "CODE":
			case "DFN":
			case "EM":
			case "I":
			case "IMG":
			case "INPUT":
			case "KBD":
			case "LABEL":
			case "MAP":
			case "OBJECT":
			case "Q":
			case "SAMP":
			case "SCRIPT":
			case "SELECT":
			case "SMALL":
			case "SPAN":
			case "STRONG":
			case "SUB":
			case "SUP":
			case "TEXTAREA":
			case "TIME":
			case "TT":
			case "VAR":
			case "P":
			case "H1":
			case "H2":
			case "H3":
			case "H4":
			case "H5":
			case "H6":
			case "FIGCAPTION":
			case "BLOCKQUOTE":
			case "PRE":
			case "LI":
			case "TR":
			case "DT":
			case "DD":
			case "VIDEO":
			case "CANVAS":
				container = false;
				break;
			default:
				container = true;
		}

		return container;
	}

	function cloneNode(n, deep=false) {
		return n.cloneNode(deep);
	}

	function findElement(node, doc) {
		const ref = node.getAttribute("data-ref");
		return findRef(ref, doc);
	}

	function findRef(ref, doc) {
		return doc.querySelector(`[data-ref='${ref}']`);
	}

	function validNode(node) {
		if (isText(node)) {
			return true;
		}

		if (isElement(node) && node.dataset.ref) {
			return true;
		}

		return false;
	}

	function prevValidNode(node) {
		while (!validNode(node)) {
			if (node.previousSibling) {
				node = node.previousSibling;
			} else {
				node = node.parentNode;
			}

			if (!node) {
				break;
			}
		}

		return node;
	}


	function indexOf$1(node) {
		let parent = node.parentNode;
		if (!parent) {
			return 0;
		}
		return Array.prototype.indexOf.call(parent.childNodes, node);
	}

	function child(node, index) {
		return node.childNodes[index];
	}

	function hasContent(node) {
		if (isElement(node)) {
			return true;
		} else if (isText(node) &&
				node.textContent.trim().length) {
			return true;
		}
		return false;
	}

	function indexOfTextNode(node, parent) {
		if (!isText(node)) {
			return -1;
		}
		let nodeTextContent = node.textContent;
		let child;
		let index = -1;
		for (var i = 0; i < parent.childNodes.length; i++) {
			child = parent.childNodes[i];
			if (child.nodeType === 3) {
				let text = parent.childNodes[i].textContent;
				if (text.includes(nodeTextContent)) {
					index = i;
					break;
				}
			}
		}

		return index;
	}


	/**
	 * Throughout, whitespace is defined as one of the characters
	 *  "\t" TAB \u0009
	 *  "\n" LF  \u000A
	 *  "\r" CR  \u000D
	 *  " "  SPC \u0020
	 *
	 * This does not use Javascript's "\s" because that includes non-breaking
	 * spaces (and also some other characters).
	 */

	/**
	 * Determine if a node should be ignored by the iterator functions.
	 * taken from https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model/Whitespace#Whitespace_helper_functions
	 *
	 * @param {Node} node An object implementing the DOM1 |Node| interface.
	 * @return {boolean} true if the node is:
	 *  1) A |Text| node that is all whitespace
	 *  2) A |Comment| node
	 *  and otherwise false.
	 */
	function isIgnorable(node) {
		return (node.nodeType === 8) || // A comment node
			((node.nodeType === 3) && isAllWhitespace(node)); // a text node, all whitespace
	}

	/**
	 * Determine whether a node's text content is entirely whitespace.
	 *
	 * @param {Node} node  A node implementing the |CharacterData| interface (i.e., a |Text|, |Comment|, or |CDATASection| node
	 * @return {boolean} true if all of the text content of |nod| is whitespace, otherwise false.
	 */
	function isAllWhitespace(node) {
		return !(/[^\t\n\r ]/.test(node.textContent));
	}

	/**
	 * Version of |previousSibling| that skips nodes that are entirely
	 * whitespace or comments.  (Normally |previousSibling| is a property
	 * of all DOM nodes that gives the sibling node, the node that is
	 * a child of the same parent, that occurs immediately before the
	 * reference node.)
	 *
	 * @param {ChildNode} sib  The reference node.
	 * @return {Node|null} Either:
	 *  1) The closest previous sibling to |sib| that is not ignorable according to |is_ignorable|, or
	 *  2) null if no such node exists.
	 */
	function previousSignificantNode(sib) {
		while ((sib = sib.previousSibling)) {
			if (!isIgnorable(sib)) return sib;
		}
		return null;
	}

	function breakInsideAvoidParentNode(node) {
		while ((node = node.parentNode)) {
			if (node && node.dataset && node.dataset.breakInside === "avoid") {
				return node;
			}
		}
		return null;
	}

	/**
	 * Find a parent with a given node name.
	 * @param {Node} node - initial Node
	 * @param {string} nodeName - node name (eg. "TD", "TABLE", "STRONG"...)
	 * @param {Node} limiter - go up to the parent until there's no more parent or the current node is equals to the limiter
	 * @returns {Node|undefined} - Either:
	 *  1) The closest parent for a the given node name, or
	 *  2) undefined if no such node exists.
	 */
	function parentOf(node, nodeName, limiter) {
		if (limiter && node === limiter) {
			return;
		}
		if (node.parentNode) {
			while ((node = node.parentNode)) {
				if (limiter && node === limiter) {
					return;
				}
				if (node.nodeName === nodeName) {
					return node;
				}
			}
		}
	}

	/**
	 * Version of |nextSibling| that skips nodes that are entirely
	 * whitespace or comments.
	 *
	 * @param {ChildNode} sib  The reference node.
	 * @return {Node|null} Either:
	 *  1) The closest next sibling to |sib| that is not ignorable according to |is_ignorable|, or
	 *  2) null if no such node exists.
	 */
	function nextSignificantNode(sib) {
		while ((sib = sib.nextSibling)) {
			if (!isIgnorable(sib)) return sib;
		}
		return null;
	}

	function filterTree(content, func, what) {
		const treeWalker = document.createTreeWalker(
			content || this.dom,
			what || NodeFilter.SHOW_ALL,
			func ? { acceptNode: func } : null,
			false
		);

		let node;
		let current;
		node = treeWalker.nextNode();
		while(node) {
			current = node;
			node = treeWalker.nextNode();
			current.parentNode.removeChild(current);
		}
	}

	/**
	 * Layout
	 * @class
	 */
	class BreakToken {

		constructor(node, offset) {
			this.node = node;
			this.offset = offset;
		}

		equals(otherBreakToken) {
			if (!otherBreakToken) {
				return false;
			}
			if (this["node"] && otherBreakToken["node"] &&
				this["node"] !== otherBreakToken["node"]) {
				return false;
			}
			if (this["offset"] && otherBreakToken["offset"] &&
				this["offset"] !== otherBreakToken["offset"]) {
				return false;
			}
			return true;
		}

	}

	const MAX_CHARS_PER_BREAK = 1500;

	/**
	 * Layout
	 * @class
	 */
	class Layout {

		constructor(element, hooks, options) {
			this.element = element;

			this.bounds = this.element.getBoundingClientRect();

			if (hooks) {
				this.hooks = hooks;
			} else {
				this.hooks = {};
				this.hooks.layout = new Hook();
				this.hooks.renderNode = new Hook();
				this.hooks.layoutNode = new Hook();
				this.hooks.beforeOverflow = new Hook();
				this.hooks.onOverflow = new Hook();
				this.hooks.onBreakToken = new Hook();
			}

			this.settings = options || {};

			this.maxChars = this.settings.maxChars || MAX_CHARS_PER_BREAK;
			this.forceRenderBreak = false;
		}

		async renderTo(wrapper, source, breakToken, bounds = this.bounds) {
			let start = this.getStart(source, breakToken);
			let walker = walk(start, source);

			let node;
			let prevNode;
			let done;
			let next;

			let hasRenderedContent = false;
			let newBreakToken;

			let length = 0;

			let prevBreakToken = breakToken || new BreakToken(start);

			while (!done && !newBreakToken) {
				next = walker.next();
				prevNode = node;
				node = next.value;
				done = next.done;

				if (!node) {
					this.hooks && this.hooks.layout.trigger(wrapper, this);

					let imgs = wrapper.querySelectorAll("img");
					if (imgs.length) {
						await this.waitForImages(imgs);
					}

					newBreakToken = this.findBreakToken(wrapper, source, bounds, prevBreakToken);

					if (newBreakToken && newBreakToken.equals(prevBreakToken)) {
						console.warn("Unable to layout item: ", prevNode);
						return undefined;
					}
					return newBreakToken;
				}

				this.hooks && this.hooks.layoutNode.trigger(node);

				// Check if the rendered element has a break set
				if (hasRenderedContent && this.shouldBreak(node)) {
					this.hooks && this.hooks.layout.trigger(wrapper, this);

					let imgs = wrapper.querySelectorAll("img");
					if (imgs.length) {
						await this.waitForImages(imgs);
					}

					newBreakToken = this.findBreakToken(wrapper, source, bounds, prevBreakToken);

					if (!newBreakToken) {
						newBreakToken = this.breakAt(node);
					}

					if (newBreakToken && newBreakToken.equals(prevBreakToken)) {
						console.warn("Unable to layout item: ", node);
						return undefined;
					}

					length = 0;

					break;
				}

				// Should the Node be a shallow or deep clone
				let shallow = isContainer(node);

				let rendered = this.append(node, wrapper, breakToken, shallow);

				length += rendered.textContent.length;

				// Check if layout has content yet
				if (!hasRenderedContent) {
					hasRenderedContent = hasContent(node);
				}

				// Skip to the next node if a deep clone was rendered
				if (!shallow) {
					walker = walk(nodeAfter(node, source), source);
				}

				if (this.forceRenderBreak) {
					this.hooks && this.hooks.layout.trigger(wrapper, this);

					newBreakToken = this.findBreakToken(wrapper, source, bounds, prevBreakToken);

					if (!newBreakToken) {
						newBreakToken = this.breakAt(node);
					}

					length = 0;
					this.forceRenderBreak = false;

					break;
				}

				// Only check x characters
				if (length >= this.maxChars) {

					this.hooks && this.hooks.layout.trigger(wrapper, this);

					let imgs = wrapper.querySelectorAll("img");
					if (imgs.length) {
						await this.waitForImages(imgs);
					}

					newBreakToken = this.findBreakToken(wrapper, source, bounds, prevBreakToken);

					if (newBreakToken && newBreakToken.equals(prevBreakToken)) {
						console.warn("Unable to layout item: ", node);
						return undefined;
					}

					if (newBreakToken) {
						length = 0;
					}
				}

			}

			return newBreakToken;
		}

		breakAt(node, offset = 0) {
			let newBreakToken = new BreakToken(
				node,
				offset
			);
			let breakHooks = this.hooks.onBreakToken.triggerSync(newBreakToken, undefined, node, this);
			breakHooks.forEach((newToken) => {
				if (typeof newToken != "undefined") {
					newBreakToken = newToken;
				}
			});

			return newBreakToken;
		}

		shouldBreak(node) {
			let previousSibling = previousSignificantNode(node);
			let parentNode = node.parentNode;
			let parentBreakBefore = needsBreakBefore(node) && parentNode && !previousSibling && needsBreakBefore(parentNode);
			let doubleBreakBefore;

			if (parentBreakBefore) {
				doubleBreakBefore = node.dataset.breakBefore === parentNode.dataset.breakBefore;
			}

			return !doubleBreakBefore && needsBreakBefore(node) || needsPreviousBreakAfter(node) || needsPageBreak(node, previousSibling);
		}

		forceBreak() {
			this.forceRenderBreak = true;
		}

		getStart(source, breakToken) {
			let start;
			let node = breakToken && breakToken.node;

			if (node) {
				start = node;
			} else {
				start = source.firstChild;
			}

			return start;
		}

		append(node, dest, breakToken, shallow = true, rebuild = true) {

			let clone = cloneNode(node, !shallow);

			if (node.parentNode && isElement(node.parentNode)) {
				let parent = findElement(node.parentNode, dest);
				// Rebuild chain
				if (parent) {
					parent.appendChild(clone);
				} else if (rebuild) {
					let fragment = rebuildAncestors(node);
					parent = findElement(node.parentNode, fragment);
					if (!parent) {
						dest.appendChild(clone);
					} else if (breakToken && isText(breakToken.node) && breakToken.offset > 0) {
						clone.textContent = clone.textContent.substring(breakToken.offset);
						parent.appendChild(clone);
					} else {
						parent.appendChild(clone);
					}

					dest.appendChild(fragment);
				} else {
					dest.appendChild(clone);
				}


			} else {
				dest.appendChild(clone);
			}

			let nodeHooks = this.hooks.renderNode.triggerSync(clone, node, this);
			nodeHooks.forEach((newNode) => {
				if (typeof newNode != "undefined") {
					clone = newNode;
				}
			});

			return clone;
		}

		async waitForImages(imgs) {
			let results = Array.from(imgs).map(async (img) => {
				return this.awaitImageLoaded(img);
			});
			await Promise.all(results);
		}

		async awaitImageLoaded(image) {
			return new Promise(resolve => {
				if (image.complete !== true) {
					image.onload = function () {
						let {width, height} = window.getComputedStyle(image);
						resolve(width, height);
					};
					image.onerror = function (e) {
						let {width, height} = window.getComputedStyle(image);
						resolve(width, height, e);
					};
				} else {
					let {width, height} = window.getComputedStyle(image);
					resolve(width, height);
				}
			});
		}

		avoidBreakInside(node, limiter) {
			let breakNode;

			if (node === limiter) {
				return;
			}

			while (node.parentNode) {
				node = node.parentNode;

				if (node === limiter) {
					break;
				}

				if (window.getComputedStyle(node)["break-inside"] === "avoid") {
					breakNode = node;
					break;
				}

			}
			return breakNode;
		}

		createBreakToken(overflow, rendered, source) {
			let container = overflow.startContainer;
			let offset = overflow.startOffset;
			let node, renderedNode, parent, index, temp;

			if (isElement(container)) {
				temp = child(container, offset);

				if (isElement(temp)) {
					renderedNode = findElement(temp, rendered);

					if (!renderedNode) {
						// Find closest element with data-ref
						let prevNode = prevValidNode(temp);
						if (!isElement(prevNode)) {
							prevNode = prevNode.parentElement;
						}
						renderedNode = findElement(prevNode, rendered);
						// Check if temp is the last rendered node at its level.
						if (!temp.nextSibling) {
							// We need to ensure that the previous sibling of temp is fully rendered.
							const renderedNodeFromSource = findElement(renderedNode, source);
							const walker = document.createTreeWalker(renderedNodeFromSource, NodeFilter.SHOW_ELEMENT);
							const lastChildOfRenderedNodeFromSource = walker.lastChild();
							const lastChildOfRenderedNodeMatchingFromRendered = findElement(lastChildOfRenderedNodeFromSource, rendered);
							// Check if we found that the last child in source
							if (!lastChildOfRenderedNodeMatchingFromRendered) {
								// Pending content to be rendered before virtual break token
								return;
							}
							// Otherwise we will return a break token as per below
						}
						// renderedNode is actually the last unbroken box that does not overflow.
						// Break Token is therefore the next sibling of renderedNode within source node.
						node = findElement(renderedNode, source).nextSibling;
						offset = 0;
					} else {
						node = findElement(renderedNode, source);
						offset = 0;
					}
				} else {
					renderedNode = findElement(container, rendered);

					if (!renderedNode) {
						renderedNode = findElement(prevValidNode(container), rendered);
					}

					parent = findElement(renderedNode, source);
					index = indexOfTextNode(temp, parent);
					// No seperatation for the first textNode of an element
					if(index === 0) {
						node = parent;
						offset = 0;
					} else {
						node = child(parent, index);
						offset = 0;
					}
				}
			} else {
				renderedNode = findElement(container.parentNode, rendered);

				if (!renderedNode) {
					renderedNode = findElement(prevValidNode(container.parentNode), rendered);
				}

				parent = findElement(renderedNode, source);
				index = indexOfTextNode(container, parent);

				if (index === -1) {
					return;
				}

				node = child(parent, index);

				offset += node.textContent.indexOf(container.textContent);
			}

			if (!node) {
				return;
			}

			return new BreakToken(
				node,
				offset
			);

		}

		findBreakToken(rendered, source, bounds = this.bounds, prevBreakToken, extract = true) {
			let overflow = this.findOverflow(rendered, bounds);
			let breakToken, breakLetter;

			let overflowHooks = this.hooks.onOverflow.triggerSync(overflow, rendered, bounds, this);
			overflowHooks.forEach((newOverflow) => {
				if (typeof newOverflow != "undefined") {
					overflow = newOverflow;
				}
			});

			if (overflow) {
				breakToken = this.createBreakToken(overflow, rendered, source);
				// breakToken is nullable
				let breakHooks = this.hooks.onBreakToken.triggerSync(breakToken, overflow, rendered, this);
				breakHooks.forEach((newToken) => {
					if (typeof newToken != "undefined") {
						breakToken = newToken;
					}
				});

				// Stop removal if we are in a loop
				if (breakToken && breakToken.equals(prevBreakToken)) {
					return breakToken;
				}

				if (breakToken && breakToken["node"] && breakToken["offset"] && breakToken["node"].textContent) {
					breakLetter = breakToken["node"].textContent.charAt(breakToken["offset"]);
				} else {
					breakLetter = undefined;
				}

				if (breakToken && breakToken.node && extract) {
					this.removeOverflow(overflow, breakLetter);
				}

			}
			return breakToken;
		}

		hasOverflow(element, bounds = this.bounds) {
			let constrainingElement = element && element.parentNode; // this gets the element, instead of the wrapper for the width workaround
			let {width} = element.getBoundingClientRect();
			let scrollWidth = constrainingElement ? constrainingElement.scrollWidth : 0;
			return Math.max(Math.floor(width), scrollWidth) > Math.round(bounds.width);
		}

		findOverflow(rendered, bounds = this.bounds) {
			if (!this.hasOverflow(rendered, bounds)) return;

			let start = Math.round(bounds.left);
			let end = Math.round(bounds.right);
			let range;

			let walker = walk(rendered.firstChild, rendered);

			// Find Start
			let next, done, node, offset, skip, breakAvoid, prev, br;
			while (!done) {
				next = walker.next();
				done = next.done;
				node = next.value;
				skip = false;
				breakAvoid = false;
				prev = undefined;
				br = undefined;

				if (node) {
					let pos = getBoundingClientRect(node);
					let left = Math.round(pos.left);
					let right = Math.floor(pos.right);

					if (!range && left >= end) {
						// Check if it is a float
						let isFloat = false;

						// Check if the node is inside a break-inside: avoid table cell
						const insideTableCell = parentOf(node, "TD", rendered);
						if (insideTableCell && window.getComputedStyle(insideTableCell)["break-inside"] === "avoid") {
							// breaking inside a table cell produces unexpected result, as a workaround, we forcibly avoid break inside in a cell.
							prev = insideTableCell;
						} else if (isElement(node)) {
							let styles = window.getComputedStyle(node);
							isFloat = styles.getPropertyValue("float") !== "none";
							skip = styles.getPropertyValue("break-inside") === "avoid";
							breakAvoid = node.dataset.breakBefore === "avoid" || node.dataset.previousBreakAfter === "avoid";
							prev = breakAvoid && nodeBefore(node, rendered);
							br = node.tagName === "BR" || node.tagName === "WBR";
						}

						if (prev) {
							range = document.createRange();
							range.selectNode(prev);
							break;
						}

						if (!br && !isFloat && isElement(node)) {
							range = document.createRange();
							range.selectNode(node);
							break;
						}

						if (isText(node) && node.textContent.trim().length) {
							range = document.createRange();
							range.selectNode(node);
							break;
						}

					}

					if (!range && isText(node) &&
						node.textContent.trim().length &&
						!breakInsideAvoidParentNode(node.parentNode)) {

						let rects = getClientRects(node);
						let rect;
						left = 0;
						for (var i = 0; i != rects.length; i++) {
							rect = rects[i];
							if (rect.width > 0 && (!left || rect.left > left)) {
								left = rect.left;
							}
						}

						if (left >= end) {
							range = document.createRange();
							offset = this.textBreak(node, start, end);
							if (!offset) {
								range = undefined;
							} else {
								range.setStart(node, offset);
							}
							break;
						}
					}

					// Skip children
					if (skip || right <= end) {
						next = nodeAfter(node, rendered);
						if (next) {
							walker = walk(next, rendered);
						}

					}

				}
			}

			// Find End
			if (range) {
				range.setEndAfter(rendered.lastChild);
				return range;
			}

		}

		findEndToken(rendered, source, bounds = this.bounds) {
			if (rendered.childNodes.length === 0) {
				return;
			}

			let lastChild = rendered.lastChild;

			let lastNodeIndex;
			while (lastChild && lastChild.lastChild) {
				if (!validNode(lastChild)) {
					// Only get elements with refs
					lastChild = lastChild.previousSibling;
				} else if (!validNode(lastChild.lastChild)) {
					// Deal with invalid dom items
					lastChild = prevValidNode(lastChild.lastChild);
					break;
				} else {
					lastChild = lastChild.lastChild;
				}
			}

			if (isText(lastChild)) {

				if (lastChild.parentNode.dataset.ref) {
					lastNodeIndex = indexOf$1(lastChild);
					lastChild = lastChild.parentNode;
				} else {
					lastChild = lastChild.previousSibling;
				}
			}

			let original = findElement(lastChild, source);

			if (lastNodeIndex) {
				original = original.childNodes[lastNodeIndex];
			}

			let after = nodeAfter(original);

			return this.breakAt(after);
		}

		textBreak(node, start, end) {
			let wordwalker = words(node);
			let left = 0;
			let right = 0;
			let word, next, done, pos;
			let offset;
			while (!done) {
				next = wordwalker.next();
				word = next.value;
				done = next.done;

				if (!word) {
					break;
				}

				pos = getBoundingClientRect(word);

				left = Math.floor(pos.left);
				right = Math.floor(pos.right);

				if (left >= end) {
					offset = word.startOffset;
					break;
				}

				if (right > end) {
					let letterwalker = letters(word);
					let letter, nextLetter, doneLetter;

					while (!doneLetter) {
						nextLetter = letterwalker.next();
						letter = nextLetter.value;
						doneLetter = nextLetter.done;

						if (!letter) {
							break;
						}

						pos = getBoundingClientRect(letter);
						left = Math.floor(pos.left);

						if (left >= end) {
							offset = letter.startOffset;
							done = true;

							break;
						}
					}
				}

			}

			return offset;
		}

		removeOverflow(overflow, breakLetter) {
			let {startContainer} = overflow;
			let extracted = overflow.extractContents();

			this.hyphenateAtBreak(startContainer, breakLetter);

			return extracted;
		}

		hyphenateAtBreak(startContainer, breakLetter) {
			if (isText(startContainer)) {
				let startText = startContainer.textContent;
				let prevLetter = startText[startText.length - 1];

				// Add a hyphen if previous character is a letter or soft hyphen
				if (
					(breakLetter && /^\w|\u00AD$/.test(prevLetter) && /^\w|\u00AD$/.test(breakLetter)) ||
					(!breakLetter && /^\w|\u00AD$/.test(prevLetter))
				) {
					startContainer.parentNode.classList.add("pagedjs_hyphen");
					startContainer.textContent += this.settings.hyphenGlyph || "\u2011";
				}
			}
		}

		equalTokens(a, b) {
			if (!a || !b) {
				return false;
			}
			if (a["node"] && b["node"] && a["node"] !== b["node"]) {
				return false;
			}
			if (a["offset"] && b["offset"] && a["offset"] !== b["offset"]) {
				return false;
			}
			return true;
		}
	}

	eventEmitter(Layout.prototype);

	/**
	 * Render a page
	 * @class
	 */
	class Page {
		constructor(pagesArea, pageTemplate, blank, hooks) {
			this.pagesArea = pagesArea;
			this.pageTemplate = pageTemplate;
			this.blank = blank;

			this.width = undefined;
			this.height = undefined;

			this.hooks = hooks;

			// this.element = this.create(this.pageTemplate);
		}

		create(template, after) {
			//let documentFragment = document.createRange().createContextualFragment( TEMPLATE );
			//let page = documentFragment.children[0];
			let clone = document.importNode(this.pageTemplate.content, true);

			let page, index;
			if (after) {
				this.pagesArea.insertBefore(clone, after.nextElementSibling);
				index = Array.prototype.indexOf.call(this.pagesArea.children, after.nextElementSibling);
				page = this.pagesArea.children[index];
			} else {
				this.pagesArea.appendChild(clone);
				page = this.pagesArea.lastChild;
			}

			let pagebox = page.querySelector(".pagedjs_pagebox");
			let area = page.querySelector(".pagedjs_page_content");


			let size = area.getBoundingClientRect();


			area.style.columnWidth = Math.round(size.width) + "px";
			area.style.columnGap = "calc(var(--pagedjs-margin-right) + var(--pagedjs-margin-left))";
			// area.style.overflow = "scroll";

			this.width = Math.round(size.width);
			this.height = Math.round(size.height);

			this.element = page;
			this.pagebox = pagebox;
			this.area = area;

			return page;
		}

		createWrapper() {
			let wrapper = document.createElement("div");

			this.area.appendChild(wrapper);

			this.wrapper = wrapper;

			return wrapper;
		}

		index(pgnum) {
			this.position = pgnum;

			let page = this.element;
			// let pagebox = this.pagebox;

			let index = pgnum + 1;

			let id = `page-${index}`;

			this.id = id;

			// page.dataset.pageNumber = index;

			page.dataset.pageNumber = index;
			page.setAttribute("id", id);

			if (this.name) {
				page.classList.add("pagedjs_" + this.name + "_page");
			}

			if (this.blank) {
				page.classList.add("pagedjs_blank_page");
			}

			if (pgnum === 0) {
				page.classList.add("pagedjs_first_page");
			}

			if (pgnum % 2 !== 1) {
				page.classList.remove("pagedjs_left_page");
				page.classList.add("pagedjs_right_page");
			} else {
				page.classList.remove("pagedjs_right_page");
				page.classList.add("pagedjs_left_page");
			}
		}

		/*
		size(width, height) {
			if (width === this.width && height === this.height) {
				return;
			}
			this.width = width;
			this.height = height;

			this.element.style.width = Math.round(width) + "px";
			this.element.style.height = Math.round(height) + "px";
			this.element.style.columnWidth = Math.round(width) + "px";
		}
		*/

		async layout(contents, breakToken, maxChars) {

			this.clear();

			this.startToken = breakToken;

			this.layoutMethod = new Layout(this.area, this.hooks, maxChars);

			let newBreakToken = await this.layoutMethod.renderTo(this.wrapper, contents, breakToken);
			
			this.addListeners(contents);

			this.endToken = newBreakToken;

			return newBreakToken;
		}

		async append(contents, breakToken) {

			if (!this.layoutMethod) {
				return this.layout(contents, breakToken);
			}

			let newBreakToken = await this.layoutMethod.renderTo(this.wrapper, contents, breakToken);

			this.endToken = newBreakToken;

			return newBreakToken;
		}

		getByParent(ref, entries) {
			let e;
			for (var i = 0; i < entries.length; i++) {
				e = entries[i];
				if (e.dataset.ref === ref) {
					return e;
				}
			}
		}

		onOverflow(func) {
			this._onOverflow = func;
		}

		onUnderflow(func) {
			this._onUnderflow = func;
		}

		clear() {
			this.removeListeners();
			this.wrapper && this.wrapper.remove();
			this.createWrapper();
		}

		addListeners(contents) {
			if (typeof ResizeObserver !== "undefined") {
				this.addResizeObserver(contents);
			} else {
				this._checkOverflowAfterResize = this.checkOverflowAfterResize.bind(this, contents);
				this.element.addEventListener("overflow", this._checkOverflowAfterResize, false);
				this.element.addEventListener("underflow", this._checkOverflowAfterResize, false);
			}
			// TODO: fall back to mutation observer?

			this._onScroll = function () {
				if (this.listening) {
					this.element.scrollLeft = 0;
				}
			}.bind(this);

			// Keep scroll left from changing
			this.element.addEventListener("scroll", this._onScroll);

			this.listening = true;

			return true;
		}

		removeListeners() {
			this.listening = false;

			if (typeof ResizeObserver !== "undefined" && this.ro) {
				this.ro.disconnect();
			} else if (this.element) {
				this.element.removeEventListener("overflow", this._checkOverflowAfterResize, false);
				this.element.removeEventListener("underflow", this._checkOverflowAfterResize, false);
			}

			this.element && this.element.removeEventListener("scroll", this._onScroll);

		}

		addResizeObserver(contents) {
			let wrapper = this.wrapper;
			let prevHeight = wrapper.getBoundingClientRect().height;
			this.ro = new ResizeObserver(entries => {

				if (!this.listening) {
					return;
				}
				requestAnimationFrame(() => {
					for (let entry of entries) {
						const cr = entry.contentRect;

						if (cr.height > prevHeight) {
							this.checkOverflowAfterResize(contents);
							prevHeight = wrapper.getBoundingClientRect().height;
						} else if (cr.height < prevHeight) { // TODO: calc line height && (prevHeight - cr.height) >= 22
							this.checkUnderflowAfterResize(contents);
							prevHeight = cr.height;
						}
					}
				});
			});

			this.ro.observe(wrapper);
		}

		checkOverflowAfterResize(contents) {
			if (!this.listening || !this.layoutMethod) {
				return;
			}

			let newBreakToken = this.layoutMethod.findBreakToken(this.wrapper, contents, this.startToken);

			if (newBreakToken) {
				this.endToken = newBreakToken;
				this._onOverflow && this._onOverflow(newBreakToken);
			}
		}

		checkUnderflowAfterResize(contents) {
			if (!this.listening || !this.layoutMethod) {
				return;
			}

			let endToken = this.layoutMethod.findEndToken(this.wrapper, contents);

			if (endToken) {
				this._onUnderflow && this._onUnderflow(endToken);
			}
		}


		destroy() {
			this.removeListeners();

			this.element.remove();

			this.element = undefined;
			this.wrapper = undefined;
		}
	}

	eventEmitter(Page.prototype);

	/**
	 * Render a flow of text offscreen
	 * @class
	 */
	class ContentParser {

		constructor(content, cb) {
			if (content && content.nodeType) {
				// handle dom
				this.dom = this.add(content);
			} else if (typeof content === "string") {
				this.dom = this.parse(content);
			}

			return this.dom;
		}

		parse(markup, mime) {
			let range = document.createRange();
			let fragment = range.createContextualFragment(markup);

			this.addRefs(fragment);

			return fragment;
		}

		add(contents) {
			// let fragment = document.createDocumentFragment();
			//
			// let children = [...contents.childNodes];
			// for (let child of children) {
			// 	let clone = child.cloneNode(true);
			// 	fragment.appendChild(clone);
			// }

			this.addRefs(contents);

			return contents;
		}

		addRefs(content) {
			var treeWalker = document.createTreeWalker(
				content,
				NodeFilter.SHOW_ELEMENT,
				null,
				false
			);

			let node = treeWalker.nextNode();
			while(node) {

				if (!node.hasAttribute("data-ref")) {
					let uuid = UUID();
					node.setAttribute("data-ref", uuid);
				}

				if (node.id) {
					node.setAttribute("data-id", node.id);
				}

				// node.setAttribute("data-children", node.childNodes.length);

				// node.setAttribute("data-text", node.textContent.trim().length);
				node = treeWalker.nextNode();
			}
		}

		find(ref) {
			return this.refs[ref];
		}

		destroy() {
			this.refs = undefined;
			this.dom = undefined;
		}
	}

	/**
	 * Queue for handling tasks one at a time
	 * @class
	 * @param {scope} context what this will resolve to in the tasks
	 */
	class Queue {
		constructor(context){
			this._q = [];
			this.context = context;
			this.tick = requestAnimationFrame;
			this.running = false;
			this.paused = false;
		}

		/**
		 * Add an item to the queue
		 * @return {Promise} enqueued
		 */
		enqueue() {
			var deferred, promise;
			var queued;
			var task = [].shift.call(arguments);
			var args = arguments;

			// Handle single args without context
			// if(args && !Array.isArray(args)) {
			//   args = [args];
			// }
			if(!task) {
				throw new Error("No Task Provided");
			}

			if(typeof task === "function"){

				deferred = new defer();
				promise = deferred.promise;

				queued = {
					"task" : task,
					"args"     : args,
					//"context"  : context,
					"deferred" : deferred,
					"promise" : promise
				};

			} else {
				// Task is a promise
				queued = {
					"promise" : task
				};

			}

			this._q.push(queued);

			// Wait to start queue flush
			if (this.paused == false && !this.running) {
				this.run();
			}

			return queued.promise;
		}

		/**
		 * Run one item
		 * @return {Promise} dequeued
		 */
		dequeue(){
			var inwait, task, result;

			if(this._q.length && !this.paused) {
				inwait = this._q.shift();
				task = inwait.task;
				if(task){
					// console.log(task)

					result = task.apply(this.context, inwait.args);

					if(result && typeof result["then"] === "function") {
						// Task is a function that returns a promise
						return result.then(function(){
							inwait.deferred.resolve.apply(this.context, arguments);
						}.bind(this), function() {
							inwait.deferred.reject.apply(this.context, arguments);
						}.bind(this));
					} else {
						// Task resolves immediately
						inwait.deferred.resolve.apply(this.context, result);
						return inwait.promise;
					}



				} else if(inwait.promise) {
					// Task is a promise
					return inwait.promise;
				}

			} else {
				inwait = new defer();
				inwait.deferred.resolve();
				return inwait.promise;
			}

		}

		// Run All Immediately
		dump(){
			while(this._q.length) {
				this.dequeue();
			}
		}

		/**
		 * Run all tasks sequentially, at convince
		 * @return {Promise} all run
		 */
		run(){

			if(!this.running){
				this.running = true;
				this.defered = new defer();
			}

			this.tick.call(window, () => {

				if(this._q.length) {

					this.dequeue()
						.then(function(){
							this.run();
						}.bind(this));

				} else {
					this.defered.resolve();
					this.running = undefined;
				}

			});

			// Unpause
			if(this.paused == true) {
				this.paused = false;
			}

			return this.defered.promise;
		}

		/**
		 * Flush all, as quickly as possible
		 * @return {Promise} ran
		 */
		flush(){

			if(this.running){
				return this.running;
			}

			if(this._q.length) {
				this.running = this.dequeue()
					.then(function(){
						this.running = undefined;
						return this.flush();
					}.bind(this));

				return this.running;
			}

		}

		/**
		 * Clear all items in wait
		 * @return {void}
		 */
		clear(){
			this._q = [];
		}

		/**
		 * Get the number of tasks in the queue
		 * @return {number} tasks
		 */
		length(){
			return this._q.length;
		}

		/**
		 * Pause a running queue
		 * @return {void}
		 */
		pause(){
			this.paused = true;
		}

		/**
		 * End the queue
		 * @return {void}
		 */
		stop(){
			this._q = [];
			this.running = false;
			this.paused = true;
		}
	}

	const TEMPLATE = `
<div class="pagedjs_page">
	<div class="pagedjs_sheet">
		<div class="pagedjs_bleed pagedjs_bleed-top">
			<div class="pagedjs_marks-crop"></div>
			<div class="pagedjs_marks-middle">
				<div class="pagedjs_marks-cross"></div>
			</div>
			<div class="pagedjs_marks-crop"></div>
		</div>
		<div class="pagedjs_bleed pagedjs_bleed-bottom">
			<div class="pagedjs_marks-crop"></div>
			<div class="pagedjs_marks-middle">
				<div class="pagedjs_marks-cross"></div>
			</div>		<div class="pagedjs_marks-crop"></div>
		</div>
		<div class="pagedjs_bleed pagedjs_bleed-left">
			<div class="pagedjs_marks-crop"></div>
			<div class="pagedjs_marks-middle">
				<div class="pagedjs_marks-cross"></div>
			</div>		<div class="pagedjs_marks-crop"></div>
		</div>
		<div class="pagedjs_bleed pagedjs_bleed-right">
			<div class="pagedjs_marks-crop"></div>
			<div class="pagedjs_marks-middle">
				<div class="pagedjs_marks-cross"></div>
			</div>
			<div class="pagedjs_marks-crop"></div>
		</div>
		<div class="pagedjs_pagebox">
			<div class="pagedjs_margin-top-left-corner-holder">
				<div class="pagedjs_margin pagedjs_margin-top-left-corner"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-top">
				<div class="pagedjs_margin pagedjs_margin-top-left"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-top-center"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-top-right"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-top-right-corner-holder">
				<div class="pagedjs_margin pagedjs_margin-top-right-corner"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-right">
				<div class="pagedjs_margin pagedjs_margin-right-top"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-right-middle"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-right-bottom"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-left">
				<div class="pagedjs_margin pagedjs_margin-left-top"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-left-middle"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-left-bottom"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-bottom-left-corner-holder">
				<div class="pagedjs_margin pagedjs_margin-bottom-left-corner"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-bottom">
				<div class="pagedjs_margin pagedjs_margin-bottom-left"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-bottom-center"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-bottom-right"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-bottom-right-corner-holder">
				<div class="pagedjs_margin pagedjs_margin-bottom-right-corner"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_area">
				<div class="pagedjs_page_content"></div>
			</div>
		</div>
	</div>
</div>`;

	/**
	 * Chop up text into flows
	 * @class
	 */
	class Chunker {
		constructor(content, renderTo, options) {
			// this.preview = preview;

			this.settings = options || {};

			this.hooks = {};
			this.hooks.beforeParsed = new Hook(this);
			this.hooks.filter = new Hook(this);
			this.hooks.afterParsed = new Hook(this);
			this.hooks.beforePageLayout = new Hook(this);
			this.hooks.layout = new Hook(this);
			this.hooks.renderNode = new Hook(this);
			this.hooks.layoutNode = new Hook(this);
			this.hooks.onOverflow = new Hook(this);
			this.hooks.onBreakToken = new Hook();
			this.hooks.afterPageLayout = new Hook(this);
			this.hooks.afterRendered = new Hook(this);

			this.pages = [];
			this.total = 0;

			this.q = new Queue(this);
			this.stopped = false;
			this.rendered = false;

			this.content = content;

			this.charsPerBreak = [];
			this.maxChars;

			if (content) {
				this.flow(content, renderTo);
			}
		}

		setup(renderTo) {
			this.pagesArea = document.createElement("div");
			this.pagesArea.classList.add("pagedjs_pages");

			if (renderTo) {
				renderTo.appendChild(this.pagesArea);
			} else {
				document.querySelector("body").appendChild(this.pagesArea);
			}

			this.pageTemplate = document.createElement("template");
			this.pageTemplate.innerHTML = TEMPLATE;

		}

		async flow(content, renderTo) {
			let parsed;

			await this.hooks.beforeParsed.trigger(content, this);

			parsed = new ContentParser(content);

			this.hooks.filter.triggerSync(parsed);

			this.source = parsed;
			this.breakToken = undefined;

			if (this.pagesArea && this.pageTemplate) {
				this.q.clear();
				this.removePages();
			} else {
				this.setup(renderTo);
			}

			this.emit("rendering", parsed);

			await this.hooks.afterParsed.trigger(parsed, this);

			await this.loadFonts();

			let rendered = await this.render(parsed, this.breakToken);
			while (rendered.canceled) {
				this.start();
				rendered = await this.render(parsed, this.breakToken);
			}

			this.rendered = true;
			this.pagesArea.style.setProperty("--pagedjs-page-count", this.total);

			await this.hooks.afterRendered.trigger(this.pages, this);

			this.emit("rendered", this.pages);



			return this;
		}

		// oversetPages() {
		// 	let overset = [];
		// 	for (let i = 0; i < this.pages.length; i++) {
		// 		let page = this.pages[i];
		// 		if (page.overset) {
		// 			overset.push(page);
		// 			// page.overset = false;
		// 		}
		// 	}
		// 	return overset;
		// }
		//
		// async handleOverset(parsed) {
		// 	let overset = this.oversetPages();
		// 	if (overset.length) {
		// 		console.log("overset", overset);
		// 		let index = this.pages.indexOf(overset[0]) + 1;
		// 		console.log("INDEX", index);
		//
		// 		// Remove pages
		// 		// this.removePages(index);
		//
		// 		// await this.render(parsed, overset[0].overset);
		//
		// 		// return this.handleOverset(parsed);
		// 	}
		// }

		async render(parsed, startAt) {
			let renderer = this.layout(parsed, startAt, this.settings);

			let done = false;
			let result;
			while (!done) {
				result = await this.q.enqueue(() => { return this.renderAsync(renderer); });
				done = result.done;
			}

			return result;
		}

		start() {
			this.rendered = false;
			this.stopped = false;
		}

		stop() {
			this.stopped = true;
			// this.q.clear();
		}

		renderOnIdle(renderer) {
			return new Promise(resolve => {
				requestIdleCallback(async () => {
					if (this.stopped) {
						return resolve({ done: true, canceled: true });
					}
					let result = await renderer.next();
					if (this.stopped) {
						resolve({ done: true, canceled: true });
					} else {
						resolve(result);
					}
				});
			});
		}

		async renderAsync(renderer) {
			if (this.stopped) {
				return { done: true, canceled: true };
			}
			let result = await renderer.next();
			if (this.stopped) {
				return { done: true, canceled: true };
			} else {
				return result;
			}
		}

		async handleBreaks(node) {
			let currentPage = this.total + 1;
			let currentPosition = currentPage % 2 === 0 ? "left" : "right";
			// TODO: Recto and Verso should reverse for rtl languages
			let currentSide = currentPage % 2 === 0 ? "verso" : "recto";
			let previousBreakAfter;
			let breakBefore;
			let page;

			if (currentPage === 1) {
				return;
			}

			if (node &&
					typeof node.dataset !== "undefined" &&
					typeof node.dataset.previousBreakAfter !== "undefined") {
				previousBreakAfter = node.dataset.previousBreakAfter;
			}

			if (node &&
					typeof node.dataset !== "undefined" &&
					typeof node.dataset.breakBefore !== "undefined") {
				breakBefore = node.dataset.breakBefore;
			}

			if( previousBreakAfter &&
					(previousBreakAfter === "left" || previousBreakAfter === "right") &&
					previousBreakAfter !== currentPosition) {
				page = this.addPage(true);
			} else if( previousBreakAfter &&
					(previousBreakAfter === "verso" || previousBreakAfter === "recto") &&
					previousBreakAfter !== currentSide) {
				page = this.addPage(true);
			} else if( breakBefore &&
					(breakBefore === "left" || breakBefore === "right") &&
					breakBefore !== currentPosition) {
				page = this.addPage(true);
			} else if( breakBefore &&
					(breakBefore === "verso" || breakBefore === "recto") &&
					breakBefore !== currentSide) {
				page = this.addPage(true);
			}

			if (page) {
				await this.hooks.beforePageLayout.trigger(page, undefined, undefined, this);
				this.emit("page", page);
				// await this.hooks.layout.trigger(page.element, page, undefined, this);
				await this.hooks.afterPageLayout.trigger(page.element, page, undefined, this);
				this.emit("renderedPage", page);
			}
		}

		async *layout(content, startAt) {
			let breakToken = startAt || false;

			while (breakToken !== undefined && ( true)) {

				if (breakToken && breakToken.node) {
					await this.handleBreaks(breakToken.node);
				} else {
					await this.handleBreaks(content.firstChild);
				}

				let page = this.addPage();

				await this.hooks.beforePageLayout.trigger(page, content, breakToken, this);
				this.emit("page", page);

				// Layout content in the page, starting from the breakToken
				breakToken = await page.layout(content, breakToken, this.maxChars);

				await this.hooks.afterPageLayout.trigger(page.element, page, breakToken, this);
				this.emit("renderedPage", page);

				this.recoredCharLength(page.wrapper.textContent.length);

				yield breakToken;

				// Stop if we get undefined, showing we have reached the end of the content
			}


		}

		recoredCharLength(length) {
			if (length === 0) {
				return;
			}

			this.charsPerBreak.push(length);

			// Keep the length of the last few breaks
			if (this.charsPerBreak.length > 4) {
				this.charsPerBreak.shift();
			}

			this.maxChars = this.charsPerBreak.reduce((a, b) => a + b, 0) / (this.charsPerBreak.length);
		}

		removePages(fromIndex=0) {

			if (fromIndex >= this.pages.length) {
				return;
			}

			// Remove pages
			for (let i = fromIndex; i < this.pages.length; i++) {
				this.pages[i].destroy();
			}

			if (fromIndex > 0) {
				this.pages.splice(fromIndex);
			} else {
				this.pages = [];
			}

			this.total = this.pages.length;
		}

		addPage(blank) {
			let lastPage = this.pages[this.pages.length - 1];
			// Create a new page from the template
			let page = new Page(this.pagesArea, this.pageTemplate, blank, this.hooks);

			this.pages.push(page);

			// Create the pages
			page.create(undefined, lastPage && lastPage.element);

			page.index(this.total);

			if (!blank) {
				// Listen for page overflow
				page.onOverflow((overflowToken) => {
					console.warn("overflow on", page.id, overflowToken);

					// Only reflow while rendering
					if (this.rendered) {
						return;
					}

					let index = this.pages.indexOf(page) + 1;

					// Stop the rendering
					this.stop();

					// Set the breakToken to resume at
					this.breakToken = overflowToken;

					// Remove pages
					this.removePages(index);

					if (this.rendered === true) {
						this.rendered = false;

						this.q.enqueue(async () => {

							this.start();

							await this.render(this.source, this.breakToken);

							this.rendered = true;

						});
					}


				});

				page.onUnderflow((overflowToken) => {
					// console.log("underflow on", page.id, overflowToken);

					// page.append(this.source, overflowToken);

				});
			}

			this.total = this.pages.length;

			return page;
		}
		/*
		insertPage(index, blank) {
			let lastPage = this.pages[index];
			// Create a new page from the template
			let page = new Page(this.pagesArea, this.pageTemplate, blank, this.hooks);

			let total = this.pages.splice(index, 0, page);

			// Create the pages
			page.create(undefined, lastPage && lastPage.element);

			page.index(index + 1);

			for (let i = index + 2; i < this.pages.length; i++) {
				this.pages[i].index(i);
			}

			if (!blank) {
				// Listen for page overflow
				page.onOverflow((overflowToken) => {
					if (total < this.pages.length) {
						this.pages[total].layout(this.source, overflowToken);
					} else {
						let newPage = this.addPage();
						newPage.layout(this.source, overflowToken);
					}
				});

				page.onUnderflow(() => {
					// console.log("underflow on", page.id);
				});
			}

			this.total += 1;

			return page;
		}
		*/



		loadFonts() {
			let fontPromises = [];
			(document.fonts || []).forEach((fontFace) => {
				if (fontFace.status !== "loaded") {
					let fontLoaded = fontFace.load().then((r) => {
						return fontFace.family;
					}, (r) => {
						console.warn("Failed to preload font-family:", fontFace.family);
						return fontFace.family;
					});
					fontPromises.push(fontLoaded);
				}
			});
			return Promise.all(fontPromises).catch((err) => {
				console.warn(err);
			});
		}

		destroy() {
			this.pagesArea.remove();
			this.pageTemplate.remove();
		}

	}

	eventEmitter(Chunker.prototype);

	//
	//                              list
	//                            ┌──────┐
	//             ┌──────────────┼─head │
	//             │              │ tail─┼──────────────┐
	//             │              └──────┘              │
	//             ▼                                    ▼
	//            item        item        item        item
	//          ┌──────┐    ┌──────┐    ┌──────┐    ┌──────┐
	//  null ◀──┼─prev │◀───┼─prev │◀───┼─prev │◀───┼─prev │
	//          │ next─┼───▶│ next─┼───▶│ next─┼───▶│ next─┼──▶ null
	//          ├──────┤    ├──────┤    ├──────┤    ├──────┤
	//          │ data │    │ data │    │ data │    │ data │
	//          └──────┘    └──────┘    └──────┘    └──────┘
	//

	function createItem(data) {
	    return {
	        prev: null,
	        next: null,
	        data: data
	    };
	}

	function allocateCursor(node, prev, next) {
	    var cursor;

	    if (cursors !== null) {
	        cursor = cursors;
	        cursors = cursors.cursor;
	        cursor.prev = prev;
	        cursor.next = next;
	        cursor.cursor = node.cursor;
	    } else {
	        cursor = {
	            prev: prev,
	            next: next,
	            cursor: node.cursor
	        };
	    }

	    node.cursor = cursor;

	    return cursor;
	}

	function releaseCursor(node) {
	    var cursor = node.cursor;

	    node.cursor = cursor.cursor;
	    cursor.prev = null;
	    cursor.next = null;
	    cursor.cursor = cursors;
	    cursors = cursor;
	}

	var cursors = null;
	var List = function() {
	    this.cursor = null;
	    this.head = null;
	    this.tail = null;
	};

	List.createItem = createItem;
	List.prototype.createItem = createItem;

	List.prototype.updateCursors = function(prevOld, prevNew, nextOld, nextNew) {
	    var cursor = this.cursor;

	    while (cursor !== null) {
	        if (cursor.prev === prevOld) {
	            cursor.prev = prevNew;
	        }

	        if (cursor.next === nextOld) {
	            cursor.next = nextNew;
	        }

	        cursor = cursor.cursor;
	    }
	};

	List.prototype.getSize = function() {
	    var size = 0;
	    var cursor = this.head;

	    while (cursor) {
	        size++;
	        cursor = cursor.next;
	    }

	    return size;
	};

	List.prototype.fromArray = function(array) {
	    var cursor = null;

	    this.head = null;

	    for (var i = 0; i < array.length; i++) {
	        var item = createItem(array[i]);

	        if (cursor !== null) {
	            cursor.next = item;
	        } else {
	            this.head = item;
	        }

	        item.prev = cursor;
	        cursor = item;
	    }

	    this.tail = cursor;

	    return this;
	};

	List.prototype.toArray = function() {
	    var cursor = this.head;
	    var result = [];

	    while (cursor) {
	        result.push(cursor.data);
	        cursor = cursor.next;
	    }

	    return result;
	};

	List.prototype.toJSON = List.prototype.toArray;

	List.prototype.isEmpty = function() {
	    return this.head === null;
	};

	List.prototype.first = function() {
	    return this.head && this.head.data;
	};

	List.prototype.last = function() {
	    return this.tail && this.tail.data;
	};

	List.prototype.each = function(fn, context) {
	    var item;

	    if (context === undefined) {
	        context = this;
	    }

	    // push cursor
	    var cursor = allocateCursor(this, null, this.head);

	    while (cursor.next !== null) {
	        item = cursor.next;
	        cursor.next = item.next;

	        fn.call(context, item.data, item, this);
	    }

	    // pop cursor
	    releaseCursor(this);
	};

	List.prototype.forEach = List.prototype.each;

	List.prototype.eachRight = function(fn, context) {
	    var item;

	    if (context === undefined) {
	        context = this;
	    }

	    // push cursor
	    var cursor = allocateCursor(this, this.tail, null);

	    while (cursor.prev !== null) {
	        item = cursor.prev;
	        cursor.prev = item.prev;

	        fn.call(context, item.data, item, this);
	    }

	    // pop cursor
	    releaseCursor(this);
	};

	List.prototype.forEachRight = List.prototype.eachRight;

	List.prototype.nextUntil = function(start, fn, context) {
	    if (start === null) {
	        return;
	    }

	    var item;

	    if (context === undefined) {
	        context = this;
	    }

	    // push cursor
	    var cursor = allocateCursor(this, null, start);

	    while (cursor.next !== null) {
	        item = cursor.next;
	        cursor.next = item.next;

	        if (fn.call(context, item.data, item, this)) {
	            break;
	        }
	    }

	    // pop cursor
	    releaseCursor(this);
	};

	List.prototype.prevUntil = function(start, fn, context) {
	    if (start === null) {
	        return;
	    }

	    var item;

	    if (context === undefined) {
	        context = this;
	    }

	    // push cursor
	    var cursor = allocateCursor(this, start, null);

	    while (cursor.prev !== null) {
	        item = cursor.prev;
	        cursor.prev = item.prev;

	        if (fn.call(context, item.data, item, this)) {
	            break;
	        }
	    }

	    // pop cursor
	    releaseCursor(this);
	};

	List.prototype.some = function(fn, context) {
	    var cursor = this.head;

	    if (context === undefined) {
	        context = this;
	    }

	    while (cursor !== null) {
	        if (fn.call(context, cursor.data, cursor, this)) {
	            return true;
	        }

	        cursor = cursor.next;
	    }

	    return false;
	};

	List.prototype.map = function(fn, context) {
	    var result = new List();
	    var cursor = this.head;

	    if (context === undefined) {
	        context = this;
	    }

	    while (cursor !== null) {
	        result.appendData(fn.call(context, cursor.data, cursor, this));
	        cursor = cursor.next;
	    }

	    return result;
	};

	List.prototype.filter = function(fn, context) {
	    var result = new List();
	    var cursor = this.head;

	    if (context === undefined) {
	        context = this;
	    }

	    while (cursor !== null) {
	        if (fn.call(context, cursor.data, cursor, this)) {
	            result.appendData(cursor.data);
	        }
	        cursor = cursor.next;
	    }

	    return result;
	};

	List.prototype.clear = function() {
	    this.head = null;
	    this.tail = null;
	};

	List.prototype.copy = function() {
	    var result = new List();
	    var cursor = this.head;

	    while (cursor !== null) {
	        result.insert(createItem(cursor.data));
	        cursor = cursor.next;
	    }

	    return result;
	};

	List.prototype.prepend = function(item) {
	    //      head
	    //    ^
	    // item
	    this.updateCursors(null, item, this.head, item);

	    // insert to the beginning of the list
	    if (this.head !== null) {
	        // new item <- first item
	        this.head.prev = item;

	        // new item -> first item
	        item.next = this.head;
	    } else {
	        // if list has no head, then it also has no tail
	        // in this case tail points to the new item
	        this.tail = item;
	    }

	    // head always points to new item
	    this.head = item;

	    return this;
	};

	List.prototype.prependData = function(data) {
	    return this.prepend(createItem(data));
	};

	List.prototype.append = function(item) {
	    return this.insert(item);
	};

	List.prototype.appendData = function(data) {
	    return this.insert(createItem(data));
	};

	List.prototype.insert = function(item, before) {
	    if (before !== undefined && before !== null) {
	        // prev   before
	        //      ^
	        //     item
	        this.updateCursors(before.prev, item, before, item);

	        if (before.prev === null) {
	            // insert to the beginning of list
	            if (this.head !== before) {
	                throw new Error('before doesn\'t belong to list');
	            }

	            // since head points to before therefore list doesn't empty
	            // no need to check tail
	            this.head = item;
	            before.prev = item;
	            item.next = before;

	            this.updateCursors(null, item);
	        } else {

	            // insert between two items
	            before.prev.next = item;
	            item.prev = before.prev;

	            before.prev = item;
	            item.next = before;
	        }
	    } else {
	        // tail
	        //      ^
	        //      item
	        this.updateCursors(this.tail, item, null, item);

	        // insert to the ending of the list
	        if (this.tail !== null) {
	            // last item -> new item
	            this.tail.next = item;

	            // last item <- new item
	            item.prev = this.tail;
	        } else {
	            // if list has no tail, then it also has no head
	            // in this case head points to new item
	            this.head = item;
	        }

	        // tail always points to new item
	        this.tail = item;
	    }

	    return this;
	};

	List.prototype.insertData = function(data, before) {
	    return this.insert(createItem(data), before);
	};

	List.prototype.remove = function(item) {
	    //      item
	    //       ^
	    // prev     next
	    this.updateCursors(item, item.prev, item, item.next);

	    if (item.prev !== null) {
	        item.prev.next = item.next;
	    } else {
	        if (this.head !== item) {
	            throw new Error('item doesn\'t belong to list');
	        }

	        this.head = item.next;
	    }

	    if (item.next !== null) {
	        item.next.prev = item.prev;
	    } else {
	        if (this.tail !== item) {
	            throw new Error('item doesn\'t belong to list');
	        }

	        this.tail = item.prev;
	    }

	    item.prev = null;
	    item.next = null;

	    return item;
	};

	List.prototype.push = function(data) {
	    this.insert(createItem(data));
	};

	List.prototype.pop = function() {
	    if (this.tail !== null) {
	        return this.remove(this.tail);
	    }
	};

	List.prototype.unshift = function(data) {
	    this.prepend(createItem(data));
	};

	List.prototype.shift = function() {
	    if (this.head !== null) {
	        return this.remove(this.head);
	    }
	};

	List.prototype.prependList = function(list) {
	    return this.insertList(list, this.head);
	};

	List.prototype.appendList = function(list) {
	    return this.insertList(list);
	};

	List.prototype.insertList = function(list, before) {
	    // ignore empty lists
	    if (list.head === null) {
	        return this;
	    }

	    if (before !== undefined && before !== null) {
	        this.updateCursors(before.prev, list.tail, before, list.head);

	        // insert in the middle of dist list
	        if (before.prev !== null) {
	            // before.prev <-> list.head
	            before.prev.next = list.head;
	            list.head.prev = before.prev;
	        } else {
	            this.head = list.head;
	        }

	        before.prev = list.tail;
	        list.tail.next = before;
	    } else {
	        this.updateCursors(this.tail, list.tail, null, list.head);

	        // insert to end of the list
	        if (this.tail !== null) {
	            // if destination list has a tail, then it also has a head,
	            // but head doesn't change

	            // dest tail -> source head
	            this.tail.next = list.head;

	            // dest tail <- source head
	            list.head.prev = this.tail;
	        } else {
	            // if list has no a tail, then it also has no a head
	            // in this case points head to new item
	            this.head = list.head;
	        }

	        // tail always start point to new item
	        this.tail = list.tail;
	    }

	    list.head = null;
	    list.tail = null;

	    return this;
	};

	List.prototype.replace = function(oldItem, newItemOrList) {
	    if ('head' in newItemOrList) {
	        this.insertList(newItemOrList, oldItem);
	    } else {
	        this.insert(newItemOrList, oldItem);
	    }

	    this.remove(oldItem);
	};

	var List_1 = List;

	var createCustomError = function createCustomError(name, message) {
	    // use Object.create(), because some VMs prevent setting line/column otherwise
	    // (iOS Safari 10 even throws an exception)
	    var error = Object.create(SyntaxError.prototype);
	    var errorStack = new Error();

	    error.name = name;
	    error.message = message;

	    Object.defineProperty(error, 'stack', {
	        get: function() {
	            return (errorStack.stack || '').replace(/^(.+\n){1,3}/, name + ': ' + message + '\n');
	        }
	    });

	    return error;
	};

	var MAX_LINE_LENGTH = 100;
	var OFFSET_CORRECTION = 60;
	var TAB_REPLACEMENT = '    ';

	function sourceFragment(error, extraLines) {
	    function processLines(start, end) {
	        return lines.slice(start, end).map(function(line, idx) {
	            var num = String(start + idx + 1);

	            while (num.length < maxNumLength) {
	                num = ' ' + num;
	            }

	            return num + ' |' + line;
	        }).join('\n');
	    }

	    var lines = error.source.split(/\r\n?|\n|\f/);
	    var line = error.line;
	    var column = error.column;
	    var startLine = Math.max(1, line - extraLines) - 1;
	    var endLine = Math.min(line + extraLines, lines.length + 1);
	    var maxNumLength = Math.max(4, String(endLine).length) + 1;
	    var cutLeft = 0;

	    // column correction according to replaced tab before column
	    column += (TAB_REPLACEMENT.length - 1) * (lines[line - 1].substr(0, column - 1).match(/\t/g) || []).length;

	    if (column > MAX_LINE_LENGTH) {
	        cutLeft = column - OFFSET_CORRECTION + 3;
	        column = OFFSET_CORRECTION - 2;
	    }

	    for (var i = startLine; i <= endLine; i++) {
	        if (i >= 0 && i < lines.length) {
	            lines[i] = lines[i].replace(/\t/g, TAB_REPLACEMENT);
	            lines[i] =
	                (cutLeft > 0 && lines[i].length > cutLeft ? '\u2026' : '') +
	                lines[i].substr(cutLeft, MAX_LINE_LENGTH - 2) +
	                (lines[i].length > cutLeft + MAX_LINE_LENGTH - 1 ? '\u2026' : '');
	        }
	    }

	    return [
	        processLines(startLine, line),
	        new Array(column + maxNumLength + 2).join('-') + '^',
	        processLines(line, endLine)
	    ].filter(Boolean).join('\n');
	}

	var SyntaxError$1 = function(message, source, offset, line, column) {
	    var error = createCustomError('SyntaxError', message);

	    error.source = source;
	    error.offset = offset;
	    error.line = line;
	    error.column = column;

	    error.sourceFragment = function(extraLines) {
	        return sourceFragment(error, isNaN(extraLines) ? 0 : extraLines);
	    };
	    Object.defineProperty(error, 'formattedMessage', {
	        get: function() {
	            return (
	                'Parse error: ' + error.message + '\n' +
	                sourceFragment(error, 2)
	            );
	        }
	    });

	    // for backward capability
	    error.parseError = {
	        offset: offset,
	        line: line,
	        column: column
	    };

	    return error;
	};

	var _SyntaxError = SyntaxError$1;

	// CSS Syntax Module Level 3
	// https://www.w3.org/TR/css-syntax-3/
	var TYPE = {
	    EOF: 0,                 // <EOF-token>
	    Ident: 1,               // <ident-token>
	    Function: 2,            // <function-token>
	    AtKeyword: 3,           // <at-keyword-token>
	    Hash: 4,                // <hash-token>
	    String: 5,              // <string-token>
	    BadString: 6,           // <bad-string-token>
	    Url: 7,                 // <url-token>
	    BadUrl: 8,              // <bad-url-token>
	    Delim: 9,               // <delim-token>
	    Number: 10,             // <number-token>
	    Percentage: 11,         // <percentage-token>
	    Dimension: 12,          // <dimension-token>
	    WhiteSpace: 13,         // <whitespace-token>
	    CDO: 14,                // <CDO-token>
	    CDC: 15,                // <CDC-token>
	    Colon: 16,              // <colon-token>     :
	    Semicolon: 17,          // <semicolon-token> ;
	    Comma: 18,              // <comma-token>     ,
	    LeftSquareBracket: 19,  // <[-token>
	    RightSquareBracket: 20, // <]-token>
	    LeftParenthesis: 21,    // <(-token>
	    RightParenthesis: 22,   // <)-token>
	    LeftCurlyBracket: 23,   // <{-token>
	    RightCurlyBracket: 24,  // <}-token>
	    Comment: 25
	};

	var NAME = Object.keys(TYPE).reduce(function(result, key) {
	    result[TYPE[key]] = key;
	    return result;
	}, {});

	var _const = {
	    TYPE: TYPE,
	    NAME: NAME
	};

	var EOF = 0;

	// https://drafts.csswg.org/css-syntax-3/
	// § 4.2. Definitions

	// digit
	// A code point between U+0030 DIGIT ZERO (0) and U+0039 DIGIT NINE (9).
	function isDigit(code) {
	    return code >= 0x0030 && code <= 0x0039;
	}

	// hex digit
	// A digit, or a code point between U+0041 LATIN CAPITAL LETTER A (A) and U+0046 LATIN CAPITAL LETTER F (F),
	// or a code point between U+0061 LATIN SMALL LETTER A (a) and U+0066 LATIN SMALL LETTER F (f).
	function isHexDigit(code) {
	    return (
	        isDigit(code) || // 0 .. 9
	        (code >= 0x0041 && code <= 0x0046) || // A .. F
	        (code >= 0x0061 && code <= 0x0066)    // a .. f
	    );
	}

	// uppercase letter
	// A code point between U+0041 LATIN CAPITAL LETTER A (A) and U+005A LATIN CAPITAL LETTER Z (Z).
	function isUppercaseLetter(code) {
	    return code >= 0x0041 && code <= 0x005A;
	}

	// lowercase letter
	// A code point between U+0061 LATIN SMALL LETTER A (a) and U+007A LATIN SMALL LETTER Z (z).
	function isLowercaseLetter(code) {
	    return code >= 0x0061 && code <= 0x007A;
	}

	// letter
	// An uppercase letter or a lowercase letter.
	function isLetter(code) {
	    return isUppercaseLetter(code) || isLowercaseLetter(code);
	}

	// non-ASCII code point
	// A code point with a value equal to or greater than U+0080 <control>.
	function isNonAscii(code) {
	    return code >= 0x0080;
	}

	// name-start code point
	// A letter, a non-ASCII code point, or U+005F LOW LINE (_).
	function isNameStart(code) {
	    return isLetter(code) || isNonAscii(code) || code === 0x005F;
	}

	// name code point
	// A name-start code point, a digit, or U+002D HYPHEN-MINUS (-).
	function isName(code) {
	    return isNameStart(code) || isDigit(code) || code === 0x002D;
	}

	// non-printable code point
	// A code point between U+0000 NULL and U+0008 BACKSPACE, or U+000B LINE TABULATION,
	// or a code point between U+000E SHIFT OUT and U+001F INFORMATION SEPARATOR ONE, or U+007F DELETE.
	function isNonPrintable(code) {
	    return (
	        (code >= 0x0000 && code <= 0x0008) ||
	        (code === 0x000B) ||
	        (code >= 0x000E && code <= 0x001F) ||
	        (code === 0x007F)
	    );
	}

	// newline
	// U+000A LINE FEED. Note that U+000D CARRIAGE RETURN and U+000C FORM FEED are not included in this definition,
	// as they are converted to U+000A LINE FEED during preprocessing.
	// TODO: we doesn't do a preprocessing, so check a code point for U+000D CARRIAGE RETURN and U+000C FORM FEED
	function isNewline(code) {
	    return code === 0x000A || code === 0x000D || code === 0x000C;
	}

	// whitespace
	// A newline, U+0009 CHARACTER TABULATION, or U+0020 SPACE.
	function isWhiteSpace(code) {
	    return isNewline(code) || code === 0x0020 || code === 0x0009;
	}

	// § 4.3.8. Check if two code points are a valid escape
	function isValidEscape(first, second) {
	    // If the first code point is not U+005C REVERSE SOLIDUS (\), return false.
	    if (first !== 0x005C) {
	        return false;
	    }

	    // Otherwise, if the second code point is a newline or EOF, return false.
	    if (isNewline(second) || second === EOF) {
	        return false;
	    }

	    // Otherwise, return true.
	    return true;
	}

	// § 4.3.9. Check if three code points would start an identifier
	function isIdentifierStart(first, second, third) {
	    // Look at the first code point:

	    // U+002D HYPHEN-MINUS
	    if (first === 0x002D) {
	        // If the second code point is a name-start code point or a U+002D HYPHEN-MINUS,
	        // or the second and third code points are a valid escape, return true. Otherwise, return false.
	        return (
	            isNameStart(second) ||
	            second === 0x002D ||
	            isValidEscape(second, third)
	        );
	    }

	    // name-start code point
	    if (isNameStart(first)) {
	        // Return true.
	        return true;
	    }

	    // U+005C REVERSE SOLIDUS (\)
	    if (first === 0x005C) {
	        // If the first and second code points are a valid escape, return true. Otherwise, return false.
	        return isValidEscape(first, second);
	    }

	    // anything else
	    // Return false.
	    return false;
	}

	// § 4.3.10. Check if three code points would start a number
	function isNumberStart(first, second, third) {
	    // Look at the first code point:

	    // U+002B PLUS SIGN (+)
	    // U+002D HYPHEN-MINUS (-)
	    if (first === 0x002B || first === 0x002D) {
	        // If the second code point is a digit, return true.
	        if (isDigit(second)) {
	            return 2;
	        }

	        // Otherwise, if the second code point is a U+002E FULL STOP (.)
	        // and the third code point is a digit, return true.
	        // Otherwise, return false.
	        return second === 0x002E && isDigit(third) ? 3 : 0;
	    }

	    // U+002E FULL STOP (.)
	    if (first === 0x002E) {
	        // If the second code point is a digit, return true. Otherwise, return false.
	        return isDigit(second) ? 2 : 0;
	    }

	    // digit
	    if (isDigit(first)) {
	        // Return true.
	        return 1;
	    }

	    // anything else
	    // Return false.
	    return 0;
	}

	//
	// Misc
	//

	// detect BOM (https://en.wikipedia.org/wiki/Byte_order_mark)
	function isBOM(code) {
	    // UTF-16BE
	    if (code === 0xFEFF) {
	        return 1;
	    }

	    // UTF-16LE
	    if (code === 0xFFFE) {
	        return 1;
	    }

	    return 0;
	}

	// Fast code category
	//
	// https://drafts.csswg.org/css-syntax/#tokenizer-definitions
	// > non-ASCII code point
	// >   A code point with a value equal to or greater than U+0080 <control>
	// > name-start code point
	// >   A letter, a non-ASCII code point, or U+005F LOW LINE (_).
	// > name code point
	// >   A name-start code point, a digit, or U+002D HYPHEN-MINUS (-)
	// That means only ASCII code points has a special meaning and we define a maps for 0..127 codes only
	var CATEGORY = new Array(0x80);
	charCodeCategory.Eof = 0x80;
	charCodeCategory.WhiteSpace = 0x82;
	charCodeCategory.Digit = 0x83;
	charCodeCategory.NameStart = 0x84;
	charCodeCategory.NonPrintable = 0x85;

	for (var i = 0; i < CATEGORY.length; i++) {
	    switch (true) {
	        case isWhiteSpace(i):
	            CATEGORY[i] = charCodeCategory.WhiteSpace;
	            break;

	        case isDigit(i):
	            CATEGORY[i] = charCodeCategory.Digit;
	            break;

	        case isNameStart(i):
	            CATEGORY[i] = charCodeCategory.NameStart;
	            break;

	        case isNonPrintable(i):
	            CATEGORY[i] = charCodeCategory.NonPrintable;
	            break;

	        default:
	            CATEGORY[i] = i || charCodeCategory.Eof;
	    }
	}

	function charCodeCategory(code) {
	    return code < 0x80 ? CATEGORY[code] : charCodeCategory.NameStart;
	}
	var charCodeDefinitions = {
	    isDigit: isDigit,
	    isHexDigit: isHexDigit,
	    isUppercaseLetter: isUppercaseLetter,
	    isLowercaseLetter: isLowercaseLetter,
	    isLetter: isLetter,
	    isNonAscii: isNonAscii,
	    isNameStart: isNameStart,
	    isName: isName,
	    isNonPrintable: isNonPrintable,
	    isNewline: isNewline,
	    isWhiteSpace: isWhiteSpace,
	    isValidEscape: isValidEscape,
	    isIdentifierStart: isIdentifierStart,
	    isNumberStart: isNumberStart,

	    isBOM: isBOM,
	    charCodeCategory: charCodeCategory
	};

	var isDigit$1 = charCodeDefinitions.isDigit;
	var isHexDigit$1 = charCodeDefinitions.isHexDigit;
	var isUppercaseLetter$1 = charCodeDefinitions.isUppercaseLetter;
	var isName$1 = charCodeDefinitions.isName;
	var isWhiteSpace$1 = charCodeDefinitions.isWhiteSpace;
	var isValidEscape$1 = charCodeDefinitions.isValidEscape;

	function getCharCode(source, offset) {
	    return offset < source.length ? source.charCodeAt(offset) : 0;
	}

	function getNewlineLength(source, offset, code) {
	    if (code === 13 /* \r */ && getCharCode(source, offset + 1) === 10 /* \n */) {
	        return 2;
	    }

	    return 1;
	}

	function cmpChar(testStr, offset, referenceCode) {
	    var code = testStr.charCodeAt(offset);

	    // code.toLowerCase() for A..Z
	    if (isUppercaseLetter$1(code)) {
	        code = code | 32;
	    }

	    return code === referenceCode;
	}

	function cmpStr(testStr, start, end, referenceStr) {
	    if (end - start !== referenceStr.length) {
	        return false;
	    }

	    if (start < 0 || end > testStr.length) {
	        return false;
	    }

	    for (var i = start; i < end; i++) {
	        var testCode = testStr.charCodeAt(i);
	        var referenceCode = referenceStr.charCodeAt(i - start);

	        // testCode.toLowerCase() for A..Z
	        if (isUppercaseLetter$1(testCode)) {
	            testCode = testCode | 32;
	        }

	        if (testCode !== referenceCode) {
	            return false;
	        }
	    }

	    return true;
	}

	function findWhiteSpaceStart(source, offset) {
	    for (; offset >= 0; offset--) {
	        if (!isWhiteSpace$1(source.charCodeAt(offset))) {
	            break;
	        }
	    }

	    return offset + 1;
	}

	function findWhiteSpaceEnd(source, offset) {
	    for (; offset < source.length; offset++) {
	        if (!isWhiteSpace$1(source.charCodeAt(offset))) {
	            break;
	        }
	    }

	    return offset;
	}

	function findDecimalNumberEnd(source, offset) {
	    for (; offset < source.length; offset++) {
	        if (!isDigit$1(source.charCodeAt(offset))) {
	            break;
	        }
	    }

	    return offset;
	}

	// § 4.3.7. Consume an escaped code point
	function consumeEscaped(source, offset) {
	    // It assumes that the U+005C REVERSE SOLIDUS (\) has already been consumed and
	    // that the next input code point has already been verified to be part of a valid escape.
	    offset += 2;

	    // hex digit
	    if (isHexDigit$1(getCharCode(source, offset - 1))) {
	        // Consume as many hex digits as possible, but no more than 5.
	        // Note that this means 1-6 hex digits have been consumed in total.
	        for (var maxOffset = Math.min(source.length, offset + 5); offset < maxOffset; offset++) {
	            if (!isHexDigit$1(getCharCode(source, offset))) {
	                break;
	            }
	        }

	        // If the next input code point is whitespace, consume it as well.
	        var code = getCharCode(source, offset);
	        if (isWhiteSpace$1(code)) {
	            offset += getNewlineLength(source, offset, code);
	        }
	    }

	    return offset;
	}

	// §4.3.11. Consume a name
	// Note: This algorithm does not do the verification of the first few code points that are necessary
	// to ensure the returned code points would constitute an <ident-token>. If that is the intended use,
	// ensure that the stream starts with an identifier before calling this algorithm.
	function consumeName(source, offset) {
	    // Let result initially be an empty string.
	    // Repeatedly consume the next input code point from the stream:
	    for (; offset < source.length; offset++) {
	        var code = source.charCodeAt(offset);

	        // name code point
	        if (isName$1(code)) {
	            // Append the code point to result.
	            continue;
	        }

	        // the stream starts with a valid escape
	        if (isValidEscape$1(code, getCharCode(source, offset + 1))) {
	            // Consume an escaped code point. Append the returned code point to result.
	            offset = consumeEscaped(source, offset) - 1;
	            continue;
	        }

	        // anything else
	        // Reconsume the current input code point. Return result.
	        break;
	    }

	    return offset;
	}

	// §4.3.12. Consume a number
	function consumeNumber(source, offset) {
	    var code = source.charCodeAt(offset);

	    // 2. If the next input code point is U+002B PLUS SIGN (+) or U+002D HYPHEN-MINUS (-),
	    // consume it and append it to repr.
	    if (code === 0x002B || code === 0x002D) {
	        code = source.charCodeAt(offset += 1);
	    }

	    // 3. While the next input code point is a digit, consume it and append it to repr.
	    if (isDigit$1(code)) {
	        offset = findDecimalNumberEnd(source, offset + 1);
	        code = source.charCodeAt(offset);
	    }

	    // 4. If the next 2 input code points are U+002E FULL STOP (.) followed by a digit, then:
	    if (code === 0x002E && isDigit$1(source.charCodeAt(offset + 1))) {
	        // 4.1 Consume them.
	        // 4.2 Append them to repr.
	        code = source.charCodeAt(offset += 2);

	        // 4.3 Set type to "number".
	        // TODO

	        // 4.4 While the next input code point is a digit, consume it and append it to repr.

	        offset = findDecimalNumberEnd(source, offset);
	    }

	    // 5. If the next 2 or 3 input code points are U+0045 LATIN CAPITAL LETTER E (E)
	    // or U+0065 LATIN SMALL LETTER E (e), ... , followed by a digit, then:
	    if (cmpChar(source, offset, 101 /* e */)) {
	        var sign = 0;
	        code = source.charCodeAt(offset + 1);

	        // ... optionally followed by U+002D HYPHEN-MINUS (-) or U+002B PLUS SIGN (+) ...
	        if (code === 0x002D || code === 0x002B) {
	            sign = 1;
	            code = source.charCodeAt(offset + 2);
	        }

	        // ... followed by a digit
	        if (isDigit$1(code)) {
	            // 5.1 Consume them.
	            // 5.2 Append them to repr.

	            // 5.3 Set type to "number".
	            // TODO

	            // 5.4 While the next input code point is a digit, consume it and append it to repr.
	            offset = findDecimalNumberEnd(source, offset + 1 + sign + 1);
	        }
	    }

	    return offset;
	}

	// § 4.3.14. Consume the remnants of a bad url
	// ... its sole use is to consume enough of the input stream to reach a recovery point
	// where normal tokenizing can resume.
	function consumeBadUrlRemnants(source, offset) {
	    // Repeatedly consume the next input code point from the stream:
	    for (; offset < source.length; offset++) {
	        var code = source.charCodeAt(offset);

	        // U+0029 RIGHT PARENTHESIS ())
	        // EOF
	        if (code === 0x0029) {
	            // Return.
	            offset++;
	            break;
	        }

	        if (isValidEscape$1(code, getCharCode(source, offset + 1))) {
	            // Consume an escaped code point.
	            // Note: This allows an escaped right parenthesis ("\)") to be encountered
	            // without ending the <bad-url-token>. This is otherwise identical to
	            // the "anything else" clause.
	            offset = consumeEscaped(source, offset);
	        }
	    }

	    return offset;
	}

	var utils = {
	    consumeEscaped: consumeEscaped,
	    consumeName: consumeName,
	    consumeNumber: consumeNumber,
	    consumeBadUrlRemnants: consumeBadUrlRemnants,

	    cmpChar: cmpChar,
	    cmpStr: cmpStr,

	    getNewlineLength: getNewlineLength,
	    findWhiteSpaceStart: findWhiteSpaceStart,
	    findWhiteSpaceEnd: findWhiteSpaceEnd
	};

	var TYPE$1 = _const.TYPE;
	var NAME$1 = _const.NAME;


	var cmpStr$1 = utils.cmpStr;

	var EOF$1 = TYPE$1.EOF;
	var WHITESPACE = TYPE$1.WhiteSpace;
	var COMMENT = TYPE$1.Comment;

	var OFFSET_MASK = 0x00FFFFFF;
	var TYPE_SHIFT = 24;

	var TokenStream = function() {
	    this.offsetAndType = null;
	    this.balance = null;

	    this.reset();
	};

	TokenStream.prototype = {
	    reset: function() {
	        this.eof = false;
	        this.tokenIndex = -1;
	        this.tokenType = 0;
	        this.tokenStart = this.firstCharOffset;
	        this.tokenEnd = this.firstCharOffset;
	    },

	    lookupType: function(offset) {
	        offset += this.tokenIndex;

	        if (offset < this.tokenCount) {
	            return this.offsetAndType[offset] >> TYPE_SHIFT;
	        }

	        return EOF$1;
	    },
	    lookupOffset: function(offset) {
	        offset += this.tokenIndex;

	        if (offset < this.tokenCount) {
	            return this.offsetAndType[offset - 1] & OFFSET_MASK;
	        }

	        return this.source.length;
	    },
	    lookupValue: function(offset, referenceStr) {
	        offset += this.tokenIndex;

	        if (offset < this.tokenCount) {
	            return cmpStr$1(
	                this.source,
	                this.offsetAndType[offset - 1] & OFFSET_MASK,
	                this.offsetAndType[offset] & OFFSET_MASK,
	                referenceStr
	            );
	        }

	        return false;
	    },
	    getTokenStart: function(tokenIndex) {
	        if (tokenIndex === this.tokenIndex) {
	            return this.tokenStart;
	        }

	        if (tokenIndex > 0) {
	            return tokenIndex < this.tokenCount
	                ? this.offsetAndType[tokenIndex - 1] & OFFSET_MASK
	                : this.offsetAndType[this.tokenCount] & OFFSET_MASK;
	        }

	        return this.firstCharOffset;
	    },

	    // TODO: -> skipUntilBalanced
	    getRawLength: function(startToken, mode) {
	        var cursor = startToken;
	        var balanceEnd;
	        var offset = this.offsetAndType[Math.max(cursor - 1, 0)] & OFFSET_MASK;
	        var type;

	        loop:
	        for (; cursor < this.tokenCount; cursor++) {
	            balanceEnd = this.balance[cursor];

	            // stop scanning on balance edge that points to offset before start token
	            if (balanceEnd < startToken) {
	                break loop;
	            }

	            type = this.offsetAndType[cursor] >> TYPE_SHIFT;

	            // check token is stop type
	            switch (mode(type, this.source, offset)) {
	                case 1:
	                    break loop;

	                case 2:
	                    cursor++;
	                    break loop;

	                default:
	                    offset = this.offsetAndType[cursor] & OFFSET_MASK;

	                    // fast forward to the end of balanced block
	                    if (this.balance[balanceEnd] === cursor) {
	                        cursor = balanceEnd;
	                    }
	            }
	        }

	        return cursor - this.tokenIndex;
	    },
	    isBalanceEdge: function(pos) {
	        return this.balance[this.tokenIndex] < pos;
	    },
	    isDelim: function(code, offset) {
	        if (offset) {
	            return (
	                this.lookupType(offset) === TYPE$1.Delim &&
	                this.source.charCodeAt(this.lookupOffset(offset)) === code
	            );
	        }

	        return (
	            this.tokenType === TYPE$1.Delim &&
	            this.source.charCodeAt(this.tokenStart) === code
	        );
	    },

	    getTokenValue: function() {
	        return this.source.substring(this.tokenStart, this.tokenEnd);
	    },
	    getTokenLength: function() {
	        return this.tokenEnd - this.tokenStart;
	    },
	    substrToCursor: function(start) {
	        return this.source.substring(start, this.tokenStart);
	    },

	    skipWS: function() {
	        for (var i = this.tokenIndex, skipTokenCount = 0; i < this.tokenCount; i++, skipTokenCount++) {
	            if ((this.offsetAndType[i] >> TYPE_SHIFT) !== WHITESPACE) {
	                break;
	            }
	        }

	        if (skipTokenCount > 0) {
	            this.skip(skipTokenCount);
	        }
	    },
	    skipSC: function() {
	        while (this.tokenType === WHITESPACE || this.tokenType === COMMENT) {
	            this.next();
	        }
	    },
	    skip: function(tokenCount) {
	        var next = this.tokenIndex + tokenCount;

	        if (next < this.tokenCount) {
	            this.tokenIndex = next;
	            this.tokenStart = this.offsetAndType[next - 1] & OFFSET_MASK;
	            next = this.offsetAndType[next];
	            this.tokenType = next >> TYPE_SHIFT;
	            this.tokenEnd = next & OFFSET_MASK;
	        } else {
	            this.tokenIndex = this.tokenCount;
	            this.next();
	        }
	    },
	    next: function() {
	        var next = this.tokenIndex + 1;

	        if (next < this.tokenCount) {
	            this.tokenIndex = next;
	            this.tokenStart = this.tokenEnd;
	            next = this.offsetAndType[next];
	            this.tokenType = next >> TYPE_SHIFT;
	            this.tokenEnd = next & OFFSET_MASK;
	        } else {
	            this.tokenIndex = this.tokenCount;
	            this.eof = true;
	            this.tokenType = EOF$1;
	            this.tokenStart = this.tokenEnd = this.source.length;
	        }
	    },

	    dump: function() {
	        var offset = this.firstCharOffset;

	        return Array.prototype.slice.call(this.offsetAndType, 0, this.tokenCount).map(function(item, idx) {
	            var start = offset;
	            var end = item & OFFSET_MASK;

	            offset = end;

	            return {
	                idx: idx,
	                type: NAME$1[item >> TYPE_SHIFT],
	                chunk: this.source.substring(start, end),
	                balance: this.balance[idx]
	            };
	        }, this);
	    }
	};

	var TokenStream_1 = TokenStream;

	function noop$1(value) {
	    return value;
	}

	function generateMultiplier(multiplier) {
	    if (multiplier.min === 0 && multiplier.max === 0) {
	        return '*';
	    }

	    if (multiplier.min === 0 && multiplier.max === 1) {
	        return '?';
	    }

	    if (multiplier.min === 1 && multiplier.max === 0) {
	        return multiplier.comma ? '#' : '+';
	    }

	    if (multiplier.min === 1 && multiplier.max === 1) {
	        return '';
	    }

	    return (
	        (multiplier.comma ? '#' : '') +
	        (multiplier.min === multiplier.max
	            ? '{' + multiplier.min + '}'
	            : '{' + multiplier.min + ',' + (multiplier.max !== 0 ? multiplier.max : '') + '}'
	        )
	    );
	}

	function generateTypeOpts(node) {
	    switch (node.type) {
	        case 'Range':
	            return (
	                ' [' +
	                (node.min === null ? '-∞' : node.min) +
	                ',' +
	                (node.max === null ? '∞' : node.max) +
	                ']'
	            );

	        default:
	            throw new Error('Unknown node type `' + node.type + '`');
	    }
	}

	function generateSequence(node, decorate, forceBraces, compact) {
	    var combinator = node.combinator === ' ' || compact ? node.combinator : ' ' + node.combinator + ' ';
	    var result = node.terms.map(function(term) {
	        return generate(term, decorate, forceBraces, compact);
	    }).join(combinator);

	    if (node.explicit || forceBraces) {
	        result = (compact || result[0] === ',' ? '[' : '[ ') + result + (compact ? ']' : ' ]');
	    }

	    return result;
	}

	function generate(node, decorate, forceBraces, compact) {
	    var result;

	    switch (node.type) {
	        case 'Group':
	            result =
	                generateSequence(node, decorate, forceBraces, compact) +
	                (node.disallowEmpty ? '!' : '');
	            break;

	        case 'Multiplier':
	            // return since node is a composition
	            return (
	                generate(node.term, decorate, forceBraces, compact) +
	                decorate(generateMultiplier(node), node)
	            );

	        case 'Type':
	            result = '<' + node.name + (node.opts ? decorate(generateTypeOpts(node.opts), node.opts) : '') + '>';
	            break;

	        case 'Property':
	            result = '<\'' + node.name + '\'>';
	            break;

	        case 'Keyword':
	            result = node.name;
	            break;

	        case 'AtKeyword':
	            result = '@' + node.name;
	            break;

	        case 'Function':
	            result = node.name + '(';
	            break;

	        case 'String':
	        case 'Token':
	            result = node.value;
	            break;

	        case 'Comma':
	            result = ',';
	            break;

	        default:
	            throw new Error('Unknown node type `' + node.type + '`');
	    }

	    return decorate(result, node);
	}

	var generate_1 = function(node, options) {
	    var decorate = noop$1;
	    var forceBraces = false;
	    var compact = false;

	    if (typeof options === 'function') {
	        decorate = options;
	    } else if (options) {
	        forceBraces = Boolean(options.forceBraces);
	        compact = Boolean(options.compact);
	        if (typeof options.decorate === 'function') {
	            decorate = options.decorate;
	        }
	    }

	    return generate(node, decorate, forceBraces, compact);
	};

	function fromMatchResult(matchResult) {
	    var tokens = matchResult.tokens;
	    var longestMatch = matchResult.longestMatch;
	    var node = longestMatch < tokens.length ? tokens[longestMatch].node : null;
	    var mismatchOffset = -1;
	    var entries = 0;
	    var css = '';

	    for (var i = 0; i < tokens.length; i++) {
	        if (i === longestMatch) {
	            mismatchOffset = css.length;
	        }

	        if (node !== null && tokens[i].node === node) {
	            if (i <= longestMatch) {
	                entries++;
	            } else {
	                entries = 0;
	            }
	        }

	        css += tokens[i].value;
	    }

	    return {
	        node: node,
	        css: css,
	        mismatchOffset: mismatchOffset === -1 ? css.length : mismatchOffset,
	        last: node === null || entries > 1
	    };
	}

	function getLocation(node, point) {
	    var loc = node && node.loc && node.loc[point];

	    if (loc) {
	        return {
	            offset: loc.offset,
	            line: loc.line,
	            column: loc.column
	        };
	    }

	    return null;
	}

	var SyntaxReferenceError = function(type, referenceName) {
	    var error = createCustomError(
	        'SyntaxReferenceError',
	        type + (referenceName ? ' `' + referenceName + '`' : '')
	    );

	    error.reference = referenceName;

	    return error;
	};

	var MatchError = function(message, syntax, node, matchResult) {
	    var error = createCustomError('SyntaxMatchError', message);
	    var details = fromMatchResult(matchResult);
	    var mismatchOffset = details.mismatchOffset || 0;
	    var badNode = details.node || node;
	    var end = getLocation(badNode, 'end');
	    var start = details.last ? end : getLocation(badNode, 'start');
	    var css = details.css;

	    error.rawMessage = message;
	    error.syntax = syntax ? generate_1(syntax) : '<generic>';
	    error.css = css;
	    error.mismatchOffset = mismatchOffset;
	    error.loc = {
	        source: (badNode && badNode.loc && badNode.loc.source) || '<unknown>',
	        start: start,
	        end: end
	    };
	    error.line = start ? start.line : undefined;
	    error.column = start ? start.column : undefined;
	    error.offset = start ? start.offset : undefined;
	    error.message = message + '\n' +
	        '  syntax: ' + error.syntax + '\n' +
	        '   value: ' + (error.css || '<empty string>') + '\n' +
	        '  --------' + new Array(error.mismatchOffset + 1).join('-') + '^';

	    return error;
	};

	var error = {
	    SyntaxReferenceError: SyntaxReferenceError,
	    MatchError: MatchError
	};

	var hasOwnProperty = Object.prototype.hasOwnProperty;
	var keywords = Object.create(null);
	var properties = Object.create(null);
	var HYPHENMINUS = 45; // '-'.charCodeAt()

	function isCustomProperty(str, offset) {
	    offset = offset || 0;

	    return str.length - offset >= 2 &&
	           str.charCodeAt(offset) === HYPHENMINUS &&
	           str.charCodeAt(offset + 1) === HYPHENMINUS;
	}

	function getVendorPrefix(str, offset) {
	    offset = offset || 0;

	    // verdor prefix should be at least 3 chars length
	    if (str.length - offset >= 3) {
	        // vendor prefix starts with hyper minus following non-hyper minus
	        if (str.charCodeAt(offset) === HYPHENMINUS &&
	            str.charCodeAt(offset + 1) !== HYPHENMINUS) {
	            // vendor prefix should contain a hyper minus at the ending
	            var secondDashIndex = str.indexOf('-', offset + 2);

	            if (secondDashIndex !== -1) {
	                return str.substring(offset, secondDashIndex + 1);
	            }
	        }
	    }

	    return '';
	}

	function getKeywordDescriptor(keyword) {
	    if (hasOwnProperty.call(keywords, keyword)) {
	        return keywords[keyword];
	    }

	    var name = keyword.toLowerCase();

	    if (hasOwnProperty.call(keywords, name)) {
	        return keywords[keyword] = keywords[name];
	    }

	    var custom = isCustomProperty(name, 0);
	    var vendor = !custom ? getVendorPrefix(name, 0) : '';

	    return keywords[keyword] = Object.freeze({
	        basename: name.substr(vendor.length),
	        name: name,
	        vendor: vendor,
	        prefix: vendor,
	        custom: custom
	    });
	}

	function getPropertyDescriptor(property) {
	    if (hasOwnProperty.call(properties, property)) {
	        return properties[property];
	    }

	    var name = property;
	    var hack = property[0];

	    if (hack === '/') {
	        hack = property[1] === '/' ? '//' : '/';
	    } else if (hack !== '_' &&
	               hack !== '*' &&
	               hack !== '$' &&
	               hack !== '#' &&
	               hack !== '+' &&
	               hack !== '&') {
	        hack = '';
	    }

	    var custom = isCustomProperty(name, hack.length);

	    // re-use result when possible (the same as for lower case)
	    if (!custom) {
	        name = name.toLowerCase();
	        if (hasOwnProperty.call(properties, name)) {
	            return properties[property] = properties[name];
	        }
	    }

	    var vendor = !custom ? getVendorPrefix(name, hack.length) : '';
	    var prefix = name.substr(0, hack.length + vendor.length);

	    return properties[property] = Object.freeze({
	        basename: name.substr(prefix.length),
	        name: name.substr(hack.length),
	        hack: hack,
	        vendor: vendor,
	        prefix: prefix,
	        custom: custom
	    });
	}

	var names = {
	    keyword: getKeywordDescriptor,
	    property: getPropertyDescriptor,
	    isCustomProperty: isCustomProperty,
	    vendorPrefix: getVendorPrefix
	};

	var MIN_SIZE = 16 * 1024;
	var SafeUint32Array = typeof Uint32Array !== 'undefined' ? Uint32Array : Array; // fallback on Array when TypedArray is not supported

	var adoptBuffer = function adoptBuffer(buffer, size) {
	    if (buffer === null || buffer.length < size) {
	        return new SafeUint32Array(Math.max(size + 1024, MIN_SIZE));
	    }

	    return buffer;
	};

	var TYPE$2 = _const.TYPE;


	var isNewline$1 = charCodeDefinitions.isNewline;
	var isName$2 = charCodeDefinitions.isName;
	var isValidEscape$2 = charCodeDefinitions.isValidEscape;
	var isNumberStart$1 = charCodeDefinitions.isNumberStart;
	var isIdentifierStart$1 = charCodeDefinitions.isIdentifierStart;
	var charCodeCategory$1 = charCodeDefinitions.charCodeCategory;
	var isBOM$1 = charCodeDefinitions.isBOM;


	var cmpStr$2 = utils.cmpStr;
	var getNewlineLength$1 = utils.getNewlineLength;
	var findWhiteSpaceEnd$1 = utils.findWhiteSpaceEnd;
	var consumeEscaped$1 = utils.consumeEscaped;
	var consumeName$1 = utils.consumeName;
	var consumeNumber$1 = utils.consumeNumber;
	var consumeBadUrlRemnants$1 = utils.consumeBadUrlRemnants;

	var OFFSET_MASK$1 = 0x00FFFFFF;
	var TYPE_SHIFT$1 = 24;

	function tokenize(source, stream) {
	    function getCharCode(offset) {
	        return offset < sourceLength ? source.charCodeAt(offset) : 0;
	    }

	    // § 4.3.3. Consume a numeric token
	    function consumeNumericToken() {
	        // Consume a number and let number be the result.
	        offset = consumeNumber$1(source, offset);

	        // If the next 3 input code points would start an identifier, then:
	        if (isIdentifierStart$1(getCharCode(offset), getCharCode(offset + 1), getCharCode(offset + 2))) {
	            // Create a <dimension-token> with the same value and type flag as number, and a unit set initially to the empty string.
	            // Consume a name. Set the <dimension-token>’s unit to the returned value.
	            // Return the <dimension-token>.
	            type = TYPE$2.Dimension;
	            offset = consumeName$1(source, offset);
	            return;
	        }

	        // Otherwise, if the next input code point is U+0025 PERCENTAGE SIGN (%), consume it.
	        if (getCharCode(offset) === 0x0025) {
	            // Create a <percentage-token> with the same value as number, and return it.
	            type = TYPE$2.Percentage;
	            offset++;
	            return;
	        }

	        // Otherwise, create a <number-token> with the same value and type flag as number, and return it.
	        type = TYPE$2.Number;
	    }

	    // § 4.3.4. Consume an ident-like token
	    function consumeIdentLikeToken() {
	        const nameStartOffset = offset;

	        // Consume a name, and let string be the result.
	        offset = consumeName$1(source, offset);

	        // If string’s value is an ASCII case-insensitive match for "url",
	        // and the next input code point is U+0028 LEFT PARENTHESIS ((), consume it.
	        if (cmpStr$2(source, nameStartOffset, offset, 'url') && getCharCode(offset) === 0x0028) {
	            // While the next two input code points are whitespace, consume the next input code point.
	            offset = findWhiteSpaceEnd$1(source, offset + 1);

	            // If the next one or two input code points are U+0022 QUOTATION MARK ("), U+0027 APOSTROPHE ('),
	            // or whitespace followed by U+0022 QUOTATION MARK (") or U+0027 APOSTROPHE ('),
	            // then create a <function-token> with its value set to string and return it.
	            if (getCharCode(offset) === 0x0022 ||
	                getCharCode(offset) === 0x0027) {
	                type = TYPE$2.Function;
	                offset = nameStartOffset + 4;
	                return;
	            }

	            // Otherwise, consume a url token, and return it.
	            consumeUrlToken();
	            return;
	        }

	        // Otherwise, if the next input code point is U+0028 LEFT PARENTHESIS ((), consume it.
	        // Create a <function-token> with its value set to string and return it.
	        if (getCharCode(offset) === 0x0028) {
	            type = TYPE$2.Function;
	            offset++;
	            return;
	        }

	        // Otherwise, create an <ident-token> with its value set to string and return it.
	        type = TYPE$2.Ident;
	    }

	    // § 4.3.5. Consume a string token
	    function consumeStringToken(endingCodePoint) {
	        // This algorithm may be called with an ending code point, which denotes the code point
	        // that ends the string. If an ending code point is not specified,
	        // the current input code point is used.
	        if (!endingCodePoint) {
	            endingCodePoint = getCharCode(offset++);
	        }

	        // Initially create a <string-token> with its value set to the empty string.
	        type = TYPE$2.String;

	        // Repeatedly consume the next input code point from the stream:
	        for (; offset < source.length; offset++) {
	            var code = source.charCodeAt(offset);

	            switch (charCodeCategory$1(code)) {
	                // ending code point
	                case endingCodePoint:
	                    // Return the <string-token>.
	                    offset++;
	                    return;

	                // EOF
	                case charCodeCategory$1.Eof:
	                    // This is a parse error. Return the <string-token>.
	                    return;

	                // newline
	                case charCodeCategory$1.WhiteSpace:
	                    if (isNewline$1(code)) {
	                        // This is a parse error. Reconsume the current input code point,
	                        // create a <bad-string-token>, and return it.
	                        offset += getNewlineLength$1(source, offset, code);
	                        type = TYPE$2.BadString;
	                        return;
	                    }
	                    break;

	                // U+005C REVERSE SOLIDUS (\)
	                case 0x005C:
	                    // If the next input code point is EOF, do nothing.
	                    if (offset === source.length - 1) {
	                        break;
	                    }

	                    var nextCode = getCharCode(offset + 1);

	                    // Otherwise, if the next input code point is a newline, consume it.
	                    if (isNewline$1(nextCode)) {
	                        offset += getNewlineLength$1(source, offset + 1, nextCode);
	                    } else if (isValidEscape$2(code, nextCode)) {
	                        // Otherwise, (the stream starts with a valid escape) consume
	                        // an escaped code point and append the returned code point to
	                        // the <string-token>’s value.
	                        offset = consumeEscaped$1(source, offset) - 1;
	                    }
	                    break;

	                // anything else
	                // Append the current input code point to the <string-token>’s value.
	            }
	        }
	    }

	    // § 4.3.6. Consume a url token
	    // Note: This algorithm assumes that the initial "url(" has already been consumed.
	    // This algorithm also assumes that it’s being called to consume an "unquoted" value, like url(foo).
	    // A quoted value, like url("foo"), is parsed as a <function-token>. Consume an ident-like token
	    // automatically handles this distinction; this algorithm shouldn’t be called directly otherwise.
	    function consumeUrlToken() {
	        // Initially create a <url-token> with its value set to the empty string.
	        type = TYPE$2.Url;

	        // Consume as much whitespace as possible.
	        offset = findWhiteSpaceEnd$1(source, offset);

	        // Repeatedly consume the next input code point from the stream:
	        for (; offset < source.length; offset++) {
	            var code = source.charCodeAt(offset);

	            switch (charCodeCategory$1(code)) {
	                // U+0029 RIGHT PARENTHESIS ())
	                case 0x0029:
	                    // Return the <url-token>.
	                    offset++;
	                    return;

	                // EOF
	                case charCodeCategory$1.Eof:
	                    // This is a parse error. Return the <url-token>.
	                    return;

	                // whitespace
	                case charCodeCategory$1.WhiteSpace:
	                    // Consume as much whitespace as possible.
	                    offset = findWhiteSpaceEnd$1(source, offset);

	                    // If the next input code point is U+0029 RIGHT PARENTHESIS ()) or EOF,
	                    // consume it and return the <url-token>
	                    // (if EOF was encountered, this is a parse error);
	                    if (getCharCode(offset) === 0x0029 || offset >= source.length) {
	                        if (offset < source.length) {
	                            offset++;
	                        }
	                        return;
	                    }

	                    // otherwise, consume the remnants of a bad url, create a <bad-url-token>,
	                    // and return it.
	                    offset = consumeBadUrlRemnants$1(source, offset);
	                    type = TYPE$2.BadUrl;
	                    return;

	                // U+0022 QUOTATION MARK (")
	                // U+0027 APOSTROPHE (')
	                // U+0028 LEFT PARENTHESIS (()
	                // non-printable code point
	                case 0x0022:
	                case 0x0027:
	                case 0x0028:
	                case charCodeCategory$1.NonPrintable:
	                    // This is a parse error. Consume the remnants of a bad url,
	                    // create a <bad-url-token>, and return it.
	                    offset = consumeBadUrlRemnants$1(source, offset);
	                    type = TYPE$2.BadUrl;
	                    return;

	                // U+005C REVERSE SOLIDUS (\)
	                case 0x005C:
	                    // If the stream starts with a valid escape, consume an escaped code point and
	                    // append the returned code point to the <url-token>’s value.
	                    if (isValidEscape$2(code, getCharCode(offset + 1))) {
	                        offset = consumeEscaped$1(source, offset) - 1;
	                        break;
	                    }

	                    // Otherwise, this is a parse error. Consume the remnants of a bad url,
	                    // create a <bad-url-token>, and return it.
	                    offset = consumeBadUrlRemnants$1(source, offset);
	                    type = TYPE$2.BadUrl;
	                    return;

	                // anything else
	                // Append the current input code point to the <url-token>’s value.
	            }
	        }
	    }

	    if (!stream) {
	        stream = new TokenStream_1();
	    }

	    // ensure source is a string
	    source = String(source || '');

	    var sourceLength = source.length;
	    var offsetAndType = adoptBuffer(stream.offsetAndType, sourceLength + 1); // +1 because of eof-token
	    var balance = adoptBuffer(stream.balance, sourceLength + 1);
	    var tokenCount = 0;
	    var start = isBOM$1(getCharCode(0));
	    var offset = start;
	    var balanceCloseType = 0;
	    var balanceStart = 0;
	    var balancePrev = 0;

	    // https://drafts.csswg.org/css-syntax-3/#consume-token
	    // § 4.3.1. Consume a token
	    while (offset < sourceLength) {
	        var code = source.charCodeAt(offset);
	        var type = 0;

	        balance[tokenCount] = sourceLength;

	        switch (charCodeCategory$1(code)) {
	            // whitespace
	            case charCodeCategory$1.WhiteSpace:
	                // Consume as much whitespace as possible. Return a <whitespace-token>.
	                type = TYPE$2.WhiteSpace;
	                offset = findWhiteSpaceEnd$1(source, offset + 1);
	                break;

	            // U+0022 QUOTATION MARK (")
	            case 0x0022:
	                // Consume a string token and return it.
	                consumeStringToken();
	                break;

	            // U+0023 NUMBER SIGN (#)
	            case 0x0023:
	                // If the next input code point is a name code point or the next two input code points are a valid escape, then:
	                if (isName$2(getCharCode(offset + 1)) || isValidEscape$2(getCharCode(offset + 1), getCharCode(offset + 2))) {
	                    // Create a <hash-token>.
	                    type = TYPE$2.Hash;

	                    // If the next 3 input code points would start an identifier, set the <hash-token>’s type flag to "id".
	                    // if (isIdentifierStart(getCharCode(offset + 1), getCharCode(offset + 2), getCharCode(offset + 3))) {
	                    //     // TODO: set id flag
	                    // }

	                    // Consume a name, and set the <hash-token>’s value to the returned string.
	                    offset = consumeName$1(source, offset + 1);

	                    // Return the <hash-token>.
	                } else {
	                    // Otherwise, return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }

	                break;

	            // U+0027 APOSTROPHE (')
	            case 0x0027:
	                // Consume a string token and return it.
	                consumeStringToken();
	                break;

	            // U+0028 LEFT PARENTHESIS (()
	            case 0x0028:
	                // Return a <(-token>.
	                type = TYPE$2.LeftParenthesis;
	                offset++;
	                break;

	            // U+0029 RIGHT PARENTHESIS ())
	            case 0x0029:
	                // Return a <)-token>.
	                type = TYPE$2.RightParenthesis;
	                offset++;
	                break;

	            // U+002B PLUS SIGN (+)
	            case 0x002B:
	                // If the input stream starts with a number, ...
	                if (isNumberStart$1(code, getCharCode(offset + 1), getCharCode(offset + 2))) {
	                    // ... reconsume the current input code point, consume a numeric token, and return it.
	                    consumeNumericToken();
	                } else {
	                    // Otherwise, return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }
	                break;

	            // U+002C COMMA (,)
	            case 0x002C:
	                // Return a <comma-token>.
	                type = TYPE$2.Comma;
	                offset++;
	                break;

	            // U+002D HYPHEN-MINUS (-)
	            case 0x002D:
	                // If the input stream starts with a number, reconsume the current input code point, consume a numeric token, and return it.
	                if (isNumberStart$1(code, getCharCode(offset + 1), getCharCode(offset + 2))) {
	                    consumeNumericToken();
	                } else {
	                    // Otherwise, if the next 2 input code points are U+002D HYPHEN-MINUS U+003E GREATER-THAN SIGN (->), consume them and return a <CDC-token>.
	                    if (getCharCode(offset + 1) === 0x002D &&
	                        getCharCode(offset + 2) === 0x003E) {
	                        type = TYPE$2.CDC;
	                        offset = offset + 3;
	                    } else {
	                        // Otherwise, if the input stream starts with an identifier, ...
	                        if (isIdentifierStart$1(code, getCharCode(offset + 1), getCharCode(offset + 2))) {
	                            // ... reconsume the current input code point, consume an ident-like token, and return it.
	                            consumeIdentLikeToken();
	                        } else {
	                            // Otherwise, return a <delim-token> with its value set to the current input code point.
	                            type = TYPE$2.Delim;
	                            offset++;
	                        }
	                    }
	                }
	                break;

	            // U+002E FULL STOP (.)
	            case 0x002E:
	                // If the input stream starts with a number, ...
	                if (isNumberStart$1(code, getCharCode(offset + 1), getCharCode(offset + 2))) {
	                    // ... reconsume the current input code point, consume a numeric token, and return it.
	                    consumeNumericToken();
	                } else {
	                    // Otherwise, return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }

	                break;

	            // U+002F SOLIDUS (/)
	            case 0x002F:
	                // If the next two input code point are U+002F SOLIDUS (/) followed by a U+002A ASTERISK (*),
	                if (getCharCode(offset + 1) === 0x002A) {
	                    // ... consume them and all following code points up to and including the first U+002A ASTERISK (*)
	                    // followed by a U+002F SOLIDUS (/), or up to an EOF code point.
	                    type = TYPE$2.Comment;
	                    offset = source.indexOf('*/', offset + 2) + 2;
	                    if (offset === 1) {
	                        offset = source.length;
	                    }
	                } else {
	                    type = TYPE$2.Delim;
	                    offset++;
	                }
	                break;

	            // U+003A COLON (:)
	            case 0x003A:
	                // Return a <colon-token>.
	                type = TYPE$2.Colon;
	                offset++;
	                break;

	            // U+003B SEMICOLON (;)
	            case 0x003B:
	                // Return a <semicolon-token>.
	                type = TYPE$2.Semicolon;
	                offset++;
	                break;

	            // U+003C LESS-THAN SIGN (<)
	            case 0x003C:
	                // If the next 3 input code points are U+0021 EXCLAMATION MARK U+002D HYPHEN-MINUS U+002D HYPHEN-MINUS (!--), ...
	                if (getCharCode(offset + 1) === 0x0021 &&
	                    getCharCode(offset + 2) === 0x002D &&
	                    getCharCode(offset + 3) === 0x002D) {
	                    // ... consume them and return a <CDO-token>.
	                    type = TYPE$2.CDO;
	                    offset = offset + 4;
	                } else {
	                    // Otherwise, return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }

	                break;

	            // U+0040 COMMERCIAL AT (@)
	            case 0x0040:
	                // If the next 3 input code points would start an identifier, ...
	                if (isIdentifierStart$1(getCharCode(offset + 1), getCharCode(offset + 2), getCharCode(offset + 3))) {
	                    // ... consume a name, create an <at-keyword-token> with its value set to the returned value, and return it.
	                    type = TYPE$2.AtKeyword;
	                    offset = consumeName$1(source, offset + 1);
	                } else {
	                    // Otherwise, return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }

	                break;

	            // U+005B LEFT SQUARE BRACKET ([)
	            case 0x005B:
	                // Return a <[-token>.
	                type = TYPE$2.LeftSquareBracket;
	                offset++;
	                break;

	            // U+005C REVERSE SOLIDUS (\)
	            case 0x005C:
	                // If the input stream starts with a valid escape, ...
	                if (isValidEscape$2(code, getCharCode(offset + 1))) {
	                    // ... reconsume the current input code point, consume an ident-like token, and return it.
	                    consumeIdentLikeToken();
	                } else {
	                    // Otherwise, this is a parse error. Return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }
	                break;

	            // U+005D RIGHT SQUARE BRACKET (])
	            case 0x005D:
	                // Return a <]-token>.
	                type = TYPE$2.RightSquareBracket;
	                offset++;
	                break;

	            // U+007B LEFT CURLY BRACKET ({)
	            case 0x007B:
	                // Return a <{-token>.
	                type = TYPE$2.LeftCurlyBracket;
	                offset++;
	                break;

	            // U+007D RIGHT CURLY BRACKET (})
	            case 0x007D:
	                // Return a <}-token>.
	                type = TYPE$2.RightCurlyBracket;
	                offset++;
	                break;

	            // digit
	            case charCodeCategory$1.Digit:
	                // Reconsume the current input code point, consume a numeric token, and return it.
	                consumeNumericToken();
	                break;

	            // name-start code point
	            case charCodeCategory$1.NameStart:
	                // Reconsume the current input code point, consume an ident-like token, and return it.
	                consumeIdentLikeToken();
	                break;

	            // EOF
	            case charCodeCategory$1.Eof:
	                // Return an <EOF-token>.
	                break;

	            // anything else
	            default:
	                // Return a <delim-token> with its value set to the current input code point.
	                type = TYPE$2.Delim;
	                offset++;
	        }

	        switch (type) {
	            case balanceCloseType:
	                balancePrev = balanceStart & OFFSET_MASK$1;
	                balanceStart = balance[balancePrev];
	                balanceCloseType = balanceStart >> TYPE_SHIFT$1;
	                balance[tokenCount] = balancePrev;
	                balance[balancePrev++] = tokenCount;
	                for (; balancePrev < tokenCount; balancePrev++) {
	                    if (balance[balancePrev] === sourceLength) {
	                        balance[balancePrev] = tokenCount;
	                    }
	                }
	                break;

	            case TYPE$2.LeftParenthesis:
	            case TYPE$2.Function:
	                balance[tokenCount] = balanceStart;
	                balanceCloseType = TYPE$2.RightParenthesis;
	                balanceStart = (balanceCloseType << TYPE_SHIFT$1) | tokenCount;
	                break;

	            case TYPE$2.LeftSquareBracket:
	                balance[tokenCount] = balanceStart;
	                balanceCloseType = TYPE$2.RightSquareBracket;
	                balanceStart = (balanceCloseType << TYPE_SHIFT$1) | tokenCount;
	                break;

	            case TYPE$2.LeftCurlyBracket:
	                balance[tokenCount] = balanceStart;
	                balanceCloseType = TYPE$2.RightCurlyBracket;
	                balanceStart = (balanceCloseType << TYPE_SHIFT$1) | tokenCount;
	                break;
	        }

	        offsetAndType[tokenCount++] = (type << TYPE_SHIFT$1) | offset;
	    }

	    // finalize buffers
	    offsetAndType[tokenCount] = (TYPE$2.EOF << TYPE_SHIFT$1) | offset; // <EOF-token>
	    balance[tokenCount] = sourceLength;
	    balance[sourceLength] = sourceLength; // prevents false positive balance match with any token
	    while (balanceStart !== 0) {
	        balancePrev = balanceStart & OFFSET_MASK$1;
	        balanceStart = balance[balancePrev];
	        balance[balancePrev] = sourceLength;
	    }

	    // update stream
	    stream.source = source;
	    stream.firstCharOffset = start;
	    stream.offsetAndType = offsetAndType;
	    stream.tokenCount = tokenCount;
	    stream.balance = balance;
	    stream.reset();
	    stream.next();

	    return stream;
	}

	// extend tokenizer with constants
	Object.keys(_const).forEach(function(key) {
	    tokenize[key] = _const[key];
	});

	// extend tokenizer with static methods from utils
	Object.keys(charCodeDefinitions).forEach(function(key) {
	    tokenize[key] = charCodeDefinitions[key];
	});
	Object.keys(utils).forEach(function(key) {
	    tokenize[key] = utils[key];
	});

	var tokenizer = tokenize;

	var isDigit$2 = tokenizer.isDigit;
	var cmpChar$1 = tokenizer.cmpChar;
	var TYPE$3 = tokenizer.TYPE;

	var DELIM = TYPE$3.Delim;
	var WHITESPACE$1 = TYPE$3.WhiteSpace;
	var COMMENT$1 = TYPE$3.Comment;
	var IDENT = TYPE$3.Ident;
	var NUMBER = TYPE$3.Number;
	var DIMENSION = TYPE$3.Dimension;
	var PLUSSIGN = 0x002B;    // U+002B PLUS SIGN (+)
	var HYPHENMINUS$1 = 0x002D; // U+002D HYPHEN-MINUS (-)
	var N = 0x006E;           // U+006E LATIN SMALL LETTER N (n)
	var DISALLOW_SIGN = true;
	var ALLOW_SIGN = false;

	function isDelim(token, code) {
	    return token !== null && token.type === DELIM && token.value.charCodeAt(0) === code;
	}

	function skipSC(token, offset, getNextToken) {
	    while (token !== null && (token.type === WHITESPACE$1 || token.type === COMMENT$1)) {
	        token = getNextToken(++offset);
	    }

	    return offset;
	}

	function checkInteger(token, valueOffset, disallowSign, offset) {
	    if (!token) {
	        return 0;
	    }

	    var code = token.value.charCodeAt(valueOffset);

	    if (code === PLUSSIGN || code === HYPHENMINUS$1) {
	        if (disallowSign) {
	            // Number sign is not allowed
	            return 0;
	        }
	        valueOffset++;
	    }

	    for (; valueOffset < token.value.length; valueOffset++) {
	        if (!isDigit$2(token.value.charCodeAt(valueOffset))) {
	            // Integer is expected
	            return 0;
	        }
	    }

	    return offset + 1;
	}

	// ... <signed-integer>
	// ... ['+' | '-'] <signless-integer>
	function consumeB(token, offset_, getNextToken) {
	    var sign = false;
	    var offset = skipSC(token, offset_, getNextToken);

	    token = getNextToken(offset);

	    if (token === null) {
	        return offset_;
	    }

	    if (token.type !== NUMBER) {
	        if (isDelim(token, PLUSSIGN) || isDelim(token, HYPHENMINUS$1)) {
	            sign = true;
	            offset = skipSC(getNextToken(++offset), offset, getNextToken);
	            token = getNextToken(offset);

	            if (token === null && token.type !== NUMBER) {
	                return 0;
	            }
	        } else {
	            return offset_;
	        }
	    }

	    if (!sign) {
	        var code = token.value.charCodeAt(0);
	        if (code !== PLUSSIGN && code !== HYPHENMINUS$1) {
	            // Number sign is expected
	            return 0;
	        }
	    }

	    return checkInteger(token, sign ? 0 : 1, sign, offset);
	}

	// An+B microsyntax https://www.w3.org/TR/css-syntax-3/#anb
	var genericAnPlusB = function anPlusB(token, getNextToken) {
	    /* eslint-disable brace-style*/
	    var offset = 0;

	    if (!token) {
	        return 0;
	    }

	    // <integer>
	    if (token.type === NUMBER) {
	        return checkInteger(token, 0, ALLOW_SIGN, offset); // b
	    }

	    // -n
	    // -n <signed-integer>
	    // -n ['+' | '-'] <signless-integer>
	    // -n- <signless-integer>
	    // <dashndashdigit-ident>
	    else if (token.type === IDENT && token.value.charCodeAt(0) === HYPHENMINUS$1) {
	        // expect 1st char is N
	        if (!cmpChar$1(token.value, 1, N)) {
	            return 0;
	        }

	        switch (token.value.length) {
	            // -n
	            // -n <signed-integer>
	            // -n ['+' | '-'] <signless-integer>
	            case 2:
	                return consumeB(getNextToken(++offset), offset, getNextToken);

	            // -n- <signless-integer>
	            case 3:
	                if (token.value.charCodeAt(2) !== HYPHENMINUS$1) {
	                    return 0;
	                }

	                offset = skipSC(getNextToken(++offset), offset, getNextToken);
	                token = getNextToken(offset);

	                return checkInteger(token, 0, DISALLOW_SIGN, offset);

	            // <dashndashdigit-ident>
	            default:
	                if (token.value.charCodeAt(2) !== HYPHENMINUS$1) {
	                    return 0;
	                }

	                return checkInteger(token, 3, DISALLOW_SIGN, offset);
	        }
	    }

	    // '+'? n
	    // '+'? n <signed-integer>
	    // '+'? n ['+' | '-'] <signless-integer>
	    // '+'? n- <signless-integer>
	    // '+'? <ndashdigit-ident>
	    else if (token.type === IDENT || (isDelim(token, PLUSSIGN) && getNextToken(offset + 1).type === IDENT)) {
	        // just ignore a plus
	        if (token.type !== IDENT) {
	            token = getNextToken(++offset);
	        }

	        if (token === null || !cmpChar$1(token.value, 0, N)) {
	            return 0;
	        }

	        switch (token.value.length) {
	            // '+'? n
	            // '+'? n <signed-integer>
	            // '+'? n ['+' | '-'] <signless-integer>
	            case 1:
	                return consumeB(getNextToken(++offset), offset, getNextToken);

	            // '+'? n- <signless-integer>
	            case 2:
	                if (token.value.charCodeAt(1) !== HYPHENMINUS$1) {
	                    return 0;
	                }

	                offset = skipSC(getNextToken(++offset), offset, getNextToken);
	                token = getNextToken(offset);

	                return checkInteger(token, 0, DISALLOW_SIGN, offset);

	            // '+'? <ndashdigit-ident>
	            default:
	                if (token.value.charCodeAt(1) !== HYPHENMINUS$1) {
	                    return 0;
	                }

	                return checkInteger(token, 2, DISALLOW_SIGN, offset);
	        }
	    }

	    // <ndashdigit-dimension>
	    // <ndash-dimension> <signless-integer>
	    // <n-dimension>
	    // <n-dimension> <signed-integer>
	    // <n-dimension> ['+' | '-'] <signless-integer>
	    else if (token.type === DIMENSION) {
	        var code = token.value.charCodeAt(0);
	        var sign = code === PLUSSIGN || code === HYPHENMINUS$1 ? 1 : 0;

	        for (var i = sign; i < token.value.length; i++) {
	            if (!isDigit$2(token.value.charCodeAt(i))) {
	                break;
	            }
	        }

	        if (i === sign) {
	            // Integer is expected
	            return 0;
	        }

	        if (!cmpChar$1(token.value, i, N)) {
	            return 0;
	        }

	        // <n-dimension>
	        // <n-dimension> <signed-integer>
	        // <n-dimension> ['+' | '-'] <signless-integer>
	        if (i + 1 === token.value.length) {
	            return consumeB(getNextToken(++offset), offset, getNextToken);
	        } else {
	            if (token.value.charCodeAt(i + 1) !== HYPHENMINUS$1) {
	                return 0;
	            }

	            // <ndash-dimension> <signless-integer>
	            if (i + 2 === token.value.length) {
	                offset = skipSC(getNextToken(++offset), offset, getNextToken);
	                token = getNextToken(offset);

	                return checkInteger(token, 0, DISALLOW_SIGN, offset);
	            }
	            // <ndashdigit-dimension>
	            else {
	                return checkInteger(token, i + 2, DISALLOW_SIGN, offset);
	            }
	        }
	    }

	    return 0;
	};

	var isHexDigit$2 = tokenizer.isHexDigit;
	var cmpChar$2 = tokenizer.cmpChar;
	var TYPE$4 = tokenizer.TYPE;

	var IDENT$1 = TYPE$4.Ident;
	var DELIM$1 = TYPE$4.Delim;
	var NUMBER$1 = TYPE$4.Number;
	var DIMENSION$1 = TYPE$4.Dimension;
	var PLUSSIGN$1 = 0x002B;     // U+002B PLUS SIGN (+)
	var HYPHENMINUS$2 = 0x002D;  // U+002D HYPHEN-MINUS (-)
	var QUESTIONMARK = 0x003F; // U+003F QUESTION MARK (?)
	var U = 0x0075;            // U+0075 LATIN SMALL LETTER U (u)

	function isDelim$1(token, code) {
	    return token !== null && token.type === DELIM$1 && token.value.charCodeAt(0) === code;
	}

	function startsWith(token, code) {
	    return token.value.charCodeAt(0) === code;
	}

	function hexSequence(token, offset, allowDash) {
	    for (var pos = offset, hexlen = 0; pos < token.value.length; pos++) {
	        var code = token.value.charCodeAt(pos);

	        if (code === HYPHENMINUS$2 && allowDash && hexlen !== 0) {
	            if (hexSequence(token, offset + hexlen + 1, false) > 0) {
	                return 6; // dissallow following question marks
	            }

	            return 0; // dash at the ending of a hex sequence is not allowed
	        }

	        if (!isHexDigit$2(code)) {
	            return 0; // not a hex digit
	        }

	        if (++hexlen > 6) {
	            return 0; // too many hex digits
	        }    }

	    return hexlen;
	}

	function withQuestionMarkSequence(consumed, length, getNextToken) {
	    if (!consumed) {
	        return 0; // nothing consumed
	    }

	    while (isDelim$1(getNextToken(length), QUESTIONMARK)) {
	        if (++consumed > 6) {
	            return 0; // too many question marks
	        }

	        length++;
	    }

	    return length;
	}

	// https://drafts.csswg.org/css-syntax/#urange
	// Informally, the <urange> production has three forms:
	// U+0001
	//      Defines a range consisting of a single code point, in this case the code point "1".
	// U+0001-00ff
	//      Defines a range of codepoints between the first and the second value, in this case
	//      the range between "1" and "ff" (255 in decimal) inclusive.
	// U+00??
	//      Defines a range of codepoints where the "?" characters range over all hex digits,
	//      in this case defining the same as the value U+0000-00ff.
	// In each form, a maximum of 6 digits is allowed for each hexadecimal number (if you treat "?" as a hexadecimal digit).
	//
	// <urange> =
	//   u '+' <ident-token> '?'* |
	//   u <dimension-token> '?'* |
	//   u <number-token> '?'* |
	//   u <number-token> <dimension-token> |
	//   u <number-token> <number-token> |
	//   u '+' '?'+
	var genericUrange = function urange(token, getNextToken) {
	    var length = 0;

	    // should start with `u` or `U`
	    if (token === null || token.type !== IDENT$1 || !cmpChar$2(token.value, 0, U)) {
	        return 0;
	    }

	    token = getNextToken(++length);
	    if (token === null) {
	        return 0;
	    }

	    // u '+' <ident-token> '?'*
	    // u '+' '?'+
	    if (isDelim$1(token, PLUSSIGN$1)) {
	        token = getNextToken(++length);
	        if (token === null) {
	            return 0;
	        }

	        if (token.type === IDENT$1) {
	            // u '+' <ident-token> '?'*
	            return withQuestionMarkSequence(hexSequence(token, 0, true), ++length, getNextToken);
	        }

	        if (isDelim$1(token, QUESTIONMARK)) {
	            // u '+' '?'+
	            return withQuestionMarkSequence(1, ++length, getNextToken);
	        }

	        // Hex digit or question mark is expected
	        return 0;
	    }

	    // u <number-token> '?'*
	    // u <number-token> <dimension-token>
	    // u <number-token> <number-token>
	    if (token.type === NUMBER$1) {
	        if (!startsWith(token, PLUSSIGN$1)) {
	            return 0;
	        }

	        var consumedHexLength = hexSequence(token, 1, true);
	        if (consumedHexLength === 0) {
	            return 0;
	        }

	        token = getNextToken(++length);
	        if (token === null) {
	            // u <number-token> <eof>
	            return length;
	        }

	        if (token.type === DIMENSION$1 || token.type === NUMBER$1) {
	            // u <number-token> <dimension-token>
	            // u <number-token> <number-token>
	            if (!startsWith(token, HYPHENMINUS$2) || !hexSequence(token, 1, false)) {
	                return 0;
	            }

	            return length + 1;
	        }

	        // u <number-token> '?'*
	        return withQuestionMarkSequence(consumedHexLength, length, getNextToken);
	    }

	    // u <dimension-token> '?'*
	    if (token.type === DIMENSION$1) {
	        if (!startsWith(token, PLUSSIGN$1)) {
	            return 0;
	        }

	        return withQuestionMarkSequence(hexSequence(token, 1, true), ++length, getNextToken);
	    }

	    return 0;
	};

	var isIdentifierStart$2 = tokenizer.isIdentifierStart;
	var isHexDigit$3 = tokenizer.isHexDigit;
	var isDigit$3 = tokenizer.isDigit;
	var cmpStr$3 = tokenizer.cmpStr;
	var consumeNumber$2 = tokenizer.consumeNumber;
	var TYPE$5 = tokenizer.TYPE;



	var cssWideKeywords = ['unset', 'initial', 'inherit'];
	var calcFunctionNames = ['calc(', '-moz-calc(', '-webkit-calc('];

	// https://www.w3.org/TR/css-values-3/#lengths
	var LENGTH = {
	    // absolute length units
	    'px': true,
	    'mm': true,
	    'cm': true,
	    'in': true,
	    'pt': true,
	    'pc': true,
	    'q': true,

	    // relative length units
	    'em': true,
	    'ex': true,
	    'ch': true,
	    'rem': true,

	    // viewport-percentage lengths
	    'vh': true,
	    'vw': true,
	    'vmin': true,
	    'vmax': true,
	    'vm': true
	};

	var ANGLE = {
	    'deg': true,
	    'grad': true,
	    'rad': true,
	    'turn': true
	};

	var TIME = {
	    's': true,
	    'ms': true
	};

	var FREQUENCY = {
	    'hz': true,
	    'khz': true
	};

	// https://www.w3.org/TR/css-values-3/#resolution (https://drafts.csswg.org/css-values/#resolution)
	var RESOLUTION = {
	    'dpi': true,
	    'dpcm': true,
	    'dppx': true,
	    'x': true      // https://github.com/w3c/csswg-drafts/issues/461
	};

	// https://drafts.csswg.org/css-grid/#fr-unit
	var FLEX = {
	    'fr': true
	};

	// https://www.w3.org/TR/css3-speech/#mixing-props-voice-volume
	var DECIBEL = {
	    'db': true
	};

	// https://www.w3.org/TR/css3-speech/#voice-props-voice-pitch
	var SEMITONES = {
	    'st': true
	};

	// safe char code getter
	function charCode(str, index) {
	    return index < str.length ? str.charCodeAt(index) : 0;
	}

	function eqStr(actual, expected) {
	    return cmpStr$3(actual, 0, actual.length, expected);
	}

	function eqStrAny(actual, expected) {
	    for (var i = 0; i < expected.length; i++) {
	        if (eqStr(actual, expected[i])) {
	            return true;
	        }
	    }

	    return false;
	}

	// IE postfix hack, i.e. 123\0 or 123px\9
	function isPostfixIeHack(str, offset) {
	    if (offset !== str.length - 2) {
	        return false;
	    }

	    return (
	        str.charCodeAt(offset) === 0x005C &&  // U+005C REVERSE SOLIDUS (\)
	        isDigit$3(str.charCodeAt(offset + 1))
	    );
	}

	function outOfRange(opts, value, numEnd) {
	    if (opts && opts.type === 'Range') {
	        var num = Number(
	            numEnd !== undefined && numEnd !== value.length
	                ? value.substr(0, numEnd)
	                : value
	        );

	        if (isNaN(num)) {
	            return true;
	        }

	        if (opts.min !== null && num < opts.min) {
	            return true;
	        }

	        if (opts.max !== null && num > opts.max) {
	            return true;
	        }
	    }

	    return false;
	}

	function consumeFunction(token, getNextToken) {
	    var startIdx = token.index;
	    var length = 0;

	    // balanced token consuming
	    do {
	        length++;

	        if (token.balance <= startIdx) {
	            break;
	        }
	    } while (token = getNextToken(length));

	    return length;
	}

	// TODO: implement
	// can be used wherever <length>, <frequency>, <angle>, <time>, <percentage>, <number>, or <integer> values are allowed
	// https://drafts.csswg.org/css-values/#calc-notation
	function calc(next) {
	    return function(token, getNextToken, opts) {
	        if (token === null) {
	            return 0;
	        }

	        if (token.type === TYPE$5.Function && eqStrAny(token.value, calcFunctionNames)) {
	            return consumeFunction(token, getNextToken);
	        }

	        return next(token, getNextToken, opts);
	    };
	}

	function tokenType(expectedTokenType) {
	    return function(token) {
	        if (token === null || token.type !== expectedTokenType) {
	            return 0;
	        }

	        return 1;
	    };
	}

	function func(name) {
	    name = name + '(';

	    return function(token, getNextToken) {
	        if (token !== null && eqStr(token.value, name)) {
	            return consumeFunction(token, getNextToken);
	        }

	        return 0;
	    };
	}

	// =========================
	// Complex types
	//

	// https://drafts.csswg.org/css-values-4/#custom-idents
	// 4.2. Author-defined Identifiers: the <custom-ident> type
	// Some properties accept arbitrary author-defined identifiers as a component value.
	// This generic data type is denoted by <custom-ident>, and represents any valid CSS identifier
	// that would not be misinterpreted as a pre-defined keyword in that property’s value definition.
	//
	// See also: https://developer.mozilla.org/en-US/docs/Web/CSS/custom-ident
	function customIdent(token) {
	    if (token === null || token.type !== TYPE$5.Ident) {
	        return 0;
	    }

	    var name = token.value.toLowerCase();

	    // The CSS-wide keywords are not valid <custom-ident>s
	    if (eqStrAny(name, cssWideKeywords)) {
	        return 0;
	    }

	    // The default keyword is reserved and is also not a valid <custom-ident>
	    if (eqStr(name, 'default')) {
	        return 0;
	    }

	    // TODO: ignore property specific keywords (as described https://developer.mozilla.org/en-US/docs/Web/CSS/custom-ident)
	    // Specifications using <custom-ident> must specify clearly what other keywords
	    // are excluded from <custom-ident>, if any—for example by saying that any pre-defined keywords
	    // in that property’s value definition are excluded. Excluded keywords are excluded
	    // in all ASCII case permutations.

	    return 1;
	}

	// https://drafts.csswg.org/css-variables/#typedef-custom-property-name
	// A custom property is any property whose name starts with two dashes (U+002D HYPHEN-MINUS), like --foo.
	// The <custom-property-name> production corresponds to this: it’s defined as any valid identifier
	// that starts with two dashes, except -- itself, which is reserved for future use by CSS.
	// NOTE: Current implementation treat `--` as a valid name since most (all?) major browsers treat it as valid.
	function customPropertyName(token) {
	    // ... defined as any valid identifier
	    if (token === null || token.type !== TYPE$5.Ident) {
	        return 0;
	    }

	    // ... that starts with two dashes (U+002D HYPHEN-MINUS)
	    if (charCode(token.value, 0) !== 0x002D || charCode(token.value, 1) !== 0x002D) {
	        return 0;
	    }

	    return 1;
	}

	// https://drafts.csswg.org/css-color-4/#hex-notation
	// The syntax of a <hex-color> is a <hash-token> token whose value consists of 3, 4, 6, or 8 hexadecimal digits.
	// In other words, a hex color is written as a hash character, "#", followed by some number of digits 0-9 or
	// letters a-f (the case of the letters doesn’t matter - #00ff00 is identical to #00FF00).
	function hexColor(token) {
	    if (token === null || token.type !== TYPE$5.Hash) {
	        return 0;
	    }

	    var length = token.value.length;

	    // valid values (length): #rgb (4), #rgba (5), #rrggbb (7), #rrggbbaa (9)
	    if (length !== 4 && length !== 5 && length !== 7 && length !== 9) {
	        return 0;
	    }

	    for (var i = 1; i < length; i++) {
	        if (!isHexDigit$3(token.value.charCodeAt(i))) {
	            return 0;
	        }
	    }

	    return 1;
	}

	function idSelector(token) {
	    if (token === null || token.type !== TYPE$5.Hash) {
	        return 0;
	    }

	    if (!isIdentifierStart$2(charCode(token.value, 1), charCode(token.value, 2), charCode(token.value, 3))) {
	        return 0;
	    }

	    return 1;
	}

	// https://drafts.csswg.org/css-syntax/#any-value
	// It represents the entirety of what a valid declaration can have as its value.
	function declarationValue(token, getNextToken) {
	    if (!token) {
	        return 0;
	    }

	    var length = 0;
	    var level = 0;
	    var startIdx = token.index;

	    // The <declaration-value> production matches any sequence of one or more tokens,
	    // so long as the sequence ...
	    scan:
	    do {
	        switch (token.type) {
	            // ... does not contain <bad-string-token>, <bad-url-token>,
	            case TYPE$5.BadString:
	            case TYPE$5.BadUrl:
	                break scan;

	            // ... unmatched <)-token>, <]-token>, or <}-token>,
	            case TYPE$5.RightCurlyBracket:
	            case TYPE$5.RightParenthesis:
	            case TYPE$5.RightSquareBracket:
	                if (token.balance > token.index || token.balance < startIdx) {
	                    break scan;
	                }

	                level--;
	                break;

	            // ... or top-level <semicolon-token> tokens
	            case TYPE$5.Semicolon:
	                if (level === 0) {
	                    break scan;
	                }

	                break;

	            // ... or <delim-token> tokens with a value of "!"
	            case TYPE$5.Delim:
	                if (token.value === '!' && level === 0) {
	                    break scan;
	                }

	                break;

	            case TYPE$5.Function:
	            case TYPE$5.LeftParenthesis:
	            case TYPE$5.LeftSquareBracket:
	            case TYPE$5.LeftCurlyBracket:
	                level++;
	                break;
	        }

	        length++;

	        // until balance closing
	        if (token.balance <= startIdx) {
	            break;
	        }
	    } while (token = getNextToken(length));

	    return length;
	}

	// https://drafts.csswg.org/css-syntax/#any-value
	// The <any-value> production is identical to <declaration-value>, but also
	// allows top-level <semicolon-token> tokens and <delim-token> tokens
	// with a value of "!". It represents the entirety of what valid CSS can be in any context.
	function anyValue(token, getNextToken) {
	    if (!token) {
	        return 0;
	    }

	    var startIdx = token.index;
	    var length = 0;

	    // The <any-value> production matches any sequence of one or more tokens,
	    // so long as the sequence ...
	    scan:
	    do {
	        switch (token.type) {
	            // ... does not contain <bad-string-token>, <bad-url-token>,
	            case TYPE$5.BadString:
	            case TYPE$5.BadUrl:
	                break scan;

	            // ... unmatched <)-token>, <]-token>, or <}-token>,
	            case TYPE$5.RightCurlyBracket:
	            case TYPE$5.RightParenthesis:
	            case TYPE$5.RightSquareBracket:
	                if (token.balance > token.index || token.balance < startIdx) {
	                    break scan;
	                }

	                break;
	        }

	        length++;

	        // until balance closing
	        if (token.balance <= startIdx) {
	            break;
	        }
	    } while (token = getNextToken(length));

	    return length;
	}

	// =========================
	// Dimensions
	//

	function dimension(type) {
	    return function(token, getNextToken, opts) {
	        if (token === null || token.type !== TYPE$5.Dimension) {
	            return 0;
	        }

	        var numberEnd = consumeNumber$2(token.value, 0);

	        // check unit
	        if (type !== null) {
	            // check for IE postfix hack, i.e. 123px\0 or 123px\9
	            var reverseSolidusOffset = token.value.indexOf('\\', numberEnd);
	            var unit = reverseSolidusOffset === -1 || !isPostfixIeHack(token.value, reverseSolidusOffset)
	                ? token.value.substr(numberEnd)
	                : token.value.substring(numberEnd, reverseSolidusOffset);

	            if (type.hasOwnProperty(unit.toLowerCase()) === false) {
	                return 0;
	            }
	        }

	        // check range if specified
	        if (outOfRange(opts, token.value, numberEnd)) {
	            return 0;
	        }

	        return 1;
	    };
	}

	// =========================
	// Percentage
	//

	// §5.5. Percentages: the <percentage> type
	// https://drafts.csswg.org/css-values-4/#percentages
	function percentage(token, getNextToken, opts) {
	    // ... corresponds to the <percentage-token> production
	    if (token === null || token.type !== TYPE$5.Percentage) {
	        return 0;
	    }

	    // check range if specified
	    if (outOfRange(opts, token.value, token.value.length - 1)) {
	        return 0;
	    }

	    return 1;
	}

	// =========================
	// Numeric
	//

	// https://drafts.csswg.org/css-values-4/#numbers
	// The value <zero> represents a literal number with the value 0. Expressions that merely
	// evaluate to a <number> with the value 0 (for example, calc(0)) do not match <zero>;
	// only literal <number-token>s do.
	function zero(next) {
	    if (typeof next !== 'function') {
	        next = function() {
	            return 0;
	        };
	    }

	    return function(token, getNextToken, opts) {
	        if (token !== null && token.type === TYPE$5.Number) {
	            if (Number(token.value) === 0) {
	                return 1;
	            }
	        }

	        return next(token, getNextToken, opts);
	    };
	}

	// § 5.3. Real Numbers: the <number> type
	// https://drafts.csswg.org/css-values-4/#numbers
	// Number values are denoted by <number>, and represent real numbers, possibly with a fractional component.
	// ... It corresponds to the <number-token> production
	function number(token, getNextToken, opts) {
	    if (token === null) {
	        return 0;
	    }

	    var numberEnd = consumeNumber$2(token.value, 0);
	    var isNumber = numberEnd === token.value.length;
	    if (!isNumber && !isPostfixIeHack(token.value, numberEnd)) {
	        return 0;
	    }

	    // check range if specified
	    if (outOfRange(opts, token.value, numberEnd)) {
	        return 0;
	    }

	    return 1;
	}

	// §5.2. Integers: the <integer> type
	// https://drafts.csswg.org/css-values-4/#integers
	function integer(token, getNextToken, opts) {
	    // ... corresponds to a subset of the <number-token> production
	    if (token === null || token.type !== TYPE$5.Number) {
	        return 0;
	    }

	    // The first digit of an integer may be immediately preceded by `-` or `+` to indicate the integer’s sign.
	    var i = token.value.charCodeAt(0) === 0x002B ||       // U+002B PLUS SIGN (+)
	            token.value.charCodeAt(0) === 0x002D ? 1 : 0; // U+002D HYPHEN-MINUS (-)

	    // When written literally, an integer is one or more decimal digits 0 through 9 ...
	    for (; i < token.value.length; i++) {
	        if (!isDigit$3(token.value.charCodeAt(i))) {
	            return 0;
	        }
	    }

	    // check range if specified
	    if (outOfRange(opts, token.value, i)) {
	        return 0;
	    }

	    return 1;
	}

	var generic = {
	    // token types
	    'ident-token': tokenType(TYPE$5.Ident),
	    'function-token': tokenType(TYPE$5.Function),
	    'at-keyword-token': tokenType(TYPE$5.AtKeyword),
	    'hash-token': tokenType(TYPE$5.Hash),
	    'string-token': tokenType(TYPE$5.String),
	    'bad-string-token': tokenType(TYPE$5.BadString),
	    'url-token': tokenType(TYPE$5.Url),
	    'bad-url-token': tokenType(TYPE$5.BadUrl),
	    'delim-token': tokenType(TYPE$5.Delim),
	    'number-token': tokenType(TYPE$5.Number),
	    'percentage-token': tokenType(TYPE$5.Percentage),
	    'dimension-token': tokenType(TYPE$5.Dimension),
	    'whitespace-token': tokenType(TYPE$5.WhiteSpace),
	    'CDO-token': tokenType(TYPE$5.CDO),
	    'CDC-token': tokenType(TYPE$5.CDC),
	    'colon-token': tokenType(TYPE$5.Colon),
	    'semicolon-token': tokenType(TYPE$5.Semicolon),
	    'comma-token': tokenType(TYPE$5.Comma),
	    '[-token': tokenType(TYPE$5.LeftSquareBracket),
	    ']-token': tokenType(TYPE$5.RightSquareBracket),
	    '(-token': tokenType(TYPE$5.LeftParenthesis),
	    ')-token': tokenType(TYPE$5.RightParenthesis),
	    '{-token': tokenType(TYPE$5.LeftCurlyBracket),
	    '}-token': tokenType(TYPE$5.RightCurlyBracket),

	    // token type aliases
	    'string': tokenType(TYPE$5.String),
	    'ident': tokenType(TYPE$5.Ident),

	    // complex types
	    'custom-ident': customIdent,
	    'custom-property-name': customPropertyName,
	    'hex-color': hexColor,
	    'id-selector': idSelector, // element( <id-selector> )
	    'an-plus-b': genericAnPlusB,
	    'urange': genericUrange,
	    'declaration-value': declarationValue,
	    'any-value': anyValue,

	    // dimensions
	    'dimension': calc(dimension(null)),
	    'angle': calc(dimension(ANGLE)),
	    'decibel': calc(dimension(DECIBEL)),
	    'frequency': calc(dimension(FREQUENCY)),
	    'flex': calc(dimension(FLEX)),
	    'length': calc(zero(dimension(LENGTH))),
	    'resolution': calc(dimension(RESOLUTION)),
	    'semitones': calc(dimension(SEMITONES)),
	    'time': calc(dimension(TIME)),

	    // percentage
	    'percentage': calc(percentage),

	    // numeric
	    'zero': zero(),
	    'number': calc(number),
	    'integer': calc(integer),

	    // old IE stuff
	    '-ms-legacy-expression': func('expression')
	};

	var _SyntaxError$1 = function SyntaxError(message, input, offset) {
	    var error = createCustomError('SyntaxError', message);

	    error.input = input;
	    error.offset = offset;
	    error.rawMessage = message;
	    error.message = error.rawMessage + '\n' +
	        '  ' + error.input + '\n' +
	        '--' + new Array((error.offset || error.input.length) + 1).join('-') + '^';

	    return error;
	};

	var TAB = 9;
	var N$1 = 10;
	var F = 12;
	var R = 13;
	var SPACE = 32;

	var Tokenizer = function(str) {
	    this.str = str;
	    this.pos = 0;
	};

	Tokenizer.prototype = {
	    charCodeAt: function(pos) {
	        return pos < this.str.length ? this.str.charCodeAt(pos) : 0;
	    },
	    charCode: function() {
	        return this.charCodeAt(this.pos);
	    },
	    nextCharCode: function() {
	        return this.charCodeAt(this.pos + 1);
	    },
	    nextNonWsCode: function(pos) {
	        return this.charCodeAt(this.findWsEnd(pos));
	    },
	    findWsEnd: function(pos) {
	        for (; pos < this.str.length; pos++) {
	            var code = this.str.charCodeAt(pos);
	            if (code !== R && code !== N$1 && code !== F && code !== SPACE && code !== TAB) {
	                break;
	            }
	        }

	        return pos;
	    },
	    substringToPos: function(end) {
	        return this.str.substring(this.pos, this.pos = end);
	    },
	    eat: function(code) {
	        if (this.charCode() !== code) {
	            this.error('Expect `' + String.fromCharCode(code) + '`');
	        }

	        this.pos++;
	    },
	    peek: function() {
	        return this.pos < this.str.length ? this.str.charAt(this.pos++) : '';
	    },
	    error: function(message) {
	        throw new _SyntaxError$1(message, this.str, this.pos);
	    }
	};

	var tokenizer$1 = Tokenizer;

	var TAB$1 = 9;
	var N$2 = 10;
	var F$1 = 12;
	var R$1 = 13;
	var SPACE$1 = 32;
	var EXCLAMATIONMARK = 33;    // !
	var NUMBERSIGN = 35;         // #
	var AMPERSAND = 38;          // &
	var APOSTROPHE = 39;         // '
	var LEFTPARENTHESIS = 40;    // (
	var RIGHTPARENTHESIS = 41;   // )
	var ASTERISK = 42;           // *
	var PLUSSIGN$2 = 43;           // +
	var COMMA = 44;              // ,
	var HYPERMINUS = 45;         // -
	var LESSTHANSIGN = 60;       // <
	var GREATERTHANSIGN = 62;    // >
	var QUESTIONMARK$1 = 63;       // ?
	var COMMERCIALAT = 64;       // @
	var LEFTSQUAREBRACKET = 91;  // [
	var RIGHTSQUAREBRACKET = 93; // ]
	var LEFTCURLYBRACKET = 123;  // {
	var VERTICALLINE = 124;      // |
	var RIGHTCURLYBRACKET = 125; // }
	var INFINITY = 8734;         // ∞
	var NAME_CHAR = createCharMap(function(ch) {
	    return /[a-zA-Z0-9\-]/.test(ch);
	});
	var COMBINATOR_PRECEDENCE = {
	    ' ': 1,
	    '&&': 2,
	    '||': 3,
	    '|': 4
	};

	function createCharMap(fn) {
	    var array = typeof Uint32Array === 'function' ? new Uint32Array(128) : new Array(128);
	    for (var i = 0; i < 128; i++) {
	        array[i] = fn(String.fromCharCode(i)) ? 1 : 0;
	    }
	    return array;
	}

	function scanSpaces(tokenizer) {
	    return tokenizer.substringToPos(
	        tokenizer.findWsEnd(tokenizer.pos)
	    );
	}

	function scanWord(tokenizer) {
	    var end = tokenizer.pos;

	    for (; end < tokenizer.str.length; end++) {
	        var code = tokenizer.str.charCodeAt(end);
	        if (code >= 128 || NAME_CHAR[code] === 0) {
	            break;
	        }
	    }

	    if (tokenizer.pos === end) {
	        tokenizer.error('Expect a keyword');
	    }

	    return tokenizer.substringToPos(end);
	}

	function scanNumber(tokenizer) {
	    var end = tokenizer.pos;

	    for (; end < tokenizer.str.length; end++) {
	        var code = tokenizer.str.charCodeAt(end);
	        if (code < 48 || code > 57) {
	            break;
	        }
	    }

	    if (tokenizer.pos === end) {
	        tokenizer.error('Expect a number');
	    }

	    return tokenizer.substringToPos(end);
	}

	function scanString(tokenizer) {
	    var end = tokenizer.str.indexOf('\'', tokenizer.pos + 1);

	    if (end === -1) {
	        tokenizer.pos = tokenizer.str.length;
	        tokenizer.error('Expect an apostrophe');
	    }

	    return tokenizer.substringToPos(end + 1);
	}

	function readMultiplierRange(tokenizer) {
	    var min = null;
	    var max = null;

	    tokenizer.eat(LEFTCURLYBRACKET);

	    min = scanNumber(tokenizer);

	    if (tokenizer.charCode() === COMMA) {
	        tokenizer.pos++;
	        if (tokenizer.charCode() !== RIGHTCURLYBRACKET) {
	            max = scanNumber(tokenizer);
	        }
	    } else {
	        max = min;
	    }

	    tokenizer.eat(RIGHTCURLYBRACKET);

	    return {
	        min: Number(min),
	        max: max ? Number(max) : 0
	    };
	}

	function readMultiplier(tokenizer) {
	    var range = null;
	    var comma = false;

	    switch (tokenizer.charCode()) {
	        case ASTERISK:
	            tokenizer.pos++;

	            range = {
	                min: 0,
	                max: 0
	            };

	            break;

	        case PLUSSIGN$2:
	            tokenizer.pos++;

	            range = {
	                min: 1,
	                max: 0
	            };

	            break;

	        case QUESTIONMARK$1:
	            tokenizer.pos++;

	            range = {
	                min: 0,
	                max: 1
	            };

	            break;

	        case NUMBERSIGN:
	            tokenizer.pos++;

	            comma = true;

	            if (tokenizer.charCode() === LEFTCURLYBRACKET) {
	                range = readMultiplierRange(tokenizer);
	            } else {
	                range = {
	                    min: 1,
	                    max: 0
	                };
	            }

	            break;

	        case LEFTCURLYBRACKET:
	            range = readMultiplierRange(tokenizer);
	            break;

	        default:
	            return null;
	    }

	    return {
	        type: 'Multiplier',
	        comma: comma,
	        min: range.min,
	        max: range.max,
	        term: null
	    };
	}

	function maybeMultiplied(tokenizer, node) {
	    var multiplier = readMultiplier(tokenizer);

	    if (multiplier !== null) {
	        multiplier.term = node;
	        return multiplier;
	    }

	    return node;
	}

	function maybeToken(tokenizer) {
	    var ch = tokenizer.peek();

	    if (ch === '') {
	        return null;
	    }

	    return {
	        type: 'Token',
	        value: ch
	    };
	}

	function readProperty(tokenizer) {
	    var name;

	    tokenizer.eat(LESSTHANSIGN);
	    tokenizer.eat(APOSTROPHE);

	    name = scanWord(tokenizer);

	    tokenizer.eat(APOSTROPHE);
	    tokenizer.eat(GREATERTHANSIGN);

	    return maybeMultiplied(tokenizer, {
	        type: 'Property',
	        name: name
	    });
	}

	// https://drafts.csswg.org/css-values-3/#numeric-ranges
	// 4.1. Range Restrictions and Range Definition Notation
	//
	// Range restrictions can be annotated in the numeric type notation using CSS bracketed
	// range notation—[min,max]—within the angle brackets, after the identifying keyword,
	// indicating a closed range between (and including) min and max.
	// For example, <integer [0, 10]> indicates an integer between 0 and 10, inclusive.
	function readTypeRange(tokenizer) {
	    // use null for Infinity to make AST format JSON serializable/deserializable
	    var min = null; // -Infinity
	    var max = null; // Infinity
	    var sign = 1;

	    tokenizer.eat(LEFTSQUAREBRACKET);

	    if (tokenizer.charCode() === HYPERMINUS) {
	        tokenizer.peek();
	        sign = -1;
	    }

	    if (sign == -1 && tokenizer.charCode() === INFINITY) {
	        tokenizer.peek();
	    } else {
	        min = sign * Number(scanNumber(tokenizer));
	    }

	    scanSpaces(tokenizer);
	    tokenizer.eat(COMMA);
	    scanSpaces(tokenizer);

	    if (tokenizer.charCode() === INFINITY) {
	        tokenizer.peek();
	    } else {
	        sign = 1;

	        if (tokenizer.charCode() === HYPERMINUS) {
	            tokenizer.peek();
	            sign = -1;
	        }

	        max = sign * Number(scanNumber(tokenizer));
	    }

	    tokenizer.eat(RIGHTSQUAREBRACKET);

	    // If no range is indicated, either by using the bracketed range notation
	    // or in the property description, then [−∞,∞] is assumed.
	    if (min === null && max === null) {
	        return null;
	    }

	    return {
	        type: 'Range',
	        min: min,
	        max: max
	    };
	}

	function readType(tokenizer) {
	    var name;
	    var opts = null;

	    tokenizer.eat(LESSTHANSIGN);
	    name = scanWord(tokenizer);

	    if (tokenizer.charCode() === LEFTPARENTHESIS &&
	        tokenizer.nextCharCode() === RIGHTPARENTHESIS) {
	        tokenizer.pos += 2;
	        name += '()';
	    }

	    if (tokenizer.charCodeAt(tokenizer.findWsEnd(tokenizer.pos)) === LEFTSQUAREBRACKET) {
	        scanSpaces(tokenizer);
	        opts = readTypeRange(tokenizer);
	    }

	    tokenizer.eat(GREATERTHANSIGN);

	    return maybeMultiplied(tokenizer, {
	        type: 'Type',
	        name: name,
	        opts: opts
	    });
	}

	function readKeywordOrFunction(tokenizer) {
	    var name;

	    name = scanWord(tokenizer);

	    if (tokenizer.charCode() === LEFTPARENTHESIS) {
	        tokenizer.pos++;

	        return {
	            type: 'Function',
	            name: name
	        };
	    }

	    return maybeMultiplied(tokenizer, {
	        type: 'Keyword',
	        name: name
	    });
	}

	function regroupTerms(terms, combinators) {
	    function createGroup(terms, combinator) {
	        return {
	            type: 'Group',
	            terms: terms,
	            combinator: combinator,
	            disallowEmpty: false,
	            explicit: false
	        };
	    }

	    combinators = Object.keys(combinators).sort(function(a, b) {
	        return COMBINATOR_PRECEDENCE[a] - COMBINATOR_PRECEDENCE[b];
	    });

	    while (combinators.length > 0) {
	        var combinator = combinators.shift();
	        for (var i = 0, subgroupStart = 0; i < terms.length; i++) {
	            var term = terms[i];
	            if (term.type === 'Combinator') {
	                if (term.value === combinator) {
	                    if (subgroupStart === -1) {
	                        subgroupStart = i - 1;
	                    }
	                    terms.splice(i, 1);
	                    i--;
	                } else {
	                    if (subgroupStart !== -1 && i - subgroupStart > 1) {
	                        terms.splice(
	                            subgroupStart,
	                            i - subgroupStart,
	                            createGroup(terms.slice(subgroupStart, i), combinator)
	                        );
	                        i = subgroupStart + 1;
	                    }
	                    subgroupStart = -1;
	                }
	            }
	        }

	        if (subgroupStart !== -1 && combinators.length) {
	            terms.splice(
	                subgroupStart,
	                i - subgroupStart,
	                createGroup(terms.slice(subgroupStart, i), combinator)
	            );
	        }
	    }

	    return combinator;
	}

	function readImplicitGroup(tokenizer) {
	    var terms = [];
	    var combinators = {};
	    var token;
	    var prevToken = null;
	    var prevTokenPos = tokenizer.pos;

	    while (token = peek(tokenizer)) {
	        if (token.type !== 'Spaces') {
	            if (token.type === 'Combinator') {
	                // check for combinator in group beginning and double combinator sequence
	                if (prevToken === null || prevToken.type === 'Combinator') {
	                    tokenizer.pos = prevTokenPos;
	                    tokenizer.error('Unexpected combinator');
	                }

	                combinators[token.value] = true;
	            } else if (prevToken !== null && prevToken.type !== 'Combinator') {
	                combinators[' '] = true;  // a b
	                terms.push({
	                    type: 'Combinator',
	                    value: ' '
	                });
	            }

	            terms.push(token);
	            prevToken = token;
	            prevTokenPos = tokenizer.pos;
	        }
	    }

	    // check for combinator in group ending
	    if (prevToken !== null && prevToken.type === 'Combinator') {
	        tokenizer.pos -= prevTokenPos;
	        tokenizer.error('Unexpected combinator');
	    }

	    return {
	        type: 'Group',
	        terms: terms,
	        combinator: regroupTerms(terms, combinators) || ' ',
	        disallowEmpty: false,
	        explicit: false
	    };
	}

	function readGroup(tokenizer) {
	    var result;

	    tokenizer.eat(LEFTSQUAREBRACKET);
	    result = readImplicitGroup(tokenizer);
	    tokenizer.eat(RIGHTSQUAREBRACKET);

	    result.explicit = true;

	    if (tokenizer.charCode() === EXCLAMATIONMARK) {
	        tokenizer.pos++;
	        result.disallowEmpty = true;
	    }

	    return result;
	}

	function peek(tokenizer) {
	    var code = tokenizer.charCode();

	    if (code < 128 && NAME_CHAR[code] === 1) {
	        return readKeywordOrFunction(tokenizer);
	    }

	    switch (code) {
	        case RIGHTSQUAREBRACKET:
	            // don't eat, stop scan a group
	            break;

	        case LEFTSQUAREBRACKET:
	            return maybeMultiplied(tokenizer, readGroup(tokenizer));

	        case LESSTHANSIGN:
	            return tokenizer.nextCharCode() === APOSTROPHE
	                ? readProperty(tokenizer)
	                : readType(tokenizer);

	        case VERTICALLINE:
	            return {
	                type: 'Combinator',
	                value: tokenizer.substringToPos(
	                    tokenizer.nextCharCode() === VERTICALLINE
	                        ? tokenizer.pos + 2
	                        : tokenizer.pos + 1
	                )
	            };

	        case AMPERSAND:
	            tokenizer.pos++;
	            tokenizer.eat(AMPERSAND);

	            return {
	                type: 'Combinator',
	                value: '&&'
	            };

	        case COMMA:
	            tokenizer.pos++;
	            return {
	                type: 'Comma'
	            };

	        case APOSTROPHE:
	            return maybeMultiplied(tokenizer, {
	                type: 'String',
	                value: scanString(tokenizer)
	            });

	        case SPACE$1:
	        case TAB$1:
	        case N$2:
	        case R$1:
	        case F$1:
	            return {
	                type: 'Spaces',
	                value: scanSpaces(tokenizer)
	            };

	        case COMMERCIALAT:
	            code = tokenizer.nextCharCode();

	            if (code < 128 && NAME_CHAR[code] === 1) {
	                tokenizer.pos++;
	                return {
	                    type: 'AtKeyword',
	                    name: scanWord(tokenizer)
	                };
	            }

	            return maybeToken(tokenizer);

	        case ASTERISK:
	        case PLUSSIGN$2:
	        case QUESTIONMARK$1:
	        case NUMBERSIGN:
	        case EXCLAMATIONMARK:
	            // prohibited tokens (used as a multiplier start)
	            break;

	        case LEFTCURLYBRACKET:
	            // LEFTCURLYBRACKET is allowed since mdn/data uses it w/o quoting
	            // check next char isn't a number, because it's likely a disjoined multiplier
	            code = tokenizer.nextCharCode();

	            if (code < 48 || code > 57) {
	                return maybeToken(tokenizer);
	            }

	            break;

	        default:
	            return maybeToken(tokenizer);
	    }
	}

	function parse(source) {
	    var tokenizer = new tokenizer$1(source);
	    var result = readImplicitGroup(tokenizer);

	    if (tokenizer.pos !== source.length) {
	        tokenizer.error('Unexpected input');
	    }

	    // reduce redundant groups with single group term
	    if (result.terms.length === 1 && result.terms[0].type === 'Group') {
	        result = result.terms[0];
	    }

	    return result;
	}

	// warm up parse to elimitate code branches that never execute
	// fix soft deoptimizations (insufficient type feedback)
	parse('[a&&<b>#|<\'c\'>*||e() f{2} /,(% g#{1,2} h{2,})]!');

	var parse_1 = parse;

	var noop$2 = function() {};

	function ensureFunction(value) {
	    return typeof value === 'function' ? value : noop$2;
	}

	var walk$1 = function(node, options, context) {
	    function walk(node) {
	        enter.call(context, node);

	        switch (node.type) {
	            case 'Group':
	                node.terms.forEach(walk);
	                break;

	            case 'Multiplier':
	                walk(node.term);
	                break;

	            case 'Type':
	            case 'Property':
	            case 'Keyword':
	            case 'AtKeyword':
	            case 'Function':
	            case 'String':
	            case 'Token':
	            case 'Comma':
	                break;

	            default:
	                throw new Error('Unknown type: ' + node.type);
	        }

	        leave.call(context, node);
	    }

	    var enter = noop$2;
	    var leave = noop$2;

	    if (typeof options === 'function') {
	        enter = options;
	    } else if (options) {
	        enter = ensureFunction(options.enter);
	        leave = ensureFunction(options.leave);
	    }

	    if (enter === noop$2 && leave === noop$2) {
	        throw new Error('Neither `enter` nor `leave` walker handler is set or both aren\'t a function');
	    }

	    walk(node);
	};

	var tokenStream = new TokenStream_1();
	var astToTokens = {
	    decorator: function(handlers) {
	        var curNode = null;
	        var prev = { len: 0, node: null };
	        var nodes = [prev];
	        var buffer = '';

	        return {
	            children: handlers.children,
	            node: function(node) {
	                var tmp = curNode;
	                curNode = node;
	                handlers.node.call(this, node);
	                curNode = tmp;
	            },
	            chunk: function(chunk) {
	                buffer += chunk;
	                if (prev.node !== curNode) {
	                    nodes.push({
	                        len: chunk.length,
	                        node: curNode
	                    });
	                } else {
	                    prev.len += chunk.length;
	                }
	            },
	            result: function() {
	                return prepareTokens(buffer, nodes);
	            }
	        };
	    }
	};

	function prepareTokens(str, nodes) {
	    var tokens = [];
	    var nodesOffset = 0;
	    var nodesIndex = 0;
	    var currentNode = nodes ? nodes[nodesIndex].node : null;

	    tokenizer(str, tokenStream);

	    while (!tokenStream.eof) {
	        if (nodes) {
	            while (nodesIndex < nodes.length && nodesOffset + nodes[nodesIndex].len <= tokenStream.tokenStart) {
	                nodesOffset += nodes[nodesIndex++].len;
	                currentNode = nodes[nodesIndex].node;
	            }
	        }

	        tokens.push({
	            type: tokenStream.tokenType,
	            value: tokenStream.getTokenValue(),
	            index: tokenStream.tokenIndex, // TODO: remove it, temporary solution
	            balance: tokenStream.balance[tokenStream.tokenIndex], // TODO: remove it, temporary solution
	            node: currentNode
	        });
	        tokenStream.next();
	        // console.log({ ...tokens[tokens.length - 1], node: undefined });
	    }

	    return tokens;
	}

	var prepareTokens_1 = function(value, syntax) {
	    if (typeof value === 'string') {
	        return prepareTokens(value, null);
	    }

	    return syntax.generate(value, astToTokens);
	};

	var MATCH = { type: 'Match' };
	var MISMATCH = { type: 'Mismatch' };
	var DISALLOW_EMPTY = { type: 'DisallowEmpty' };
	var LEFTPARENTHESIS$1 = 40;  // (
	var RIGHTPARENTHESIS$1 = 41; // )

	function createCondition(match, thenBranch, elseBranch) {
	    // reduce node count
	    if (thenBranch === MATCH && elseBranch === MISMATCH) {
	        return match;
	    }

	    if (match === MATCH && thenBranch === MATCH && elseBranch === MATCH) {
	        return match;
	    }

	    if (match.type === 'If' && match.else === MISMATCH && thenBranch === MATCH) {
	        thenBranch = match.then;
	        match = match.match;
	    }

	    return {
	        type: 'If',
	        match: match,
	        then: thenBranch,
	        else: elseBranch
	    };
	}

	function isFunctionType(name) {
	    return (
	        name.length > 2 &&
	        name.charCodeAt(name.length - 2) === LEFTPARENTHESIS$1 &&
	        name.charCodeAt(name.length - 1) === RIGHTPARENTHESIS$1
	    );
	}

	function isEnumCapatible(term) {
	    return (
	        term.type === 'Keyword' ||
	        term.type === 'AtKeyword' ||
	        term.type === 'Function' ||
	        term.type === 'Type' && isFunctionType(term.name)
	    );
	}

	function buildGroupMatchGraph(combinator, terms, atLeastOneTermMatched) {
	    switch (combinator) {
	        case ' ':
	            // Juxtaposing components means that all of them must occur, in the given order.
	            //
	            // a b c
	            // =
	            // match a
	            //   then match b
	            //     then match c
	            //       then MATCH
	            //       else MISMATCH
	            //     else MISMATCH
	            //   else MISMATCH
	            var result = MATCH;

	            for (var i = terms.length - 1; i >= 0; i--) {
	                var term = terms[i];

	                result = createCondition(
	                    term,
	                    result,
	                    MISMATCH
	                );
	            }
	            return result;

	        case '|':
	            // A bar (|) separates two or more alternatives: exactly one of them must occur.
	            //
	            // a | b | c
	            // =
	            // match a
	            //   then MATCH
	            //   else match b
	            //     then MATCH
	            //     else match c
	            //       then MATCH
	            //       else MISMATCH

	            var result = MISMATCH;
	            var map = null;

	            for (var i = terms.length - 1; i >= 0; i--) {
	                var term = terms[i];

	                // reduce sequence of keywords into a Enum
	                if (isEnumCapatible(term)) {
	                    if (map === null && i > 0 && isEnumCapatible(terms[i - 1])) {
	                        map = Object.create(null);
	                        result = createCondition(
	                            {
	                                type: 'Enum',
	                                map: map
	                            },
	                            MATCH,
	                            result
	                        );
	                    }

	                    if (map !== null) {
	                        var key = (isFunctionType(term.name) ? term.name.slice(0, -1) : term.name).toLowerCase();
	                        if (key in map === false) {
	                            map[key] = term;
	                            continue;
	                        }
	                    }
	                }

	                map = null;

	                // create a new conditonal node
	                result = createCondition(
	                    term,
	                    MATCH,
	                    result
	                );
	            }
	            return result;

	        case '&&':
	            // A double ampersand (&&) separates two or more components,
	            // all of which must occur, in any order.

	            // Use MatchOnce for groups with a large number of terms,
	            // since &&-groups produces at least N!-node trees
	            if (terms.length > 5) {
	                return {
	                    type: 'MatchOnce',
	                    terms: terms,
	                    all: true
	                };
	            }

	            // Use a combination tree for groups with small number of terms
	            //
	            // a && b && c
	            // =
	            // match a
	            //   then [b && c]
	            //   else match b
	            //     then [a && c]
	            //     else match c
	            //       then [a && b]
	            //       else MISMATCH
	            //
	            // a && b
	            // =
	            // match a
	            //   then match b
	            //     then MATCH
	            //     else MISMATCH
	            //   else match b
	            //     then match a
	            //       then MATCH
	            //       else MISMATCH
	            //     else MISMATCH
	            var result = MISMATCH;

	            for (var i = terms.length - 1; i >= 0; i--) {
	                var term = terms[i];
	                var thenClause;

	                if (terms.length > 1) {
	                    thenClause = buildGroupMatchGraph(
	                        combinator,
	                        terms.filter(function(newGroupTerm) {
	                            return newGroupTerm !== term;
	                        }),
	                        false
	                    );
	                } else {
	                    thenClause = MATCH;
	                }

	                result = createCondition(
	                    term,
	                    thenClause,
	                    result
	                );
	            }
	            return result;

	        case '||':
	            // A double bar (||) separates two or more options:
	            // one or more of them must occur, in any order.

	            // Use MatchOnce for groups with a large number of terms,
	            // since ||-groups produces at least N!-node trees
	            if (terms.length > 5) {
	                return {
	                    type: 'MatchOnce',
	                    terms: terms,
	                    all: false
	                };
	            }

	            // Use a combination tree for groups with small number of terms
	            //
	            // a || b || c
	            // =
	            // match a
	            //   then [b || c]
	            //   else match b
	            //     then [a || c]
	            //     else match c
	            //       then [a || b]
	            //       else MISMATCH
	            //
	            // a || b
	            // =
	            // match a
	            //   then match b
	            //     then MATCH
	            //     else MATCH
	            //   else match b
	            //     then match a
	            //       then MATCH
	            //       else MATCH
	            //     else MISMATCH
	            var result = atLeastOneTermMatched ? MATCH : MISMATCH;

	            for (var i = terms.length - 1; i >= 0; i--) {
	                var term = terms[i];
	                var thenClause;

	                if (terms.length > 1) {
	                    thenClause = buildGroupMatchGraph(
	                        combinator,
	                        terms.filter(function(newGroupTerm) {
	                            return newGroupTerm !== term;
	                        }),
	                        true
	                    );
	                } else {
	                    thenClause = MATCH;
	                }

	                result = createCondition(
	                    term,
	                    thenClause,
	                    result
	                );
	            }
	            return result;
	    }
	}

	function buildMultiplierMatchGraph(node) {
	    var result = MATCH;
	    var matchTerm = buildMatchGraph(node.term);

	    if (node.max === 0) {
	        // disable repeating of empty match to prevent infinite loop
	        matchTerm = createCondition(
	            matchTerm,
	            DISALLOW_EMPTY,
	            MISMATCH
	        );

	        // an occurrence count is not limited, make a cycle;
	        // to collect more terms on each following matching mismatch
	        result = createCondition(
	            matchTerm,
	            null, // will be a loop
	            MISMATCH
	        );

	        result.then = createCondition(
	            MATCH,
	            MATCH,
	            result // make a loop
	        );

	        if (node.comma) {
	            result.then.else = createCondition(
	                { type: 'Comma', syntax: node },
	                result,
	                MISMATCH
	            );
	        }
	    } else {
	        // create a match node chain for [min .. max] interval with optional matches
	        for (var i = node.min || 1; i <= node.max; i++) {
	            if (node.comma && result !== MATCH) {
	                result = createCondition(
	                    { type: 'Comma', syntax: node },
	                    result,
	                    MISMATCH
	                );
	            }

	            result = createCondition(
	                matchTerm,
	                createCondition(
	                    MATCH,
	                    MATCH,
	                    result
	                ),
	                MISMATCH
	            );
	        }
	    }

	    if (node.min === 0) {
	        // allow zero match
	        result = createCondition(
	            MATCH,
	            MATCH,
	            result
	        );
	    } else {
	        // create a match node chain to collect [0 ... min - 1] required matches
	        for (var i = 0; i < node.min - 1; i++) {
	            if (node.comma && result !== MATCH) {
	                result = createCondition(
	                    { type: 'Comma', syntax: node },
	                    result,
	                    MISMATCH
	                );
	            }

	            result = createCondition(
	                matchTerm,
	                result,
	                MISMATCH
	            );
	        }
	    }

	    return result;
	}

	function buildMatchGraph(node) {
	    if (typeof node === 'function') {
	        return {
	            type: 'Generic',
	            fn: node
	        };
	    }

	    switch (node.type) {
	        case 'Group':
	            var result = buildGroupMatchGraph(
	                node.combinator,
	                node.terms.map(buildMatchGraph),
	                false
	            );

	            if (node.disallowEmpty) {
	                result = createCondition(
	                    result,
	                    DISALLOW_EMPTY,
	                    MISMATCH
	                );
	            }

	            return result;

	        case 'Multiplier':
	            return buildMultiplierMatchGraph(node);

	        case 'Type':
	        case 'Property':
	            return {
	                type: node.type,
	                name: node.name,
	                syntax: node
	            };

	        case 'Keyword':
	            return {
	                type: node.type,
	                name: node.name.toLowerCase(),
	                syntax: node
	            };

	        case 'AtKeyword':
	            return {
	                type: node.type,
	                name: '@' + node.name.toLowerCase(),
	                syntax: node
	            };

	        case 'Function':
	            return {
	                type: node.type,
	                name: node.name.toLowerCase() + '(',
	                syntax: node
	            };

	        case 'String':
	            // convert a one char length String to a Token
	            if (node.value.length === 3) {
	                return {
	                    type: 'Token',
	                    value: node.value.charAt(1),
	                    syntax: node
	                };
	            }

	            // otherwise use it as is
	            return {
	                type: node.type,
	                value: node.value.substr(1, node.value.length - 2).replace(/\\'/g, '\''),
	                syntax: node
	            };

	        case 'Token':
	            return {
	                type: node.type,
	                value: node.value,
	                syntax: node
	            };

	        case 'Comma':
	            return {
	                type: node.type,
	                syntax: node
	            };

	        default:
	            throw new Error('Unknown node type:', node.type);
	    }
	}

	var matchGraph = {
	    MATCH: MATCH,
	    MISMATCH: MISMATCH,
	    DISALLOW_EMPTY: DISALLOW_EMPTY,
	    buildMatchGraph: function(syntaxTree, ref) {
	        if (typeof syntaxTree === 'string') {
	            syntaxTree = parse_1(syntaxTree);
	        }

	        return {
	            type: 'MatchGraph',
	            match: buildMatchGraph(syntaxTree),
	            syntax: ref || null,
	            source: syntaxTree
	        };
	    }
	};

	var hasOwnProperty$1 = Object.prototype.hasOwnProperty;

	var MATCH$1 = matchGraph.MATCH;
	var MISMATCH$1 = matchGraph.MISMATCH;
	var DISALLOW_EMPTY$1 = matchGraph.DISALLOW_EMPTY;
	var TYPE$6 = _const.TYPE;

	var STUB = 0;
	var TOKEN = 1;
	var OPEN_SYNTAX = 2;
	var CLOSE_SYNTAX = 3;

	var EXIT_REASON_MATCH = 'Match';
	var EXIT_REASON_MISMATCH = 'Mismatch';
	var EXIT_REASON_ITERATION_LIMIT = 'Maximum iteration number exceeded (please fill an issue on https://github.com/csstree/csstree/issues)';

	var ITERATION_LIMIT = 15000;
	var totalIterationCount = 0;

	function reverseList(list) {
	    var prev = null;
	    var next = null;
	    var item = list;

	    while (item !== null) {
	        next = item.prev;
	        item.prev = prev;
	        prev = item;
	        item = next;
	    }

	    return prev;
	}

	function areStringsEqualCaseInsensitive(testStr, referenceStr) {
	    if (testStr.length !== referenceStr.length) {
	        return false;
	    }

	    for (var i = 0; i < testStr.length; i++) {
	        var testCode = testStr.charCodeAt(i);
	        var referenceCode = referenceStr.charCodeAt(i);

	        // testCode.toLowerCase() for U+0041 LATIN CAPITAL LETTER A (A) .. U+005A LATIN CAPITAL LETTER Z (Z).
	        if (testCode >= 0x0041 && testCode <= 0x005A) {
	            testCode = testCode | 32;
	        }

	        if (testCode !== referenceCode) {
	            return false;
	        }
	    }

	    return true;
	}

	function isCommaContextStart(token) {
	    if (token === null) {
	        return true;
	    }

	    return (
	        token.type === TYPE$6.Comma ||
	        token.type === TYPE$6.Function ||
	        token.type === TYPE$6.LeftParenthesis ||
	        token.type === TYPE$6.LeftSquareBracket ||
	        token.type === TYPE$6.LeftCurlyBracket ||
	        token.type === TYPE$6.Delim
	    );
	}

	function isCommaContextEnd(token) {
	    if (token === null) {
	        return true;
	    }

	    return (
	        token.type === TYPE$6.RightParenthesis ||
	        token.type === TYPE$6.RightSquareBracket ||
	        token.type === TYPE$6.RightCurlyBracket ||
	        token.type === TYPE$6.Delim
	    );
	}

	function internalMatch(tokens, state, syntaxes) {
	    function moveToNextToken() {
	        do {
	            tokenIndex++;
	            token = tokenIndex < tokens.length ? tokens[tokenIndex] : null;
	        } while (token !== null && (token.type === TYPE$6.WhiteSpace || token.type === TYPE$6.Comment));
	    }

	    function getNextToken(offset) {
	        var nextIndex = tokenIndex + offset;

	        return nextIndex < tokens.length ? tokens[nextIndex] : null;
	    }

	    function stateSnapshotFromSyntax(nextState, prev) {
	        return {
	            nextState: nextState,
	            matchStack: matchStack,
	            syntaxStack: syntaxStack,
	            thenStack: thenStack,
	            tokenIndex: tokenIndex,
	            prev: prev
	        };
	    }

	    function pushThenStack(nextState) {
	        thenStack = {
	            nextState: nextState,
	            matchStack: matchStack,
	            syntaxStack: syntaxStack,
	            prev: thenStack
	        };
	    }

	    function pushElseStack(nextState) {
	        elseStack = stateSnapshotFromSyntax(nextState, elseStack);
	    }

	    function addTokenToMatch() {
	        matchStack = {
	            type: TOKEN,
	            syntax: state.syntax,
	            token: token,
	            prev: matchStack
	        };

	        moveToNextToken();
	        syntaxStash = null;

	        if (tokenIndex > longestMatch) {
	            longestMatch = tokenIndex;
	        }
	    }

	    function openSyntax() {
	        syntaxStack = {
	            syntax: state.syntax,
	            opts: state.syntax.opts || (syntaxStack !== null && syntaxStack.opts) || null,
	            prev: syntaxStack
	        };

	        matchStack = {
	            type: OPEN_SYNTAX,
	            syntax: state.syntax,
	            token: matchStack.token,
	            prev: matchStack
	        };
	    }

	    function closeSyntax() {
	        if (matchStack.type === OPEN_SYNTAX) {
	            matchStack = matchStack.prev;
	        } else {
	            matchStack = {
	                type: CLOSE_SYNTAX,
	                syntax: syntaxStack.syntax,
	                token: matchStack.token,
	                prev: matchStack
	            };
	        }

	        syntaxStack = syntaxStack.prev;
	    }

	    var syntaxStack = null;
	    var thenStack = null;
	    var elseStack = null;

	    // null – stashing allowed, nothing stashed
	    // false – stashing disabled, nothing stashed
	    // anithing else – fail stashable syntaxes, some syntax stashed
	    var syntaxStash = null;

	    var iterationCount = 0; // count iterations and prevent infinite loop
	    var exitReason = null;

	    var token = null;
	    var tokenIndex = -1;
	    var longestMatch = 0;
	    var matchStack = {
	        type: STUB,
	        syntax: null,
	        token: null,
	        prev: null
	    };

	    moveToNextToken();

	    while (exitReason === null && ++iterationCount < ITERATION_LIMIT) {
	        // function mapList(list, fn) {
	        //     var result = [];
	        //     while (list) {
	        //         result.unshift(fn(list));
	        //         list = list.prev;
	        //     }
	        //     return result;
	        // }
	        // console.log('--\n',
	        //     '#' + iterationCount,
	        //     require('util').inspect({
	        //         match: mapList(matchStack, x => x.type === TOKEN ? x.token && x.token.value : x.syntax ? ({ [OPEN_SYNTAX]: '<', [CLOSE_SYNTAX]: '</' }[x.type] || x.type) + '!' + x.syntax.name : null),
	        //         token: token && token.value,
	        //         tokenIndex,
	        //         syntax: syntax.type + (syntax.id ? ' #' + syntax.id : '')
	        //     }, { depth: null })
	        // );
	        switch (state.type) {
	            case 'Match':
	                if (thenStack === null) {
	                    // turn to MISMATCH when some tokens left unmatched
	                    if (token !== null) {
	                        // doesn't mismatch if just one token left and it's an IE hack
	                        if (tokenIndex !== tokens.length - 1 || (token.value !== '\\0' && token.value !== '\\9')) {
	                            state = MISMATCH$1;
	                            break;
	                        }
	                    }

	                    // break the main loop, return a result - MATCH
	                    exitReason = EXIT_REASON_MATCH;
	                    break;
	                }

	                // go to next syntax (`then` branch)
	                state = thenStack.nextState;

	                // check match is not empty
	                if (state === DISALLOW_EMPTY$1) {
	                    if (thenStack.matchStack === matchStack) {
	                        state = MISMATCH$1;
	                        break;
	                    } else {
	                        state = MATCH$1;
	                    }
	                }

	                // close syntax if needed
	                while (thenStack.syntaxStack !== syntaxStack) {
	                    closeSyntax();
	                }

	                // pop stack
	                thenStack = thenStack.prev;
	                break;

	            case 'Mismatch':
	                // when some syntax is stashed
	                if (syntaxStash !== null && syntaxStash !== false) {
	                    // there is no else branches or a branch reduce match stack
	                    if (elseStack === null || tokenIndex > elseStack.tokenIndex) {
	                        // restore state from the stash
	                        elseStack = syntaxStash;
	                        syntaxStash = false; // disable stashing
	                    }
	                } else if (elseStack === null) {
	                    // no else branches -> break the main loop
	                    // return a result - MISMATCH
	                    exitReason = EXIT_REASON_MISMATCH;
	                    break;
	                }

	                // go to next syntax (`else` branch)
	                state = elseStack.nextState;

	                // restore all the rest stack states
	                thenStack = elseStack.thenStack;
	                syntaxStack = elseStack.syntaxStack;
	                matchStack = elseStack.matchStack;
	                tokenIndex = elseStack.tokenIndex;
	                token = tokenIndex < tokens.length ? tokens[tokenIndex] : null;

	                // pop stack
	                elseStack = elseStack.prev;
	                break;

	            case 'MatchGraph':
	                state = state.match;
	                break;

	            case 'If':
	                // IMPORTANT: else stack push must go first,
	                // since it stores the state of thenStack before changes
	                if (state.else !== MISMATCH$1) {
	                    pushElseStack(state.else);
	                }

	                if (state.then !== MATCH$1) {
	                    pushThenStack(state.then);
	                }

	                state = state.match;
	                break;

	            case 'MatchOnce':
	                state = {
	                    type: 'MatchOnceBuffer',
	                    syntax: state,
	                    index: 0,
	                    mask: 0
	                };
	                break;

	            case 'MatchOnceBuffer':
	                var terms = state.syntax.terms;

	                if (state.index === terms.length) {
	                    // no matches at all or it's required all terms to be matched
	                    if (state.mask === 0 || state.syntax.all) {
	                        state = MISMATCH$1;
	                        break;
	                    }

	                    // a partial match is ok
	                    state = MATCH$1;
	                    break;
	                }

	                // all terms are matched
	                if (state.mask === (1 << terms.length) - 1) {
	                    state = MATCH$1;
	                    break;
	                }

	                for (; state.index < terms.length; state.index++) {
	                    var matchFlag = 1 << state.index;

	                    if ((state.mask & matchFlag) === 0) {
	                        // IMPORTANT: else stack push must go first,
	                        // since it stores the state of thenStack before changes
	                        pushElseStack(state);
	                        pushThenStack({
	                            type: 'AddMatchOnce',
	                            syntax: state.syntax,
	                            mask: state.mask | matchFlag
	                        });

	                        // match
	                        state = terms[state.index++];
	                        break;
	                    }
	                }
	                break;

	            case 'AddMatchOnce':
	                state = {
	                    type: 'MatchOnceBuffer',
	                    syntax: state.syntax,
	                    index: 0,
	                    mask: state.mask
	                };
	                break;

	            case 'Enum':
	                if (token !== null) {
	                    var name = token.value.toLowerCase();

	                    // drop \0 and \9 hack from keyword name
	                    if (name.indexOf('\\') !== -1) {
	                        name = name.replace(/\\[09].*$/, '');
	                    }

	                    if (hasOwnProperty$1.call(state.map, name)) {
	                        state = state.map[name];
	                        break;
	                    }
	                }

	                state = MISMATCH$1;
	                break;

	            case 'Generic':
	                var opts = syntaxStack !== null ? syntaxStack.opts : null;
	                var lastTokenIndex = tokenIndex + Math.floor(state.fn(token, getNextToken, opts));

	                if (!isNaN(lastTokenIndex) && lastTokenIndex > tokenIndex) {
	                    while (tokenIndex < lastTokenIndex) {
	                        addTokenToMatch();
	                    }

	                    state = MATCH$1;
	                } else {
	                    state = MISMATCH$1;
	                }

	                break;

	            case 'Type':
	            case 'Property':
	                var syntaxDict = state.type === 'Type' ? 'types' : 'properties';
	                var dictSyntax = hasOwnProperty$1.call(syntaxes, syntaxDict) ? syntaxes[syntaxDict][state.name] : null;

	                if (!dictSyntax || !dictSyntax.match) {
	                    throw new Error(
	                        'Bad syntax reference: ' +
	                        (state.type === 'Type'
	                            ? '<' + state.name + '>'
	                            : '<\'' + state.name + '\'>')
	                    );
	                }

	                // stash a syntax for types with low priority
	                if (syntaxStash !== false && token !== null && state.type === 'Type') {
	                    var lowPriorityMatching =
	                        // https://drafts.csswg.org/css-values-4/#custom-idents
	                        // When parsing positionally-ambiguous keywords in a property value, a <custom-ident> production
	                        // can only claim the keyword if no other unfulfilled production can claim it.
	                        (state.name === 'custom-ident' && token.type === TYPE$6.Ident) ||

	                        // https://drafts.csswg.org/css-values-4/#lengths
	                        // ... if a `0` could be parsed as either a <number> or a <length> in a property (such as line-height),
	                        // it must parse as a <number>
	                        (state.name === 'length' && token.value === '0');

	                    if (lowPriorityMatching) {
	                        if (syntaxStash === null) {
	                            syntaxStash = stateSnapshotFromSyntax(state, elseStack);
	                        }

	                        state = MISMATCH$1;
	                        break;
	                    }
	                }

	                openSyntax();
	                state = dictSyntax.match;
	                break;

	            case 'Keyword':
	                var name = state.name;

	                if (token !== null) {
	                    var keywordName = token.value;

	                    // drop \0 and \9 hack from keyword name
	                    if (keywordName.indexOf('\\') !== -1) {
	                        keywordName = keywordName.replace(/\\[09].*$/, '');
	                    }

	                    if (areStringsEqualCaseInsensitive(keywordName, name)) {
	                        addTokenToMatch();
	                        state = MATCH$1;
	                        break;
	                    }
	                }

	                state = MISMATCH$1;
	                break;

	            case 'AtKeyword':
	            case 'Function':
	                if (token !== null && areStringsEqualCaseInsensitive(token.value, state.name)) {
	                    addTokenToMatch();
	                    state = MATCH$1;
	                    break;
	                }

	                state = MISMATCH$1;
	                break;

	            case 'Token':
	                if (token !== null && token.value === state.value) {
	                    addTokenToMatch();
	                    state = MATCH$1;
	                    break;
	                }

	                state = MISMATCH$1;
	                break;

	            case 'Comma':
	                if (token !== null && token.type === TYPE$6.Comma) {
	                    if (isCommaContextStart(matchStack.token)) {
	                        state = MISMATCH$1;
	                    } else {
	                        addTokenToMatch();
	                        state = isCommaContextEnd(token) ? MISMATCH$1 : MATCH$1;
	                    }
	                } else {
	                    state = isCommaContextStart(matchStack.token) || isCommaContextEnd(token) ? MATCH$1 : MISMATCH$1;
	                }

	                break;

	            case 'String':
	                var string = '';

	                for (var lastTokenIndex = tokenIndex; lastTokenIndex < tokens.length && string.length < state.value.length; lastTokenIndex++) {
	                    string += tokens[lastTokenIndex].value;
	                }

	                if (areStringsEqualCaseInsensitive(string, state.value)) {
	                    while (tokenIndex < lastTokenIndex) {
	                        addTokenToMatch();
	                    }

	                    state = MATCH$1;
	                } else {
	                    state = MISMATCH$1;
	                }

	                break;

	            default:
	                throw new Error('Unknown node type: ' + state.type);
	        }
	    }

	    totalIterationCount += iterationCount;

	    switch (exitReason) {
	        case null:
	            console.warn('[csstree-match] BREAK after ' + ITERATION_LIMIT + ' iterations');
	            exitReason = EXIT_REASON_ITERATION_LIMIT;
	            matchStack = null;
	            break;

	        case EXIT_REASON_MATCH:
	            while (syntaxStack !== null) {
	                closeSyntax();
	            }
	            break;

	        default:
	            matchStack = null;
	    }

	    return {
	        tokens: tokens,
	        reason: exitReason,
	        iterations: iterationCount,
	        match: matchStack,
	        longestMatch: longestMatch
	    };
	}

	function matchAsList(tokens, matchGraph, syntaxes) {
	    var matchResult = internalMatch(tokens, matchGraph, syntaxes || {});

	    if (matchResult.match !== null) {
	        var item = reverseList(matchResult.match).prev;

	        matchResult.match = [];

	        while (item !== null) {
	            switch (item.type) {
	                case STUB:
	                    break;

	                case OPEN_SYNTAX:
	                case CLOSE_SYNTAX:
	                    matchResult.match.push({
	                        type: item.type,
	                        syntax: item.syntax
	                    });
	                    break;

	                default:
	                    matchResult.match.push({
	                        token: item.token.value,
	                        node: item.token.node
	                    });
	                    break;
	            }

	            item = item.prev;
	        }
	    }

	    return matchResult;
	}

	function matchAsTree(tokens, matchGraph, syntaxes) {
	    var matchResult = internalMatch(tokens, matchGraph, syntaxes || {});

	    if (matchResult.match === null) {
	        return matchResult;
	    }

	    var item = matchResult.match;
	    var host = matchResult.match = {
	        syntax: matchGraph.syntax || null,
	        match: []
	    };
	    var hostStack = [host];

	    // revert a list and start with 2nd item since 1st is a stub item
	    item = reverseList(item).prev;

	    // build a tree
	    while (item !== null) {
	        switch (item.type) {
	            case OPEN_SYNTAX:
	                host.match.push(host = {
	                    syntax: item.syntax,
	                    match: []
	                });
	                hostStack.push(host);
	                break;

	            case CLOSE_SYNTAX:
	                hostStack.pop();
	                host = hostStack[hostStack.length - 1];
	                break;

	            default:
	                host.match.push({
	                    syntax: item.syntax || null,
	                    token: item.token.value,
	                    node: item.token.node
	                });
	        }

	        item = item.prev;
	    }

	    return matchResult;
	}

	var match = {
	    matchAsList: matchAsList,
	    matchAsTree: matchAsTree,
	    getTotalIterationCount: function() {
	        return totalIterationCount;
	    }
	};

	function getTrace(node) {
	    function shouldPutToTrace(syntax) {
	        if (syntax === null) {
	            return false;
	        }

	        return (
	            syntax.type === 'Type' ||
	            syntax.type === 'Property' ||
	            syntax.type === 'Keyword'
	        );
	    }

	    function hasMatch(matchNode) {
	        if (Array.isArray(matchNode.match)) {
	            // use for-loop for better perfomance
	            for (var i = 0; i < matchNode.match.length; i++) {
	                if (hasMatch(matchNode.match[i])) {
	                    if (shouldPutToTrace(matchNode.syntax)) {
	                        result.unshift(matchNode.syntax);
	                    }

	                    return true;
	                }
	            }
	        } else if (matchNode.node === node) {
	            result = shouldPutToTrace(matchNode.syntax)
	                ? [matchNode.syntax]
	                : [];

	            return true;
	        }

	        return false;
	    }

	    var result = null;

	    if (this.matched !== null) {
	        hasMatch(this.matched);
	    }

	    return result;
	}

	function testNode(match, node, fn) {
	    var trace = getTrace.call(match, node);

	    if (trace === null) {
	        return false;
	    }

	    return trace.some(fn);
	}

	function isType(node, type) {
	    return testNode(this, node, function(matchNode) {
	        return matchNode.type === 'Type' && matchNode.name === type;
	    });
	}

	function isProperty(node, property) {
	    return testNode(this, node, function(matchNode) {
	        return matchNode.type === 'Property' && matchNode.name === property;
	    });
	}

	function isKeyword(node) {
	    return testNode(this, node, function(matchNode) {
	        return matchNode.type === 'Keyword';
	    });
	}

	var trace = {
	    getTrace: getTrace,
	    isType: isType,
	    isProperty: isProperty,
	    isKeyword: isKeyword
	};

	function getFirstMatchNode(matchNode) {
	    if ('node' in matchNode) {
	        return matchNode.node;
	    }

	    return getFirstMatchNode(matchNode.match[0]);
	}

	function getLastMatchNode(matchNode) {
	    if ('node' in matchNode) {
	        return matchNode.node;
	    }

	    return getLastMatchNode(matchNode.match[matchNode.match.length - 1]);
	}

	function matchFragments(lexer, ast, match, type, name) {
	    function findFragments(matchNode) {
	        if (matchNode.syntax !== null &&
	            matchNode.syntax.type === type &&
	            matchNode.syntax.name === name) {
	            var start = getFirstMatchNode(matchNode);
	            var end = getLastMatchNode(matchNode);

	            lexer.syntax.walk(ast, function(node, item, list) {
	                if (node === start) {
	                    var nodes = new List_1();

	                    do {
	                        nodes.appendData(item.data);

	                        if (item.data === end) {
	                            break;
	                        }

	                        item = item.next;
	                    } while (item !== null);

	                    fragments.push({
	                        parent: list,
	                        nodes: nodes
	                    });
	                }
	            });
	        }

	        if (Array.isArray(matchNode.match)) {
	            matchNode.match.forEach(findFragments);
	        }
	    }

	    var fragments = [];

	    if (match.matched !== null) {
	        findFragments(match.matched);
	    }

	    return fragments;
	}

	var search = {
	    matchFragments: matchFragments
	};

	var hasOwnProperty$2 = Object.prototype.hasOwnProperty;

	function isValidNumber(value) {
	    // Number.isInteger(value) && value >= 0
	    return (
	        typeof value === 'number' &&
	        isFinite(value) &&
	        Math.floor(value) === value &&
	        value >= 0
	    );
	}

	function isValidLocation(loc) {
	    return (
	        Boolean(loc) &&
	        isValidNumber(loc.offset) &&
	        isValidNumber(loc.line) &&
	        isValidNumber(loc.column)
	    );
	}

	function createNodeStructureChecker(type, fields) {
	    return function checkNode(node, warn) {
	        if (!node || node.constructor !== Object) {
	            return warn(node, 'Type of node should be an Object');
	        }

	        for (var key in node) {
	            var valid = true;

	            if (hasOwnProperty$2.call(node, key) === false) {
	                continue;
	            }

	            if (key === 'type') {
	                if (node.type !== type) {
	                    warn(node, 'Wrong node type `' + node.type + '`, expected `' + type + '`');
	                }
	            } else if (key === 'loc') {
	                if (node.loc === null) {
	                    continue;
	                } else if (node.loc && node.loc.constructor === Object) {
	                    if (typeof node.loc.source !== 'string') {
	                        key += '.source';
	                    } else if (!isValidLocation(node.loc.start)) {
	                        key += '.start';
	                    } else if (!isValidLocation(node.loc.end)) {
	                        key += '.end';
	                    } else {
	                        continue;
	                    }
	                }

	                valid = false;
	            } else if (fields.hasOwnProperty(key)) {
	                for (var i = 0, valid = false; !valid && i < fields[key].length; i++) {
	                    var fieldType = fields[key][i];

	                    switch (fieldType) {
	                        case String:
	                            valid = typeof node[key] === 'string';
	                            break;

	                        case Boolean:
	                            valid = typeof node[key] === 'boolean';
	                            break;

	                        case null:
	                            valid = node[key] === null;
	                            break;

	                        default:
	                            if (typeof fieldType === 'string') {
	                                valid = node[key] && node[key].type === fieldType;
	                            } else if (Array.isArray(fieldType)) {
	                                valid = node[key] instanceof List_1;
	                            }
	                    }
	                }
	            } else {
	                warn(node, 'Unknown field `' + key + '` for ' + type + ' node type');
	            }

	            if (!valid) {
	                warn(node, 'Bad value for `' + type + '.' + key + '`');
	            }
	        }

	        for (var key in fields) {
	            if (hasOwnProperty$2.call(fields, key) &&
	                hasOwnProperty$2.call(node, key) === false) {
	                warn(node, 'Field `' + type + '.' + key + '` is missed');
	            }
	        }
	    };
	}

	function processStructure(name, nodeType) {
	    var structure = nodeType.structure;
	    var fields = {
	        type: String,
	        loc: true
	    };
	    var docs = {
	        type: '"' + name + '"'
	    };

	    for (var key in structure) {
	        if (hasOwnProperty$2.call(structure, key) === false) {
	            continue;
	        }

	        var docsTypes = [];
	        var fieldTypes = fields[key] = Array.isArray(structure[key])
	            ? structure[key].slice()
	            : [structure[key]];

	        for (var i = 0; i < fieldTypes.length; i++) {
	            var fieldType = fieldTypes[i];
	            if (fieldType === String || fieldType === Boolean) {
	                docsTypes.push(fieldType.name);
	            } else if (fieldType === null) {
	                docsTypes.push('null');
	            } else if (typeof fieldType === 'string') {
	                docsTypes.push('<' + fieldType + '>');
	            } else if (Array.isArray(fieldType)) {
	                docsTypes.push('List'); // TODO: use type enum
	            } else {
	                throw new Error('Wrong value `' + fieldType + '` in `' + name + '.' + key + '` structure definition');
	            }
	        }

	        docs[key] = docsTypes.join(' | ');
	    }

	    return {
	        docs: docs,
	        check: createNodeStructureChecker(name, fields)
	    };
	}

	var structure = {
	    getStructureFromConfig: function(config) {
	        var structure = {};

	        if (config.node) {
	            for (var name in config.node) {
	                if (hasOwnProperty$2.call(config.node, name)) {
	                    var nodeType = config.node[name];

	                    if (nodeType.structure) {
	                        structure[name] = processStructure(name, nodeType);
	                    } else {
	                        throw new Error('Missed `structure` field in `' + name + '` node type definition');
	                    }
	                }
	            }
	        }

	        return structure;
	    }
	};

	var SyntaxReferenceError$1 = error.SyntaxReferenceError;
	var MatchError$1 = error.MatchError;






	var buildMatchGraph$1 = matchGraph.buildMatchGraph;
	var matchAsTree$1 = match.matchAsTree;


	var getStructureFromConfig = structure.getStructureFromConfig;
	var cssWideKeywords$1 = buildMatchGraph$1('inherit | initial | unset');
	var cssWideKeywordsWithExpression = buildMatchGraph$1('inherit | initial | unset | <-ms-legacy-expression>');

	function dumpMapSyntax(map, compact, syntaxAsAst) {
	    var result = {};

	    for (var name in map) {
	        if (map[name].syntax) {
	            result[name] = syntaxAsAst
	                ? map[name].syntax
	                : generate_1(map[name].syntax, { compact: compact });
	        }
	    }

	    return result;
	}

	function valueHasVar(tokens) {
	    for (var i = 0; i < tokens.length; i++) {
	        if (tokens[i].value.toLowerCase() === 'var(') {
	            return true;
	        }
	    }

	    return false;
	}

	function buildMatchResult(match, error, iterations) {
	    return {
	        matched: match,
	        iterations: iterations,
	        error: error,
	        getTrace: trace.getTrace,
	        isType: trace.isType,
	        isProperty: trace.isProperty,
	        isKeyword: trace.isKeyword
	    };
	}

	function matchSyntax(lexer, syntax, value, useCommon) {
	    var tokens = prepareTokens_1(value, lexer.syntax);
	    var result;

	    if (valueHasVar(tokens)) {
	        return buildMatchResult(null, new Error('Matching for a tree with var() is not supported'));
	    }

	    if (useCommon) {
	        result = matchAsTree$1(tokens, lexer.valueCommonSyntax, lexer);
	    }

	    if (!useCommon || !result.match) {
	        result = matchAsTree$1(tokens, syntax.match, lexer);
	        if (!result.match) {
	            return buildMatchResult(
	                null,
	                new MatchError$1(result.reason, syntax.syntax, value, result),
	                result.iterations
	            );
	        }
	    }

	    return buildMatchResult(result.match, null, result.iterations);
	}

	var Lexer = function(config, syntax, structure) {
	    this.valueCommonSyntax = cssWideKeywords$1;
	    this.syntax = syntax;
	    this.generic = false;
	    this.atrules = {};
	    this.properties = {};
	    this.types = {};
	    this.structure = structure || getStructureFromConfig(config);

	    if (config) {
	        if (config.types) {
	            for (var name in config.types) {
	                this.addType_(name, config.types[name]);
	            }
	        }

	        if (config.generic) {
	            this.generic = true;
	            for (var name in generic) {
	                this.addType_(name, generic[name]);
	            }
	        }

	        if (config.atrules) {
	            for (var name in config.atrules) {
	                this.addAtrule_(name, config.atrules[name]);
	            }
	        }

	        if (config.properties) {
	            for (var name in config.properties) {
	                this.addProperty_(name, config.properties[name]);
	            }
	        }
	    }
	};

	Lexer.prototype = {
	    structure: {},
	    checkStructure: function(ast) {
	        function collectWarning(node, message) {
	            warns.push({
	                node: node,
	                message: message
	            });
	        }

	        var structure = this.structure;
	        var warns = [];

	        this.syntax.walk(ast, function(node) {
	            if (structure.hasOwnProperty(node.type)) {
	                structure[node.type].check(node, collectWarning);
	            } else {
	                collectWarning(node, 'Unknown node type `' + node.type + '`');
	            }
	        });

	        return warns.length ? warns : false;
	    },

	    createDescriptor: function(syntax, type, name) {
	        var ref = {
	            type: type,
	            name: name
	        };
	        var descriptor = {
	            type: type,
	            name: name,
	            syntax: null,
	            match: null
	        };

	        if (typeof syntax === 'function') {
	            descriptor.match = buildMatchGraph$1(syntax, ref);
	        } else {
	            if (typeof syntax === 'string') {
	                // lazy parsing on first access
	                Object.defineProperty(descriptor, 'syntax', {
	                    get: function() {
	                        Object.defineProperty(descriptor, 'syntax', {
	                            value: parse_1(syntax)
	                        });

	                        return descriptor.syntax;
	                    }
	                });
	            } else {
	                descriptor.syntax = syntax;
	            }

	            // lazy graph build on first access
	            Object.defineProperty(descriptor, 'match', {
	                get: function() {
	                    Object.defineProperty(descriptor, 'match', {
	                        value: buildMatchGraph$1(descriptor.syntax, ref)
	                    });

	                    return descriptor.match;
	                }
	            });
	        }

	        return descriptor;
	    },
	    addAtrule_: function(name, syntax) {
	        this.atrules[name] = {
	            prelude: syntax.prelude ? this.createDescriptor(syntax.prelude, 'AtrulePrelude', name) : null,
	            descriptors: syntax.descriptors
	                ? Object.keys(syntax.descriptors).reduce((res, name) => {
	                    res[name] = this.createDescriptor(syntax.descriptors[name], 'AtruleDescriptor', name);
	                    return res;
	                }, {})
	                : null
	        };
	    },
	    addProperty_: function(name, syntax) {
	        this.properties[name] = this.createDescriptor(syntax, 'Property', name);
	    },
	    addType_: function(name, syntax) {
	        this.types[name] = this.createDescriptor(syntax, 'Type', name);

	        if (syntax === generic['-ms-legacy-expression']) {
	            this.valueCommonSyntax = cssWideKeywordsWithExpression;
	        }
	    },

	    matchAtrulePrelude: function(atruleName, prelude) {
	        var atrule = names.keyword(atruleName);

	        var atrulePreludeSyntax = atrule.vendor
	            ? this.getAtrulePrelude(atrule.name) || this.getAtrulePrelude(atrule.basename)
	            : this.getAtrulePrelude(atrule.name);

	        if (!atrulePreludeSyntax) {
	            if (atrule.basename in this.atrules) {
	                return buildMatchResult(null, new Error('At-rule `' + atruleName + '` should not contain a prelude'));
	            }

	            return buildMatchResult(null, new SyntaxReferenceError$1('Unknown at-rule', atruleName));
	        }

	        return matchSyntax(this, atrulePreludeSyntax, prelude, true);
	    },
	    matchAtruleDescriptor: function(atruleName, descriptorName, value) {
	        var atrule = names.keyword(atruleName);
	        var descriptor = names.keyword(descriptorName);

	        var atruleEntry = atrule.vendor
	            ? this.atrules[atrule.name] || this.atrules[atrule.basename]
	            : this.atrules[atrule.name];

	        if (!atruleEntry) {
	            return buildMatchResult(null, new SyntaxReferenceError$1('Unknown at-rule', atruleName));
	        }

	        if (!atruleEntry.descriptors) {
	            return buildMatchResult(null, new Error('At-rule `' + atruleName + '` has no known descriptors'));
	        }

	        var atruleDescriptorSyntax = descriptor.vendor
	            ? atruleEntry.descriptors[descriptor.name] || atruleEntry.descriptors[descriptor.basename]
	            : atruleEntry.descriptors[descriptor.name];

	        if (!atruleDescriptorSyntax) {
	            return buildMatchResult(null, new SyntaxReferenceError$1('Unknown at-rule descriptor', descriptorName));
	        }

	        return matchSyntax(this, atruleDescriptorSyntax, value, true);
	    },
	    matchDeclaration: function(node) {
	        if (node.type !== 'Declaration') {
	            return buildMatchResult(null, new Error('Not a Declaration node'));
	        }

	        return this.matchProperty(node.property, node.value);
	    },
	    matchProperty: function(propertyName, value) {
	        var property = names.property(propertyName);

	        // don't match syntax for a custom property
	        if (property.custom) {
	            return buildMatchResult(null, new Error('Lexer matching doesn\'t applicable for custom properties'));
	        }

	        var propertySyntax = property.vendor
	            ? this.getProperty(property.name) || this.getProperty(property.basename)
	            : this.getProperty(property.name);

	        if (!propertySyntax) {
	            return buildMatchResult(null, new SyntaxReferenceError$1('Unknown property', propertyName));
	        }

	        return matchSyntax(this, propertySyntax, value, true);
	    },
	    matchType: function(typeName, value) {
	        var typeSyntax = this.getType(typeName);

	        if (!typeSyntax) {
	            return buildMatchResult(null, new SyntaxReferenceError$1('Unknown type', typeName));
	        }

	        return matchSyntax(this, typeSyntax, value, false);
	    },
	    match: function(syntax, value) {
	        if (typeof syntax !== 'string' && (!syntax || !syntax.type)) {
	            return buildMatchResult(null, new SyntaxReferenceError$1('Bad syntax'));
	        }

	        if (typeof syntax === 'string' || !syntax.match) {
	            syntax = this.createDescriptor(syntax, 'Type', 'anonymous');
	        }

	        return matchSyntax(this, syntax, value, false);
	    },

	    findValueFragments: function(propertyName, value, type, name) {
	        return search.matchFragments(this, value, this.matchProperty(propertyName, value), type, name);
	    },
	    findDeclarationValueFragments: function(declaration, type, name) {
	        return search.matchFragments(this, declaration.value, this.matchDeclaration(declaration), type, name);
	    },
	    findAllFragments: function(ast, type, name) {
	        var result = [];

	        this.syntax.walk(ast, {
	            visit: 'Declaration',
	            enter: function(declaration) {
	                result.push.apply(result, this.findDeclarationValueFragments(declaration, type, name));
	            }.bind(this)
	        });

	        return result;
	    },

	    getAtrulePrelude: function(atruleName) {
	        return this.atrules.hasOwnProperty(atruleName) ? this.atrules[atruleName].prelude : null;
	    },
	    getAtruleDescriptor: function(atruleName, name) {
	        return this.atrules.hasOwnProperty(atruleName) && this.atrules.declarators
	            ? this.atrules[atruleName].declarators[name] || null
	            : null;
	    },
	    getProperty: function(name) {
	        return this.properties.hasOwnProperty(name) ? this.properties[name] : null;
	    },
	    getType: function(name) {
	        return this.types.hasOwnProperty(name) ? this.types[name] : null;
	    },

	    validate: function() {
	        function validate(syntax, name, broken, descriptor) {
	            if (broken.hasOwnProperty(name)) {
	                return broken[name];
	            }

	            broken[name] = false;
	            if (descriptor.syntax !== null) {
	                walk$1(descriptor.syntax, function(node) {
	                    if (node.type !== 'Type' && node.type !== 'Property') {
	                        return;
	                    }

	                    var map = node.type === 'Type' ? syntax.types : syntax.properties;
	                    var brokenMap = node.type === 'Type' ? brokenTypes : brokenProperties;

	                    if (!map.hasOwnProperty(node.name) || validate(syntax, node.name, brokenMap, map[node.name])) {
	                        broken[name] = true;
	                    }
	                }, this);
	            }
	        }

	        var brokenTypes = {};
	        var brokenProperties = {};

	        for (var key in this.types) {
	            validate(this, key, brokenTypes, this.types[key]);
	        }

	        for (var key in this.properties) {
	            validate(this, key, brokenProperties, this.properties[key]);
	        }

	        brokenTypes = Object.keys(brokenTypes).filter(function(name) {
	            return brokenTypes[name];
	        });
	        brokenProperties = Object.keys(brokenProperties).filter(function(name) {
	            return brokenProperties[name];
	        });

	        if (brokenTypes.length || brokenProperties.length) {
	            return {
	                types: brokenTypes,
	                properties: brokenProperties
	            };
	        }

	        return null;
	    },
	    dump: function(syntaxAsAst, pretty) {
	        return {
	            generic: this.generic,
	            types: dumpMapSyntax(this.types, !pretty, syntaxAsAst),
	            properties: dumpMapSyntax(this.properties, !pretty, syntaxAsAst)
	        };
	    },
	    toString: function() {
	        return JSON.stringify(this.dump());
	    }
	};

	var Lexer_1 = Lexer;

	var definitionSyntax = {
	    SyntaxError: _SyntaxError$1,
	    parse: parse_1,
	    generate: generate_1,
	    walk: walk$1
	};

	var isBOM$2 = tokenizer.isBOM;

	var N$3 = 10;
	var F$2 = 12;
	var R$2 = 13;

	function computeLinesAndColumns(host, source) {
	    var sourceLength = source.length;
	    var lines = adoptBuffer(host.lines, sourceLength); // +1
	    var line = host.startLine;
	    var columns = adoptBuffer(host.columns, sourceLength);
	    var column = host.startColumn;
	    var startOffset = source.length > 0 ? isBOM$2(source.charCodeAt(0)) : 0;

	    for (var i = startOffset; i < sourceLength; i++) { // -1
	        var code = source.charCodeAt(i);

	        lines[i] = line;
	        columns[i] = column++;

	        if (code === N$3 || code === R$2 || code === F$2) {
	            if (code === R$2 && i + 1 < sourceLength && source.charCodeAt(i + 1) === N$3) {
	                i++;
	                lines[i] = line;
	                columns[i] = column;
	            }

	            line++;
	            column = 1;
	        }
	    }

	    lines[i] = line;
	    columns[i] = column;

	    host.lines = lines;
	    host.columns = columns;
	}

	var OffsetToLocation = function() {
	    this.lines = null;
	    this.columns = null;
	    this.linesAndColumnsComputed = false;
	};

	OffsetToLocation.prototype = {
	    setSource: function(source, startOffset, startLine, startColumn) {
	        this.source = source;
	        this.startOffset = typeof startOffset === 'undefined' ? 0 : startOffset;
	        this.startLine = typeof startLine === 'undefined' ? 1 : startLine;
	        this.startColumn = typeof startColumn === 'undefined' ? 1 : startColumn;
	        this.linesAndColumnsComputed = false;
	    },

	    ensureLinesAndColumnsComputed: function() {
	        if (!this.linesAndColumnsComputed) {
	            computeLinesAndColumns(this, this.source);
	            this.linesAndColumnsComputed = true;
	        }
	    },
	    getLocation: function(offset, filename) {
	        this.ensureLinesAndColumnsComputed();

	        return {
	            source: filename,
	            offset: this.startOffset + offset,
	            line: this.lines[offset],
	            column: this.columns[offset]
	        };
	    },
	    getLocationRange: function(start, end, filename) {
	        this.ensureLinesAndColumnsComputed();

	        return {
	            source: filename,
	            start: {
	                offset: this.startOffset + start,
	                line: this.lines[start],
	                column: this.columns[start]
	            },
	            end: {
	                offset: this.startOffset + end,
	                line: this.lines[end],
	                column: this.columns[end]
	            }
	        };
	    }
	};

	var OffsetToLocation_1 = OffsetToLocation;

	var TYPE$7 = tokenizer.TYPE;
	var WHITESPACE$2 = TYPE$7.WhiteSpace;
	var COMMENT$2 = TYPE$7.Comment;

	var sequence = function readSequence(recognizer) {
	    var children = this.createList();
	    var child = null;
	    var context = {
	        recognizer: recognizer,
	        space: null,
	        ignoreWS: false,
	        ignoreWSAfter: false
	    };

	    this.scanner.skipSC();

	    while (!this.scanner.eof) {
	        switch (this.scanner.tokenType) {
	            case COMMENT$2:
	                this.scanner.next();
	                continue;

	            case WHITESPACE$2:
	                if (context.ignoreWS) {
	                    this.scanner.next();
	                } else {
	                    context.space = this.WhiteSpace();
	                }
	                continue;
	        }

	        child = recognizer.getNode.call(this, context);

	        if (child === undefined) {
	            break;
	        }

	        if (context.space !== null) {
	            children.push(context.space);
	            context.space = null;
	        }

	        children.push(child);

	        if (context.ignoreWSAfter) {
	            context.ignoreWSAfter = false;
	            context.ignoreWS = true;
	        } else {
	            context.ignoreWS = false;
	        }
	    }

	    return children;
	};

	var findWhiteSpaceStart$1 = utils.findWhiteSpaceStart;

	var noop$3 = function() {};

	var TYPE$8 = _const.TYPE;
	var NAME$2 = _const.NAME;
	var WHITESPACE$3 = TYPE$8.WhiteSpace;
	var IDENT$2 = TYPE$8.Ident;
	var FUNCTION = TYPE$8.Function;
	var URL$1 = TYPE$8.Url;
	var HASH = TYPE$8.Hash;
	var PERCENTAGE = TYPE$8.Percentage;
	var NUMBER$2 = TYPE$8.Number;
	var NUMBERSIGN$1 = 0x0023; // U+0023 NUMBER SIGN (#)
	var NULL = 0;

	function createParseContext(name) {
	    return function() {
	        return this[name]();
	    };
	}

	function processConfig(config) {
	    var parserConfig = {
	        context: {},
	        scope: {},
	        atrule: {},
	        pseudo: {}
	    };

	    if (config.parseContext) {
	        for (var name in config.parseContext) {
	            switch (typeof config.parseContext[name]) {
	                case 'function':
	                    parserConfig.context[name] = config.parseContext[name];
	                    break;

	                case 'string':
	                    parserConfig.context[name] = createParseContext(config.parseContext[name]);
	                    break;
	            }
	        }
	    }

	    if (config.scope) {
	        for (var name in config.scope) {
	            parserConfig.scope[name] = config.scope[name];
	        }
	    }

	    if (config.atrule) {
	        for (var name in config.atrule) {
	            var atrule = config.atrule[name];

	            if (atrule.parse) {
	                parserConfig.atrule[name] = atrule.parse;
	            }
	        }
	    }

	    if (config.pseudo) {
	        for (var name in config.pseudo) {
	            var pseudo = config.pseudo[name];

	            if (pseudo.parse) {
	                parserConfig.pseudo[name] = pseudo.parse;
	            }
	        }
	    }

	    if (config.node) {
	        for (var name in config.node) {
	            parserConfig[name] = config.node[name].parse;
	        }
	    }

	    return parserConfig;
	}

	var create$1 = function createParser(config) {
	    var parser = {
	        scanner: new TokenStream_1(),
	        locationMap: new OffsetToLocation_1(),

	        filename: '<unknown>',
	        needPositions: false,
	        onParseError: noop$3,
	        onParseErrorThrow: false,
	        parseAtrulePrelude: true,
	        parseRulePrelude: true,
	        parseValue: true,
	        parseCustomProperty: false,

	        readSequence: sequence,

	        createList: function() {
	            return new List_1();
	        },
	        createSingleNodeList: function(node) {
	            return new List_1().appendData(node);
	        },
	        getFirstListNode: function(list) {
	            return list && list.first();
	        },
	        getLastListNode: function(list) {
	            return list.last();
	        },

	        parseWithFallback: function(consumer, fallback) {
	            var startToken = this.scanner.tokenIndex;

	            try {
	                return consumer.call(this);
	            } catch (e) {
	                if (this.onParseErrorThrow) {
	                    throw e;
	                }

	                var fallbackNode = fallback.call(this, startToken);

	                this.onParseErrorThrow = true;
	                this.onParseError(e, fallbackNode);
	                this.onParseErrorThrow = false;

	                return fallbackNode;
	            }
	        },

	        lookupNonWSType: function(offset) {
	            do {
	                var type = this.scanner.lookupType(offset++);
	                if (type !== WHITESPACE$3) {
	                    return type;
	                }
	            } while (type !== NULL);

	            return NULL;
	        },

	        eat: function(tokenType) {
	            if (this.scanner.tokenType !== tokenType) {
	                var offset = this.scanner.tokenStart;
	                var message = NAME$2[tokenType] + ' is expected';

	                // tweak message and offset
	                switch (tokenType) {
	                    case IDENT$2:
	                        // when identifier is expected but there is a function or url
	                        if (this.scanner.tokenType === FUNCTION || this.scanner.tokenType === URL$1) {
	                            offset = this.scanner.tokenEnd - 1;
	                            message = 'Identifier is expected but function found';
	                        } else {
	                            message = 'Identifier is expected';
	                        }
	                        break;

	                    case HASH:
	                        if (this.scanner.isDelim(NUMBERSIGN$1)) {
	                            this.scanner.next();
	                            offset++;
	                            message = 'Name is expected';
	                        }
	                        break;

	                    case PERCENTAGE:
	                        if (this.scanner.tokenType === NUMBER$2) {
	                            offset = this.scanner.tokenEnd;
	                            message = 'Percent sign is expected';
	                        }
	                        break;

	                    default:
	                        // when test type is part of another token show error for current position + 1
	                        // e.g. eat(HYPHENMINUS) will fail on "-foo", but pointing on "-" is odd
	                        if (this.scanner.source.charCodeAt(this.scanner.tokenStart) === tokenType) {
	                            offset = offset + 1;
	                        }
	                }

	                this.error(message, offset);
	            }

	            this.scanner.next();
	        },

	        consume: function(tokenType) {
	            var value = this.scanner.getTokenValue();

	            this.eat(tokenType);

	            return value;
	        },
	        consumeFunctionName: function() {
	            var name = this.scanner.source.substring(this.scanner.tokenStart, this.scanner.tokenEnd - 1);

	            this.eat(FUNCTION);

	            return name;
	        },

	        getLocation: function(start, end) {
	            if (this.needPositions) {
	                return this.locationMap.getLocationRange(
	                    start,
	                    end,
	                    this.filename
	                );
	            }

	            return null;
	        },
	        getLocationFromList: function(list) {
	            if (this.needPositions) {
	                var head = this.getFirstListNode(list);
	                var tail = this.getLastListNode(list);
	                return this.locationMap.getLocationRange(
	                    head !== null ? head.loc.start.offset - this.locationMap.startOffset : this.scanner.tokenStart,
	                    tail !== null ? tail.loc.end.offset - this.locationMap.startOffset : this.scanner.tokenStart,
	                    this.filename
	                );
	            }

	            return null;
	        },

	        error: function(message, offset) {
	            var location = typeof offset !== 'undefined' && offset < this.scanner.source.length
	                ? this.locationMap.getLocation(offset)
	                : this.scanner.eof
	                    ? this.locationMap.getLocation(findWhiteSpaceStart$1(this.scanner.source, this.scanner.source.length - 1))
	                    : this.locationMap.getLocation(this.scanner.tokenStart);

	            throw new _SyntaxError(
	                message || 'Unexpected input',
	                this.scanner.source,
	                location.offset,
	                location.line,
	                location.column
	            );
	        }
	    };

	    config = processConfig(config || {});
	    for (var key in config) {
	        parser[key] = config[key];
	    }

	    return function(source, options) {
	        options = options || {};

	        var context = options.context || 'default';
	        var ast;

	        tokenizer(source, parser.scanner);
	        parser.locationMap.setSource(
	            source,
	            options.offset,
	            options.line,
	            options.column
	        );

	        parser.filename = options.filename || '<unknown>';
	        parser.needPositions = Boolean(options.positions);
	        parser.onParseError = typeof options.onParseError === 'function' ? options.onParseError : noop$3;
	        parser.onParseErrorThrow = false;
	        parser.parseAtrulePrelude = 'parseAtrulePrelude' in options ? Boolean(options.parseAtrulePrelude) : true;
	        parser.parseRulePrelude = 'parseRulePrelude' in options ? Boolean(options.parseRulePrelude) : true;
	        parser.parseValue = 'parseValue' in options ? Boolean(options.parseValue) : true;
	        parser.parseCustomProperty = 'parseCustomProperty' in options ? Boolean(options.parseCustomProperty) : false;

	        if (!parser.context.hasOwnProperty(context)) {
	            throw new Error('Unknown context `' + context + '`');
	        }

	        ast = parser.context[context].call(parser, options);

	        if (!parser.scanner.eof) {
	            parser.error();
	        }

	        return ast;
	    };
	};

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */

	var intToCharMap = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.split('');

	/**
	 * Encode an integer in the range of 0 to 63 to a single base 64 digit.
	 */
	var encode = function (number) {
	  if (0 <= number && number < intToCharMap.length) {
	    return intToCharMap[number];
	  }
	  throw new TypeError("Must be between 0 and 63: " + number);
	};

	/**
	 * Decode a single base 64 character code digit to an integer. Returns -1 on
	 * failure.
	 */
	var decode = function (charCode) {
	  var bigA = 65;     // 'A'
	  var bigZ = 90;     // 'Z'

	  var littleA = 97;  // 'a'
	  var littleZ = 122; // 'z'

	  var zero = 48;     // '0'
	  var nine = 57;     // '9'

	  var plus = 43;     // '+'
	  var slash = 47;    // '/'

	  var littleOffset = 26;
	  var numberOffset = 52;

	  // 0 - 25: ABCDEFGHIJKLMNOPQRSTUVWXYZ
	  if (bigA <= charCode && charCode <= bigZ) {
	    return (charCode - bigA);
	  }

	  // 26 - 51: abcdefghijklmnopqrstuvwxyz
	  if (littleA <= charCode && charCode <= littleZ) {
	    return (charCode - littleA + littleOffset);
	  }

	  // 52 - 61: 0123456789
	  if (zero <= charCode && charCode <= nine) {
	    return (charCode - zero + numberOffset);
	  }

	  // 62: +
	  if (charCode == plus) {
	    return 62;
	  }

	  // 63: /
	  if (charCode == slash) {
	    return 63;
	  }

	  // Invalid base64 digit.
	  return -1;
	};

	var base64 = {
		encode: encode,
		decode: decode
	};

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 *
	 * Based on the Base 64 VLQ implementation in Closure Compiler:
	 * https://code.google.com/p/closure-compiler/source/browse/trunk/src/com/google/debugging/sourcemap/Base64VLQ.java
	 *
	 * Copyright 2011 The Closure Compiler Authors. All rights reserved.
	 * Redistribution and use in source and binary forms, with or without
	 * modification, are permitted provided that the following conditions are
	 * met:
	 *
	 *  * Redistributions of source code must retain the above copyright
	 *    notice, this list of conditions and the following disclaimer.
	 *  * Redistributions in binary form must reproduce the above
	 *    copyright notice, this list of conditions and the following
	 *    disclaimer in the documentation and/or other materials provided
	 *    with the distribution.
	 *  * Neither the name of Google Inc. nor the names of its
	 *    contributors may be used to endorse or promote products derived
	 *    from this software without specific prior written permission.
	 *
	 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
	 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
	 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
	 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
	 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
	 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
	 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
	 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
	 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
	 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	 */



	// A single base 64 digit can contain 6 bits of data. For the base 64 variable
	// length quantities we use in the source map spec, the first bit is the sign,
	// the next four bits are the actual value, and the 6th bit is the
	// continuation bit. The continuation bit tells us whether there are more
	// digits in this value following this digit.
	//
	//   Continuation
	//   |    Sign
	//   |    |
	//   V    V
	//   101011

	var VLQ_BASE_SHIFT = 5;

	// binary: 100000
	var VLQ_BASE = 1 << VLQ_BASE_SHIFT;

	// binary: 011111
	var VLQ_BASE_MASK = VLQ_BASE - 1;

	// binary: 100000
	var VLQ_CONTINUATION_BIT = VLQ_BASE;

	/**
	 * Converts from a two-complement value to a value where the sign bit is
	 * placed in the least significant bit.  For example, as decimals:
	 *   1 becomes 2 (10 binary), -1 becomes 3 (11 binary)
	 *   2 becomes 4 (100 binary), -2 becomes 5 (101 binary)
	 */
	function toVLQSigned(aValue) {
	  return aValue < 0
	    ? ((-aValue) << 1) + 1
	    : (aValue << 1) + 0;
	}

	/**
	 * Converts to a two-complement value from a value where the sign bit is
	 * placed in the least significant bit.  For example, as decimals:
	 *   2 (10 binary) becomes 1, 3 (11 binary) becomes -1
	 *   4 (100 binary) becomes 2, 5 (101 binary) becomes -2
	 */
	function fromVLQSigned(aValue) {
	  var isNegative = (aValue & 1) === 1;
	  var shifted = aValue >> 1;
	  return isNegative
	    ? -shifted
	    : shifted;
	}

	/**
	 * Returns the base 64 VLQ encoded value.
	 */
	var encode$1 = function base64VLQ_encode(aValue) {
	  var encoded = "";
	  var digit;

	  var vlq = toVLQSigned(aValue);

	  do {
	    digit = vlq & VLQ_BASE_MASK;
	    vlq >>>= VLQ_BASE_SHIFT;
	    if (vlq > 0) {
	      // There are still more digits in this value, so we must make sure the
	      // continuation bit is marked.
	      digit |= VLQ_CONTINUATION_BIT;
	    }
	    encoded += base64.encode(digit);
	  } while (vlq > 0);

	  return encoded;
	};

	/**
	 * Decodes the next base 64 VLQ value from the given string and returns the
	 * value and the rest of the string via the out parameter.
	 */
	var decode$1 = function base64VLQ_decode(aStr, aIndex, aOutParam) {
	  var strLen = aStr.length;
	  var result = 0;
	  var shift = 0;
	  var continuation, digit;

	  do {
	    if (aIndex >= strLen) {
	      throw new Error("Expected more digits in base 64 VLQ value.");
	    }

	    digit = base64.decode(aStr.charCodeAt(aIndex++));
	    if (digit === -1) {
	      throw new Error("Invalid base64 digit: " + aStr.charAt(aIndex - 1));
	    }

	    continuation = !!(digit & VLQ_CONTINUATION_BIT);
	    digit &= VLQ_BASE_MASK;
	    result = result + (digit << shift);
	    shift += VLQ_BASE_SHIFT;
	  } while (continuation);

	  aOutParam.value = fromVLQSigned(result);
	  aOutParam.rest = aIndex;
	};

	var base64Vlq = {
		encode: encode$1,
		decode: decode$1
	};

	var util = createCommonjsModule(function (module, exports) {
	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */

	/**
	 * This is a helper function for getting values from parameter/options
	 * objects.
	 *
	 * @param args The object we are extracting values from
	 * @param name The name of the property we are getting.
	 * @param defaultValue An optional value to return if the property is missing
	 * from the object. If this is not specified and the property is missing, an
	 * error will be thrown.
	 */
	function getArg(aArgs, aName, aDefaultValue) {
	  if (aName in aArgs) {
	    return aArgs[aName];
	  } else if (arguments.length === 3) {
	    return aDefaultValue;
	  } else {
	    throw new Error('"' + aName + '" is a required argument.');
	  }
	}
	exports.getArg = getArg;

	var urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.-]*)(?::(\d+))?(.*)$/;
	var dataUrlRegexp = /^data:.+\,.+$/;

	function urlParse(aUrl) {
	  var match = aUrl.match(urlRegexp);
	  if (!match) {
	    return null;
	  }
	  return {
	    scheme: match[1],
	    auth: match[2],
	    host: match[3],
	    port: match[4],
	    path: match[5]
	  };
	}
	exports.urlParse = urlParse;

	function urlGenerate(aParsedUrl) {
	  var url = '';
	  if (aParsedUrl.scheme) {
	    url += aParsedUrl.scheme + ':';
	  }
	  url += '//';
	  if (aParsedUrl.auth) {
	    url += aParsedUrl.auth + '@';
	  }
	  if (aParsedUrl.host) {
	    url += aParsedUrl.host;
	  }
	  if (aParsedUrl.port) {
	    url += ":" + aParsedUrl.port;
	  }
	  if (aParsedUrl.path) {
	    url += aParsedUrl.path;
	  }
	  return url;
	}
	exports.urlGenerate = urlGenerate;

	/**
	 * Normalizes a path, or the path portion of a URL:
	 *
	 * - Replaces consecutive slashes with one slash.
	 * - Removes unnecessary '.' parts.
	 * - Removes unnecessary '<dir>/..' parts.
	 *
	 * Based on code in the Node.js 'path' core module.
	 *
	 * @param aPath The path or url to normalize.
	 */
	function normalize(aPath) {
	  var path = aPath;
	  var url = urlParse(aPath);
	  if (url) {
	    if (!url.path) {
	      return aPath;
	    }
	    path = url.path;
	  }
	  var isAbsolute = exports.isAbsolute(path);

	  var parts = path.split(/\/+/);
	  for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {
	    part = parts[i];
	    if (part === '.') {
	      parts.splice(i, 1);
	    } else if (part === '..') {
	      up++;
	    } else if (up > 0) {
	      if (part === '') {
	        // The first part is blank if the path is absolute. Trying to go
	        // above the root is a no-op. Therefore we can remove all '..' parts
	        // directly after the root.
	        parts.splice(i + 1, up);
	        up = 0;
	      } else {
	        parts.splice(i, 2);
	        up--;
	      }
	    }
	  }
	  path = parts.join('/');

	  if (path === '') {
	    path = isAbsolute ? '/' : '.';
	  }

	  if (url) {
	    url.path = path;
	    return urlGenerate(url);
	  }
	  return path;
	}
	exports.normalize = normalize;

	/**
	 * Joins two paths/URLs.
	 *
	 * @param aRoot The root path or URL.
	 * @param aPath The path or URL to be joined with the root.
	 *
	 * - If aPath is a URL or a data URI, aPath is returned, unless aPath is a
	 *   scheme-relative URL: Then the scheme of aRoot, if any, is prepended
	 *   first.
	 * - Otherwise aPath is a path. If aRoot is a URL, then its path portion
	 *   is updated with the result and aRoot is returned. Otherwise the result
	 *   is returned.
	 *   - If aPath is absolute, the result is aPath.
	 *   - Otherwise the two paths are joined with a slash.
	 * - Joining for example 'http://' and 'www.example.com' is also supported.
	 */
	function join(aRoot, aPath) {
	  if (aRoot === "") {
	    aRoot = ".";
	  }
	  if (aPath === "") {
	    aPath = ".";
	  }
	  var aPathUrl = urlParse(aPath);
	  var aRootUrl = urlParse(aRoot);
	  if (aRootUrl) {
	    aRoot = aRootUrl.path || '/';
	  }

	  // `join(foo, '//www.example.org')`
	  if (aPathUrl && !aPathUrl.scheme) {
	    if (aRootUrl) {
	      aPathUrl.scheme = aRootUrl.scheme;
	    }
	    return urlGenerate(aPathUrl);
	  }

	  if (aPathUrl || aPath.match(dataUrlRegexp)) {
	    return aPath;
	  }

	  // `join('http://', 'www.example.com')`
	  if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {
	    aRootUrl.host = aPath;
	    return urlGenerate(aRootUrl);
	  }

	  var joined = aPath.charAt(0) === '/'
	    ? aPath
	    : normalize(aRoot.replace(/\/+$/, '') + '/' + aPath);

	  if (aRootUrl) {
	    aRootUrl.path = joined;
	    return urlGenerate(aRootUrl);
	  }
	  return joined;
	}
	exports.join = join;

	exports.isAbsolute = function (aPath) {
	  return aPath.charAt(0) === '/' || urlRegexp.test(aPath);
	};

	/**
	 * Make a path relative to a URL or another path.
	 *
	 * @param aRoot The root path or URL.
	 * @param aPath The path or URL to be made relative to aRoot.
	 */
	function relative(aRoot, aPath) {
	  if (aRoot === "") {
	    aRoot = ".";
	  }

	  aRoot = aRoot.replace(/\/$/, '');

	  // It is possible for the path to be above the root. In this case, simply
	  // checking whether the root is a prefix of the path won't work. Instead, we
	  // need to remove components from the root one by one, until either we find
	  // a prefix that fits, or we run out of components to remove.
	  var level = 0;
	  while (aPath.indexOf(aRoot + '/') !== 0) {
	    var index = aRoot.lastIndexOf("/");
	    if (index < 0) {
	      return aPath;
	    }

	    // If the only part of the root that is left is the scheme (i.e. http://,
	    // file:///, etc.), one or more slashes (/), or simply nothing at all, we
	    // have exhausted all components, so the path is not relative to the root.
	    aRoot = aRoot.slice(0, index);
	    if (aRoot.match(/^([^\/]+:\/)?\/*$/)) {
	      return aPath;
	    }

	    ++level;
	  }

	  // Make sure we add a "../" for each component we removed from the root.
	  return Array(level + 1).join("../") + aPath.substr(aRoot.length + 1);
	}
	exports.relative = relative;

	var supportsNullProto = (function () {
	  var obj = Object.create(null);
	  return !('__proto__' in obj);
	}());

	function identity (s) {
	  return s;
	}

	/**
	 * Because behavior goes wacky when you set `__proto__` on objects, we
	 * have to prefix all the strings in our set with an arbitrary character.
	 *
	 * See https://github.com/mozilla/source-map/pull/31 and
	 * https://github.com/mozilla/source-map/issues/30
	 *
	 * @param String aStr
	 */
	function toSetString(aStr) {
	  if (isProtoString(aStr)) {
	    return '$' + aStr;
	  }

	  return aStr;
	}
	exports.toSetString = supportsNullProto ? identity : toSetString;

	function fromSetString(aStr) {
	  if (isProtoString(aStr)) {
	    return aStr.slice(1);
	  }

	  return aStr;
	}
	exports.fromSetString = supportsNullProto ? identity : fromSetString;

	function isProtoString(s) {
	  if (!s) {
	    return false;
	  }

	  var length = s.length;

	  if (length < 9 /* "__proto__".length */) {
	    return false;
	  }

	  if (s.charCodeAt(length - 1) !== 95  /* '_' */ ||
	      s.charCodeAt(length - 2) !== 95  /* '_' */ ||
	      s.charCodeAt(length - 3) !== 111 /* 'o' */ ||
	      s.charCodeAt(length - 4) !== 116 /* 't' */ ||
	      s.charCodeAt(length - 5) !== 111 /* 'o' */ ||
	      s.charCodeAt(length - 6) !== 114 /* 'r' */ ||
	      s.charCodeAt(length - 7) !== 112 /* 'p' */ ||
	      s.charCodeAt(length - 8) !== 95  /* '_' */ ||
	      s.charCodeAt(length - 9) !== 95  /* '_' */) {
	    return false;
	  }

	  for (var i = length - 10; i >= 0; i--) {
	    if (s.charCodeAt(i) !== 36 /* '$' */) {
	      return false;
	    }
	  }

	  return true;
	}

	/**
	 * Comparator between two mappings where the original positions are compared.
	 *
	 * Optionally pass in `true` as `onlyCompareGenerated` to consider two
	 * mappings with the same original source/line/column, but different generated
	 * line and column the same. Useful when searching for a mapping with a
	 * stubbed out mapping.
	 */
	function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {
	  var cmp = strcmp(mappingA.source, mappingB.source);
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalLine - mappingB.originalLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalColumn - mappingB.originalColumn;
	  if (cmp !== 0 || onlyCompareOriginal) {
	    return cmp;
	  }

	  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.generatedLine - mappingB.generatedLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  return strcmp(mappingA.name, mappingB.name);
	}
	exports.compareByOriginalPositions = compareByOriginalPositions;

	/**
	 * Comparator between two mappings with deflated source and name indices where
	 * the generated positions are compared.
	 *
	 * Optionally pass in `true` as `onlyCompareGenerated` to consider two
	 * mappings with the same generated line and column, but different
	 * source/name/original line and column the same. Useful when searching for a
	 * mapping with a stubbed out mapping.
	 */
	function compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {
	  var cmp = mappingA.generatedLine - mappingB.generatedLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
	  if (cmp !== 0 || onlyCompareGenerated) {
	    return cmp;
	  }

	  cmp = strcmp(mappingA.source, mappingB.source);
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalLine - mappingB.originalLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalColumn - mappingB.originalColumn;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  return strcmp(mappingA.name, mappingB.name);
	}
	exports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;

	function strcmp(aStr1, aStr2) {
	  if (aStr1 === aStr2) {
	    return 0;
	  }

	  if (aStr1 === null) {
	    return 1; // aStr2 !== null
	  }

	  if (aStr2 === null) {
	    return -1; // aStr1 !== null
	  }

	  if (aStr1 > aStr2) {
	    return 1;
	  }

	  return -1;
	}

	/**
	 * Comparator between two mappings with inflated source and name strings where
	 * the generated positions are compared.
	 */
	function compareByGeneratedPositionsInflated(mappingA, mappingB) {
	  var cmp = mappingA.generatedLine - mappingB.generatedLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = strcmp(mappingA.source, mappingB.source);
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalLine - mappingB.originalLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalColumn - mappingB.originalColumn;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  return strcmp(mappingA.name, mappingB.name);
	}
	exports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;

	/**
	 * Strip any JSON XSSI avoidance prefix from the string (as documented
	 * in the source maps specification), and then parse the string as
	 * JSON.
	 */
	function parseSourceMapInput(str) {
	  return JSON.parse(str.replace(/^\)]}'[^\n]*\n/, ''));
	}
	exports.parseSourceMapInput = parseSourceMapInput;

	/**
	 * Compute the URL of a source given the the source root, the source's
	 * URL, and the source map's URL.
	 */
	function computeSourceURL(sourceRoot, sourceURL, sourceMapURL) {
	  sourceURL = sourceURL || '';

	  if (sourceRoot) {
	    // This follows what Chrome does.
	    if (sourceRoot[sourceRoot.length - 1] !== '/' && sourceURL[0] !== '/') {
	      sourceRoot += '/';
	    }
	    // The spec says:
	    //   Line 4: An optional source root, useful for relocating source
	    //   files on a server or removing repeated values in the
	    //   “sources” entry.  This value is prepended to the individual
	    //   entries in the “source” field.
	    sourceURL = sourceRoot + sourceURL;
	  }

	  // Historically, SourceMapConsumer did not take the sourceMapURL as
	  // a parameter.  This mode is still somewhat supported, which is why
	  // this code block is conditional.  However, it's preferable to pass
	  // the source map URL to SourceMapConsumer, so that this function
	  // can implement the source URL resolution algorithm as outlined in
	  // the spec.  This block is basically the equivalent of:
	  //    new URL(sourceURL, sourceMapURL).toString()
	  // ... except it avoids using URL, which wasn't available in the
	  // older releases of node still supported by this library.
	  //
	  // The spec says:
	  //   If the sources are not absolute URLs after prepending of the
	  //   “sourceRoot”, the sources are resolved relative to the
	  //   SourceMap (like resolving script src in a html document).
	  if (sourceMapURL) {
	    var parsed = urlParse(sourceMapURL);
	    if (!parsed) {
	      throw new Error("sourceMapURL could not be parsed");
	    }
	    if (parsed.path) {
	      // Strip the last path component, but keep the "/".
	      var index = parsed.path.lastIndexOf('/');
	      if (index >= 0) {
	        parsed.path = parsed.path.substring(0, index + 1);
	      }
	    }
	    sourceURL = join(urlGenerate(parsed), sourceURL);
	  }

	  return normalize(sourceURL);
	}
	exports.computeSourceURL = computeSourceURL;
	});
	var util_1 = util.getArg;
	var util_2 = util.urlParse;
	var util_3 = util.urlGenerate;
	var util_4 = util.normalize;
	var util_5 = util.join;
	var util_6 = util.isAbsolute;
	var util_7 = util.relative;
	var util_8 = util.toSetString;
	var util_9 = util.fromSetString;
	var util_10 = util.compareByOriginalPositions;
	var util_11 = util.compareByGeneratedPositionsDeflated;
	var util_12 = util.compareByGeneratedPositionsInflated;
	var util_13 = util.parseSourceMapInput;
	var util_14 = util.computeSourceURL;

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */


	var has = Object.prototype.hasOwnProperty;
	var hasNativeMap = typeof Map !== "undefined";

	/**
	 * A data structure which is a combination of an array and a set. Adding a new
	 * member is O(1), testing for membership is O(1), and finding the index of an
	 * element is O(1). Removing elements from the set is not supported. Only
	 * strings are supported for membership.
	 */
	function ArraySet() {
	  this._array = [];
	  this._set = hasNativeMap ? new Map() : Object.create(null);
	}

	/**
	 * Static method for creating ArraySet instances from an existing array.
	 */
	ArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {
	  var set = new ArraySet();
	  for (var i = 0, len = aArray.length; i < len; i++) {
	    set.add(aArray[i], aAllowDuplicates);
	  }
	  return set;
	};

	/**
	 * Return how many unique items are in this ArraySet. If duplicates have been
	 * added, than those do not count towards the size.
	 *
	 * @returns Number
	 */
	ArraySet.prototype.size = function ArraySet_size() {
	  return hasNativeMap ? this._set.size : Object.getOwnPropertyNames(this._set).length;
	};

	/**
	 * Add the given string to this set.
	 *
	 * @param String aStr
	 */
	ArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {
	  var sStr = hasNativeMap ? aStr : util.toSetString(aStr);
	  var isDuplicate = hasNativeMap ? this.has(aStr) : has.call(this._set, sStr);
	  var idx = this._array.length;
	  if (!isDuplicate || aAllowDuplicates) {
	    this._array.push(aStr);
	  }
	  if (!isDuplicate) {
	    if (hasNativeMap) {
	      this._set.set(aStr, idx);
	    } else {
	      this._set[sStr] = idx;
	    }
	  }
	};

	/**
	 * Is the given string a member of this set?
	 *
	 * @param String aStr
	 */
	ArraySet.prototype.has = function ArraySet_has(aStr) {
	  if (hasNativeMap) {
	    return this._set.has(aStr);
	  } else {
	    var sStr = util.toSetString(aStr);
	    return has.call(this._set, sStr);
	  }
	};

	/**
	 * What is the index of the given string in the array?
	 *
	 * @param String aStr
	 */
	ArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {
	  if (hasNativeMap) {
	    var idx = this._set.get(aStr);
	    if (idx >= 0) {
	        return idx;
	    }
	  } else {
	    var sStr = util.toSetString(aStr);
	    if (has.call(this._set, sStr)) {
	      return this._set[sStr];
	    }
	  }

	  throw new Error('"' + aStr + '" is not in the set.');
	};

	/**
	 * What is the element at the given index?
	 *
	 * @param Number aIdx
	 */
	ArraySet.prototype.at = function ArraySet_at(aIdx) {
	  if (aIdx >= 0 && aIdx < this._array.length) {
	    return this._array[aIdx];
	  }
	  throw new Error('No element indexed by ' + aIdx);
	};

	/**
	 * Returns the array representation of this set (which has the proper indices
	 * indicated by indexOf). Note that this is a copy of the internal array used
	 * for storing the members so that no one can mess with internal state.
	 */
	ArraySet.prototype.toArray = function ArraySet_toArray() {
	  return this._array.slice();
	};

	var ArraySet_1 = ArraySet;

	var arraySet = {
		ArraySet: ArraySet_1
	};

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2014 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */



	/**
	 * Determine whether mappingB is after mappingA with respect to generated
	 * position.
	 */
	function generatedPositionAfter(mappingA, mappingB) {
	  // Optimized for most common case
	  var lineA = mappingA.generatedLine;
	  var lineB = mappingB.generatedLine;
	  var columnA = mappingA.generatedColumn;
	  var columnB = mappingB.generatedColumn;
	  return lineB > lineA || lineB == lineA && columnB >= columnA ||
	         util.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;
	}

	/**
	 * A data structure to provide a sorted view of accumulated mappings in a
	 * performance conscious manner. It trades a neglibable overhead in general
	 * case for a large speedup in case of mappings being added in order.
	 */
	function MappingList() {
	  this._array = [];
	  this._sorted = true;
	  // Serves as infimum
	  this._last = {generatedLine: -1, generatedColumn: 0};
	}

	/**
	 * Iterate through internal items. This method takes the same arguments that
	 * `Array.prototype.forEach` takes.
	 *
	 * NOTE: The order of the mappings is NOT guaranteed.
	 */
	MappingList.prototype.unsortedForEach =
	  function MappingList_forEach(aCallback, aThisArg) {
	    this._array.forEach(aCallback, aThisArg);
	  };

	/**
	 * Add the given source mapping.
	 *
	 * @param Object aMapping
	 */
	MappingList.prototype.add = function MappingList_add(aMapping) {
	  if (generatedPositionAfter(this._last, aMapping)) {
	    this._last = aMapping;
	    this._array.push(aMapping);
	  } else {
	    this._sorted = false;
	    this._array.push(aMapping);
	  }
	};

	/**
	 * Returns the flat, sorted array of mappings. The mappings are sorted by
	 * generated position.
	 *
	 * WARNING: This method returns internal data without copying, for
	 * performance. The return value must NOT be mutated, and should be treated as
	 * an immutable borrow. If you want to take ownership, you must make your own
	 * copy.
	 */
	MappingList.prototype.toArray = function MappingList_toArray() {
	  if (!this._sorted) {
	    this._array.sort(util.compareByGeneratedPositionsInflated);
	    this._sorted = true;
	  }
	  return this._array;
	};

	var MappingList_1 = MappingList;

	var mappingList = {
		MappingList: MappingList_1
	};

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */



	var ArraySet$1 = arraySet.ArraySet;
	var MappingList$1 = mappingList.MappingList;

	/**
	 * An instance of the SourceMapGenerator represents a source map which is
	 * being built incrementally. You may pass an object with the following
	 * properties:
	 *
	 *   - file: The filename of the generated source.
	 *   - sourceRoot: A root for all relative URLs in this source map.
	 */
	function SourceMapGenerator(aArgs) {
	  if (!aArgs) {
	    aArgs = {};
	  }
	  this._file = util.getArg(aArgs, 'file', null);
	  this._sourceRoot = util.getArg(aArgs, 'sourceRoot', null);
	  this._skipValidation = util.getArg(aArgs, 'skipValidation', false);
	  this._sources = new ArraySet$1();
	  this._names = new ArraySet$1();
	  this._mappings = new MappingList$1();
	  this._sourcesContents = null;
	}

	SourceMapGenerator.prototype._version = 3;

	/**
	 * Creates a new SourceMapGenerator based on a SourceMapConsumer
	 *
	 * @param aSourceMapConsumer The SourceMap.
	 */
	SourceMapGenerator.fromSourceMap =
	  function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {
	    var sourceRoot = aSourceMapConsumer.sourceRoot;
	    var generator = new SourceMapGenerator({
	      file: aSourceMapConsumer.file,
	      sourceRoot: sourceRoot
	    });
	    aSourceMapConsumer.eachMapping(function (mapping) {
	      var newMapping = {
	        generated: {
	          line: mapping.generatedLine,
	          column: mapping.generatedColumn
	        }
	      };

	      if (mapping.source != null) {
	        newMapping.source = mapping.source;
	        if (sourceRoot != null) {
	          newMapping.source = util.relative(sourceRoot, newMapping.source);
	        }

	        newMapping.original = {
	          line: mapping.originalLine,
	          column: mapping.originalColumn
	        };

	        if (mapping.name != null) {
	          newMapping.name = mapping.name;
	        }
	      }

	      generator.addMapping(newMapping);
	    });
	    aSourceMapConsumer.sources.forEach(function (sourceFile) {
	      var sourceRelative = sourceFile;
	      if (sourceRoot !== null) {
	        sourceRelative = util.relative(sourceRoot, sourceFile);
	      }

	      if (!generator._sources.has(sourceRelative)) {
	        generator._sources.add(sourceRelative);
	      }

	      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
	      if (content != null) {
	        generator.setSourceContent(sourceFile, content);
	      }
	    });
	    return generator;
	  };

	/**
	 * Add a single mapping from original source line and column to the generated
	 * source's line and column for this source map being created. The mapping
	 * object should have the following properties:
	 *
	 *   - generated: An object with the generated line and column positions.
	 *   - original: An object with the original line and column positions.
	 *   - source: The original source file (relative to the sourceRoot).
	 *   - name: An optional original token name for this mapping.
	 */
	SourceMapGenerator.prototype.addMapping =
	  function SourceMapGenerator_addMapping(aArgs) {
	    var generated = util.getArg(aArgs, 'generated');
	    var original = util.getArg(aArgs, 'original', null);
	    var source = util.getArg(aArgs, 'source', null);
	    var name = util.getArg(aArgs, 'name', null);

	    if (!this._skipValidation) {
	      this._validateMapping(generated, original, source, name);
	    }

	    if (source != null) {
	      source = String(source);
	      if (!this._sources.has(source)) {
	        this._sources.add(source);
	      }
	    }

	    if (name != null) {
	      name = String(name);
	      if (!this._names.has(name)) {
	        this._names.add(name);
	      }
	    }

	    this._mappings.add({
	      generatedLine: generated.line,
	      generatedColumn: generated.column,
	      originalLine: original != null && original.line,
	      originalColumn: original != null && original.column,
	      source: source,
	      name: name
	    });
	  };

	/**
	 * Set the source content for a source file.
	 */
	SourceMapGenerator.prototype.setSourceContent =
	  function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {
	    var source = aSourceFile;
	    if (this._sourceRoot != null) {
	      source = util.relative(this._sourceRoot, source);
	    }

	    if (aSourceContent != null) {
	      // Add the source content to the _sourcesContents map.
	      // Create a new _sourcesContents map if the property is null.
	      if (!this._sourcesContents) {
	        this._sourcesContents = Object.create(null);
	      }
	      this._sourcesContents[util.toSetString(source)] = aSourceContent;
	    } else if (this._sourcesContents) {
	      // Remove the source file from the _sourcesContents map.
	      // If the _sourcesContents map is empty, set the property to null.
	      delete this._sourcesContents[util.toSetString(source)];
	      if (Object.keys(this._sourcesContents).length === 0) {
	        this._sourcesContents = null;
	      }
	    }
	  };

	/**
	 * Applies the mappings of a sub-source-map for a specific source file to the
	 * source map being generated. Each mapping to the supplied source file is
	 * rewritten using the supplied source map. Note: The resolution for the
	 * resulting mappings is the minimium of this map and the supplied map.
	 *
	 * @param aSourceMapConsumer The source map to be applied.
	 * @param aSourceFile Optional. The filename of the source file.
	 *        If omitted, SourceMapConsumer's file property will be used.
	 * @param aSourceMapPath Optional. The dirname of the path to the source map
	 *        to be applied. If relative, it is relative to the SourceMapConsumer.
	 *        This parameter is needed when the two source maps aren't in the same
	 *        directory, and the source map to be applied contains relative source
	 *        paths. If so, those relative source paths need to be rewritten
	 *        relative to the SourceMapGenerator.
	 */
	SourceMapGenerator.prototype.applySourceMap =
	  function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {
	    var sourceFile = aSourceFile;
	    // If aSourceFile is omitted, we will use the file property of the SourceMap
	    if (aSourceFile == null) {
	      if (aSourceMapConsumer.file == null) {
	        throw new Error(
	          'SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, ' +
	          'or the source map\'s "file" property. Both were omitted.'
	        );
	      }
	      sourceFile = aSourceMapConsumer.file;
	    }
	    var sourceRoot = this._sourceRoot;
	    // Make "sourceFile" relative if an absolute Url is passed.
	    if (sourceRoot != null) {
	      sourceFile = util.relative(sourceRoot, sourceFile);
	    }
	    // Applying the SourceMap can add and remove items from the sources and
	    // the names array.
	    var newSources = new ArraySet$1();
	    var newNames = new ArraySet$1();

	    // Find mappings for the "sourceFile"
	    this._mappings.unsortedForEach(function (mapping) {
	      if (mapping.source === sourceFile && mapping.originalLine != null) {
	        // Check if it can be mapped by the source map, then update the mapping.
	        var original = aSourceMapConsumer.originalPositionFor({
	          line: mapping.originalLine,
	          column: mapping.originalColumn
	        });
	        if (original.source != null) {
	          // Copy mapping
	          mapping.source = original.source;
	          if (aSourceMapPath != null) {
	            mapping.source = util.join(aSourceMapPath, mapping.source);
	          }
	          if (sourceRoot != null) {
	            mapping.source = util.relative(sourceRoot, mapping.source);
	          }
	          mapping.originalLine = original.line;
	          mapping.originalColumn = original.column;
	          if (original.name != null) {
	            mapping.name = original.name;
	          }
	        }
	      }

	      var source = mapping.source;
	      if (source != null && !newSources.has(source)) {
	        newSources.add(source);
	      }

	      var name = mapping.name;
	      if (name != null && !newNames.has(name)) {
	        newNames.add(name);
	      }

	    }, this);
	    this._sources = newSources;
	    this._names = newNames;

	    // Copy sourcesContents of applied map.
	    aSourceMapConsumer.sources.forEach(function (sourceFile) {
	      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
	      if (content != null) {
	        if (aSourceMapPath != null) {
	          sourceFile = util.join(aSourceMapPath, sourceFile);
	        }
	        if (sourceRoot != null) {
	          sourceFile = util.relative(sourceRoot, sourceFile);
	        }
	        this.setSourceContent(sourceFile, content);
	      }
	    }, this);
	  };

	/**
	 * A mapping can have one of the three levels of data:
	 *
	 *   1. Just the generated position.
	 *   2. The Generated position, original position, and original source.
	 *   3. Generated and original position, original source, as well as a name
	 *      token.
	 *
	 * To maintain consistency, we validate that any new mapping being added falls
	 * in to one of these categories.
	 */
	SourceMapGenerator.prototype._validateMapping =
	  function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource,
	                                              aName) {
	    // When aOriginal is truthy but has empty values for .line and .column,
	    // it is most likely a programmer error. In this case we throw a very
	    // specific error message to try to guide them the right way.
	    // For example: https://github.com/Polymer/polymer-bundler/pull/519
	    if (aOriginal && typeof aOriginal.line !== 'number' && typeof aOriginal.column !== 'number') {
	        throw new Error(
	            'original.line and original.column are not numbers -- you probably meant to omit ' +
	            'the original mapping entirely and only map the generated position. If so, pass ' +
	            'null for the original mapping instead of an object with empty or null values.'
	        );
	    }

	    if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
	        && aGenerated.line > 0 && aGenerated.column >= 0
	        && !aOriginal && !aSource && !aName) {
	      // Case 1.
	      return;
	    }
	    else if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
	             && aOriginal && 'line' in aOriginal && 'column' in aOriginal
	             && aGenerated.line > 0 && aGenerated.column >= 0
	             && aOriginal.line > 0 && aOriginal.column >= 0
	             && aSource) {
	      // Cases 2 and 3.
	      return;
	    }
	    else {
	      throw new Error('Invalid mapping: ' + JSON.stringify({
	        generated: aGenerated,
	        source: aSource,
	        original: aOriginal,
	        name: aName
	      }));
	    }
	  };

	/**
	 * Serialize the accumulated mappings in to the stream of base 64 VLQs
	 * specified by the source map format.
	 */
	SourceMapGenerator.prototype._serializeMappings =
	  function SourceMapGenerator_serializeMappings() {
	    var previousGeneratedColumn = 0;
	    var previousGeneratedLine = 1;
	    var previousOriginalColumn = 0;
	    var previousOriginalLine = 0;
	    var previousName = 0;
	    var previousSource = 0;
	    var result = '';
	    var next;
	    var mapping;
	    var nameIdx;
	    var sourceIdx;

	    var mappings = this._mappings.toArray();
	    for (var i = 0, len = mappings.length; i < len; i++) {
	      mapping = mappings[i];
	      next = '';

	      if (mapping.generatedLine !== previousGeneratedLine) {
	        previousGeneratedColumn = 0;
	        while (mapping.generatedLine !== previousGeneratedLine) {
	          next += ';';
	          previousGeneratedLine++;
	        }
	      }
	      else {
	        if (i > 0) {
	          if (!util.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])) {
	            continue;
	          }
	          next += ',';
	        }
	      }

	      next += base64Vlq.encode(mapping.generatedColumn
	                                 - previousGeneratedColumn);
	      previousGeneratedColumn = mapping.generatedColumn;

	      if (mapping.source != null) {
	        sourceIdx = this._sources.indexOf(mapping.source);
	        next += base64Vlq.encode(sourceIdx - previousSource);
	        previousSource = sourceIdx;

	        // lines are stored 0-based in SourceMap spec version 3
	        next += base64Vlq.encode(mapping.originalLine - 1
	                                   - previousOriginalLine);
	        previousOriginalLine = mapping.originalLine - 1;

	        next += base64Vlq.encode(mapping.originalColumn
	                                   - previousOriginalColumn);
	        previousOriginalColumn = mapping.originalColumn;

	        if (mapping.name != null) {
	          nameIdx = this._names.indexOf(mapping.name);
	          next += base64Vlq.encode(nameIdx - previousName);
	          previousName = nameIdx;
	        }
	      }

	      result += next;
	    }

	    return result;
	  };

	SourceMapGenerator.prototype._generateSourcesContent =
	  function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {
	    return aSources.map(function (source) {
	      if (!this._sourcesContents) {
	        return null;
	      }
	      if (aSourceRoot != null) {
	        source = util.relative(aSourceRoot, source);
	      }
	      var key = util.toSetString(source);
	      return Object.prototype.hasOwnProperty.call(this._sourcesContents, key)
	        ? this._sourcesContents[key]
	        : null;
	    }, this);
	  };

	/**
	 * Externalize the source map.
	 */
	SourceMapGenerator.prototype.toJSON =
	  function SourceMapGenerator_toJSON() {
	    var map = {
	      version: this._version,
	      sources: this._sources.toArray(),
	      names: this._names.toArray(),
	      mappings: this._serializeMappings()
	    };
	    if (this._file != null) {
	      map.file = this._file;
	    }
	    if (this._sourceRoot != null) {
	      map.sourceRoot = this._sourceRoot;
	    }
	    if (this._sourcesContents) {
	      map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);
	    }

	    return map;
	  };

	/**
	 * Render the source map being generated to a string.
	 */
	SourceMapGenerator.prototype.toString =
	  function SourceMapGenerator_toString() {
	    return JSON.stringify(this.toJSON());
	  };

	var SourceMapGenerator_1 = SourceMapGenerator;

	var sourceMapGenerator = {
		SourceMapGenerator: SourceMapGenerator_1
	};

	var SourceMapGenerator$1 = sourceMapGenerator.SourceMapGenerator;
	var trackNodes = {
	    Atrule: true,
	    Selector: true,
	    Declaration: true
	};

	var sourceMap = function generateSourceMap(handlers) {
	    var map = new SourceMapGenerator$1();
	    var line = 1;
	    var column = 0;
	    var generated = {
	        line: 1,
	        column: 0
	    };
	    var original = {
	        line: 0, // should be zero to add first mapping
	        column: 0
	    };
	    var sourceMappingActive = false;
	    var activatedGenerated = {
	        line: 1,
	        column: 0
	    };
	    var activatedMapping = {
	        generated: activatedGenerated
	    };

	    var handlersNode = handlers.node;
	    handlers.node = function(node) {
	        if (node.loc && node.loc.start && trackNodes.hasOwnProperty(node.type)) {
	            var nodeLine = node.loc.start.line;
	            var nodeColumn = node.loc.start.column - 1;

	            if (original.line !== nodeLine ||
	                original.column !== nodeColumn) {
	                original.line = nodeLine;
	                original.column = nodeColumn;

	                generated.line = line;
	                generated.column = column;

	                if (sourceMappingActive) {
	                    sourceMappingActive = false;
	                    if (generated.line !== activatedGenerated.line ||
	                        generated.column !== activatedGenerated.column) {
	                        map.addMapping(activatedMapping);
	                    }
	                }

	                sourceMappingActive = true;
	                map.addMapping({
	                    source: node.loc.source,
	                    original: original,
	                    generated: generated
	                });
	            }
	        }

	        handlersNode.call(this, node);

	        if (sourceMappingActive && trackNodes.hasOwnProperty(node.type)) {
	            activatedGenerated.line = line;
	            activatedGenerated.column = column;
	        }
	    };

	    var handlersChunk = handlers.chunk;
	    handlers.chunk = function(chunk) {
	        for (var i = 0; i < chunk.length; i++) {
	            if (chunk.charCodeAt(i) === 10) { // \n
	                line++;
	                column = 0;
	            } else {
	                column++;
	            }
	        }

	        handlersChunk(chunk);
	    };

	    var handlersResult = handlers.result;
	    handlers.result = function() {
	        if (sourceMappingActive) {
	            map.addMapping(activatedMapping);
	        }

	        return {
	            css: handlersResult(),
	            map: map
	        };
	    };

	    return handlers;
	};

	var hasOwnProperty$3 = Object.prototype.hasOwnProperty;

	function processChildren(node, delimeter) {
	    var list = node.children;
	    var prev = null;

	    if (typeof delimeter !== 'function') {
	        list.forEach(this.node, this);
	    } else {
	        list.forEach(function(node) {
	            if (prev !== null) {
	                delimeter.call(this, prev);
	            }

	            this.node(node);
	            prev = node;
	        }, this);
	    }
	}

	var create$2 = function createGenerator(config) {
	    function processNode(node) {
	        if (hasOwnProperty$3.call(types, node.type)) {
	            types[node.type].call(this, node);
	        } else {
	            throw new Error('Unknown node type: ' + node.type);
	        }
	    }

	    var types = {};

	    if (config.node) {
	        for (var name in config.node) {
	            types[name] = config.node[name].generate;
	        }
	    }

	    return function(node, options) {
	        var buffer = '';
	        var handlers = {
	            children: processChildren,
	            node: processNode,
	            chunk: function(chunk) {
	                buffer += chunk;
	            },
	            result: function() {
	                return buffer;
	            }
	        };

	        if (options) {
	            if (typeof options.decorator === 'function') {
	                handlers = options.decorator(handlers);
	            }

	            if (options.sourceMap) {
	                handlers = sourceMap(handlers);
	            }
	        }

	        handlers.node(node);

	        return handlers.result();
	    };
	};

	var create$3 = function createConvertors(walk) {
	    return {
	        fromPlainObject: function(ast) {
	            walk(ast, {
	                enter: function(node) {
	                    if (node.children && node.children instanceof List_1 === false) {
	                        node.children = new List_1().fromArray(node.children);
	                    }
	                }
	            });

	            return ast;
	        },
	        toPlainObject: function(ast) {
	            walk(ast, {
	                leave: function(node) {
	                    if (node.children && node.children instanceof List_1) {
	                        node.children = node.children.toArray();
	                    }
	                }
	            });

	            return ast;
	        }
	    };
	};

	var hasOwnProperty$4 = Object.prototype.hasOwnProperty;
	var noop$4 = function() {};

	function ensureFunction$1(value) {
	    return typeof value === 'function' ? value : noop$4;
	}

	function invokeForType(fn, type) {
	    return function(node, item, list) {
	        if (node.type === type) {
	            fn.call(this, node, item, list);
	        }
	    };
	}

	function getWalkersFromStructure(name, nodeType) {
	    var structure = nodeType.structure;
	    var walkers = [];

	    for (var key in structure) {
	        if (hasOwnProperty$4.call(structure, key) === false) {
	            continue;
	        }

	        var fieldTypes = structure[key];
	        var walker = {
	            name: key,
	            type: false,
	            nullable: false
	        };

	        if (!Array.isArray(structure[key])) {
	            fieldTypes = [structure[key]];
	        }

	        for (var i = 0; i < fieldTypes.length; i++) {
	            var fieldType = fieldTypes[i];
	            if (fieldType === null) {
	                walker.nullable = true;
	            } else if (typeof fieldType === 'string') {
	                walker.type = 'node';
	            } else if (Array.isArray(fieldType)) {
	                walker.type = 'list';
	            }
	        }

	        if (walker.type) {
	            walkers.push(walker);
	        }
	    }

	    if (walkers.length) {
	        return {
	            context: nodeType.walkContext,
	            fields: walkers
	        };
	    }

	    return null;
	}

	function getTypesFromConfig(config) {
	    var types = {};

	    for (var name in config.node) {
	        if (hasOwnProperty$4.call(config.node, name)) {
	            var nodeType = config.node[name];

	            if (!nodeType.structure) {
	                throw new Error('Missed `structure` field in `' + name + '` node type definition');
	            }

	            types[name] = getWalkersFromStructure(name, nodeType);
	        }
	    }

	    return types;
	}

	function createTypeIterator(config, reverse) {
	    var fields = config.fields.slice();
	    var contextName = config.context;
	    var useContext = typeof contextName === 'string';

	    if (reverse) {
	        fields.reverse();
	    }

	    return function(node, context, walk) {
	        var prevContextValue;

	        if (useContext) {
	            prevContextValue = context[contextName];
	            context[contextName] = node;
	        }

	        for (var i = 0; i < fields.length; i++) {
	            var field = fields[i];
	            var ref = node[field.name];

	            if (!field.nullable || ref) {
	                if (field.type === 'list') {
	                    if (reverse) {
	                        ref.forEachRight(walk);
	                    } else {
	                        ref.forEach(walk);
	                    }
	                } else {
	                    walk(ref);
	                }
	            }
	        }

	        if (useContext) {
	            context[contextName] = prevContextValue;
	        }
	    };
	}

	function createFastTraveralMap(iterators) {
	    return {
	        Atrule: {
	            StyleSheet: iterators.StyleSheet,
	            Atrule: iterators.Atrule,
	            Rule: iterators.Rule,
	            Block: iterators.Block
	        },
	        Rule: {
	            StyleSheet: iterators.StyleSheet,
	            Atrule: iterators.Atrule,
	            Rule: iterators.Rule,
	            Block: iterators.Block
	        },
	        Declaration: {
	            StyleSheet: iterators.StyleSheet,
	            Atrule: iterators.Atrule,
	            Rule: iterators.Rule,
	            Block: iterators.Block,
	            DeclarationList: iterators.DeclarationList
	        }
	    };
	}

	var create$4 = function createWalker(config) {
	    var types = getTypesFromConfig(config);
	    var iteratorsNatural = {};
	    var iteratorsReverse = {};

	    for (var name in types) {
	        if (hasOwnProperty$4.call(types, name) && types[name] !== null) {
	            iteratorsNatural[name] = createTypeIterator(types[name], false);
	            iteratorsReverse[name] = createTypeIterator(types[name], true);
	        }
	    }

	    var fastTraversalIteratorsNatural = createFastTraveralMap(iteratorsNatural);
	    var fastTraversalIteratorsReverse = createFastTraveralMap(iteratorsReverse);

	    var walk = function(root, options) {
	        function walkNode(node, item, list) {
	            enter.call(context, node, item, list);

	            if (iterators.hasOwnProperty(node.type)) {
	                iterators[node.type](node, context, walkNode);
	            }

	            leave.call(context, node, item, list);
	        }

	        var enter = noop$4;
	        var leave = noop$4;
	        var iterators = iteratorsNatural;
	        var context = {
	            root: root,
	            stylesheet: null,
	            atrule: null,
	            atrulePrelude: null,
	            rule: null,
	            selector: null,
	            block: null,
	            declaration: null,
	            function: null
	        };

	        if (typeof options === 'function') {
	            enter = options;
	        } else if (options) {
	            enter = ensureFunction$1(options.enter);
	            leave = ensureFunction$1(options.leave);

	            if (options.reverse) {
	                iterators = iteratorsReverse;
	            }

	            if (options.visit) {
	                if (fastTraversalIteratorsNatural.hasOwnProperty(options.visit)) {
	                    iterators = options.reverse
	                        ? fastTraversalIteratorsReverse[options.visit]
	                        : fastTraversalIteratorsNatural[options.visit];
	                } else if (!types.hasOwnProperty(options.visit)) {
	                    throw new Error('Bad value `' + options.visit + '` for `visit` option (should be: ' + Object.keys(types).join(', ') + ')');
	                }

	                enter = invokeForType(enter, options.visit);
	                leave = invokeForType(leave, options.visit);
	            }
	        }

	        if (enter === noop$4 && leave === noop$4) {
	            throw new Error('Neither `enter` nor `leave` walker handler is set or both aren\'t a function');
	        }

	        // swap handlers in reverse mode to invert visit order
	        if (options.reverse) {
	            var tmp = enter;
	            enter = leave;
	            leave = tmp;
	        }

	        walkNode(root);
	    };

	    walk.find = function(ast, fn) {
	        var found = null;

	        walk(ast, function(node, item, list) {
	            if (found === null && fn.call(this, node, item, list)) {
	                found = node;
	            }
	        });

	        return found;
	    };

	    walk.findLast = function(ast, fn) {
	        var found = null;

	        walk(ast, {
	            reverse: true,
	            enter: function(node, item, list) {
	                if (found === null && fn.call(this, node, item, list)) {
	                    found = node;
	                }
	            }
	        });

	        return found;
	    };

	    walk.findAll = function(ast, fn) {
	        var found = [];

	        walk(ast, function(node, item, list) {
	            if (fn.call(this, node, item, list)) {
	                found.push(node);
	            }
	        });

	        return found;
	    };

	    return walk;
	};

	var clone = function clone(node) {
	    var result = {};

	    for (var key in node) {
	        var value = node[key];

	        if (value) {
	            if (Array.isArray(value) || value instanceof List_1) {
	                value = value.map(clone);
	            } else if (value.constructor === Object) {
	                value = clone(value);
	            }
	        }

	        result[key] = value;
	    }

	    return result;
	};

	var hasOwnProperty$5 = Object.prototype.hasOwnProperty;
	var shape = {
	    generic: true,
	    types: {},
	    atrules: {},
	    properties: {},
	    parseContext: {},
	    scope: {},
	    atrule: ['parse'],
	    pseudo: ['parse'],
	    node: ['name', 'structure', 'parse', 'generate', 'walkContext']
	};

	function isObject(value) {
	    return value && value.constructor === Object;
	}

	function copy(value) {
	    if (isObject(value)) {
	        return Object.assign({}, value);
	    } else {
	        return value;
	    }
	}
	function extend(dest, src) {
	    for (var key in src) {
	        if (hasOwnProperty$5.call(src, key)) {
	            if (isObject(dest[key])) {
	                extend(dest[key], copy(src[key]));
	            } else {
	                dest[key] = copy(src[key]);
	            }
	        }
	    }
	}

	function mix(dest, src, shape) {
	    for (var key in shape) {
	        if (hasOwnProperty$5.call(shape, key) === false) {
	            continue;
	        }

	        if (shape[key] === true) {
	            if (key in src) {
	                if (hasOwnProperty$5.call(src, key)) {
	                    dest[key] = copy(src[key]);
	                }
	            }
	        } else if (shape[key]) {
	            if (isObject(shape[key])) {
	                var res = {};
	                extend(res, dest[key]);
	                extend(res, src[key]);
	                dest[key] = res;
	            } else if (Array.isArray(shape[key])) {
	                var res = {};
	                var innerShape = shape[key].reduce(function(s, k) {
	                    s[k] = true;
	                    return s;
	                }, {});
	                for (var name in dest[key]) {
	                    if (hasOwnProperty$5.call(dest[key], name)) {
	                        res[name] = {};
	                        if (dest[key] && dest[key][name]) {
	                            mix(res[name], dest[key][name], innerShape);
	                        }
	                    }
	                }
	                for (var name in src[key]) {
	                    if (hasOwnProperty$5.call(src[key], name)) {
	                        if (!res[name]) {
	                            res[name] = {};
	                        }
	                        if (src[key] && src[key][name]) {
	                            mix(res[name], src[key][name], innerShape);
	                        }
	                    }
	                }
	                dest[key] = res;
	            }
	        }
	    }
	    return dest;
	}

	var mix_1 = function(dest, src) {
	    return mix(dest, src, shape);
	};

	function createSyntax(config) {
	    var parse = create$1(config);
	    var walk = create$4(config);
	    var generate = create$2(config);
	    var convert = create$3(walk);

	    var syntax = {
	        List: List_1,
	        SyntaxError: _SyntaxError,
	        TokenStream: TokenStream_1,
	        Lexer: Lexer_1,

	        vendorPrefix: names.vendorPrefix,
	        keyword: names.keyword,
	        property: names.property,
	        isCustomProperty: names.isCustomProperty,

	        definitionSyntax: definitionSyntax,
	        lexer: null,
	        createLexer: function(config) {
	            return new Lexer_1(config, syntax, syntax.lexer.structure);
	        },

	        tokenize: tokenizer,
	        parse: parse,
	        walk: walk,
	        generate: generate,

	        find: walk.find,
	        findLast: walk.findLast,
	        findAll: walk.findAll,

	        clone: clone,
	        fromPlainObject: convert.fromPlainObject,
	        toPlainObject: convert.toPlainObject,

	        createSyntax: function(config) {
	            return createSyntax(mix_1({}, config));
	        },
	        fork: function(extension) {
	            var base = mix_1({}, config); // copy of config
	            return createSyntax(
	                typeof extension === 'function'
	                    ? extension(base, Object.assign)
	                    : mix_1(base, extension)
	            );
	        }
	    };

	    syntax.lexer = new Lexer_1({
	        generic: true,
	        types: config.types,
	        atrules: config.atrules,
	        properties: config.properties,
	        node: config.node
	    }, syntax);

	    return syntax;
	}
	var create_1 = function(config) {
	    return createSyntax(mix_1({}, config));
	};

	var create$5 = {
		create: create_1
	};

	var atRules = {
		"@charset": {
		syntax: "@charset \"<charset>\";",
		groups: [
			"CSS Charsets"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@charset"
	},
		"@counter-style": {
		syntax: "@counter-style <counter-style-name> {\n  [ system: <counter-system>; ] ||\n  [ symbols: <counter-symbols>; ] ||\n  [ additive-symbols: <additive-symbols>; ] ||\n  [ negative: <negative-symbol>; ] ||\n  [ prefix: <prefix>; ] ||\n  [ suffix: <suffix>; ] ||\n  [ range: <range>; ] ||\n  [ pad: <padding>; ] ||\n  [ speak-as: <speak-as>; ] ||\n  [ fallback: <counter-style-name>; ]\n}",
		interfaces: [
			"CSSCounterStyleRule"
		],
		groups: [
			"CSS Counter Styles"
		],
		descriptors: {
			"additive-symbols": {
				syntax: "[ <integer> && <symbol> ]#",
				media: "all",
				initial: "N/A",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			fallback: {
				syntax: "<counter-style-name>",
				media: "all",
				initial: "decimal",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			negative: {
				syntax: "<symbol> <symbol>?",
				media: "all",
				initial: "\"-\" hyphen-minus",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			pad: {
				syntax: "<integer> && <symbol>",
				media: "all",
				initial: "0 \"\"",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			prefix: {
				syntax: "<symbol>",
				media: "all",
				initial: "\"\"",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			range: {
				syntax: "[ [ <integer> | infinite ]{2} ]# | auto",
				media: "all",
				initial: "auto",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			"speak-as": {
				syntax: "auto | bullets | numbers | words | spell-out | <counter-style-name>",
				media: "all",
				initial: "auto",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			suffix: {
				syntax: "<symbol>",
				media: "all",
				initial: "\". \"",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			symbols: {
				syntax: "<symbol>+",
				media: "all",
				initial: "N/A",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			system: {
				syntax: "cyclic | numeric | alphabetic | symbolic | additive | [ fixed <integer>? ] | [ extends <counter-style-name> ]",
				media: "all",
				initial: "symbolic",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			}
		},
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@counter-style"
	},
		"@document": {
		syntax: "@document [ <url> | url-prefix(<string>) | domain(<string>) | media-document(<string>) | regexp(<string>) ]# {\n  <group-rule-body>\n}",
		interfaces: [
			"CSSGroupingRule",
			"CSSConditionRule"
		],
		groups: [
			"CSS Conditional Rules"
		],
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@document"
	},
		"@font-face": {
		syntax: "@font-face {\n  [ font-family: <family-name>; ] ||\n  [ src: <src>; ] ||\n  [ unicode-range: <unicode-range>; ] ||\n  [ font-variant: <font-variant>; ] ||\n  [ font-feature-settings: <font-feature-settings>; ] ||\n  [ font-variation-settings: <font-variation-settings>; ] ||\n  [ font-stretch: <font-stretch>; ] ||\n  [ font-weight: <font-weight>; ] ||\n  [ font-style: <font-style>; ]\n}",
		interfaces: [
			"CSSFontFaceRule"
		],
		groups: [
			"CSS Fonts"
		],
		descriptors: {
			"font-display": {
				syntax: "[ auto | block | swap | fallback | optional ]",
				media: "visual",
				percentages: "no",
				initial: "auto",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "experimental"
			},
			"font-family": {
				syntax: "<family-name>",
				media: "all",
				initial: "n/a (required)",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			"font-feature-settings": {
				syntax: "normal | <feature-tag-value>#",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			"font-variation-settings": {
				syntax: "normal | [ <string> <number> ]#",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			"font-stretch": {
				syntax: "<font-stretch-absolute>{1,2}",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			"font-style": {
				syntax: "normal | italic | oblique <angle>{0,2}",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			"font-weight": {
				syntax: "<font-weight-absolute>{1,2}",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			"font-variant": {
				syntax: "normal | none | [ <common-lig-values> || <discretionary-lig-values> || <historical-lig-values> || <contextual-alt-values> || stylistic(<feature-value-name>) || historical-forms || styleset(<feature-value-name>#) || character-variant(<feature-value-name>#) || swash(<feature-value-name>) || ornaments(<feature-value-name>) || annotation(<feature-value-name>) || [ small-caps | all-small-caps | petite-caps | all-petite-caps | unicase | titling-caps ] || <numeric-figure-values> || <numeric-spacing-values> || <numeric-fraction-values> || ordinal || slashed-zero || <east-asian-variant-values> || <east-asian-width-values> || ruby ]",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			src: {
				syntax: "[ <url> [ format( <string># ) ]? | local( <family-name> ) ]#",
				media: "all",
				initial: "n/a (required)",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			"unicode-range": {
				syntax: "<unicode-range>#",
				media: "all",
				initial: "U+0-10FFFF",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			}
		},
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@font-face"
	},
		"@font-feature-values": {
		syntax: "@font-feature-values <family-name># {\n  <feature-value-block-list>\n}",
		interfaces: [
			"CSSFontFeatureValuesRule"
		],
		groups: [
			"CSS Fonts"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@font-feature-values"
	},
		"@import": {
		syntax: "@import [ <string> | <url> ] [ <media-query-list> ]?;",
		groups: [
			"Media Queries"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@import"
	},
		"@keyframes": {
		syntax: "@keyframes <keyframes-name> {\n  <keyframe-block-list>\n}",
		interfaces: [
			"CSSKeyframeRule",
			"CSSKeyframesRule"
		],
		groups: [
			"CSS Animations"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@keyframes"
	},
		"@media": {
		syntax: "@media <media-query-list> {\n  <group-rule-body>\n}",
		interfaces: [
			"CSSGroupingRule",
			"CSSConditionRule",
			"CSSMediaRule",
			"CSSCustomMediaRule"
		],
		groups: [
			"CSS Conditional Rules",
			"Media Queries"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@media"
	},
		"@namespace": {
		syntax: "@namespace <namespace-prefix>? [ <string> | <url> ];",
		groups: [
			"CSS Namespaces"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@namespace"
	},
		"@page": {
		syntax: "@page <page-selector-list> {\n  <page-body>\n}",
		interfaces: [
			"CSSPageRule"
		],
		groups: [
			"CSS Pages"
		],
		descriptors: {
			bleed: {
				syntax: "auto | <length>",
				media: [
					"visual",
					"paged"
				],
				initial: "auto",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "experimental"
			},
			marks: {
				syntax: "none | [ crop || cross ]",
				media: [
					"visual",
					"paged"
				],
				initial: "none",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "experimental"
			}
		},
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@page"
	},
		"@supports": {
		syntax: "@supports <supports-condition> {\n  <group-rule-body>\n}",
		interfaces: [
			"CSSGroupingRule",
			"CSSConditionRule",
			"CSSSupportsRule"
		],
		groups: [
			"CSS Conditional Rules"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@supports"
	},
		"@viewport": {
		syntax: "@viewport {\n  <group-rule-body>\n}",
		interfaces: [
			"CSSViewportRule"
		],
		groups: [
			"CSS Device Adaptation"
		],
		descriptors: {
			height: {
				syntax: "<viewport-length>{1,2}",
				media: [
					"visual",
					"continuous"
				],
				initial: [
					"min-height",
					"max-height"
				],
				percentages: [
					"min-height",
					"max-height"
				],
				computed: [
					"min-height",
					"max-height"
				],
				order: "orderOfAppearance",
				status: "standard"
			},
			"max-height": {
				syntax: "<viewport-length>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "referToHeightOfInitialViewport",
				computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
				order: "uniqueOrder",
				status: "standard"
			},
			"max-width": {
				syntax: "<viewport-length>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "referToWidthOfInitialViewport",
				computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
				order: "uniqueOrder",
				status: "standard"
			},
			"max-zoom": {
				syntax: "auto | <number> | <percentage>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "the zoom factor itself",
				computed: "autoNonNegativeOrPercentage",
				order: "uniqueOrder",
				status: "standard"
			},
			"min-height": {
				syntax: "<viewport-length>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "referToHeightOfInitialViewport",
				computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
				order: "uniqueOrder",
				status: "standard"
			},
			"min-width": {
				syntax: "<viewport-length>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "referToWidthOfInitialViewport",
				computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
				order: "uniqueOrder",
				status: "standard"
			},
			"min-zoom": {
				syntax: "auto | <number> | <percentage>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "the zoom factor itself",
				computed: "autoNonNegativeOrPercentage",
				order: "uniqueOrder",
				status: "standard"
			},
			orientation: {
				syntax: "auto | portrait | landscape",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "referToSizeOfBoundingBox",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			"user-zoom": {
				syntax: "zoom | fixed",
				media: [
					"visual",
					"continuous"
				],
				initial: "zoom",
				percentages: "referToSizeOfBoundingBox",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			width: {
				syntax: "<viewport-length>{1,2}",
				media: [
					"visual",
					"continuous"
				],
				initial: [
					"min-width",
					"max-width"
				],
				percentages: [
					"min-width",
					"max-width"
				],
				computed: [
					"min-width",
					"max-width"
				],
				order: "orderOfAppearance",
				status: "standard"
			},
			zoom: {
				syntax: "auto | <number> | <percentage>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "the zoom factor itself",
				computed: "autoNonNegativeOrPercentage",
				order: "uniqueOrder",
				status: "standard"
			}
		},
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@viewport"
	}
	};

	var atRules$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		'default': atRules
	});

	var all = {
		syntax: "initial | inherit | unset | revert",
		media: "noPracticalMedia",
		inherited: false,
		animationType: "eachOfShorthandPropertiesExceptUnicodeBiDiAndDirection",
		percentages: "no",
		groups: [
			"CSS Miscellaneous"
		],
		initial: "noPracticalInitialValue",
		appliesto: "allElements",
		computed: "asSpecifiedAppliesToEachProperty",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/all"
	};
	var animation = {
		syntax: "<single-animation>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: [
			"animation-name",
			"animation-duration",
			"animation-timing-function",
			"animation-delay",
			"animation-iteration-count",
			"animation-direction",
			"animation-fill-mode",
			"animation-play-state"
		],
		appliesto: "allElementsAndPseudos",
		computed: [
			"animation-name",
			"animation-duration",
			"animation-timing-function",
			"animation-delay",
			"animation-direction",
			"animation-iteration-count",
			"animation-fill-mode",
			"animation-play-state"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation"
	};
	var appearance = {
		syntax: "none | auto | button | textfield | <compat>",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-appearance"
	};
	var azimuth = {
		syntax: "<angle> | [ [ left-side | far-left | left | center-left | center | center-right | right | far-right | right-side ] || behind ] | leftwards | rightwards",
		media: "aural",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Speech"
		],
		initial: "center",
		appliesto: "allElements",
		computed: "normalizedAngle",
		order: "orderOfAppearance",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/azimuth"
	};
	var background = {
		syntax: "[ <bg-layer> , ]* <final-bg-layer>",
		media: "visual",
		inherited: false,
		animationType: [
			"background-color",
			"background-image",
			"background-clip",
			"background-position",
			"background-size",
			"background-repeat",
			"background-attachment"
		],
		percentages: [
			"background-position",
			"background-size"
		],
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"background-image",
			"background-position",
			"background-size",
			"background-repeat",
			"background-origin",
			"background-clip",
			"background-attachment",
			"background-color"
		],
		appliesto: "allElements",
		computed: [
			"background-image",
			"background-position",
			"background-size",
			"background-repeat",
			"background-origin",
			"background-clip",
			"background-attachment",
			"background-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background"
	};
	var border = {
		syntax: "<line-width> || <line-style> || <color>",
		media: "visual",
		inherited: false,
		animationType: [
			"border-color",
			"border-style",
			"border-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-width",
			"border-style",
			"border-color"
		],
		appliesto: "allElements",
		computed: [
			"border-width",
			"border-style",
			"border-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border"
	};
	var bottom = {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToContainingBlockHeight",
		groups: [
			"CSS Positioning"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/bottom"
	};
	var clear = {
		syntax: "none | left | right | both | inline-start | inline-end",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Positioning"
		],
		initial: "none",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/clear"
	};
	var clip = {
		syntax: "<shape> | auto",
		media: "visual",
		inherited: false,
		animationType: "rectangle",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "auto",
		appliesto: "absolutelyPositionedElements",
		computed: "autoOrRectangle",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/clip"
	};
	var color = {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Color"
		],
		initial: "variesFromBrowserToBrowser",
		appliesto: "allElements",
		computed: "translucentValuesRGBAOtherwiseRGB",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/color"
	};
	var columns = {
		syntax: "<'column-width'> || <'column-count'>",
		media: "visual",
		inherited: false,
		animationType: [
			"column-width",
			"column-count"
		],
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: [
			"column-width",
			"column-count"
		],
		appliesto: "blockContainersExceptTableWrappers",
		computed: [
			"column-width",
			"column-count"
		],
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/columns"
	};
	var contain = {
		syntax: "none | strict | content | [ size || layout || style || paint ]",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Containment"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/contain"
	};
	var content = {
		syntax: "normal | none | [ <content-replacement> | <content-list> ] [/ <string> ]?",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Generated Content"
		],
		initial: "normal",
		appliesto: "beforeAndAfterPseudos",
		computed: "normalOnElementsForPseudosNoneAbsoluteURIStringOrAsSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/content"
	};
	var cursor = {
		syntax: "[ [ <url> [ <x> <y> ]? , ]* [ auto | default | none | context-menu | help | pointer | progress | wait | cell | crosshair | text | vertical-text | alias | copy | move | no-drop | not-allowed | e-resize | n-resize | ne-resize | nw-resize | s-resize | se-resize | sw-resize | w-resize | ew-resize | ns-resize | nesw-resize | nwse-resize | col-resize | row-resize | all-scroll | zoom-in | zoom-out | grab | grabbing ] ]",
		media: [
			"visual",
			"interactive"
		],
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecifiedURLsAbsolute",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/cursor"
	};
	var direction = {
		syntax: "ltr | rtl",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Writing Modes"
		],
		initial: "ltr",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/direction"
	};
	var display = {
		syntax: "[ <display-outside> || <display-inside> ] | <display-listitem> | <display-internal> | <display-box> | <display-legacy>",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Display"
		],
		initial: "inline",
		appliesto: "allElements",
		computed: "asSpecifiedExceptPositionedFloatingAndRootElementsKeywordMaybeDifferent",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/display"
	};
	var filter = {
		syntax: "none | <filter-function-list>",
		media: "visual",
		inherited: false,
		animationType: "filterList",
		percentages: "no",
		groups: [
			"Filter Effects"
		],
		initial: "none",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/filter"
	};
	var flex = {
		syntax: "none | [ <'flex-grow'> <'flex-shrink'>? || <'flex-basis'> ]",
		media: "visual",
		inherited: false,
		animationType: [
			"flex-grow",
			"flex-shrink",
			"flex-basis"
		],
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: [
			"flex-grow",
			"flex-shrink",
			"flex-basis"
		],
		appliesto: "flexItemsAndInFlowPseudos",
		computed: [
			"flex-grow",
			"flex-shrink",
			"flex-basis"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex"
	};
	var float = {
		syntax: "left | right | none | inline-start | inline-end",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Positioning"
		],
		initial: "none",
		appliesto: "allElementsNoEffectIfDisplayNone",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/float"
	};
	var font = {
		syntax: "[ [ <'font-style'> || <font-variant-css21> || <'font-weight'> || <'font-stretch'> ]? <'font-size'> [ / <'line-height'> ]? <'font-family'> ] | caption | icon | menu | message-box | small-caption | status-bar",
		media: "visual",
		inherited: true,
		animationType: [
			"font-style",
			"font-variant",
			"font-weight",
			"font-stretch",
			"font-size",
			"line-height",
			"font-family"
		],
		percentages: [
			"font-size",
			"line-height"
		],
		groups: [
			"CSS Fonts"
		],
		initial: [
			"font-style",
			"font-variant",
			"font-weight",
			"font-stretch",
			"font-size",
			"line-height",
			"font-family"
		],
		appliesto: "allElements",
		computed: [
			"font-style",
			"font-variant",
			"font-weight",
			"font-stretch",
			"font-size",
			"line-height",
			"font-family"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font"
	};
	var gap = {
		syntax: "<'row-gap'> <'column-gap'>?",
		media: "visual",
		inherited: false,
		animationType: [
			"row-gap",
			"column-gap"
		],
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: [
			"row-gap",
			"column-gap"
		],
		appliesto: "gridContainers",
		computed: [
			"row-gap",
			"column-gap"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/gap"
	};
	var grid = {
		syntax: "<'grid-template'> | <'grid-template-rows'> / [ auto-flow && dense? ] <'grid-auto-columns'>? | [ auto-flow && dense? ] <'grid-auto-rows'>? / <'grid-template-columns'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: [
			"grid-template-rows",
			"grid-template-columns",
			"grid-auto-rows",
			"grid-auto-columns"
		],
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-template-rows",
			"grid-template-columns",
			"grid-template-areas",
			"grid-auto-rows",
			"grid-auto-columns",
			"grid-auto-flow",
			"grid-column-gap",
			"grid-row-gap",
			"column-gap",
			"row-gap"
		],
		appliesto: "gridContainers",
		computed: [
			"grid-template-rows",
			"grid-template-columns",
			"grid-template-areas",
			"grid-auto-rows",
			"grid-auto-columns",
			"grid-auto-flow",
			"grid-column-gap",
			"grid-row-gap",
			"column-gap",
			"row-gap"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid"
	};
	var height = {
		syntax: "[ <length> | <percentage> ] && [ border-box | content-box ]? | available | min-content | max-content | fit-content | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "regardingHeightOfGeneratedBoxContainingBlockPercentagesRelativeToContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "allElementsButNonReplacedAndTableColumns",
		computed: "percentageAutoOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/height"
	};
	var hyphens = {
		syntax: "none | manual | auto",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "manual",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/hyphens"
	};
	var inset = {
		syntax: "<'top'>{1,4}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalHeightOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset"
	};
	var isolation = {
		syntax: "auto | isolate",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Compositing and Blending"
		],
		initial: "auto",
		appliesto: "allElementsSVGContainerGraphicsAndGraphicsReferencingElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/isolation"
	};
	var left = {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Positioning"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/left"
	};
	var margin = {
		syntax: "[ <length> | <percentage> | auto ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: [
			"margin-bottom",
			"margin-left",
			"margin-right",
			"margin-top"
		],
		appliesto: "allElementsExceptTableDisplayTypes",
		computed: [
			"margin-bottom",
			"margin-left",
			"margin-right",
			"margin-top"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin"
	};
	var mask = {
		syntax: "<mask-layer>#",
		media: "visual",
		inherited: false,
		animationType: [
			"mask-image",
			"mask-mode",
			"mask-repeat",
			"mask-position",
			"mask-clip",
			"mask-origin",
			"mask-size",
			"mask-composite"
		],
		percentages: [
			"mask-position"
		],
		groups: [
			"CSS Masking"
		],
		initial: [
			"mask-image",
			"mask-mode",
			"mask-repeat",
			"mask-position",
			"mask-clip",
			"mask-origin",
			"mask-size",
			"mask-composite"
		],
		appliesto: "allElementsSVGContainerElements",
		computed: [
			"mask-image",
			"mask-mode",
			"mask-repeat",
			"mask-position",
			"mask-clip",
			"mask-origin",
			"mask-size",
			"mask-composite"
		],
		order: "perGrammar",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask"
	};
	var offset = {
		syntax: "[ <'offset-position'>? [ <'offset-path'> [ <'offset-distance'> || <'offset-rotate'> ]? ]? ]! [ / <'offset-anchor'> ]?",
		media: "visual",
		inherited: false,
		animationType: [
			"offset-position",
			"offset-path",
			"offset-distance",
			"offset-anchor",
			"offset-rotate"
		],
		percentages: [
			"offset-position",
			"offset-distance",
			"offset-anchor"
		],
		groups: [
			"CSS Motion Path"
		],
		initial: [
			"offset-position",
			"offset-path",
			"offset-distance",
			"offset-anchor",
			"offset-rotate"
		],
		appliesto: "transformableElements",
		computed: [
			"offset-position",
			"offset-path",
			"offset-distance",
			"offset-anchor",
			"offset-rotate"
		],
		order: "perGrammar",
		stacking: true,
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/offset"
	};
	var opacity = {
		syntax: "<alpha-value>",
		media: "visual",
		inherited: false,
		animationType: "number",
		percentages: "no",
		groups: [
			"CSS Color"
		],
		initial: "1.0",
		appliesto: "allElements",
		computed: "specifiedValueClipped0To1",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/opacity"
	};
	var order = {
		syntax: "<integer>",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "0",
		appliesto: "flexItemsAndAbsolutelyPositionedFlexContainerChildren",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/order"
	};
	var orphans = {
		syntax: "<integer>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "2",
		appliesto: "blockContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/orphans"
	};
	var outline = {
		syntax: "[ <'outline-color'> || <'outline-style'> || <'outline-width'> ]",
		media: [
			"visual",
			"interactive"
		],
		inherited: false,
		animationType: [
			"outline-color",
			"outline-width",
			"outline-style"
		],
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: [
			"outline-color",
			"outline-style",
			"outline-width"
		],
		appliesto: "allElements",
		computed: [
			"outline-color",
			"outline-width",
			"outline-style"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline"
	};
	var overflow = {
		syntax: "[ visible | hidden | clip | scroll | auto ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "visible",
		appliesto: "blockContainersFlexContainersGridContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow"
	};
	var padding = {
		syntax: "[ <length> | <percentage> ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: [
			"padding-bottom",
			"padding-left",
			"padding-right",
			"padding-top"
		],
		appliesto: "allElementsExceptInternalTableDisplayTypes",
		computed: [
			"padding-bottom",
			"padding-left",
			"padding-right",
			"padding-top"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding"
	};
	var perspective = {
		syntax: "none | <length>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "absoluteLengthOrNone",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/perspective"
	};
	var position = {
		syntax: "static | relative | absolute | sticky | fixed",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Positioning"
		],
		initial: "static",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/position"
	};
	var quotes = {
		syntax: "none | auto | [ <string> <string> ]+",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Generated Content"
		],
		initial: "dependsOnUserAgent",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/quotes"
	};
	var resize = {
		syntax: "none | both | horizontal | vertical | block | inline",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "none",
		appliesto: "elementsWithOverflowNotVisibleAndReplacedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/resize"
	};
	var right = {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Positioning"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/right"
	};
	var rotate = {
		syntax: "none | <angle> | [ x | y | z | <number>{3} ] && <angle>",
		media: "visual",
		inherited: false,
		animationType: "transform",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "perGrammar",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/rotate"
	};
	var scale = {
		syntax: "none | <number>{1,3}",
		media: "visual",
		inherited: false,
		animationType: "transform",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "perGrammar",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scale"
	};
	var top = {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToContainingBlockHeight",
		groups: [
			"CSS Positioning"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/top"
	};
	var transform = {
		syntax: "none | <transform-list>",
		media: "visual",
		inherited: false,
		animationType: "transform",
		percentages: "referToSizeOfBoundingBox",
		groups: [
			"CSS Transforms"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transform"
	};
	var transition = {
		syntax: "<single-transition>#",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transitions"
		],
		initial: [
			"transition-delay",
			"transition-duration",
			"transition-property",
			"transition-timing-function"
		],
		appliesto: "allElementsAndPseudos",
		computed: [
			"transition-delay",
			"transition-duration",
			"transition-property",
			"transition-timing-function"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition"
	};
	var translate = {
		syntax: "none | <length-percentage> [ <length-percentage> <length>? ]?",
		media: "visual",
		inherited: false,
		animationType: "transform",
		percentages: "referToSizeOfBoundingBox",
		groups: [
			"CSS Transforms"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "perGrammar",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/translate"
	};
	var visibility = {
		syntax: "visible | hidden | collapse",
		media: "visual",
		inherited: true,
		animationType: "visibility",
		percentages: "no",
		groups: [
			"CSS Box Model"
		],
		initial: "visible",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/visibility"
	};
	var widows = {
		syntax: "<integer>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "2",
		appliesto: "blockContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/widows"
	};
	var width = {
		syntax: "[ <length> | <percentage> ] && [ border-box | content-box ]? | available | min-content | max-content | fit-content | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "allElementsButNonReplacedAndTableRows",
		computed: "percentageAutoOrAbsoluteLength",
		order: "lengthOrPercentageBeforeKeywordIfBothPresent",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/width"
	};
	var zoom = {
		syntax: "normal | reset | <number> | <percentage>",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/zoom"
	};
	var properties$1 = {
		"--*": {
		syntax: "<declaration-value>",
		media: "all",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Variables"
		],
		initial: "seeProse",
		appliesto: "allElements",
		computed: "asSpecifiedWithVarsSubstituted",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/--*"
	},
		"-ms-accelerator": {
		syntax: "false | true",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "false",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-accelerator"
	},
		"-ms-block-progression": {
		syntax: "tb | rl | bt | lr",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "tb",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-block-progression"
	},
		"-ms-content-zoom-chaining": {
		syntax: "none | chained",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-chaining"
	},
		"-ms-content-zooming": {
		syntax: "none | zoom",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "zoomForTheTopLevelNoneForTheRest",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zooming"
	},
		"-ms-content-zoom-limit": {
		syntax: "<'-ms-content-zoom-limit-min'> <'-ms-content-zoom-limit-max'>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: [
			"-ms-content-zoom-limit-max",
			"-ms-content-zoom-limit-min"
		],
		groups: [
			"Microsoft Extensions"
		],
		initial: [
			"-ms-content-zoom-limit-max",
			"-ms-content-zoom-limit-min"
		],
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: [
			"-ms-content-zoom-limit-max",
			"-ms-content-zoom-limit-min"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-limit"
	},
		"-ms-content-zoom-limit-max": {
		syntax: "<percentage>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "maxZoomFactor",
		groups: [
			"Microsoft Extensions"
		],
		initial: "400%",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-limit-max"
	},
		"-ms-content-zoom-limit-min": {
		syntax: "<percentage>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "minZoomFactor",
		groups: [
			"Microsoft Extensions"
		],
		initial: "100%",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-limit-min"
	},
		"-ms-content-zoom-snap": {
		syntax: "<'-ms-content-zoom-snap-type'> || <'-ms-content-zoom-snap-points'>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: [
			"-ms-content-zoom-snap-type",
			"-ms-content-zoom-snap-points"
		],
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: [
			"-ms-content-zoom-snap-type",
			"-ms-content-zoom-snap-points"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-snap"
	},
		"-ms-content-zoom-snap-points": {
		syntax: "snapInterval( <percentage>, <percentage> ) | snapList( <percentage># )",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "snapInterval(0%, 100%)",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-snap-points"
	},
		"-ms-content-zoom-snap-type": {
		syntax: "none | proximity | mandatory",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-snap-type"
	},
		"-ms-filter": {
		syntax: "<string>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "\"\"",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-filter"
	},
		"-ms-flow-from": {
		syntax: "[ none | <custom-ident> ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "nonReplacedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-flow-from"
	},
		"-ms-flow-into": {
		syntax: "[ none | <custom-ident> ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "iframeElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-flow-into"
	},
		"-ms-high-contrast-adjust": {
		syntax: "auto | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-high-contrast-adjust"
	},
		"-ms-hyphenate-limit-chars": {
		syntax: "auto | <integer>{1,3}",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-hyphenate-limit-chars"
	},
		"-ms-hyphenate-limit-lines": {
		syntax: "no-limit | <integer>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "no-limit",
		appliesto: "blockContainerElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-hyphenate-limit-lines"
	},
		"-ms-hyphenate-limit-zone": {
		syntax: "<percentage> | <length>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "referToLineBoxWidth",
		groups: [
			"Microsoft Extensions"
		],
		initial: "0",
		appliesto: "blockContainerElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-hyphenate-limit-zone"
	},
		"-ms-ime-align": {
		syntax: "auto | after",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-ime-align"
	},
		"-ms-overflow-style": {
		syntax: "auto | none | scrollbar | -ms-autohiding-scrollbar",
		media: "interactive",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-overflow-style"
	},
		"-ms-scrollbar-3dlight-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "dependsOnUserAgent",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-3dlight-color"
	},
		"-ms-scrollbar-arrow-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "ButtonText",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-arrow-color"
	},
		"-ms-scrollbar-base-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "dependsOnUserAgent",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-base-color"
	},
		"-ms-scrollbar-darkshadow-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "ThreeDDarkShadow",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-darkshadow-color"
	},
		"-ms-scrollbar-face-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "ThreeDFace",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-face-color"
	},
		"-ms-scrollbar-highlight-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "ThreeDHighlight",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-highlight-color"
	},
		"-ms-scrollbar-shadow-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "ThreeDDarkShadow",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-shadow-color"
	},
		"-ms-scrollbar-track-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "Scrollbar",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-track-color"
	},
		"-ms-scroll-chaining": {
		syntax: "chained | none",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "chained",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-chaining"
	},
		"-ms-scroll-limit": {
		syntax: "<'-ms-scroll-limit-x-min'> <'-ms-scroll-limit-y-min'> <'-ms-scroll-limit-x-max'> <'-ms-scroll-limit-y-max'>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: [
			"-ms-scroll-limit-x-min",
			"-ms-scroll-limit-y-min",
			"-ms-scroll-limit-x-max",
			"-ms-scroll-limit-y-max"
		],
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: [
			"-ms-scroll-limit-x-min",
			"-ms-scroll-limit-y-min",
			"-ms-scroll-limit-x-max",
			"-ms-scroll-limit-y-max"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit"
	},
		"-ms-scroll-limit-x-max": {
		syntax: "auto | <length>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit-x-max"
	},
		"-ms-scroll-limit-x-min": {
		syntax: "<length>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "0",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit-x-min"
	},
		"-ms-scroll-limit-y-max": {
		syntax: "auto | <length>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit-y-max"
	},
		"-ms-scroll-limit-y-min": {
		syntax: "<length>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "0",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit-y-min"
	},
		"-ms-scroll-rails": {
		syntax: "none | railed",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "railed",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-rails"
	},
		"-ms-scroll-snap-points-x": {
		syntax: "snapInterval( <length-percentage>, <length-percentage> ) | snapList( <length-percentage># )",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "snapInterval(0px, 100%)",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-points-x"
	},
		"-ms-scroll-snap-points-y": {
		syntax: "snapInterval( <length-percentage>, <length-percentage> ) | snapList( <length-percentage># )",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "snapInterval(0px, 100%)",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-points-y"
	},
		"-ms-scroll-snap-type": {
		syntax: "none | proximity | mandatory",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-type"
	},
		"-ms-scroll-snap-x": {
		syntax: "<'-ms-scroll-snap-type'> <'-ms-scroll-snap-points-x'>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: [
			"-ms-scroll-snap-type",
			"-ms-scroll-snap-points-x"
		],
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: [
			"-ms-scroll-snap-type",
			"-ms-scroll-snap-points-x"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-x"
	},
		"-ms-scroll-snap-y": {
		syntax: "<'-ms-scroll-snap-type'> <'-ms-scroll-snap-points-y'>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: [
			"-ms-scroll-snap-type",
			"-ms-scroll-snap-points-y"
		],
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: [
			"-ms-scroll-snap-type",
			"-ms-scroll-snap-points-y"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-y"
	},
		"-ms-scroll-translation": {
		syntax: "none | vertical-to-horizontal",
		media: "interactive",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-translation"
	},
		"-ms-text-autospace": {
		syntax: "none | ideograph-alpha | ideograph-numeric | ideograph-parenthesis | ideograph-space",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-text-autospace"
	},
		"-ms-touch-select": {
		syntax: "grippers | none",
		media: "interactive",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "grippers",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-touch-select"
	},
		"-ms-user-select": {
		syntax: "none | element | text",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "text",
		appliesto: "nonReplacedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-user-select"
	},
		"-ms-wrap-flow": {
		syntax: "auto | both | start | end | maximum | clear",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-wrap-flow"
	},
		"-ms-wrap-margin": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "0",
		appliesto: "exclusionElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-wrap-margin"
	},
		"-ms-wrap-through": {
		syntax: "wrap | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "wrap",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-wrap-through"
	},
		"-moz-appearance": {
		syntax: "none | button | button-arrow-down | button-arrow-next | button-arrow-previous | button-arrow-up | button-bevel | button-focus | caret | checkbox | checkbox-container | checkbox-label | checkmenuitem | dualbutton | groupbox | listbox | listitem | menuarrow | menubar | menucheckbox | menuimage | menuitem | menuitemtext | menulist | menulist-button | menulist-text | menulist-textfield | menupopup | menuradio | menuseparator | meterbar | meterchunk | progressbar | progressbar-vertical | progresschunk | progresschunk-vertical | radio | radio-container | radio-label | radiomenuitem | range | range-thumb | resizer | resizerpanel | scale-horizontal | scalethumbend | scalethumb-horizontal | scalethumbstart | scalethumbtick | scalethumb-vertical | scale-vertical | scrollbarbutton-down | scrollbarbutton-left | scrollbarbutton-right | scrollbarbutton-up | scrollbarthumb-horizontal | scrollbarthumb-vertical | scrollbartrack-horizontal | scrollbartrack-vertical | searchfield | separator | sheet | spinner | spinner-downbutton | spinner-textfield | spinner-upbutton | splitter | statusbar | statusbarpanel | tab | tabpanel | tabpanels | tab-scroll-arrow-back | tab-scroll-arrow-forward | textfield | textfield-multiline | toolbar | toolbarbutton | toolbarbutton-dropdown | toolbargripper | toolbox | tooltip | treeheader | treeheadercell | treeheadersortarrow | treeitem | treeline | treetwisty | treetwistyopen | treeview | -moz-mac-unified-toolbar | -moz-win-borderless-glass | -moz-win-browsertabbar-toolbox | -moz-win-communicationstext | -moz-win-communications-toolbox | -moz-win-exclude-glass | -moz-win-glass | -moz-win-mediatext | -moz-win-media-toolbox | -moz-window-button-box | -moz-window-button-box-maximized | -moz-window-button-close | -moz-window-button-maximize | -moz-window-button-minimize | -moz-window-button-restore | -moz-window-frame-bottom | -moz-window-frame-left | -moz-window-frame-right | -moz-window-titlebar | -moz-window-titlebar-maximized",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "noneButOverriddenInUserAgentCSS",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-appearance"
	},
		"-moz-binding": {
		syntax: "<url> | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElementsExceptGeneratedContentOrPseudoElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-binding"
	},
		"-moz-border-bottom-colors": {
		syntax: "<color>+ | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-border-bottom-colors"
	},
		"-moz-border-left-colors": {
		syntax: "<color>+ | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-border-left-colors"
	},
		"-moz-border-right-colors": {
		syntax: "<color>+ | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-border-right-colors"
	},
		"-moz-border-top-colors": {
		syntax: "<color>+ | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-border-top-colors"
	},
		"-moz-context-properties": {
		syntax: "none | [ fill | fill-opacity | stroke | stroke-opacity ]#",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElementsThatCanReferenceImages",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-context-properties"
	},
		"-moz-float-edge": {
		syntax: "border-box | content-box | margin-box | padding-box",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "content-box",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-float-edge"
	},
		"-moz-force-broken-image-icon": {
		syntax: "<integer>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "0",
		appliesto: "images",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-force-broken-image-icon"
	},
		"-moz-image-region": {
		syntax: "<shape> | auto",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "auto",
		appliesto: "xulImageElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-image-region"
	},
		"-moz-orient": {
		syntax: "inline | block | horizontal | vertical",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "inline",
		appliesto: "anyElementEffectOnProgressAndMeter",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-orient"
	},
		"-moz-outline-radius": {
		syntax: "<outline-radius>{1,4} [ / <outline-radius>{1,4} ]?",
		media: "visual",
		inherited: false,
		animationType: [
			"-moz-outline-radius-topleft",
			"-moz-outline-radius-topright",
			"-moz-outline-radius-bottomright",
			"-moz-outline-radius-bottomleft"
		],
		percentages: [
			"-moz-outline-radius-topleft",
			"-moz-outline-radius-topright",
			"-moz-outline-radius-bottomright",
			"-moz-outline-radius-bottomleft"
		],
		groups: [
			"Mozilla Extensions"
		],
		initial: [
			"-moz-outline-radius-topleft",
			"-moz-outline-radius-topright",
			"-moz-outline-radius-bottomright",
			"-moz-outline-radius-bottomleft"
		],
		appliesto: "allElements",
		computed: [
			"-moz-outline-radius-topleft",
			"-moz-outline-radius-topright",
			"-moz-outline-radius-bottomright",
			"-moz-outline-radius-bottomleft"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius"
	},
		"-moz-outline-radius-bottomleft": {
		syntax: "<outline-radius>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"Mozilla Extensions"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius-bottomleft"
	},
		"-moz-outline-radius-bottomright": {
		syntax: "<outline-radius>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"Mozilla Extensions"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius-bottomright"
	},
		"-moz-outline-radius-topleft": {
		syntax: "<outline-radius>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"Mozilla Extensions"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius-topleft"
	},
		"-moz-outline-radius-topright": {
		syntax: "<outline-radius>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"Mozilla Extensions"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius-topright"
	},
		"-moz-stack-sizing": {
		syntax: "ignore | stretch-to-fit",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "stretch-to-fit",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-stack-sizing"
	},
		"-moz-text-blink": {
		syntax: "none | blink",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-text-blink"
	},
		"-moz-user-focus": {
		syntax: "ignore | normal | select-after | select-before | select-menu | select-same | select-all | none",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-user-focus"
	},
		"-moz-user-input": {
		syntax: "auto | none | enabled | disabled",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-user-input"
	},
		"-moz-user-modify": {
		syntax: "read-only | read-write | write-only",
		media: "interactive",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "read-only",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-user-modify"
	},
		"-moz-window-dragging": {
		syntax: "drag | no-drag",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "drag",
		appliesto: "allElementsCreatingNativeWindows",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-window-dragging"
	},
		"-moz-window-shadow": {
		syntax: "default | menu | tooltip | sheet | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "default",
		appliesto: "allElementsCreatingNativeWindows",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-window-shadow"
	},
		"-webkit-appearance": {
		syntax: "none | button | button-bevel | caret | checkbox | default-button | inner-spin-button | listbox | listitem | media-controls-background | media-controls-fullscreen-background | media-current-time-display | media-enter-fullscreen-button | media-exit-fullscreen-button | media-fullscreen-button | media-mute-button | media-overlay-play-button | media-play-button | media-seek-back-button | media-seek-forward-button | media-slider | media-sliderthumb | media-time-remaining-display | media-toggle-closed-captions-button | media-volume-slider | media-volume-slider-container | media-volume-sliderthumb | menulist | menulist-button | menulist-text | menulist-textfield | meter | progress-bar | progress-bar-value | push-button | radio | searchfield | searchfield-cancel-button | searchfield-decoration | searchfield-results-button | searchfield-results-decoration | slider-horizontal | slider-vertical | sliderthumb-horizontal | sliderthumb-vertical | square-button | textarea | textfield",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "noneButOverriddenInUserAgentCSS",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-appearance"
	},
		"-webkit-border-before": {
		syntax: "<'border-width'> || <'border-style'> || <'color'>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: [
			"-webkit-border-before-width"
		],
		groups: [
			"WebKit Extensions"
		],
		initial: [
			"border-width",
			"border-style",
			"color"
		],
		appliesto: "allElements",
		computed: [
			"border-width",
			"border-style",
			"color"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-border-before"
	},
		"-webkit-border-before-color": {
		syntax: "<'color'>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-webkit-border-before-style": {
		syntax: "<'border-style'>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-webkit-border-before-width": {
		syntax: "<'border-width'>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"WebKit Extensions"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-webkit-box-reflect": {
		syntax: "[ above | below | right | left ]? <length>? <image>?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-box-reflect"
	},
		"-webkit-line-clamp": {
		syntax: "none | <integer>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"WebKit Extensions",
			"CSS Overflow"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-line-clamp"
	},
		"-webkit-mask": {
		syntax: "[ <mask-reference> || <position> [ / <bg-size> ]? || <repeat-style> || [ <box> | border | padding | content | text ] || [ <box> | border | padding | content ] ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: [
			"-webkit-mask-image",
			"-webkit-mask-repeat",
			"-webkit-mask-attachment",
			"-webkit-mask-position",
			"-webkit-mask-origin",
			"-webkit-mask-clip"
		],
		appliesto: "allElements",
		computed: [
			"-webkit-mask-image",
			"-webkit-mask-repeat",
			"-webkit-mask-attachment",
			"-webkit-mask-position",
			"-webkit-mask-origin",
			"-webkit-mask-clip"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask"
	},
		"-webkit-mask-attachment": {
		syntax: "<attachment>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "scroll",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-attachment"
	},
		"-webkit-mask-clip": {
		syntax: "[ <box> | border | padding | content | text ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "border",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-clip"
	},
		"-webkit-mask-composite": {
		syntax: "<composite-style>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "source-over",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-composite"
	},
		"-webkit-mask-image": {
		syntax: "<mask-reference>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "absoluteURIOrNone",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-image"
	},
		"-webkit-mask-origin": {
		syntax: "[ <box> | border | padding | content ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "padding",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-origin"
	},
		"-webkit-mask-position": {
		syntax: "<position>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToSizeOfElement",
		groups: [
			"WebKit Extensions"
		],
		initial: "0% 0%",
		appliesto: "allElements",
		computed: "absoluteLengthOrPercentage",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-position"
	},
		"-webkit-mask-position-x": {
		syntax: "[ <length-percentage> | left | center | right ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToSizeOfElement",
		groups: [
			"WebKit Extensions"
		],
		initial: "0%",
		appliesto: "allElements",
		computed: "absoluteLengthOrPercentage",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-position-x"
	},
		"-webkit-mask-position-y": {
		syntax: "[ <length-percentage> | top | center | bottom ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToSizeOfElement",
		groups: [
			"WebKit Extensions"
		],
		initial: "0%",
		appliesto: "allElements",
		computed: "absoluteLengthOrPercentage",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-position-y"
	},
		"-webkit-mask-repeat": {
		syntax: "<repeat-style>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "repeat",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-repeat"
	},
		"-webkit-mask-repeat-x": {
		syntax: "repeat | no-repeat | space | round",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "repeat",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-repeat-x"
	},
		"-webkit-mask-repeat-y": {
		syntax: "repeat | no-repeat | space | round",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "repeat",
		appliesto: "allElements",
		computed: "absoluteLengthOrPercentage",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-repeat-y"
	},
		"-webkit-mask-size": {
		syntax: "<bg-size>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "relativeToBackgroundPositioningArea",
		groups: [
			"WebKit Extensions"
		],
		initial: "auto auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-size"
	},
		"-webkit-overflow-scrolling": {
		syntax: "auto | touch",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "auto",
		appliesto: "scrollingBoxes",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-overflow-scrolling"
	},
		"-webkit-tap-highlight-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "black",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-tap-highlight-color"
	},
		"-webkit-text-fill-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "color",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-text-fill-color"
	},
		"-webkit-text-stroke": {
		syntax: "<length> || <color>",
		media: "visual",
		inherited: true,
		animationType: [
			"-webkit-text-stroke-width",
			"-webkit-text-stroke-color"
		],
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: [
			"-webkit-text-stroke-width",
			"-webkit-text-stroke-color"
		],
		appliesto: "allElements",
		computed: [
			"-webkit-text-stroke-width",
			"-webkit-text-stroke-color"
		],
		order: "canonicalOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-text-stroke"
	},
		"-webkit-text-stroke-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "color",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-text-stroke-color"
	},
		"-webkit-text-stroke-width": {
		syntax: "<length>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "absoluteLength",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-text-stroke-width"
	},
		"-webkit-touch-callout": {
		syntax: "default | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "default",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-touch-callout"
	},
		"-webkit-user-modify": {
		syntax: "read-only | read-write | read-write-plaintext-only",
		media: "interactive",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "read-only",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"align-content": {
		syntax: "normal | <baseline-position> | <content-distribution> | <overflow-position>? <content-position>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "multilineFlexContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/align-content"
	},
		"align-items": {
		syntax: "normal | stretch | <baseline-position> | [ <overflow-position>? <self-position> ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/align-items"
	},
		"align-self": {
		syntax: "auto | normal | stretch | <baseline-position> | <overflow-position>? <self-position>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "auto",
		appliesto: "flexItemsGridItemsAndAbsolutelyPositionedBoxes",
		computed: "autoOnAbsolutelyPositionedElementsValueOfAlignItemsOnParent",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/align-self"
	},
		all: all,
		animation: animation,
		"animation-delay": {
		syntax: "<time>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "0s",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-delay"
	},
		"animation-direction": {
		syntax: "<single-animation-direction>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "normal",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-direction"
	},
		"animation-duration": {
		syntax: "<time>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "0s",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-duration"
	},
		"animation-fill-mode": {
		syntax: "<single-animation-fill-mode>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "none",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-fill-mode"
	},
		"animation-iteration-count": {
		syntax: "<single-animation-iteration-count>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "1",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-iteration-count"
	},
		"animation-name": {
		syntax: "[ none | <keyframes-name> ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "none",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-name"
	},
		"animation-play-state": {
		syntax: "<single-animation-play-state>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "running",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-play-state"
	},
		"animation-timing-function": {
		syntax: "<timing-function>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "ease",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-timing-function"
	},
		appearance: appearance,
		"aspect-ratio": {
		syntax: "auto | <ratio>",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "allElementsExceptInlineBoxesAndInternalRubyOrTableBoxes",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/aspect-ratio"
	},
		azimuth: azimuth,
		"backdrop-filter": {
		syntax: "none | <filter-function-list>",
		media: "visual",
		inherited: false,
		animationType: "filterList",
		percentages: "no",
		groups: [
			"Filter Effects"
		],
		initial: "none",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/backdrop-filter"
	},
		"backface-visibility": {
		syntax: "visible | hidden",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "visible",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/backface-visibility"
	},
		background: background,
		"background-attachment": {
		syntax: "<attachment>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "scroll",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-attachment"
	},
		"background-blend-mode": {
		syntax: "<blend-mode>#",
		media: "none",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Compositing and Blending"
		],
		initial: "normal",
		appliesto: "allElementsSVGContainerGraphicsAndGraphicsReferencingElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-blend-mode"
	},
		"background-clip": {
		syntax: "<box>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "border-box",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-clip"
	},
		"background-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "transparent",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-color"
	},
		"background-image": {
		syntax: "<bg-image>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecifiedURLsAbsolute",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-image"
	},
		"background-origin": {
		syntax: "<box>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "padding-box",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-origin"
	},
		"background-position": {
		syntax: "<bg-position>#",
		media: "visual",
		inherited: false,
		animationType: "repeatableListOfSimpleListOfLpc",
		percentages: "referToSizeOfBackgroundPositioningAreaMinusBackgroundImageSize",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0% 0%",
		appliesto: "allElements",
		computed: "listEachItemTwoKeywordsOriginOffsets",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-position"
	},
		"background-position-x": {
		syntax: "[ center | [ left | right | x-start | x-end ]? <length-percentage>? ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToWidthOfBackgroundPositioningAreaMinusBackgroundImageHeight",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "left",
		appliesto: "allElements",
		computed: "listEachItemConsistingOfAbsoluteLengthPercentageAndOrigin",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-position-x"
	},
		"background-position-y": {
		syntax: "[ center | [ top | bottom | y-start | y-end ]? <length-percentage>? ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToHeightOfBackgroundPositioningAreaMinusBackgroundImageHeight",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "top",
		appliesto: "allElements",
		computed: "listEachItemConsistingOfAbsoluteLengthPercentageAndOrigin",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-position-y"
	},
		"background-repeat": {
		syntax: "<repeat-style>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "repeat",
		appliesto: "allElements",
		computed: "listEachItemHasTwoKeywordsOnePerDimension",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-repeat"
	},
		"background-size": {
		syntax: "<bg-size>#",
		media: "visual",
		inherited: false,
		animationType: "repeatableListOfSimpleListOfLpc",
		percentages: "relativeToBackgroundPositioningArea",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "auto auto",
		appliesto: "allElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-size"
	},
		"block-overflow": {
		syntax: "clip | ellipsis | <string>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "clip",
		appliesto: "blockContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"block-size": {
		syntax: "<'width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "blockSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsWidthAndHeight",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/block-size"
	},
		border: border,
		"border-block": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		appliesto: "allElements",
		computed: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block"
	},
		"border-block-color": {
		syntax: "<'border-top-color'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-color"
	},
		"border-block-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-style"
	},
		"border-block-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-width"
	},
		"border-block-end": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		appliesto: "allElements",
		computed: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-end"
	},
		"border-block-end-color": {
		syntax: "<'border-top-color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-end-color"
	},
		"border-block-end-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-end-style"
	},
		"border-block-end-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-end-width"
	},
		"border-block-start": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-width",
			"border-style",
			"color"
		],
		appliesto: "allElements",
		computed: [
			"border-width",
			"border-style",
			"border-block-start-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-start"
	},
		"border-block-start-color": {
		syntax: "<'border-top-color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-start-color"
	},
		"border-block-start-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-start-style"
	},
		"border-block-start-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-start-width"
	},
		"border-bottom": {
		syntax: "<line-width> || <line-style> || <color>",
		media: "visual",
		inherited: false,
		animationType: [
			"border-bottom-color",
			"border-bottom-style",
			"border-bottom-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-bottom-width",
			"border-bottom-style",
			"border-bottom-color"
		],
		appliesto: "allElements",
		computed: [
			"border-bottom-width",
			"border-bottom-style",
			"border-bottom-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom"
	},
		"border-bottom-color": {
		syntax: "<'border-top-color'>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-color"
	},
		"border-bottom-left-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-left-radius"
	},
		"border-bottom-right-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-right-radius"
	},
		"border-bottom-style": {
		syntax: "<line-style>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-style"
	},
		"border-bottom-width": {
		syntax: "<line-width>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthOr0IfBorderBottomStyleNoneOrHidden",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-width"
	},
		"border-collapse": {
		syntax: "collapse | separate",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Table"
		],
		initial: "separate",
		appliesto: "tableElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-collapse"
	},
		"border-color": {
		syntax: "<color>{1,4}",
		media: "visual",
		inherited: false,
		animationType: [
			"border-bottom-color",
			"border-left-color",
			"border-right-color",
			"border-top-color"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-top-color",
			"border-right-color",
			"border-bottom-color",
			"border-left-color"
		],
		appliesto: "allElements",
		computed: [
			"border-bottom-color",
			"border-left-color",
			"border-right-color",
			"border-top-color"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-color"
	},
		"border-end-end-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-end-end-radius"
	},
		"border-end-start-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-end-start-radius"
	},
		"border-image": {
		syntax: "<'border-image-source'> || <'border-image-slice'> [ / <'border-image-width'> | / <'border-image-width'>? / <'border-image-outset'> ]? || <'border-image-repeat'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: [
			"border-image-slice",
			"border-image-width"
		],
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-image-source",
			"border-image-slice",
			"border-image-width",
			"border-image-outset",
			"border-image-repeat"
		],
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: [
			"border-image-outset",
			"border-image-repeat",
			"border-image-slice",
			"border-image-source",
			"border-image-width"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image"
	},
		"border-image-outset": {
		syntax: "[ <length> | <number> ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0",
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-outset"
	},
		"border-image-repeat": {
		syntax: "[ stretch | repeat | round | space ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "stretch",
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-repeat"
	},
		"border-image-slice": {
		syntax: "<number-percentage>{1,4} && fill?",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "referToSizeOfBorderImage",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "100%",
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: "oneToFourPercentagesOrAbsoluteLengthsPlusFill",
		order: "percentagesOrLengthsFollowedByFill",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-slice"
	},
		"border-image-source": {
		syntax: "none | <image>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: "noneOrImageWithAbsoluteURI",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-source"
	},
		"border-image-width": {
		syntax: "[ <length-percentage> | <number> | auto ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "referToWidthOrHeightOfBorderImageArea",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "1",
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-width"
	},
		"border-inline": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		appliesto: "allElements",
		computed: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline"
	},
		"border-inline-end": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-width",
			"border-style",
			"color"
		],
		appliesto: "allElements",
		computed: [
			"border-width",
			"border-style",
			"border-inline-end-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-end"
	},
		"border-inline-color": {
		syntax: "<'border-top-color'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-color"
	},
		"border-inline-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-style"
	},
		"border-inline-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-width"
	},
		"border-inline-end-color": {
		syntax: "<'border-top-color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-end-color"
	},
		"border-inline-end-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-end-style"
	},
		"border-inline-end-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-end-width"
	},
		"border-inline-start": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-width",
			"border-style",
			"color"
		],
		appliesto: "allElements",
		computed: [
			"border-width",
			"border-style",
			"border-inline-start-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-start"
	},
		"border-inline-start-color": {
		syntax: "<'border-top-color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-start-color"
	},
		"border-inline-start-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-start-style"
	},
		"border-inline-start-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-start-width"
	},
		"border-left": {
		syntax: "<line-width> || <line-style> || <color>",
		media: "visual",
		inherited: false,
		animationType: [
			"border-left-color",
			"border-left-style",
			"border-left-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-left-width",
			"border-left-style",
			"border-left-color"
		],
		appliesto: "allElements",
		computed: [
			"border-left-width",
			"border-left-style",
			"border-left-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-left"
	},
		"border-left-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-left-color"
	},
		"border-left-style": {
		syntax: "<line-style>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-left-style"
	},
		"border-left-width": {
		syntax: "<line-width>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthOr0IfBorderLeftStyleNoneOrHidden",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-left-width"
	},
		"border-radius": {
		syntax: "<length-percentage>{1,4} [ / <length-percentage>{1,4} ]?",
		media: "visual",
		inherited: false,
		animationType: [
			"border-top-left-radius",
			"border-top-right-radius",
			"border-bottom-right-radius",
			"border-bottom-left-radius"
		],
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-top-left-radius",
			"border-top-right-radius",
			"border-bottom-right-radius",
			"border-bottom-left-radius"
		],
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: [
			"border-bottom-left-radius",
			"border-bottom-right-radius",
			"border-top-left-radius",
			"border-top-right-radius"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-radius"
	},
		"border-right": {
		syntax: "<line-width> || <line-style> || <color>",
		media: "visual",
		inherited: false,
		animationType: [
			"border-right-color",
			"border-right-style",
			"border-right-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-right-width",
			"border-right-style",
			"border-right-color"
		],
		appliesto: "allElements",
		computed: [
			"border-right-width",
			"border-right-style",
			"border-right-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-right"
	},
		"border-right-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-right-color"
	},
		"border-right-style": {
		syntax: "<line-style>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-right-style"
	},
		"border-right-width": {
		syntax: "<line-width>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthOr0IfBorderRightStyleNoneOrHidden",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-right-width"
	},
		"border-spacing": {
		syntax: "<length> <length>?",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Table"
		],
		initial: "0",
		appliesto: "tableElements",
		computed: "twoAbsoluteLengths",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-spacing"
	},
		"border-start-end-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-start-end-radius"
	},
		"border-start-start-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-start-start-radius"
	},
		"border-style": {
		syntax: "<line-style>{1,4}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-top-style",
			"border-right-style",
			"border-bottom-style",
			"border-left-style"
		],
		appliesto: "allElements",
		computed: [
			"border-bottom-style",
			"border-left-style",
			"border-right-style",
			"border-top-style"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-style"
	},
		"border-top": {
		syntax: "<line-width> || <line-style> || <color>",
		media: "visual",
		inherited: false,
		animationType: [
			"border-top-color",
			"border-top-style",
			"border-top-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		appliesto: "allElements",
		computed: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top"
	},
		"border-top-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-color"
	},
		"border-top-left-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-left-radius"
	},
		"border-top-right-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-right-radius"
	},
		"border-top-style": {
		syntax: "<line-style>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-style"
	},
		"border-top-width": {
		syntax: "<line-width>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthOr0IfBorderTopStyleNoneOrHidden",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-width"
	},
		"border-width": {
		syntax: "<line-width>{1,4}",
		media: "visual",
		inherited: false,
		animationType: [
			"border-bottom-width",
			"border-left-width",
			"border-right-width",
			"border-top-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-top-width",
			"border-right-width",
			"border-bottom-width",
			"border-left-width"
		],
		appliesto: "allElements",
		computed: [
			"border-bottom-width",
			"border-left-width",
			"border-right-width",
			"border-top-width"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-width"
	},
		bottom: bottom,
		"box-align": {
		syntax: "start | center | end | baseline | stretch",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "stretch",
		appliesto: "elementsWithDisplayBoxOrInlineBox",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-align"
	},
		"box-decoration-break": {
		syntax: "slice | clone",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "slice",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-decoration-break"
	},
		"box-direction": {
		syntax: "normal | reverse | inherit",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "normal",
		appliesto: "elementsWithDisplayBoxOrInlineBox",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-direction"
	},
		"box-flex": {
		syntax: "<number>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "0",
		appliesto: "directChildrenOfElementsWithDisplayMozBoxMozInlineBox",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-flex"
	},
		"box-flex-group": {
		syntax: "<integer>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "1",
		appliesto: "inFlowChildrenOfBoxElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-flex-group"
	},
		"box-lines": {
		syntax: "single | multiple",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "single",
		appliesto: "boxElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-lines"
	},
		"box-ordinal-group": {
		syntax: "<integer>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "1",
		appliesto: "childrenOfBoxElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-ordinal-group"
	},
		"box-orient": {
		syntax: "horizontal | vertical | inline-axis | block-axis | inherit",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "inlineAxisHorizontalInXUL",
		appliesto: "elementsWithDisplayBoxOrInlineBox",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-orient"
	},
		"box-pack": {
		syntax: "start | center | end | justify",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "start",
		appliesto: "elementsWithDisplayMozBoxMozInlineBox",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-pack"
	},
		"box-shadow": {
		syntax: "none | <shadow>#",
		media: "visual",
		inherited: false,
		animationType: "shadowList",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "absoluteLengthsSpecifiedColorAsSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-shadow"
	},
		"box-sizing": {
		syntax: "content-box | border-box",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "content-box",
		appliesto: "allElementsAcceptingWidthOrHeight",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-sizing"
	},
		"break-after": {
		syntax: "auto | avoid | always | all | avoid-page | page | left | right | recto | verso | avoid-column | column | avoid-region | region",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "auto",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/break-after"
	},
		"break-before": {
		syntax: "auto | avoid | always | all | avoid-page | page | left | right | recto | verso | avoid-column | column | avoid-region | region",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "auto",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/break-before"
	},
		"break-inside": {
		syntax: "auto | avoid | avoid-page | avoid-column | avoid-region",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "auto",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/break-inside"
	},
		"caption-side": {
		syntax: "top | bottom | block-start | block-end | inline-start | inline-end",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Table"
		],
		initial: "top",
		appliesto: "tableCaptionElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/caption-side"
	},
		"caret-color": {
		syntax: "auto | <color>",
		media: "interactive",
		inherited: true,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asAutoOrColor",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/caret-color"
	},
		clear: clear,
		clip: clip,
		"clip-path": {
		syntax: "<clip-source> | [ <basic-shape> || <geometry-box> ] | none",
		media: "visual",
		inherited: false,
		animationType: "basicShapeOtherwiseNo",
		percentages: "referToReferenceBoxWhenSpecifiedOtherwiseBorderBox",
		groups: [
			"CSS Masking"
		],
		initial: "none",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedURLsAbsolute",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/clip-path"
	},
		color: color,
		"color-adjust": {
		syntax: "economy | exact",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Color"
		],
		initial: "economy",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/color-adjust"
	},
		"column-count": {
		syntax: "<integer> | auto",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "auto",
		appliesto: "blockContainersExceptTableWrappers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-count"
	},
		"column-fill": {
		syntax: "auto | balance | balance-all",
		media: "visualInContinuousMediaNoEffectInOverflowColumns",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "balance",
		appliesto: "multicolElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-fill"
	},
		"column-gap": {
		syntax: "normal | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "multiColumnElementsFlexContainersGridContainers",
		computed: "asSpecifiedWithLengthsAbsoluteAndNormalComputingToZeroExceptMultiColumn",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-gap"
	},
		"column-rule": {
		syntax: "<'column-rule-width'> || <'column-rule-style'> || <'column-rule-color'>",
		media: "visual",
		inherited: false,
		animationType: [
			"column-rule-color",
			"column-rule-style",
			"column-rule-width"
		],
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: [
			"column-rule-width",
			"column-rule-style",
			"column-rule-color"
		],
		appliesto: "multicolElements",
		computed: [
			"column-rule-color",
			"column-rule-style",
			"column-rule-width"
		],
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-rule"
	},
		"column-rule-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "currentcolor",
		appliesto: "multicolElements",
		computed: "computedColor",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-rule-color"
	},
		"column-rule-style": {
		syntax: "<'border-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "none",
		appliesto: "multicolElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-rule-style"
	},
		"column-rule-width": {
		syntax: "<'border-width'>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "medium",
		appliesto: "multicolElements",
		computed: "absoluteLength0IfColumnRuleStyleNoneOrHidden",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-rule-width"
	},
		"column-span": {
		syntax: "none | all",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "none",
		appliesto: "inFlowBlockLevelElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-span"
	},
		"column-width": {
		syntax: "<length> | auto",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "auto",
		appliesto: "blockContainersExceptTableWrappers",
		computed: "absoluteLengthZeroOrLarger",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-width"
	},
		columns: columns,
		contain: contain,
		content: content,
		"counter-increment": {
		syntax: "[ <custom-ident> <integer>? ]+ | none",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Counter Styles"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/counter-increment"
	},
		"counter-reset": {
		syntax: "[ <custom-ident> <integer>? ]+ | none",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Counter Styles"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/counter-reset"
	},
		"counter-set": {
		syntax: "[ <custom-ident> <integer>? ]+ | none",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Counter Styles"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/counter-set"
	},
		cursor: cursor,
		direction: direction,
		display: display,
		"empty-cells": {
		syntax: "show | hide",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Table"
		],
		initial: "show",
		appliesto: "tableCellElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/empty-cells"
	},
		filter: filter,
		flex: flex,
		"flex-basis": {
		syntax: "content | <'width'>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToFlexContainersInnerMainSize",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "auto",
		appliesto: "flexItemsAndInFlowPseudos",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "lengthOrPercentageBeforeKeywordIfBothPresent",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-basis"
	},
		"flex-direction": {
		syntax: "row | row-reverse | column | column-reverse",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "row",
		appliesto: "flexContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-direction"
	},
		"flex-flow": {
		syntax: "<'flex-direction'> || <'flex-wrap'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: [
			"flex-direction",
			"flex-wrap"
		],
		appliesto: "flexContainers",
		computed: [
			"flex-direction",
			"flex-wrap"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-flow"
	},
		"flex-grow": {
		syntax: "<number>",
		media: "visual",
		inherited: false,
		animationType: "number",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "0",
		appliesto: "flexItemsAndInFlowPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-grow"
	},
		"flex-shrink": {
		syntax: "<number>",
		media: "visual",
		inherited: false,
		animationType: "number",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "1",
		appliesto: "flexItemsAndInFlowPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-shrink"
	},
		"flex-wrap": {
		syntax: "nowrap | wrap | wrap-reverse",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "nowrap",
		appliesto: "flexContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-wrap"
	},
		float: float,
		font: font,
		"font-family": {
		syntax: "[ <family-name> | <generic-family> ]#",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "dependsOnUserAgent",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-family"
	},
		"font-feature-settings": {
		syntax: "normal | <feature-tag-value>#",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-feature-settings"
	},
		"font-kerning": {
		syntax: "auto | normal | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-kerning"
	},
		"font-language-override": {
		syntax: "normal | <string>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-language-override"
	},
		"font-optical-sizing": {
		syntax: "auto | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-optical-sizing"
	},
		"font-variation-settings": {
		syntax: "normal | [ <string> <number> ]#",
		media: "visual",
		inherited: true,
		animationType: "transform",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variation-settings"
	},
		"font-size": {
		syntax: "<absolute-size> | <relative-size> | <length-percentage>",
		media: "visual",
		inherited: true,
		animationType: "length",
		percentages: "referToParentElementsFontSize",
		groups: [
			"CSS Fonts"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-size"
	},
		"font-size-adjust": {
		syntax: "none | <number>",
		media: "visual",
		inherited: true,
		animationType: "number",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-size-adjust"
	},
		"font-stretch": {
		syntax: "<font-stretch-absolute>",
		media: "visual",
		inherited: true,
		animationType: "fontStretch",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-stretch"
	},
		"font-style": {
		syntax: "normal | italic | oblique <angle>?",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-style"
	},
		"font-synthesis": {
		syntax: "none | [ weight || style ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "weight style",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-synthesis"
	},
		"font-variant": {
		syntax: "normal | none | [ <common-lig-values> || <discretionary-lig-values> || <historical-lig-values> || <contextual-alt-values> || stylistic( <feature-value-name> ) || historical-forms || styleset( <feature-value-name># ) || character-variant( <feature-value-name># ) || swash( <feature-value-name> ) || ornaments( <feature-value-name> ) || annotation( <feature-value-name> ) || [ small-caps | all-small-caps | petite-caps | all-petite-caps | unicase | titling-caps ] || <numeric-figure-values> || <numeric-spacing-values> || <numeric-fraction-values> || ordinal || slashed-zero || <east-asian-variant-values> || <east-asian-width-values> || ruby ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant"
	},
		"font-variant-alternates": {
		syntax: "normal | [ stylistic( <feature-value-name> ) || historical-forms || styleset( <feature-value-name># ) || character-variant( <feature-value-name># ) || swash( <feature-value-name> ) || ornaments( <feature-value-name> ) || annotation( <feature-value-name> ) ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-alternates"
	},
		"font-variant-caps": {
		syntax: "normal | small-caps | all-small-caps | petite-caps | all-petite-caps | unicase | titling-caps",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-caps"
	},
		"font-variant-east-asian": {
		syntax: "normal | [ <east-asian-variant-values> || <east-asian-width-values> || ruby ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-east-asian"
	},
		"font-variant-ligatures": {
		syntax: "normal | none | [ <common-lig-values> || <discretionary-lig-values> || <historical-lig-values> || <contextual-alt-values> ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-ligatures"
	},
		"font-variant-numeric": {
		syntax: "normal | [ <numeric-figure-values> || <numeric-spacing-values> || <numeric-fraction-values> || ordinal || slashed-zero ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-numeric"
	},
		"font-variant-position": {
		syntax: "normal | sub | super",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-position"
	},
		"font-weight": {
		syntax: "<font-weight-absolute> | bolder | lighter",
		media: "visual",
		inherited: true,
		animationType: "fontWeight",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "keywordOrNumericalValueBolderLighterTransformedToRealValue",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-weight"
	},
		gap: gap,
		grid: grid,
		"grid-area": {
		syntax: "<grid-line> [ / <grid-line> ]{0,3}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-row-start",
			"grid-column-start",
			"grid-row-end",
			"grid-column-end"
		],
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: [
			"grid-row-start",
			"grid-column-start",
			"grid-row-end",
			"grid-column-end"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-area"
	},
		"grid-auto-columns": {
		syntax: "<track-size>+",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridContainers",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-auto-columns"
	},
		"grid-auto-flow": {
		syntax: "[ row | column ] || dense",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "row",
		appliesto: "gridContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-auto-flow"
	},
		"grid-auto-rows": {
		syntax: "<track-size>+",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridContainers",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-auto-rows"
	},
		"grid-column": {
		syntax: "<grid-line> [ / <grid-line> ]?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-column-start",
			"grid-column-end"
		],
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: [
			"grid-column-start",
			"grid-column-end"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-column"
	},
		"grid-column-end": {
		syntax: "<grid-line>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-column-end"
	},
		"grid-column-gap": {
		syntax: "<length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "0",
		appliesto: "gridContainers",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-gap"
	},
		"grid-column-start": {
		syntax: "<grid-line>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-column-start"
	},
		"grid-gap": {
		syntax: "<'grid-row-gap'> <'grid-column-gap'>?",
		media: "visual",
		inherited: false,
		animationType: [
			"grid-row-gap",
			"grid-column-gap"
		],
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-row-gap",
			"grid-column-gap"
		],
		appliesto: "gridContainers",
		computed: [
			"grid-row-gap",
			"grid-column-gap"
		],
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/gap"
	},
		"grid-row": {
		syntax: "<grid-line> [ / <grid-line> ]?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-row-start",
			"grid-row-end"
		],
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: [
			"grid-row-start",
			"grid-row-end"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-row"
	},
		"grid-row-end": {
		syntax: "<grid-line>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-row-end"
	},
		"grid-row-gap": {
		syntax: "<length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "0",
		appliesto: "gridContainers",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/row-gap"
	},
		"grid-row-start": {
		syntax: "<grid-line>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-row-start"
	},
		"grid-template": {
		syntax: "none | [ <'grid-template-rows'> / <'grid-template-columns'> ] | [ <line-names>? <string> <track-size>? <line-names>? ]+ [ / <explicit-track-list> ]?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: [
			"grid-template-columns",
			"grid-template-rows"
		],
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-template-columns",
			"grid-template-rows",
			"grid-template-areas"
		],
		appliesto: "gridContainers",
		computed: [
			"grid-template-columns",
			"grid-template-rows",
			"grid-template-areas"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-template"
	},
		"grid-template-areas": {
		syntax: "none | <string>+",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "none",
		appliesto: "gridContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-template-areas"
	},
		"grid-template-columns": {
		syntax: "none | <track-list> | <auto-track-list> | subgrid <line-name-list>?",
		media: "visual",
		inherited: false,
		animationType: "simpleListOfLpcDifferenceLpc",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "none",
		appliesto: "gridContainers",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-template-columns"
	},
		"grid-template-rows": {
		syntax: "none | <track-list> | <auto-track-list> | subgrid <line-name-list>?",
		media: "visual",
		inherited: false,
		animationType: "simpleListOfLpcDifferenceLpc",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "none",
		appliesto: "gridContainers",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-template-rows"
	},
		"hanging-punctuation": {
		syntax: "none | [ first || [ force-end | allow-end ] || last ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/hanging-punctuation"
	},
		height: height,
		hyphens: hyphens,
		"image-orientation": {
		syntax: "from-image | <angle> | [ <angle>? flip ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Images"
		],
		initial: "0deg",
		appliesto: "allElements",
		computed: "angleRoundedToNextQuarter",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/image-orientation"
	},
		"image-rendering": {
		syntax: "auto | crisp-edges | pixelated",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Images"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/image-rendering"
	},
		"image-resolution": {
		syntax: "[ from-image || <resolution> ] && snap?",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Images"
		],
		initial: "1dppx",
		appliesto: "allElements",
		computed: "asSpecifiedWithExceptionOfResolution",
		order: "uniqueOrder",
		status: "experimental"
	},
		"ime-mode": {
		syntax: "auto | normal | active | inactive | disabled",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "textFields",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/ime-mode"
	},
		"initial-letter": {
		syntax: "normal | [ <number> <integer>? ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Inline"
		],
		initial: "normal",
		appliesto: "firstLetterPseudoElementsAndInlineLevelFirstChildren",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/initial-letter"
	},
		"initial-letter-align": {
		syntax: "[ auto | alphabetic | hanging | ideographic ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Inline"
		],
		initial: "auto",
		appliesto: "firstLetterPseudoElementsAndInlineLevelFirstChildren",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/initial-letter-align"
	},
		"inline-size": {
		syntax: "<'width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "inlineSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsWidthAndHeight",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inline-size"
	},
		inset: inset,
		"inset-block": {
		syntax: "<'top'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalHeightOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-block"
	},
		"inset-block-end": {
		syntax: "<'top'>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalHeightOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-block-end"
	},
		"inset-block-start": {
		syntax: "<'top'>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalHeightOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-block-start"
	},
		"inset-inline": {
		syntax: "<'top'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-inline"
	},
		"inset-inline-end": {
		syntax: "<'top'>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-inline-end"
	},
		"inset-inline-start": {
		syntax: "<'top'>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-inline-start"
	},
		isolation: isolation,
		"justify-content": {
		syntax: "normal | <content-distribution> | <overflow-position>? [ <content-position> | left | right ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "flexContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/justify-content"
	},
		"justify-items": {
		syntax: "normal | stretch | <baseline-position> | <overflow-position>? [ <self-position> | left | right ] | legacy | legacy && [ left | right | center ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "legacy",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/justify-items"
	},
		"justify-self": {
		syntax: "auto | normal | stretch | <baseline-position> | <overflow-position>? [ <self-position> | left | right ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "auto",
		appliesto: "blockLevelBoxesAndAbsolutelyPositionedBoxesAndGridItems",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/justify-self"
	},
		left: left,
		"letter-spacing": {
		syntax: "normal | <length>",
		media: "visual",
		inherited: true,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "optimumValueOfAbsoluteLengthOrNormal",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/letter-spacing"
	},
		"line-break": {
		syntax: "auto | loose | normal | strict | anywhere",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/line-break"
	},
		"line-clamp": {
		syntax: "none | <integer>",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "none",
		appliesto: "blockContainersExceptMultiColumnContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"line-height": {
		syntax: "normal | <number> | <length> | <percentage>",
		media: "visual",
		inherited: true,
		animationType: "numberOrLength",
		percentages: "referToElementFontSize",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "absoluteLengthOrAsSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/line-height"
	},
		"line-height-step": {
		syntax: "<length>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "0",
		appliesto: "blockContainers",
		computed: "absoluteLength",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/line-height-step"
	},
		"list-style": {
		syntax: "<'list-style-type'> || <'list-style-position'> || <'list-style-image'>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Lists and Counters"
		],
		initial: [
			"list-style-type",
			"list-style-position",
			"list-style-image"
		],
		appliesto: "listItems",
		computed: [
			"list-style-image",
			"list-style-position",
			"list-style-type"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/list-style"
	},
		"list-style-image": {
		syntax: "<url> | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Lists and Counters"
		],
		initial: "none",
		appliesto: "listItems",
		computed: "noneOrImageWithAbsoluteURI",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/list-style-image"
	},
		"list-style-position": {
		syntax: "inside | outside",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Lists and Counters"
		],
		initial: "outside",
		appliesto: "listItems",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/list-style-position"
	},
		"list-style-type": {
		syntax: "<counter-style> | <string> | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Lists and Counters"
		],
		initial: "disc",
		appliesto: "listItems",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/list-style-type"
	},
		margin: margin,
		"margin-block": {
		syntax: "<'margin-left'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-block"
	},
		"margin-block-end": {
		syntax: "<'margin-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-block-end"
	},
		"margin-block-start": {
		syntax: "<'margin-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-block-start"
	},
		"margin-bottom": {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-bottom"
	},
		"margin-inline": {
		syntax: "<'margin-left'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-inline"
	},
		"margin-inline-end": {
		syntax: "<'margin-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-inline-end"
	},
		"margin-inline-start": {
		syntax: "<'margin-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-inline-start"
	},
		"margin-left": {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-left"
	},
		"margin-right": {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-right"
	},
		"margin-top": {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-top"
	},
		mask: mask,
		"mask-border": {
		syntax: "<'mask-border-source'> || <'mask-border-slice'> [ / <'mask-border-width'>? [ / <'mask-border-outset'> ]? ]? || <'mask-border-repeat'> || <'mask-border-mode'>",
		media: "visual",
		inherited: false,
		animationType: [
			"mask-border-mode",
			"mask-border-outset",
			"mask-border-repeat",
			"mask-border-slice",
			"mask-border-source",
			"mask-border-width"
		],
		percentages: [
			"mask-border-slice",
			"mask-border-width"
		],
		groups: [
			"CSS Masking"
		],
		initial: [
			"mask-border-mode",
			"mask-border-outset",
			"mask-border-repeat",
			"mask-border-slice",
			"mask-border-source",
			"mask-border-width"
		],
		appliesto: "allElementsSVGContainerElements",
		computed: [
			"mask-border-mode",
			"mask-border-outset",
			"mask-border-repeat",
			"mask-border-slice",
			"mask-border-source",
			"mask-border-width"
		],
		order: "perGrammar",
		stacking: true,
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border"
	},
		"mask-border-mode": {
		syntax: "luminance | alpha",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "alpha",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-mode"
	},
		"mask-border-outset": {
		syntax: "[ <length> | <number> ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "0",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-outset"
	},
		"mask-border-repeat": {
		syntax: "[ stretch | repeat | round | space ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "stretch",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-repeat"
	},
		"mask-border-slice": {
		syntax: "<number-percentage>{1,4} fill?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToSizeOfMaskBorderImage",
		groups: [
			"CSS Masking"
		],
		initial: "0",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-slice"
	},
		"mask-border-source": {
		syntax: "none | <image>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "none",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedURLsAbsolute",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-source"
	},
		"mask-border-width": {
		syntax: "[ <length-percentage> | <number> | auto ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "relativeToMaskBorderImageArea",
		groups: [
			"CSS Masking"
		],
		initial: "auto",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-width"
	},
		"mask-clip": {
		syntax: "[ <geometry-box> | no-clip ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "border-box",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-clip"
	},
		"mask-composite": {
		syntax: "<compositing-operator>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "add",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-composite"
	},
		"mask-image": {
		syntax: "<mask-reference>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "none",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedURLsAbsolute",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-image"
	},
		"mask-mode": {
		syntax: "<masking-mode>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "match-source",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-mode"
	},
		"mask-origin": {
		syntax: "<geometry-box>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "border-box",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-origin"
	},
		"mask-position": {
		syntax: "<position>#",
		media: "visual",
		inherited: false,
		animationType: "repeatableListOfSimpleListOfLpc",
		percentages: "referToSizeOfMaskPaintingArea",
		groups: [
			"CSS Masking"
		],
		initial: "center",
		appliesto: "allElementsSVGContainerElements",
		computed: "consistsOfTwoKeywordsForOriginAndOffsets",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-position"
	},
		"mask-repeat": {
		syntax: "<repeat-style>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "no-repeat",
		appliesto: "allElementsSVGContainerElements",
		computed: "consistsOfTwoDimensionKeywords",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-repeat"
	},
		"mask-size": {
		syntax: "<bg-size>#",
		media: "visual",
		inherited: false,
		animationType: "repeatableListOfSimpleListOfLpc",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "auto",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-size"
	},
		"mask-type": {
		syntax: "luminance | alpha",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "luminance",
		appliesto: "maskElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-type"
	},
		"max-block-size": {
		syntax: "<'max-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "blockSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsMaxWidthAndMaxHeight",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/max-block-size"
	},
		"max-height": {
		syntax: "<length> | <percentage> | none | max-content | min-content | fit-content | fill-available",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "regardingHeightOfGeneratedBoxContainingBlockPercentagesNone",
		groups: [
			"CSS Box Model"
		],
		initial: "none",
		appliesto: "allElementsButNonReplacedAndTableColumns",
		computed: "percentageAsSpecifiedAbsoluteLengthOrNone",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/max-height"
	},
		"max-inline-size": {
		syntax: "<'max-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "inlineSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsMaxWidthAndMaxHeight",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/max-inline-size"
	},
		"max-lines": {
		syntax: "none | <integer>",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "none",
		appliesto: "blockContainersExceptMultiColumnContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"max-width": {
		syntax: "<length> | <percentage> | none | max-content | min-content | fit-content | fill-available",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "none",
		appliesto: "allElementsButNonReplacedAndTableRows",
		computed: "percentageAsSpecifiedAbsoluteLengthOrNone",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/max-width"
	},
		"min-block-size": {
		syntax: "<'min-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "blockSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsMinWidthAndMinHeight",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/min-block-size"
	},
		"min-height": {
		syntax: "<length> | <percentage> | auto | max-content | min-content | fit-content | fill-available",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "regardingHeightOfGeneratedBoxContainingBlockPercentages0",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "allElementsButNonReplacedAndTableColumns",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/min-height"
	},
		"min-inline-size": {
		syntax: "<'min-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "inlineSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsMinWidthAndMinHeight",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/min-inline-size"
	},
		"min-width": {
		syntax: "<length> | <percentage> | auto | max-content | min-content | fit-content | fill-available",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "allElementsButNonReplacedAndTableRows",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/min-width"
	},
		"mix-blend-mode": {
		syntax: "<blend-mode>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Compositing and Blending"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mix-blend-mode"
	},
		"object-fit": {
		syntax: "fill | contain | cover | none | scale-down",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Images"
		],
		initial: "fill",
		appliesto: "replacedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/object-fit"
	},
		"object-position": {
		syntax: "<position>",
		media: "visual",
		inherited: true,
		animationType: "repeatableListOfSimpleListOfLpc",
		percentages: "referToWidthAndHeightOfElement",
		groups: [
			"CSS Images"
		],
		initial: "50% 50%",
		appliesto: "replacedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/object-position"
	},
		offset: offset,
		"offset-anchor": {
		syntax: "auto | <position>",
		media: "visual",
		inherited: false,
		animationType: "position",
		percentages: "relativeToWidthAndHeight",
		groups: [
			"CSS Motion Path"
		],
		initial: "auto",
		appliesto: "transformableElements",
		computed: "forLengthAbsoluteValueOtherwisePercentage",
		order: "perGrammar",
		status: "experimental"
	},
		"offset-distance": {
		syntax: "<length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToTotalPathLength",
		groups: [
			"CSS Motion Path"
		],
		initial: "0",
		appliesto: "transformableElements",
		computed: "forLengthAbsoluteValueOtherwisePercentage",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/offset-distance"
	},
		"offset-path": {
		syntax: "none | ray( [ <angle> && <size>? && contain? ] ) | <path()> | <url> | [ <basic-shape> || <geometry-box> ]",
		media: "visual",
		inherited: false,
		animationType: "angleOrBasicShapeOrPath",
		percentages: "no",
		groups: [
			"CSS Motion Path"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "perGrammar",
		stacking: true,
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/offset-path"
	},
		"offset-position": {
		syntax: "auto | <position>",
		media: "visual",
		inherited: false,
		animationType: "position",
		percentages: "referToSizeOfContainingBlock",
		groups: [
			"CSS Motion Path"
		],
		initial: "auto",
		appliesto: "transformableElements",
		computed: "forLengthAbsoluteValueOtherwisePercentage",
		order: "perGrammar",
		status: "experimental"
	},
		"offset-rotate": {
		syntax: "[ auto | reverse ] || <angle>",
		media: "visual",
		inherited: false,
		animationType: "angleOrBasicShapeOrPath",
		percentages: "no",
		groups: [
			"CSS Motion Path"
		],
		initial: "auto",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/offset-rotate"
	},
		opacity: opacity,
		order: order,
		orphans: orphans,
		outline: outline,
		"outline-color": {
		syntax: "<color> | invert",
		media: [
			"visual",
			"interactive"
		],
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "invertOrCurrentColor",
		appliesto: "allElements",
		computed: "invertForTranslucentColorRGBAOtherwiseRGB",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline-color"
	},
		"outline-offset": {
		syntax: "<length>",
		media: [
			"visual",
			"interactive"
		],
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline-offset"
	},
		"outline-style": {
		syntax: "auto | <'border-style'>",
		media: [
			"visual",
			"interactive"
		],
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline-style"
	},
		"outline-width": {
		syntax: "<line-width>",
		media: [
			"visual",
			"interactive"
		],
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLength0ForNone",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline-width"
	},
		overflow: overflow,
		"overflow-anchor": {
		syntax: "auto | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Anchoring"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"overflow-block": {
		syntax: "visible | hidden | clip | scroll | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "auto",
		appliesto: "blockContainersFlexContainersGridContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"overflow-clip-box": {
		syntax: "padding-box | content-box",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "padding-box",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Mozilla/CSS/overflow-clip-box"
	},
		"overflow-inline": {
		syntax: "visible | hidden | clip | scroll | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "auto",
		appliesto: "blockContainersFlexContainersGridContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"overflow-wrap": {
		syntax: "normal | break-word | anywhere",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "nonReplacedInlineElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow-wrap"
	},
		"overflow-x": {
		syntax: "visible | hidden | clip | scroll | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "visible",
		appliesto: "blockContainersFlexContainersGridContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow-x"
	},
		"overflow-y": {
		syntax: "visible | hidden | clip | scroll | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "visible",
		appliesto: "blockContainersFlexContainersGridContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow-y"
	},
		"overscroll-behavior": {
		syntax: "[ contain | none | auto ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overscroll-behavior"
	},
		"overscroll-behavior-x": {
		syntax: "contain | none | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overscroll-behavior-x"
	},
		"overscroll-behavior-y": {
		syntax: "contain | none | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overscroll-behavior-y"
	},
		padding: padding,
		"padding-block": {
		syntax: "<'padding-left'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-block"
	},
		"padding-block-end": {
		syntax: "<'padding-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-block-end"
	},
		"padding-block-start": {
		syntax: "<'padding-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-block-start"
	},
		"padding-bottom": {
		syntax: "<length> | <percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptInternalTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-bottom"
	},
		"padding-inline": {
		syntax: "<'padding-left'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-inline"
	},
		"padding-inline-end": {
		syntax: "<'padding-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-inline-end"
	},
		"padding-inline-start": {
		syntax: "<'padding-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-inline-start"
	},
		"padding-left": {
		syntax: "<length> | <percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptInternalTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-left"
	},
		"padding-right": {
		syntax: "<length> | <percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptInternalTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-right"
	},
		"padding-top": {
		syntax: "<length> | <percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptInternalTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-top"
	},
		"page-break-after": {
		syntax: "auto | always | avoid | left | right | recto | verso",
		media: [
			"visual",
			"paged"
		],
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Pages"
		],
		initial: "auto",
		appliesto: "blockElementsInNormalFlow",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/page-break-after"
	},
		"page-break-before": {
		syntax: "auto | always | avoid | left | right | recto | verso",
		media: [
			"visual",
			"paged"
		],
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Pages"
		],
		initial: "auto",
		appliesto: "blockElementsInNormalFlow",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/page-break-before"
	},
		"page-break-inside": {
		syntax: "auto | avoid",
		media: [
			"visual",
			"paged"
		],
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Pages"
		],
		initial: "auto",
		appliesto: "blockElementsInNormalFlow",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/page-break-inside"
	},
		"paint-order": {
		syntax: "normal | [ fill || stroke || markers ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "textElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/paint-order"
	},
		perspective: perspective,
		"perspective-origin": {
		syntax: "<position>",
		media: "visual",
		inherited: false,
		animationType: "simpleListOfLpc",
		percentages: "referToSizeOfBoundingBox",
		groups: [
			"CSS Transforms"
		],
		initial: "50% 50%",
		appliesto: "transformableElements",
		computed: "forLengthAbsoluteValueOtherwisePercentage",
		order: "oneOrTwoValuesLengthAbsoluteKeywordsPercentages",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/perspective-origin"
	},
		"place-content": {
		syntax: "<'align-content'> <'justify-content'>?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "multilineFlexContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/place-content"
	},
		"place-items": {
		syntax: "<'align-items'> <'justify-items'>?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: [
			"align-items",
			"justify-items"
		],
		appliesto: "allElements",
		computed: [
			"align-items",
			"justify-items"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/place-items"
	},
		"place-self": {
		syntax: "<'align-self'> <'justify-self'>?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: [
			"align-self",
			"justify-self"
		],
		appliesto: "blockLevelBoxesAndAbsolutelyPositionedBoxesAndGridItems",
		computed: [
			"align-self",
			"justify-self"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/place-self"
	},
		"pointer-events": {
		syntax: "auto | none | visiblePainted | visibleFill | visibleStroke | visible | painted | fill | stroke | all | inherit",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Pointer Events"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/pointer-events"
	},
		position: position,
		quotes: quotes,
		resize: resize,
		right: right,
		rotate: rotate,
		"row-gap": {
		syntax: "normal | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "multiColumnElementsFlexContainersGridContainers",
		computed: "asSpecifiedWithLengthsAbsoluteAndNormalComputingToZeroExceptMultiColumn",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/row-gap"
	},
		"ruby-align": {
		syntax: "start | center | space-between | space-around",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Ruby"
		],
		initial: "space-around",
		appliesto: "rubyBasesAnnotationsBaseAnnotationContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/ruby-align"
	},
		"ruby-merge": {
		syntax: "separate | collapse | auto",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Ruby"
		],
		initial: "separate",
		appliesto: "rubyAnnotationsContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental"
	},
		"ruby-position": {
		syntax: "over | under | inter-character",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Ruby"
		],
		initial: "over",
		appliesto: "rubyAnnotationsContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/ruby-position"
	},
		scale: scale,
		"scrollbar-color": {
		syntax: "auto | dark | light | <color>{2}",
		media: "visual",
		inherited: true,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Scrollbars"
		],
		initial: "auto",
		appliesto: "scrollingBoxes",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scrollbar-color"
	},
		"scrollbar-width": {
		syntax: "auto | thin | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scrollbars"
		],
		initial: "auto",
		appliesto: "scrollingBoxes",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scrollbar-width"
	},
		"scroll-behavior": {
		syntax: "auto | smooth",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSSOM View"
		],
		initial: "auto",
		appliesto: "scrollingBoxes",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-behavior"
	},
		"scroll-margin": {
		syntax: "<length>{1,4}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin"
	},
		"scroll-margin-block": {
		syntax: "<length>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-block"
	},
		"scroll-margin-block-start": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-block-start"
	},
		"scroll-margin-block-end": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-block-end"
	},
		"scroll-margin-bottom": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-bottom"
	},
		"scroll-margin-inline": {
		syntax: "<length>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-inline"
	},
		"scroll-margin-inline-start": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-inline-start"
	},
		"scroll-margin-inline-end": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-inline-end"
	},
		"scroll-margin-left": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-left"
	},
		"scroll-margin-right": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-right"
	},
		"scroll-margin-top": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-top"
	},
		"scroll-padding": {
		syntax: "[ auto | <length-percentage> ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding"
	},
		"scroll-padding-block": {
		syntax: "[ auto | <length-percentage> ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-block"
	},
		"scroll-padding-block-start": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-block-start"
	},
		"scroll-padding-block-end": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-block-end"
	},
		"scroll-padding-bottom": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-bottom"
	},
		"scroll-padding-inline": {
		syntax: "[ auto | <length-percentage> ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-inline"
	},
		"scroll-padding-inline-start": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-inline-start"
	},
		"scroll-padding-inline-end": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-inline-end"
	},
		"scroll-padding-left": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-left"
	},
		"scroll-padding-right": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-right"
	},
		"scroll-padding-top": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-top"
	},
		"scroll-snap-align": {
		syntax: "[ none | start | end | center ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-align"
	},
		"scroll-snap-coordinate": {
		syntax: "none | <position>#",
		media: "interactive",
		inherited: false,
		animationType: "position",
		percentages: "referToBorderBox",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-coordinate"
	},
		"scroll-snap-destination": {
		syntax: "<position>",
		media: "interactive",
		inherited: false,
		animationType: "position",
		percentages: "relativeToScrollContainerPaddingBoxAxis",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0px 0px",
		appliesto: "scrollContainers",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-destination"
	},
		"scroll-snap-points-x": {
		syntax: "none | repeat( <length-percentage> )",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "relativeToScrollContainerPaddingBoxAxis",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "scrollContainers",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-points-x"
	},
		"scroll-snap-points-y": {
		syntax: "none | repeat( <length-percentage> )",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "relativeToScrollContainerPaddingBoxAxis",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "scrollContainers",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-points-y"
	},
		"scroll-snap-stop": {
		syntax: "normal | always",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-stop"
	},
		"scroll-snap-type": {
		syntax: "none | [ x | y | block | inline | both ] [ mandatory | proximity ]?",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-type"
	},
		"scroll-snap-type-x": {
		syntax: "none | mandatory | proximity",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-type-x"
	},
		"scroll-snap-type-y": {
		syntax: "none | mandatory | proximity",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-type-y"
	},
		"shape-image-threshold": {
		syntax: "<alpha-value>",
		media: "visual",
		inherited: false,
		animationType: "number",
		percentages: "no",
		groups: [
			"CSS Shapes"
		],
		initial: "0.0",
		appliesto: "floats",
		computed: "specifiedValueNumberClipped0To1",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/shape-image-threshold"
	},
		"shape-margin": {
		syntax: "<length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Shapes"
		],
		initial: "0",
		appliesto: "floats",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/shape-margin"
	},
		"shape-outside": {
		syntax: "none | <shape-box> || <basic-shape> | <image>",
		media: "visual",
		inherited: false,
		animationType: "basicShapeOtherwiseNo",
		percentages: "no",
		groups: [
			"CSS Shapes"
		],
		initial: "none",
		appliesto: "floats",
		computed: "asDefinedForBasicShapeWithAbsoluteURIOtherwiseAsSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/shape-outside"
	},
		"tab-size": {
		syntax: "<integer> | <length>",
		media: "visual",
		inherited: true,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "8",
		appliesto: "blockContainers",
		computed: "specifiedIntegerOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/tab-size"
	},
		"table-layout": {
		syntax: "auto | fixed",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Table"
		],
		initial: "auto",
		appliesto: "tableElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/table-layout"
	},
		"text-align": {
		syntax: "start | end | left | right | center | justify | match-parent",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "startOrNamelessValueIfLTRRightIfRTL",
		appliesto: "blockContainers",
		computed: "asSpecifiedExceptMatchParent",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-align"
	},
		"text-align-last": {
		syntax: "auto | start | end | left | right | center | justify",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "auto",
		appliesto: "blockContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-align-last"
	},
		"text-combine-upright": {
		syntax: "none | all | [ digits <integer>? ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Writing Modes"
		],
		initial: "none",
		appliesto: "nonReplacedInlineElements",
		computed: "keywordPlusIntegerIfDigits",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-combine-upright"
	},
		"text-decoration": {
		syntax: "<'text-decoration-line'> || <'text-decoration-style'> || <'text-decoration-color'> || <'text-decoration-thickness'>",
		media: "visual",
		inherited: false,
		animationType: [
			"text-decoration-color",
			"text-decoration-style",
			"text-decoration-line",
			"text-decoration-thickness"
		],
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: [
			"text-decoration-color",
			"text-decoration-style",
			"text-decoration-line"
		],
		appliesto: "allElements",
		computed: [
			"text-decoration-line",
			"text-decoration-style",
			"text-decoration-color",
			"text-decoration-thickness"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration"
	},
		"text-decoration-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-color"
	},
		"text-decoration-line": {
		syntax: "none | [ underline || overline || line-through || blink ] | spelling-error | grammar-error",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-line"
	},
		"text-decoration-skip": {
		syntax: "none | [ objects || [ spaces | [ leading-spaces || trailing-spaces ] ] || edges || box-decoration ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "objects",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-skip"
	},
		"text-decoration-skip-ink": {
		syntax: "auto | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-skip-ink"
	},
		"text-decoration-style": {
		syntax: "solid | double | dotted | dashed | wavy",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "solid",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-style"
	},
		"text-decoration-thickness": {
		syntax: "auto | from-font | <length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-thickness"
	},
		"text-emphasis": {
		syntax: "<'text-emphasis-style'> || <'text-emphasis-color'>",
		media: "visual",
		inherited: false,
		animationType: [
			"text-emphasis-color",
			"text-emphasis-style"
		],
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: [
			"text-emphasis-style",
			"text-emphasis-color"
		],
		appliesto: "allElements",
		computed: [
			"text-emphasis-style",
			"text-emphasis-color"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-emphasis"
	},
		"text-emphasis-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-emphasis-color"
	},
		"text-emphasis-position": {
		syntax: "[ over | under ] && [ right | left ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "over right",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-emphasis-position"
	},
		"text-emphasis-style": {
		syntax: "none | [ [ filled | open ] || [ dot | circle | double-circle | triangle | sesame ] ] | <string>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-emphasis-style"
	},
		"text-indent": {
		syntax: "<length-percentage> && hanging? && each-line?",
		media: "visual",
		inherited: true,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Text"
		],
		initial: "0",
		appliesto: "blockContainers",
		computed: "percentageOrAbsoluteLengthPlusKeywords",
		order: "lengthOrPercentageBeforeKeywords",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-indent"
	},
		"text-justify": {
		syntax: "auto | inter-character | inter-word | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "auto",
		appliesto: "inlineLevelAndTableCellElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-justify"
	},
		"text-orientation": {
		syntax: "mixed | upright | sideways",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Writing Modes"
		],
		initial: "mixed",
		appliesto: "allElementsExceptTableRowGroupsRowsColumnGroupsAndColumns",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-orientation"
	},
		"text-overflow": {
		syntax: "[ clip | ellipsis | <string> ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "clip",
		appliesto: "blockContainerElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-overflow"
	},
		"text-rendering": {
		syntax: "auto | optimizeSpeed | optimizeLegibility | geometricPrecision",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Miscellaneous"
		],
		initial: "auto",
		appliesto: "textElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-rendering"
	},
		"text-shadow": {
		syntax: "none | <shadow-t>#",
		media: "visual",
		inherited: true,
		animationType: "shadowList",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "colorPlusThreeAbsoluteLengths",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-shadow"
	},
		"text-size-adjust": {
		syntax: "none | auto | <percentage>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "referToSizeOfFont",
		groups: [
			"CSS Text"
		],
		initial: "autoForSmartphoneBrowsersSupportingInflation",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-size-adjust"
	},
		"text-transform": {
		syntax: "none | capitalize | uppercase | lowercase | full-width | full-size-kana",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-transform"
	},
		"text-underline-offset": {
		syntax: "auto | from-font | <length>",
		media: "visual",
		inherited: true,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-underline-offset"
	},
		"text-underline-position": {
		syntax: "auto | [ under || [ left | right ] ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-underline-position"
	},
		top: top,
		"touch-action": {
		syntax: "auto | none | [ [ pan-x | pan-left | pan-right ] || [ pan-y | pan-up | pan-down ] || pinch-zoom ] | manipulation",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Pointer Events"
		],
		initial: "auto",
		appliesto: "allElementsExceptNonReplacedInlineElementsTableRowsColumnsRowColumnGroups",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/touch-action"
	},
		transform: transform,
		"transform-box": {
		syntax: "border-box | fill-box | view-box",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "border-box ",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transform-box"
	},
		"transform-origin": {
		syntax: "[ <length-percentage> | left | center | right | top | bottom ] | [ [ <length-percentage> | left | center | right ] && [ <length-percentage> | top | center | bottom ] ] <length>?",
		media: "visual",
		inherited: false,
		animationType: "simpleListOfLpc",
		percentages: "referToSizeOfBoundingBox",
		groups: [
			"CSS Transforms"
		],
		initial: "50% 50% 0",
		appliesto: "transformableElements",
		computed: "forLengthAbsoluteValueOtherwisePercentage",
		order: "oneOrTwoValuesLengthAbsoluteKeywordsPercentages",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transform-origin"
	},
		"transform-style": {
		syntax: "flat | preserve-3d",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "flat",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transform-style"
	},
		transition: transition,
		"transition-delay": {
		syntax: "<time>#",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transitions"
		],
		initial: "0s",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition-delay"
	},
		"transition-duration": {
		syntax: "<time>#",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transitions"
		],
		initial: "0s",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition-duration"
	},
		"transition-property": {
		syntax: "none | <single-transition-property>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transitions"
		],
		initial: "all",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition-property"
	},
		"transition-timing-function": {
		syntax: "<timing-function>#",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transitions"
		],
		initial: "ease",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition-timing-function"
	},
		translate: translate,
		"unicode-bidi": {
		syntax: "normal | embed | isolate | bidi-override | isolate-override | plaintext",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Writing Modes"
		],
		initial: "normal",
		appliesto: "allElementsSomeValuesNoEffectOnNonInlineElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/unicode-bidi"
	},
		"user-select": {
		syntax: "auto | text | none | contain | all",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/user-select"
	},
		"vertical-align": {
		syntax: "baseline | sub | super | text-top | text-bottom | middle | top | bottom | <percentage> | <length>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToLineHeight",
		groups: [
			"CSS Table"
		],
		initial: "baseline",
		appliesto: "inlineLevelAndTableCellElements",
		computed: "absoluteLengthOrKeyword",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/vertical-align"
	},
		visibility: visibility,
		"white-space": {
		syntax: "normal | pre | nowrap | pre-wrap | pre-line | break-spaces",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/white-space"
	},
		widows: widows,
		width: width,
		"will-change": {
		syntax: "auto | <animateable-feature>#",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Will Change"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/will-change"
	},
		"word-break": {
		syntax: "normal | break-all | keep-all | break-word",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/word-break"
	},
		"word-spacing": {
		syntax: "normal | <length-percentage>",
		media: "visual",
		inherited: true,
		animationType: "length",
		percentages: "referToWidthOfAffectedGlyph",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "optimumMinAndMaxValueOfAbsoluteLengthPercentageOrNormal",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/word-spacing"
	},
		"word-wrap": {
		syntax: "normal | break-word",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "nonReplacedInlineElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow-wrap"
	},
		"writing-mode": {
		syntax: "horizontal-tb | vertical-rl | vertical-lr | sideways-rl | sideways-lr",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Writing Modes"
		],
		initial: "horizontal-tb",
		appliesto: "allElementsExceptTableRowColumnGroupsTableRowsColumns",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/writing-mode"
	},
		"z-index": {
		syntax: "auto | <integer>",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"CSS Positioning"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/z-index"
	},
		zoom: zoom
	};

	var properties$2 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		all: all,
		animation: animation,
		appearance: appearance,
		azimuth: azimuth,
		background: background,
		border: border,
		bottom: bottom,
		clear: clear,
		clip: clip,
		color: color,
		columns: columns,
		contain: contain,
		content: content,
		cursor: cursor,
		direction: direction,
		display: display,
		filter: filter,
		flex: flex,
		float: float,
		font: font,
		gap: gap,
		grid: grid,
		height: height,
		hyphens: hyphens,
		inset: inset,
		isolation: isolation,
		left: left,
		margin: margin,
		mask: mask,
		offset: offset,
		opacity: opacity,
		order: order,
		orphans: orphans,
		outline: outline,
		overflow: overflow,
		padding: padding,
		perspective: perspective,
		position: position,
		quotes: quotes,
		resize: resize,
		right: right,
		rotate: rotate,
		scale: scale,
		top: top,
		transform: transform,
		transition: transition,
		translate: translate,
		visibility: visibility,
		widows: widows,
		width: width,
		zoom: zoom,
		'default': properties$1
	});

	var attachment = {
		syntax: "scroll | fixed | local"
	};
	var box = {
		syntax: "border-box | padding-box | content-box"
	};
	var color$1 = {
		syntax: "<rgb()> | <rgba()> | <hsl()> | <hsla()> | <hex-color> | <named-color> | currentcolor | <deprecated-system-color>"
	};
	var combinator = {
		syntax: "'>' | '+' | '~' | [ '||' ]"
	};
	var compat = {
		syntax: "searchfield | textarea | push-button | button-bevel | slider-horizontal | checkbox | radio | square-button | menulist | menulist-button | listbox | meter | progress-bar"
	};
	var gradient = {
		syntax: "<linear-gradient()> | <repeating-linear-gradient()> | <radial-gradient()> | <repeating-radial-gradient()> | <conic-gradient()>"
	};
	var hue = {
		syntax: "<number> | <angle>"
	};
	var image = {
		syntax: "<url> | <image()> | <image-set()> | <element()> | <paint()> | <cross-fade()> | <gradient>"
	};
	var nth = {
		syntax: "<an-plus-b> | even | odd"
	};
	var position$1 = {
		syntax: "[ [ left | center | right ] || [ top | center | bottom ] | [ left | center | right | <length-percentage> ] [ top | center | bottom | <length-percentage> ]? | [ [ left | right ] <length-percentage> ] && [ [ top | bottom ] <length-percentage> ] ]"
	};
	var quote = {
		syntax: "open-quote | close-quote | no-open-quote | no-close-quote"
	};
	var shadow = {
		syntax: "inset? && <length>{2,4} && <color>?"
	};
	var shape$1 = {
		syntax: "rect(<top>, <right>, <bottom>, <left>)"
	};
	var size = {
		syntax: "closest-side | farthest-side | closest-corner | farthest-corner | <length> | <length-percentage>{2}"
	};
	var symbol = {
		syntax: "<string> | <image> | <custom-ident>"
	};
	var target = {
		syntax: "<target-counter()> | <target-counters()> | <target-text()>"
	};
	var syntaxes = {
		"absolute-size": {
		syntax: "xx-small | x-small | small | medium | large | x-large | xx-large | xxx-large"
	},
		"alpha-value": {
		syntax: "<number> | <percentage>"
	},
		"angle-percentage": {
		syntax: "<angle> | <percentage>"
	},
		"angular-color-hint": {
		syntax: "<angle-percentage>"
	},
		"angular-color-stop": {
		syntax: "<color> && <color-stop-angle>?"
	},
		"angular-color-stop-list": {
		syntax: "[ <angular-color-stop> [, <angular-color-hint>]? ]# , <angular-color-stop>"
	},
		"animateable-feature": {
		syntax: "scroll-position | contents | <custom-ident>"
	},
		attachment: attachment,
		"attr()": {
		syntax: "attr( <attr-name> <type-or-unit>? [, <attr-fallback> ]? )"
	},
		"attr-matcher": {
		syntax: "[ '~' | '|' | '^' | '$' | '*' ]? '='"
	},
		"attr-modifier": {
		syntax: "i | s"
	},
		"attribute-selector": {
		syntax: "'[' <wq-name> ']' | '[' <wq-name> <attr-matcher> [ <string-token> | <ident-token> ] <attr-modifier>? ']'"
	},
		"auto-repeat": {
		syntax: "repeat( [ auto-fill | auto-fit ] , [ <line-names>? <fixed-size> ]+ <line-names>? )"
	},
		"auto-track-list": {
		syntax: "[ <line-names>? [ <fixed-size> | <fixed-repeat> ] ]* <line-names>? <auto-repeat>\n[ <line-names>? [ <fixed-size> | <fixed-repeat> ] ]* <line-names>?"
	},
		"baseline-position": {
		syntax: "[ first | last ]? baseline"
	},
		"basic-shape": {
		syntax: "<inset()> | <circle()> | <ellipse()> | <polygon()>"
	},
		"bg-image": {
		syntax: "none | <image>"
	},
		"bg-layer": {
		syntax: "<bg-image> || <bg-position> [ / <bg-size> ]? || <repeat-style> || <attachment> || <box> || <box>"
	},
		"bg-position": {
		syntax: "[ [ left | center | right | top | bottom | <length-percentage> ] | [ left | center | right | <length-percentage> ] [ top | center | bottom | <length-percentage> ] | [ center | [ left | right ] <length-percentage>? ] && [ center | [ top | bottom ] <length-percentage>? ] ]"
	},
		"bg-size": {
		syntax: "[ <length-percentage> | auto ]{1,2} | cover | contain"
	},
		"blur()": {
		syntax: "blur( <length> )"
	},
		"blend-mode": {
		syntax: "normal | multiply | screen | overlay | darken | lighten | color-dodge | color-burn | hard-light | soft-light | difference | exclusion | hue | saturation | color | luminosity"
	},
		box: box,
		"brightness()": {
		syntax: "brightness( <number-percentage> )"
	},
		"calc()": {
		syntax: "calc( <calc-sum> )"
	},
		"calc-sum": {
		syntax: "<calc-product> [ [ '+' | '-' ] <calc-product> ]*"
	},
		"calc-product": {
		syntax: "<calc-value> [ '*' <calc-value> | '/' <number> ]*"
	},
		"calc-value": {
		syntax: "<number> | <dimension> | <percentage> | ( <calc-sum> )"
	},
		"cf-final-image": {
		syntax: "<image> | <color>"
	},
		"cf-mixing-image": {
		syntax: "<percentage>? && <image>"
	},
		"circle()": {
		syntax: "circle( [ <shape-radius> ]? [ at <position> ]? )"
	},
		"clamp()": {
		syntax: "clamp( <calc-sum>#{3} )"
	},
		"class-selector": {
		syntax: "'.' <ident-token>"
	},
		"clip-source": {
		syntax: "<url>"
	},
		color: color$1,
		"color-stop": {
		syntax: "<color-stop-length> | <color-stop-angle>"
	},
		"color-stop-angle": {
		syntax: "<angle-percentage>{1,2}"
	},
		"color-stop-length": {
		syntax: "<length-percentage>{1,2}"
	},
		"color-stop-list": {
		syntax: "[ <linear-color-stop> [, <linear-color-hint>]? ]# , <linear-color-stop>"
	},
		combinator: combinator,
		"common-lig-values": {
		syntax: "[ common-ligatures | no-common-ligatures ]"
	},
		compat: compat,
		"composite-style": {
		syntax: "clear | copy | source-over | source-in | source-out | source-atop | destination-over | destination-in | destination-out | destination-atop | xor"
	},
		"compositing-operator": {
		syntax: "add | subtract | intersect | exclude"
	},
		"compound-selector": {
		syntax: "[ <type-selector>? <subclass-selector>* [ <pseudo-element-selector> <pseudo-class-selector>* ]* ]!"
	},
		"compound-selector-list": {
		syntax: "<compound-selector>#"
	},
		"complex-selector": {
		syntax: "<compound-selector> [ <combinator>? <compound-selector> ]*"
	},
		"complex-selector-list": {
		syntax: "<complex-selector>#"
	},
		"conic-gradient()": {
		syntax: "conic-gradient( [ from <angle> ]? [ at <position> ]?, <angular-color-stop-list> )"
	},
		"contextual-alt-values": {
		syntax: "[ contextual | no-contextual ]"
	},
		"content-distribution": {
		syntax: "space-between | space-around | space-evenly | stretch"
	},
		"content-list": {
		syntax: "[ <string> | contents | <image> | <quote> | <target> | <leader()> ]+"
	},
		"content-position": {
		syntax: "center | start | end | flex-start | flex-end"
	},
		"content-replacement": {
		syntax: "<image>"
	},
		"contrast()": {
		syntax: "contrast( [ <number-percentage> ] )"
	},
		"counter()": {
		syntax: "counter( <custom-ident>, <counter-style>? )"
	},
		"counter-style": {
		syntax: "<counter-style-name> | symbols()"
	},
		"counter-style-name": {
		syntax: "<custom-ident>"
	},
		"counters()": {
		syntax: "counters( <custom-ident>, <string>, <counter-style>? )"
	},
		"cross-fade()": {
		syntax: "cross-fade( <cf-mixing-image> , <cf-final-image>? )"
	},
		"cubic-bezier-timing-function": {
		syntax: "ease | ease-in | ease-out | ease-in-out | cubic-bezier(<number>, <number>, <number>, <number>)"
	},
		"deprecated-system-color": {
		syntax: "ActiveBorder | ActiveCaption | AppWorkspace | Background | ButtonFace | ButtonHighlight | ButtonShadow | ButtonText | CaptionText | GrayText | Highlight | HighlightText | InactiveBorder | InactiveCaption | InactiveCaptionText | InfoBackground | InfoText | Menu | MenuText | Scrollbar | ThreeDDarkShadow | ThreeDFace | ThreeDHighlight | ThreeDLightShadow | ThreeDShadow | Window | WindowFrame | WindowText"
	},
		"discretionary-lig-values": {
		syntax: "[ discretionary-ligatures | no-discretionary-ligatures ]"
	},
		"display-box": {
		syntax: "contents | none"
	},
		"display-inside": {
		syntax: "flow | flow-root | table | flex | grid | ruby"
	},
		"display-internal": {
		syntax: "table-row-group | table-header-group | table-footer-group | table-row | table-cell | table-column-group | table-column | table-caption | ruby-base | ruby-text | ruby-base-container | ruby-text-container"
	},
		"display-legacy": {
		syntax: "inline-block | inline-list-item | inline-table | inline-flex | inline-grid"
	},
		"display-listitem": {
		syntax: "<display-outside>? && [ flow | flow-root ]? && list-item"
	},
		"display-outside": {
		syntax: "block | inline | run-in"
	},
		"drop-shadow()": {
		syntax: "drop-shadow( <length>{2,3} <color>? )"
	},
		"east-asian-variant-values": {
		syntax: "[ jis78 | jis83 | jis90 | jis04 | simplified | traditional ]"
	},
		"east-asian-width-values": {
		syntax: "[ full-width | proportional-width ]"
	},
		"element()": {
		syntax: "element( <id-selector> )"
	},
		"ellipse()": {
		syntax: "ellipse( [ <shape-radius>{2} ]? [ at <position> ]? )"
	},
		"ending-shape": {
		syntax: "circle | ellipse"
	},
		"env()": {
		syntax: "env( <custom-ident> , <declaration-value>? )"
	},
		"explicit-track-list": {
		syntax: "[ <line-names>? <track-size> ]+ <line-names>?"
	},
		"family-name": {
		syntax: "<string> | <custom-ident>+"
	},
		"feature-tag-value": {
		syntax: "<string> [ <integer> | on | off ]?"
	},
		"feature-type": {
		syntax: "@stylistic | @historical-forms | @styleset | @character-variant | @swash | @ornaments | @annotation"
	},
		"feature-value-block": {
		syntax: "<feature-type> '{' <feature-value-declaration-list> '}'"
	},
		"feature-value-block-list": {
		syntax: "<feature-value-block>+"
	},
		"feature-value-declaration": {
		syntax: "<custom-ident>: <integer>+;"
	},
		"feature-value-declaration-list": {
		syntax: "<feature-value-declaration>"
	},
		"feature-value-name": {
		syntax: "<custom-ident>"
	},
		"fill-rule": {
		syntax: "nonzero | evenodd"
	},
		"filter-function": {
		syntax: "<blur()> | <brightness()> | <contrast()> | <drop-shadow()> | <grayscale()> | <hue-rotate()> | <invert()> | <opacity()> | <saturate()> | <sepia()>"
	},
		"filter-function-list": {
		syntax: "[ <filter-function> | <url> ]+"
	},
		"final-bg-layer": {
		syntax: "<'background-color'> || <bg-image> || <bg-position> [ / <bg-size> ]? || <repeat-style> || <attachment> || <box> || <box>"
	},
		"fit-content()": {
		syntax: "fit-content( [ <length> | <percentage> ] )"
	},
		"fixed-breadth": {
		syntax: "<length-percentage>"
	},
		"fixed-repeat": {
		syntax: "repeat( [ <positive-integer> ] , [ <line-names>? <fixed-size> ]+ <line-names>? )"
	},
		"fixed-size": {
		syntax: "<fixed-breadth> | minmax( <fixed-breadth> , <track-breadth> ) | minmax( <inflexible-breadth> , <fixed-breadth> )"
	},
		"font-stretch-absolute": {
		syntax: "normal | ultra-condensed | extra-condensed | condensed | semi-condensed | semi-expanded | expanded | extra-expanded | ultra-expanded | <percentage>"
	},
		"font-variant-css21": {
		syntax: "[ normal | small-caps ]"
	},
		"font-weight-absolute": {
		syntax: "normal | bold | <number>"
	},
		"frequency-percentage": {
		syntax: "<frequency> | <percentage>"
	},
		"general-enclosed": {
		syntax: "[ <function-token> <any-value> ) ] | ( <ident> <any-value> )"
	},
		"generic-family": {
		syntax: "serif | sans-serif | cursive | fantasy | monospace"
	},
		"generic-name": {
		syntax: "serif | sans-serif | cursive | fantasy | monospace"
	},
		"geometry-box": {
		syntax: "<shape-box> | fill-box | stroke-box | view-box"
	},
		gradient: gradient,
		"grayscale()": {
		syntax: "grayscale( <number-percentage> )"
	},
		"grid-line": {
		syntax: "auto | <custom-ident> | [ <integer> && <custom-ident>? ] | [ span && [ <integer> || <custom-ident> ] ]"
	},
		"historical-lig-values": {
		syntax: "[ historical-ligatures | no-historical-ligatures ]"
	},
		"hsl()": {
		syntax: "hsl( <hue> <percentage> <percentage> [ / <alpha-value> ]? ) | hsl( <hue>, <percentage>, <percentage>, <alpha-value>? )"
	},
		"hsla()": {
		syntax: "hsla( <hue> <percentage> <percentage> [ / <alpha-value> ]? ) | hsla( <hue>, <percentage>, <percentage>, <alpha-value>? )"
	},
		hue: hue,
		"hue-rotate()": {
		syntax: "hue-rotate( <angle> )"
	},
		"id-selector": {
		syntax: "<hash-token>"
	},
		image: image,
		"image()": {
		syntax: "image( <image-tags>? [ <image-src>? , <color>? ]! )"
	},
		"image-set()": {
		syntax: "image-set( <image-set-option># )"
	},
		"image-set-option": {
		syntax: "[ <image> | <string> ] <resolution>"
	},
		"image-src": {
		syntax: "<url> | <string>"
	},
		"image-tags": {
		syntax: "ltr | rtl"
	},
		"inflexible-breadth": {
		syntax: "<length> | <percentage> | min-content | max-content | auto"
	},
		"inset()": {
		syntax: "inset( <length-percentage>{1,4} [ round <'border-radius'> ]? )"
	},
		"invert()": {
		syntax: "invert( <number-percentage> )"
	},
		"keyframes-name": {
		syntax: "<custom-ident> | <string>"
	},
		"keyframe-block": {
		syntax: "<keyframe-selector># {\n  <declaration-list>\n}"
	},
		"keyframe-block-list": {
		syntax: "<keyframe-block>+"
	},
		"keyframe-selector": {
		syntax: "from | to | <percentage>"
	},
		"leader()": {
		syntax: "leader( <leader-type> )"
	},
		"leader-type": {
		syntax: "dotted | solid | space | <string>"
	},
		"length-percentage": {
		syntax: "<length> | <percentage>"
	},
		"line-names": {
		syntax: "'[' <custom-ident>* ']'"
	},
		"line-name-list": {
		syntax: "[ <line-names> | <name-repeat> ]+"
	},
		"line-style": {
		syntax: "none | hidden | dotted | dashed | solid | double | groove | ridge | inset | outset"
	},
		"line-width": {
		syntax: "<length> | thin | medium | thick"
	},
		"linear-color-hint": {
		syntax: "<length-percentage>"
	},
		"linear-color-stop": {
		syntax: "<color> <color-stop-length>?"
	},
		"linear-gradient()": {
		syntax: "linear-gradient( [ <angle> | to <side-or-corner> ]? , <color-stop-list> )"
	},
		"mask-layer": {
		syntax: "<mask-reference> || <position> [ / <bg-size> ]? || <repeat-style> || <geometry-box> || [ <geometry-box> | no-clip ] || <compositing-operator> || <masking-mode>"
	},
		"mask-position": {
		syntax: "[ <length-percentage> | left | center | right ] [ <length-percentage> | top | center | bottom ]?"
	},
		"mask-reference": {
		syntax: "none | <image> | <mask-source>"
	},
		"mask-source": {
		syntax: "<url>"
	},
		"masking-mode": {
		syntax: "alpha | luminance | match-source"
	},
		"matrix()": {
		syntax: "matrix( <number>#{6} )"
	},
		"matrix3d()": {
		syntax: "matrix3d( <number>#{16} )"
	},
		"max()": {
		syntax: "max( <calc-sum># )"
	},
		"media-and": {
		syntax: "<media-in-parens> [ and <media-in-parens> ]+"
	},
		"media-condition": {
		syntax: "<media-not> | <media-and> | <media-or> | <media-in-parens>"
	},
		"media-condition-without-or": {
		syntax: "<media-not> | <media-and> | <media-in-parens>"
	},
		"media-feature": {
		syntax: "( [ <mf-plain> | <mf-boolean> | <mf-range> ] )"
	},
		"media-in-parens": {
		syntax: "( <media-condition> ) | <media-feature> | <general-enclosed>"
	},
		"media-not": {
		syntax: "not <media-in-parens>"
	},
		"media-or": {
		syntax: "<media-in-parens> [ or <media-in-parens> ]+"
	},
		"media-query": {
		syntax: "<media-condition> | [ not | only ]? <media-type> [ and <media-condition-without-or> ]?"
	},
		"media-query-list": {
		syntax: "<media-query>#"
	},
		"media-type": {
		syntax: "<ident>"
	},
		"mf-boolean": {
		syntax: "<mf-name>"
	},
		"mf-name": {
		syntax: "<ident>"
	},
		"mf-plain": {
		syntax: "<mf-name> : <mf-value>"
	},
		"mf-range": {
		syntax: "<mf-name> [ '<' | '>' ]? '='? <mf-value>\n| <mf-value> [ '<' | '>' ]? '='? <mf-name>\n| <mf-value> '<' '='? <mf-name> '<' '='? <mf-value>\n| <mf-value> '>' '='? <mf-name> '>' '='? <mf-value>"
	},
		"mf-value": {
		syntax: "<number> | <dimension> | <ident> | <ratio>"
	},
		"min()": {
		syntax: "min( <calc-sum># )"
	},
		"minmax()": {
		syntax: "minmax( [ <length> | <percentage> | <flex> | min-content | max-content | auto ] , [ <length> | <percentage> | <flex> | min-content | max-content | auto ] )"
	},
		"named-color": {
		syntax: "transparent | aliceblue | antiquewhite | aqua | aquamarine | azure | beige | bisque | black | blanchedalmond | blue | blueviolet | brown | burlywood | cadetblue | chartreuse | chocolate | coral | cornflowerblue | cornsilk | crimson | cyan | darkblue | darkcyan | darkgoldenrod | darkgray | darkgreen | darkgrey | darkkhaki | darkmagenta | darkolivegreen | darkorange | darkorchid | darkred | darksalmon | darkseagreen | darkslateblue | darkslategray | darkslategrey | darkturquoise | darkviolet | deeppink | deepskyblue | dimgray | dimgrey | dodgerblue | firebrick | floralwhite | forestgreen | fuchsia | gainsboro | ghostwhite | gold | goldenrod | gray | green | greenyellow | grey | honeydew | hotpink | indianred | indigo | ivory | khaki | lavender | lavenderblush | lawngreen | lemonchiffon | lightblue | lightcoral | lightcyan | lightgoldenrodyellow | lightgray | lightgreen | lightgrey | lightpink | lightsalmon | lightseagreen | lightskyblue | lightslategray | lightslategrey | lightsteelblue | lightyellow | lime | limegreen | linen | magenta | maroon | mediumaquamarine | mediumblue | mediumorchid | mediumpurple | mediumseagreen | mediumslateblue | mediumspringgreen | mediumturquoise | mediumvioletred | midnightblue | mintcream | mistyrose | moccasin | navajowhite | navy | oldlace | olive | olivedrab | orange | orangered | orchid | palegoldenrod | palegreen | paleturquoise | palevioletred | papayawhip | peachpuff | peru | pink | plum | powderblue | purple | rebeccapurple | red | rosybrown | royalblue | saddlebrown | salmon | sandybrown | seagreen | seashell | sienna | silver | skyblue | slateblue | slategray | slategrey | snow | springgreen | steelblue | tan | teal | thistle | tomato | turquoise | violet | wheat | white | whitesmoke | yellow | yellowgreen"
	},
		"namespace-prefix": {
		syntax: "<ident>"
	},
		"ns-prefix": {
		syntax: "[ <ident-token> | '*' ]? '|'"
	},
		"number-percentage": {
		syntax: "<number> | <percentage>"
	},
		"numeric-figure-values": {
		syntax: "[ lining-nums | oldstyle-nums ]"
	},
		"numeric-fraction-values": {
		syntax: "[ diagonal-fractions | stacked-fractions ]"
	},
		"numeric-spacing-values": {
		syntax: "[ proportional-nums | tabular-nums ]"
	},
		nth: nth,
		"opacity()": {
		syntax: "opacity( [ <number-percentage> ] )"
	},
		"overflow-position": {
		syntax: "unsafe | safe"
	},
		"outline-radius": {
		syntax: "<length> | <percentage>"
	},
		"page-body": {
		syntax: "<declaration>? [ ; <page-body> ]? | <page-margin-box> <page-body>"
	},
		"page-margin-box": {
		syntax: "<page-margin-box-type> '{' <declaration-list> '}'"
	},
		"page-margin-box-type": {
		syntax: "@top-left-corner | @top-left | @top-center | @top-right | @top-right-corner | @bottom-left-corner | @bottom-left | @bottom-center | @bottom-right | @bottom-right-corner | @left-top | @left-middle | @left-bottom | @right-top | @right-middle | @right-bottom"
	},
		"page-selector-list": {
		syntax: "[ <page-selector># ]?"
	},
		"page-selector": {
		syntax: "<pseudo-page>+ | <ident> <pseudo-page>*"
	},
		"paint()": {
		syntax: "paint( <ident>, <declaration-value>? )"
	},
		"perspective()": {
		syntax: "perspective( <length> )"
	},
		"polygon()": {
		syntax: "polygon( <fill-rule>? , [ <length-percentage> <length-percentage> ]# )"
	},
		position: position$1,
		"pseudo-class-selector": {
		syntax: "':' <ident-token> | ':' <function-token> <any-value> ')'"
	},
		"pseudo-element-selector": {
		syntax: "':' <pseudo-class-selector>"
	},
		"pseudo-page": {
		syntax: ": [ left | right | first | blank ]"
	},
		quote: quote,
		"radial-gradient()": {
		syntax: "radial-gradient( [ <ending-shape> || <size> ]? [ at <position> ]? , <color-stop-list> )"
	},
		"relative-selector": {
		syntax: "<combinator>? <complex-selector>"
	},
		"relative-selector-list": {
		syntax: "<relative-selector>#"
	},
		"relative-size": {
		syntax: "larger | smaller"
	},
		"repeat-style": {
		syntax: "repeat-x | repeat-y | [ repeat | space | round | no-repeat ]{1,2}"
	},
		"repeating-linear-gradient()": {
		syntax: "repeating-linear-gradient( [ <angle> | to <side-or-corner> ]? , <color-stop-list> )"
	},
		"repeating-radial-gradient()": {
		syntax: "repeating-radial-gradient( [ <ending-shape> || <size> ]? [ at <position> ]? , <color-stop-list> )"
	},
		"rgb()": {
		syntax: "rgb( <percentage>{3} [ / <alpha-value> ]? ) | rgb( <number>{3} [ / <alpha-value> ]? ) | rgb( <percentage>#{3} , <alpha-value>? ) | rgb( <number>#{3} , <alpha-value>? )"
	},
		"rgba()": {
		syntax: "rgba( <percentage>{3} [ / <alpha-value> ]? ) | rgba( <number>{3} [ / <alpha-value> ]? ) | rgba( <percentage>#{3} , <alpha-value>? ) | rgba( <number>#{3} , <alpha-value>? )"
	},
		"rotate()": {
		syntax: "rotate( [ <angle> | <zero> ] )"
	},
		"rotate3d()": {
		syntax: "rotate3d( <number> , <number> , <number> , [ <angle> | <zero> ] )"
	},
		"rotateX()": {
		syntax: "rotateX( [ <angle> | <zero> ] )"
	},
		"rotateY()": {
		syntax: "rotateY( [ <angle> | <zero> ] )"
	},
		"rotateZ()": {
		syntax: "rotateZ( [ <angle> | <zero> ] )"
	},
		"saturate()": {
		syntax: "saturate( <number-percentage> )"
	},
		"scale()": {
		syntax: "scale( <number> , <number>? )"
	},
		"scale3d()": {
		syntax: "scale3d( <number> , <number> , <number> )"
	},
		"scaleX()": {
		syntax: "scaleX( <number> )"
	},
		"scaleY()": {
		syntax: "scaleY( <number> )"
	},
		"scaleZ()": {
		syntax: "scaleZ( <number> )"
	},
		"self-position": {
		syntax: "center | start | end | self-start | self-end | flex-start | flex-end"
	},
		"shape-radius": {
		syntax: "<length-percentage> | closest-side | farthest-side"
	},
		"skew()": {
		syntax: "skew( [ <angle> | <zero> ] , [ <angle> | <zero> ]? )"
	},
		"skewX()": {
		syntax: "skewX( [ <angle> | <zero> ] )"
	},
		"skewY()": {
		syntax: "skewY( [ <angle> | <zero> ] )"
	},
		"sepia()": {
		syntax: "sepia( <number-percentage> )"
	},
		shadow: shadow,
		"shadow-t": {
		syntax: "[ <length>{2,3} && <color>? ]"
	},
		shape: shape$1,
		"shape-box": {
		syntax: "<box> | margin-box"
	},
		"side-or-corner": {
		syntax: "[ left | right ] || [ top | bottom ]"
	},
		"single-animation": {
		syntax: "<time> || <timing-function> || <time> || <single-animation-iteration-count> || <single-animation-direction> || <single-animation-fill-mode> || <single-animation-play-state> || [ none | <keyframes-name> ]"
	},
		"single-animation-direction": {
		syntax: "normal | reverse | alternate | alternate-reverse"
	},
		"single-animation-fill-mode": {
		syntax: "none | forwards | backwards | both"
	},
		"single-animation-iteration-count": {
		syntax: "infinite | <number>"
	},
		"single-animation-play-state": {
		syntax: "running | paused"
	},
		"single-transition": {
		syntax: "[ none | <single-transition-property> ] || <time> || <timing-function> || <time>"
	},
		"single-transition-property": {
		syntax: "all | <custom-ident>"
	},
		size: size,
		"step-position": {
		syntax: "jump-start | jump-end | jump-none | jump-both | start | end"
	},
		"step-timing-function": {
		syntax: "step-start | step-end | steps(<integer>[, <step-position>]?)"
	},
		"subclass-selector": {
		syntax: "<id-selector> | <class-selector> | <attribute-selector> | <pseudo-class-selector>"
	},
		"supports-condition": {
		syntax: "not <supports-in-parens> | <supports-in-parens> [ and <supports-in-parens> ]* | <supports-in-parens> [ or <supports-in-parens> ]*"
	},
		"supports-in-parens": {
		syntax: "( <supports-condition> ) | <supports-feature> | <general-enclosed>"
	},
		"supports-feature": {
		syntax: "<supports-decl> | <supports-selector-fn>"
	},
		"supports-decl": {
		syntax: "( <declaration> )"
	},
		"supports-selector-fn": {
		syntax: "selector( <complex-selector> )"
	},
		symbol: symbol,
		target: target,
		"target-counter()": {
		syntax: "target-counter( [ <string> | <url> ] , <custom-ident> , <counter-style>? )"
	},
		"target-counters()": {
		syntax: "target-counters( [ <string> | <url> ] , <custom-ident> , <string> , <counter-style>? )"
	},
		"target-text()": {
		syntax: "target-text( [ <string> | <url> ] , [ content | before | after | first-letter ]? )"
	},
		"time-percentage": {
		syntax: "<time> | <percentage>"
	},
		"timing-function": {
		syntax: "linear | <cubic-bezier-timing-function> | <step-timing-function>"
	},
		"track-breadth": {
		syntax: "<length-percentage> | <flex> | min-content | max-content | auto"
	},
		"track-list": {
		syntax: "[ <line-names>? [ <track-size> | <track-repeat> ] ]+ <line-names>?"
	},
		"track-repeat": {
		syntax: "repeat( [ <positive-integer> ] , [ <line-names>? <track-size> ]+ <line-names>? )"
	},
		"track-size": {
		syntax: "<track-breadth> | minmax( <inflexible-breadth> , <track-breadth> ) | fit-content( [ <length> | <percentage> ] )"
	},
		"transform-function": {
		syntax: "<matrix()> | <translate()> | <translateX()> | <translateY()> | <scale()> | <scaleX()> | <scaleY()> | <rotate()> | <skew()> | <skewX()> | <skewY()> | <matrix3d()> | <translate3d()> | <translateZ()> | <scale3d()> | <scaleZ()> | <rotate3d()> | <rotateX()> | <rotateY()> | <rotateZ()> | <perspective()>"
	},
		"transform-list": {
		syntax: "<transform-function>+"
	},
		"translate()": {
		syntax: "translate( <length-percentage> , <length-percentage>? )"
	},
		"translate3d()": {
		syntax: "translate3d( <length-percentage> , <length-percentage> , <length> )"
	},
		"translateX()": {
		syntax: "translateX( <length-percentage> )"
	},
		"translateY()": {
		syntax: "translateY( <length-percentage> )"
	},
		"translateZ()": {
		syntax: "translateZ( <length> )"
	},
		"type-or-unit": {
		syntax: "string | color | url | integer | number | length | angle | time | frequency | cap | ch | em | ex | ic | lh | rlh | rem | vb | vi | vw | vh | vmin | vmax | mm | Q | cm | in | pt | pc | px | deg | grad | rad | turn | ms | s | Hz | kHz | %"
	},
		"type-selector": {
		syntax: "<wq-name> | <ns-prefix>? '*'"
	},
		"var()": {
		syntax: "var( <custom-property-name> , <declaration-value>? )"
	},
		"viewport-length": {
		syntax: "auto | <length-percentage>"
	},
		"wq-name": {
		syntax: "<ns-prefix>? <ident-token>"
	}
	};

	var syntaxes$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		attachment: attachment,
		box: box,
		color: color$1,
		combinator: combinator,
		compat: compat,
		gradient: gradient,
		hue: hue,
		image: image,
		nth: nth,
		position: position$1,
		quote: quote,
		shadow: shadow,
		shape: shape$1,
		size: size,
		symbol: symbol,
		target: target,
		'default': syntaxes
	});

	var properties$3 = {
		"-moz-background-clip": {
			comment: "deprecated syntax in old Firefox, https://developer.mozilla.org/en/docs/Web/CSS/background-clip",
			syntax: "padding | border"
		},
		"-moz-border-radius-bottomleft": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/border-bottom-left-radius",
			syntax: "<'border-bottom-left-radius'>"
		},
		"-moz-border-radius-bottomright": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/border-bottom-right-radius",
			syntax: "<'border-bottom-right-radius'>"
		},
		"-moz-border-radius-topleft": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/border-top-left-radius",
			syntax: "<'border-top-left-radius'>"
		},
		"-moz-border-radius-topright": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/border-bottom-right-radius",
			syntax: "<'border-bottom-right-radius'>"
		},
		"-moz-control-character-visibility": {
			comment: "firefox specific keywords, https://bugzilla.mozilla.org/show_bug.cgi?id=947588",
			syntax: "visible | hidden"
		},
		"-moz-osx-font-smoothing": {
			comment: "misssed old syntax https://developer.mozilla.org/en-US/docs/Web/CSS/font-smooth",
			syntax: "auto | grayscale"
		},
		"-moz-user-select": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/user-select",
			syntax: "none | text | all | -moz-none"
		},
		"-ms-flex-align": {
			comment: "misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-align",
			syntax: "start | end | center | baseline | stretch"
		},
		"-ms-flex-item-align": {
			comment: "misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-align",
			syntax: "auto | start | end | center | baseline | stretch"
		},
		"-ms-flex-line-pack": {
			comment: "misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-line-pack",
			syntax: "start | end | center | justify | distribute | stretch"
		},
		"-ms-flex-negative": {
			comment: "misssed old syntax implemented in IE; TODO: find references for comfirmation",
			syntax: "<'flex-shrink'>"
		},
		"-ms-flex-pack": {
			comment: "misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-pack",
			syntax: "start | end | center | justify | distribute"
		},
		"-ms-flex-order": {
			comment: "misssed old syntax implemented in IE; https://msdn.microsoft.com/en-us/library/jj127303(v=vs.85).aspx",
			syntax: "<integer>"
		},
		"-ms-flex-positive": {
			comment: "misssed old syntax implemented in IE; TODO: find references for comfirmation",
			syntax: "<'flex-grow'>"
		},
		"-ms-flex-preferred-size": {
			comment: "misssed old syntax implemented in IE; TODO: find references for comfirmation",
			syntax: "<'flex-basis'>"
		},
		"-ms-interpolation-mode": {
			comment: "https://msdn.microsoft.com/en-us/library/ff521095(v=vs.85).aspx",
			syntax: "nearest-neighbor | bicubic"
		},
		"-ms-grid-column-align": {
			comment: "add this property first since it uses as fallback for flexbox, https://msdn.microsoft.com/en-us/library/windows/apps/hh466338.aspx",
			syntax: "start | end | center | stretch"
		},
		"-ms-grid-columns": {
			comment: "misssed old syntax implemented in IE; https://www.w3.org/TR/2012/WD-css3-grid-layout-20120322/#grid-columns",
			syntax: "<track-list-v0>"
		},
		"-ms-grid-row-align": {
			comment: "add this property first since it uses as fallback for flexbox, https://msdn.microsoft.com/en-us/library/windows/apps/hh466348.aspx",
			syntax: "start | end | center | stretch"
		},
		"-ms-grid-rows": {
			comment: "misssed old syntax implemented in IE; https://www.w3.org/TR/2012/WD-css3-grid-layout-20120322/#grid-rows",
			syntax: "<track-list-v0>"
		},
		"-ms-hyphenate-limit-last": {
			comment: "misssed old syntax implemented in IE; https://www.w3.org/TR/css-text-4/#hyphenate-line-limits",
			syntax: "none | always | column | page | spread"
		},
		"-webkit-appearance": {
			comment: "webkit specific keywords",
			references: [
				"http://css-infos.net/property/-webkit-appearance"
			],
			syntax: "none | button | button-bevel | caps-lock-indicator | caret | checkbox | default-button | listbox | listitem | media-fullscreen-button | media-mute-button | media-play-button | media-seek-back-button | media-seek-forward-button | media-slider | media-sliderthumb | menulist | menulist-button | menulist-text | menulist-textfield | push-button | radio | scrollbarbutton-down | scrollbarbutton-left | scrollbarbutton-right | scrollbarbutton-up | scrollbargripper-horizontal | scrollbargripper-vertical | scrollbarthumb-horizontal | scrollbarthumb-vertical | scrollbartrack-horizontal | scrollbartrack-vertical | searchfield | searchfield-cancel-button | searchfield-decoration | searchfield-results-button | searchfield-results-decoration | slider-horizontal | slider-vertical | sliderthumb-horizontal | sliderthumb-vertical | square-button | textarea | textfield"
		},
		"-webkit-background-clip": {
			comment: "https://developer.mozilla.org/en/docs/Web/CSS/background-clip",
			syntax: "[ <box> | border | padding | content | text ]#"
		},
		"-webkit-column-break-after": {
			comment: "added, http://help.dottoro.com/lcrthhhv.php",
			syntax: "always | auto | avoid"
		},
		"-webkit-column-break-before": {
			comment: "added, http://help.dottoro.com/lcxquvkf.php",
			syntax: "always | auto | avoid"
		},
		"-webkit-column-break-inside": {
			comment: "added, http://help.dottoro.com/lclhnthl.php",
			syntax: "always | auto | avoid"
		},
		"-webkit-font-smoothing": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/font-smooth",
			syntax: "auto | none | antialiased | subpixel-antialiased"
		},
		"-webkit-mask-box-image": {
			comment: "missed; https://developer.mozilla.org/en-US/docs/Web/CSS/-webkit-mask-box-image",
			syntax: "[ <url> | <gradient> | none ] [ <length-percentage>{4} <-webkit-mask-box-repeat>{2} ]?"
		},
		"-webkit-print-color-adjust": {
			comment: "missed",
			references: [
				"https://developer.mozilla.org/en/docs/Web/CSS/-webkit-print-color-adjust"
			],
			syntax: "economy | exact"
		},
		"-webkit-text-security": {
			comment: "missed; http://help.dottoro.com/lcbkewgt.php",
			syntax: "none | circle | disc | square"
		},
		"-webkit-user-drag": {
			comment: "missed; http://help.dottoro.com/lcbixvwm.php",
			syntax: "none | element | auto"
		},
		"-webkit-user-select": {
			comment: "auto is supported by old webkit, https://developer.mozilla.org/en-US/docs/Web/CSS/user-select",
			syntax: "auto | none | text | all"
		},
		"alignment-baseline": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#AlignmentBaselineProperty"
			],
			syntax: "auto | baseline | before-edge | text-before-edge | middle | central | after-edge | text-after-edge | ideographic | alphabetic | hanging | mathematical"
		},
		"baseline-shift": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#BaselineShiftProperty"
			],
			syntax: "baseline | sub | super | <svg-length>"
		},
		behavior: {
			comment: "added old IE property https://msdn.microsoft.com/en-us/library/ms530723(v=vs.85).aspx",
			syntax: "<url>+"
		},
		"clip-rule": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/masking.html#ClipRuleProperty"
			],
			syntax: "nonzero | evenodd"
		},
		cue: {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<'cue-before'> <'cue-after'>?"
		},
		"cue-after": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<url> <decibel>? | none"
		},
		"cue-before": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<url> <decibel>? | none"
		},
		cursor: {
			comment: "added legacy keywords: hand, -webkit-grab. -webkit-grabbing, -webkit-zoom-in, -webkit-zoom-out, -moz-grab, -moz-grabbing, -moz-zoom-in, -moz-zoom-out",
			references: [
				"https://www.sitepoint.com/css3-cursor-styles/"
			],
			syntax: "[ [ <url> [ <x> <y> ]? , ]* [ auto | default | none | context-menu | help | pointer | progress | wait | cell | crosshair | text | vertical-text | alias | copy | move | no-drop | not-allowed | e-resize | n-resize | ne-resize | nw-resize | s-resize | se-resize | sw-resize | w-resize | ew-resize | ns-resize | nesw-resize | nwse-resize | col-resize | row-resize | all-scroll | zoom-in | zoom-out | grab | grabbing | hand | -webkit-grab | -webkit-grabbing | -webkit-zoom-in | -webkit-zoom-out | -moz-grab | -moz-grabbing | -moz-zoom-in | -moz-zoom-out ] ]"
		},
		display: {
			comment: "extended with -ms-flexbox",
			syntax: "block | contents | flex | flow | flow-root | grid | inline | inline-block | inline-flex | inline-grid | inline-list-item | inline-table | list-item | none | ruby | ruby-base | ruby-base-container | ruby-text | ruby-text-container | run-in | table | table-caption | table-cell | table-column | table-column-group | table-footer-group | table-header-group | table-row | table-row-group | -ms-flexbox | -ms-inline-flexbox | -ms-grid | -ms-inline-grid | -webkit-flex | -webkit-inline-flex | -webkit-box | -webkit-inline-box | -moz-inline-stack | -moz-box | -moz-inline-box"
		},
		position: {
			comment: "extended with -webkit-sticky",
			syntax: "static | relative | absolute | sticky | fixed | -webkit-sticky"
		},
		"dominant-baseline": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#DominantBaselineProperty"
			],
			syntax: "auto | use-script | no-change | reset-size | ideographic | alphabetic | hanging | mathematical | central | middle | text-after-edge | text-before-edge"
		},
		"image-rendering": {
			comment: "extended with <-non-standard-image-rendering>, added SVG keywords optimizeSpeed and optimizeQuality",
			references: [
				"https://developer.mozilla.org/en/docs/Web/CSS/image-rendering",
				"https://www.w3.org/TR/SVG/painting.html#ImageRenderingProperty"
			],
			syntax: "auto | crisp-edges | pixelated | optimizeSpeed | optimizeQuality | <-non-standard-image-rendering>"
		},
		fill: {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#FillProperty"
			],
			syntax: "<paint>"
		},
		"fill-opacity": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#FillProperty"
			],
			syntax: "<number-zero-one>"
		},
		"fill-rule": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#FillProperty"
			],
			syntax: "nonzero | evenodd"
		},
		filter: {
			comment: "extend with IE legacy syntaxes",
			syntax: "none | <filter-function-list> | <-ms-filter-function-list>"
		},
		"glyph-orientation-horizontal": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#GlyphOrientationHorizontalProperty"
			],
			syntax: "<angle>"
		},
		"glyph-orientation-vertical": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#GlyphOrientationVerticalProperty"
			],
			syntax: "<angle>"
		},
		kerning: {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#KerningProperty"
			],
			syntax: "auto | <svg-length>"
		},
		"letter-spacing": {
			comment: "fix syntax <length> -> <length-percentage>",
			references: [
				"https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/letter-spacing"
			],
			syntax: "normal | <length-percentage>"
		},
		marker: {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#MarkerProperties"
			],
			syntax: "none | <url>"
		},
		"marker-end": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#MarkerProperties"
			],
			syntax: "none | <url>"
		},
		"marker-mid": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#MarkerProperties"
			],
			syntax: "none | <url>"
		},
		"marker-start": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#MarkerProperties"
			],
			syntax: "none | <url>"
		},
		"max-width": {
			comment: "extend by non-standard width keywords https://developer.mozilla.org/en-US/docs/Web/CSS/max-width",
			syntax: "<length> | <percentage> | none | max-content | min-content | fit-content | fill-available | <-non-standard-width>"
		},
		"min-width": {
			comment: "extend by non-standard width keywords https://developer.mozilla.org/en-US/docs/Web/CSS/width",
			syntax: "<length> | <percentage> | auto | max-content | min-content | fit-content | fill-available | <-non-standard-width>"
		},
		opacity: {
			comment: "strict to 0..1 <number> -> <number-zero-one>",
			syntax: "<number-zero-one>"
		},
		overflow: {
			comment: "extend by vendor keywords https://developer.mozilla.org/en-US/docs/Web/CSS/overflow",
			syntax: "[ visible | hidden | clip | scroll | auto ]{1,2} | <-non-standard-overflow>"
		},
		pause: {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<'pause-before'> <'pause-after'>?"
		},
		"pause-after": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<time> | none | x-weak | weak | medium | strong | x-strong"
		},
		"pause-before": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<time> | none | x-weak | weak | medium | strong | x-strong"
		},
		rest: {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<'rest-before'> <'rest-after'>?"
		},
		"rest-after": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<time> | none | x-weak | weak | medium | strong | x-strong"
		},
		"rest-before": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<time> | none | x-weak | weak | medium | strong | x-strong"
		},
		"shape-rendering": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#ShapeRenderingPropert"
			],
			syntax: "auto | optimizeSpeed | crispEdges | geometricPrecision"
		},
		src: {
			comment: "added @font-face's src property https://developer.mozilla.org/en-US/docs/Web/CSS/@font-face/src",
			syntax: "[ <url> [ format( <string># ) ]? | local( <family-name> ) ]#"
		},
		speak: {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "auto | none | normal"
		},
		"speak-as": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "normal | spell-out || digits || [ literal-punctuation | no-punctuation ]"
		},
		stroke: {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "<paint>"
		},
		"stroke-dasharray": {
			comment: "added SVG property; a list of comma and/or white space separated <length>s and <percentage>s",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "none | [ <svg-length>+ ]#"
		},
		"stroke-dashoffset": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "<svg-length>"
		},
		"stroke-linecap": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "butt | round | square"
		},
		"stroke-linejoin": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "miter | round | bevel"
		},
		"stroke-miterlimit": {
			comment: "added SVG property (<miterlimit> = <number-one-or-greater>) ",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "<number-one-or-greater>"
		},
		"stroke-opacity": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "<number-zero-one>"
		},
		"stroke-width": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "<svg-length>"
		},
		"text-anchor": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#TextAlignmentProperties"
			],
			syntax: "start | middle | end"
		},
		"unicode-bidi": {
			comment: "added prefixed keywords https://developer.mozilla.org/en-US/docs/Web/CSS/unicode-bidi",
			syntax: "normal | embed | isolate | bidi-override | isolate-override | plaintext | -moz-isolate | -moz-isolate-override | -moz-plaintext | -webkit-isolate"
		},
		"unicode-range": {
			comment: "added missed property https://developer.mozilla.org/en-US/docs/Web/CSS/%40font-face/unicode-range",
			syntax: "<urange>#"
		},
		"voice-balance": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<number> | left | center | right | leftwards | rightwards"
		},
		"voice-duration": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "auto | <time>"
		},
		"voice-family": {
			comment: "<name> -> <family-name>, https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "[ [ <family-name> | <generic-voice> ] , ]* [ <family-name> | <generic-voice> ] | preserve"
		},
		"voice-pitch": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<frequency> && absolute | [ [ x-low | low | medium | high | x-high ] || [ <frequency> | <semitones> | <percentage> ] ]"
		},
		"voice-range": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<frequency> && absolute | [ [ x-low | low | medium | high | x-high ] || [ <frequency> | <semitones> | <percentage> ] ]"
		},
		"voice-rate": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "[ normal | x-slow | slow | medium | fast | x-fast ] || <percentage>"
		},
		"voice-stress": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "normal | strong | moderate | none | reduced"
		},
		"voice-volume": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "silent | [ [ x-soft | soft | medium | loud | x-loud ] || <decibel> ]"
		},
		"writing-mode": {
			comment: "extend with SVG keywords",
			syntax: "horizontal-tb | vertical-rl | vertical-lr | sideways-rl | sideways-lr | <svg-writing-mode>"
		}
	};
	var syntaxes$2 = {
		"-legacy-gradient": {
			comment: "added collection of legacy gradient syntaxes",
			syntax: "<-webkit-gradient()> | <-legacy-linear-gradient> | <-legacy-repeating-linear-gradient> | <-legacy-radial-gradient> | <-legacy-repeating-radial-gradient>"
		},
		"-legacy-linear-gradient": {
			comment: "like standard syntax but w/o `to` keyword https://developer.mozilla.org/en-US/docs/Web/CSS/linear-gradient",
			syntax: "-moz-linear-gradient( <-legacy-linear-gradient-arguments> ) | -webkit-linear-gradient( <-legacy-linear-gradient-arguments> ) | -o-linear-gradient( <-legacy-linear-gradient-arguments> )"
		},
		"-legacy-repeating-linear-gradient": {
			comment: "like standard syntax but w/o `to` keyword https://developer.mozilla.org/en-US/docs/Web/CSS/linear-gradient",
			syntax: "-moz-repeating-linear-gradient( <-legacy-linear-gradient-arguments> ) | -webkit-repeating-linear-gradient( <-legacy-linear-gradient-arguments> ) | -o-repeating-linear-gradient( <-legacy-linear-gradient-arguments> )"
		},
		"-legacy-linear-gradient-arguments": {
			comment: "like standard syntax but w/o `to` keyword https://developer.mozilla.org/en-US/docs/Web/CSS/linear-gradient",
			syntax: "[ <angle> | <side-or-corner> ]? , <color-stop-list>"
		},
		"-legacy-radial-gradient": {
			comment: "deprecated syntax that implemented by some browsers https://www.w3.org/TR/2011/WD-css3-images-20110908/#radial-gradients",
			syntax: "-moz-radial-gradient( <-legacy-radial-gradient-arguments> ) | -webkit-radial-gradient( <-legacy-radial-gradient-arguments> ) | -o-radial-gradient( <-legacy-radial-gradient-arguments> )"
		},
		"-legacy-repeating-radial-gradient": {
			comment: "deprecated syntax that implemented by some browsers https://www.w3.org/TR/2011/WD-css3-images-20110908/#radial-gradients",
			syntax: "-moz-repeating-radial-gradient( <-legacy-radial-gradient-arguments> ) | -webkit-repeating-radial-gradient( <-legacy-radial-gradient-arguments> ) | -o-repeating-radial-gradient( <-legacy-radial-gradient-arguments> )"
		},
		"-legacy-radial-gradient-arguments": {
			comment: "deprecated syntax that implemented by some browsers https://www.w3.org/TR/2011/WD-css3-images-20110908/#radial-gradients",
			syntax: "[ <position> , ]? [ [ [ <-legacy-radial-gradient-shape> || <-legacy-radial-gradient-size> ] | [ <length> | <percentage> ]{2} ] , ]? <color-stop-list>"
		},
		"-legacy-radial-gradient-size": {
			comment: "before a standard it contains 2 extra keywords (`contain` and `cover`) https://www.w3.org/TR/2011/WD-css3-images-20110908/#ltsize",
			syntax: "closest-side | closest-corner | farthest-side | farthest-corner | contain | cover"
		},
		"-legacy-radial-gradient-shape": {
			comment: "define to double sure it doesn't extends in future https://www.w3.org/TR/2011/WD-css3-images-20110908/#ltshape",
			syntax: "circle | ellipse"
		},
		"-non-standard-font": {
			comment: "non standard fonts",
			references: [
				"https://webkit.org/blog/3709/using-the-system-font-in-web-content/"
			],
			syntax: "-apple-system-body | -apple-system-headline | -apple-system-subheadline | -apple-system-caption1 | -apple-system-caption2 | -apple-system-footnote | -apple-system-short-body | -apple-system-short-headline | -apple-system-short-subheadline | -apple-system-short-caption1 | -apple-system-short-footnote | -apple-system-tall-body"
		},
		"-non-standard-color": {
			comment: "non standard colors",
			references: [
				"http://cssdot.ru/%D0%A1%D0%BF%D1%80%D0%B0%D0%B2%D0%BE%D1%87%D0%BD%D0%B8%D0%BA_CSS/color-i305.html",
				"https://developer.mozilla.org/en-US/docs/Web/CSS/color_value#Mozilla_Color_Preference_Extensions"
			],
			syntax: "-moz-ButtonDefault | -moz-ButtonHoverFace | -moz-ButtonHoverText | -moz-CellHighlight | -moz-CellHighlightText | -moz-Combobox | -moz-ComboboxText | -moz-Dialog | -moz-DialogText | -moz-dragtargetzone | -moz-EvenTreeRow | -moz-Field | -moz-FieldText | -moz-html-CellHighlight | -moz-html-CellHighlightText | -moz-mac-accentdarkestshadow | -moz-mac-accentdarkshadow | -moz-mac-accentface | -moz-mac-accentlightesthighlight | -moz-mac-accentlightshadow | -moz-mac-accentregularhighlight | -moz-mac-accentregularshadow | -moz-mac-chrome-active | -moz-mac-chrome-inactive | -moz-mac-focusring | -moz-mac-menuselect | -moz-mac-menushadow | -moz-mac-menutextselect | -moz-MenuHover | -moz-MenuHoverText | -moz-MenuBarText | -moz-MenuBarHoverText | -moz-nativehyperlinktext | -moz-OddTreeRow | -moz-win-communicationstext | -moz-win-mediatext | -moz-activehyperlinktext | -moz-default-background-color | -moz-default-color | -moz-hyperlinktext | -moz-visitedhyperlinktext | -webkit-activelink | -webkit-focus-ring-color | -webkit-link | -webkit-text"
		},
		"-non-standard-image-rendering": {
			comment: "non-standard keywords http://phrogz.net/tmp/canvas_image_zoom.html",
			syntax: "optimize-contrast | -moz-crisp-edges | -o-crisp-edges | -webkit-optimize-contrast"
		},
		"-non-standard-overflow": {
			comment: "non-standard keywords https://developer.mozilla.org/en-US/docs/Web/CSS/overflow",
			syntax: "-moz-scrollbars-none | -moz-scrollbars-horizontal | -moz-scrollbars-vertical | -moz-hidden-unscrollable"
		},
		"-non-standard-width": {
			comment: "non-standard keywords https://developer.mozilla.org/en-US/docs/Web/CSS/width",
			syntax: "min-intrinsic | intrinsic | -moz-min-content | -moz-max-content | -webkit-min-content | -webkit-max-content"
		},
		"-webkit-gradient()": {
			comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/ - TODO: simplify when after match algorithm improvement ( [, point, radius | , point] -> [, radius]? , point )",
			syntax: "-webkit-gradient( <-webkit-gradient-type>, <-webkit-gradient-point> [, <-webkit-gradient-point> | , <-webkit-gradient-radius>, <-webkit-gradient-point> ] [, <-webkit-gradient-radius>]? [, <-webkit-gradient-color-stop>]* )"
		},
		"-webkit-gradient-color-stop": {
			comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/",
			syntax: "from( <color> ) | color-stop( [ <number-zero-one> | <percentage> ] , <color> ) | to( <color> )"
		},
		"-webkit-gradient-point": {
			comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/",
			syntax: "[ left | center | right | <length-percentage> ] [ top | center | bottom | <length-percentage> ]"
		},
		"-webkit-gradient-radius": {
			comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/",
			syntax: "<length> | <percentage>"
		},
		"-webkit-gradient-type": {
			comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/",
			syntax: "linear | radial"
		},
		"-webkit-mask-box-repeat": {
			comment: "missed; https://developer.mozilla.org/en-US/docs/Web/CSS/-webkit-mask-box-image",
			syntax: "repeat | stretch | round"
		},
		"-webkit-mask-clip-style": {
			comment: "missed; there is no enough information about `-webkit-mask-clip` property, but looks like all those keywords are working",
			syntax: "border | border-box | padding | padding-box | content | content-box | text"
		},
		"-ms-filter-function-list": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter",
			syntax: "<-ms-filter-function>+"
		},
		"-ms-filter-function": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter",
			syntax: "<-ms-filter-function-progid> | <-ms-filter-function-legacy>"
		},
		"-ms-filter-function-progid": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter",
			syntax: "'progid:' [ <ident-token> '.' ]* [ <ident-token> | <function-token> <any-value>? ) ]"
		},
		"-ms-filter-function-legacy": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter",
			syntax: "<ident-token> | <function-token> <any-value>? )"
		},
		"-ms-filter": {
			syntax: "<string>"
		},
		age: {
			comment: "https://www.w3.org/TR/css3-speech/#voice-family",
			syntax: "child | young | old"
		},
		"attr-name": {
			syntax: "<wq-name>"
		},
		"attr-fallback": {
			syntax: "<any-value>"
		},
		"border-radius": {
			comment: "missed, https://drafts.csswg.org/css-backgrounds-3/#the-border-radius",
			syntax: "<length-percentage>{1,2}"
		},
		bottom: {
			comment: "missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect",
			syntax: "<length> | auto"
		},
		"content-list": {
			comment: "missed -> https://drafts.csswg.org/css-content/#typedef-content-list (document-url, <target> and leader() is omitted util stabilization)",
			syntax: "[ <string> | contents | <url> | <quote> | <attr()> | counter( <ident>, <'list-style-type'>? ) ]+"
		},
		"generic-voice": {
			comment: "https://www.w3.org/TR/css3-speech/#voice-family",
			syntax: "[ <age>? <gender> <integer>? ]"
		},
		gender: {
			comment: "https://www.w3.org/TR/css3-speech/#voice-family",
			syntax: "male | female | neutral"
		},
		"generic-family": {
			comment: "added -apple-system",
			references: [
				"https://webkit.org/blog/3709/using-the-system-font-in-web-content/"
			],
			syntax: "serif | sans-serif | cursive | fantasy | monospace | -apple-system"
		},
		gradient: {
			comment: "added legacy syntaxes support",
			syntax: "<linear-gradient()> | <repeating-linear-gradient()> | <radial-gradient()> | <repeating-radial-gradient()> | <conic-gradient()> | <-legacy-gradient>"
		},
		left: {
			comment: "missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect",
			syntax: "<length> | auto"
		},
		"mask-image": {
			comment: "missed; https://drafts.fxtf.org/css-masking-1/#the-mask-image",
			syntax: "<mask-reference>#"
		},
		"name-repeat": {
			comment: "missed, and looks like obsolete, keep it as is since other property syntaxes should be changed too; https://www.w3.org/TR/2015/WD-css-grid-1-20150917/#typedef-name-repeat",
			syntax: "repeat( [ <positive-integer> | auto-fill ], <line-names>+)"
		},
		"named-color": {
			comment: "added non standard color names",
			syntax: "transparent | aliceblue | antiquewhite | aqua | aquamarine | azure | beige | bisque | black | blanchedalmond | blue | blueviolet | brown | burlywood | cadetblue | chartreuse | chocolate | coral | cornflowerblue | cornsilk | crimson | cyan | darkblue | darkcyan | darkgoldenrod | darkgray | darkgreen | darkgrey | darkkhaki | darkmagenta | darkolivegreen | darkorange | darkorchid | darkred | darksalmon | darkseagreen | darkslateblue | darkslategray | darkslategrey | darkturquoise | darkviolet | deeppink | deepskyblue | dimgray | dimgrey | dodgerblue | firebrick | floralwhite | forestgreen | fuchsia | gainsboro | ghostwhite | gold | goldenrod | gray | green | greenyellow | grey | honeydew | hotpink | indianred | indigo | ivory | khaki | lavender | lavenderblush | lawngreen | lemonchiffon | lightblue | lightcoral | lightcyan | lightgoldenrodyellow | lightgray | lightgreen | lightgrey | lightpink | lightsalmon | lightseagreen | lightskyblue | lightslategray | lightslategrey | lightsteelblue | lightyellow | lime | limegreen | linen | magenta | maroon | mediumaquamarine | mediumblue | mediumorchid | mediumpurple | mediumseagreen | mediumslateblue | mediumspringgreen | mediumturquoise | mediumvioletred | midnightblue | mintcream | mistyrose | moccasin | navajowhite | navy | oldlace | olive | olivedrab | orange | orangered | orchid | palegoldenrod | palegreen | paleturquoise | palevioletred | papayawhip | peachpuff | peru | pink | plum | powderblue | purple | rebeccapurple | red | rosybrown | royalblue | saddlebrown | salmon | sandybrown | seagreen | seashell | sienna | silver | skyblue | slateblue | slategray | slategrey | snow | springgreen | steelblue | tan | teal | thistle | tomato | turquoise | violet | wheat | white | whitesmoke | yellow | yellowgreen | <-non-standard-color>"
		},
		paint: {
			comment: "used by SVG https://www.w3.org/TR/SVG/painting.html#SpecifyingPaint",
			syntax: "none | <color> | <url> [ none | <color> ]? | context-fill | context-stroke"
		},
		"path()": {
			comment: "missed, `motion` property was renamed, but left it as is for now; path() syntax was get from last draft https://drafts.fxtf.org/motion-1/#funcdef-offset-path-path",
			syntax: "path( <string> )"
		},
		ratio: {
			comment: "missed, https://drafts.csswg.org/mediaqueries-4/#typedef-ratio",
			syntax: "<integer> / <integer>"
		},
		right: {
			comment: "missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect",
			syntax: "<length> | auto"
		},
		shape: {
			comment: "missed spaces in function body and add backwards compatible syntax",
			syntax: "rect( <top>, <right>, <bottom>, <left> ) | rect( <top> <right> <bottom> <left> )"
		},
		"svg-length": {
			comment: "All coordinates and lengths in SVG can be specified with or without a unit identifier",
			references: [
				"https://www.w3.org/TR/SVG11/coords.html#Units"
			],
			syntax: "<percentage> | <length> | <number>"
		},
		"svg-writing-mode": {
			comment: "SVG specific keywords (deprecated for CSS)",
			references: [
				"https://developer.mozilla.org/en/docs/Web/CSS/writing-mode",
				"https://www.w3.org/TR/SVG/text.html#WritingModeProperty"
			],
			syntax: "lr-tb | rl-tb | tb-rl | lr | rl | tb"
		},
		top: {
			comment: "missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect",
			syntax: "<length> | auto"
		},
		"track-group": {
			comment: "used by old grid-columns and grid-rows syntax v0",
			syntax: "'(' [ <string>* <track-minmax> <string>* ]+ ')' [ '[' <positive-integer> ']' ]? | <track-minmax>"
		},
		"track-list-v0": {
			comment: "used by old grid-columns and grid-rows syntax v0",
			syntax: "[ <string>* <track-group> <string>* ]+ | none"
		},
		"track-minmax": {
			comment: "used by old grid-columns and grid-rows syntax v0",
			syntax: "minmax( <track-breadth> , <track-breadth> ) | auto | <track-breadth> | fit-content"
		},
		x: {
			comment: "missed; not sure we should add it, but no others except `cursor` is using it so it's ok for now; https://drafts.csswg.org/css-ui-3/#cursor",
			syntax: "<number>"
		},
		y: {
			comment: "missed; not sure we should add it, but no others except `cursor` is using so it's ok for now; https://drafts.csswg.org/css-ui-3/#cursor",
			syntax: "<number>"
		},
		declaration: {
			comment: "missed, restored by https://drafts.csswg.org/css-syntax",
			syntax: "<ident-token> : <declaration-value>? [ '!' important ]?"
		},
		"declaration-list": {
			comment: "missed, restored by https://drafts.csswg.org/css-syntax",
			syntax: "[ <declaration>? ';' ]* <declaration>?"
		},
		url: {
			comment: "https://drafts.csswg.org/css-values-4/#urls",
			syntax: "url( <string> <url-modifier>* ) | <url-token>"
		},
		"url-modifier": {
			comment: "https://drafts.csswg.org/css-values-4/#typedef-url-modifier",
			syntax: "<ident> | <function-token> <any-value> )"
		},
		"number-zero-one": {
			syntax: "<number [0,1]>"
		},
		"number-one-or-greater": {
			syntax: "<number [1,∞]>"
		},
		"positive-integer": {
			syntax: "<integer [0,∞]>"
		}
	};
	var patch = {
		properties: properties$3,
		syntaxes: syntaxes$2
	};

	var patch$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		properties: properties$3,
		syntaxes: syntaxes$2,
		'default': patch
	});

	var mdnAtrules = getCjsExportFromNamespace(atRules$1);

	var mdnProperties = getCjsExportFromNamespace(properties$2);

	var mdnSyntaxes = getCjsExportFromNamespace(syntaxes$1);

	var patch$2 = getCjsExportFromNamespace(patch$1);

	function preprocessAtrules(dict) {
	    var result = Object.create(null);

	    for (var atruleName in dict) {
	        var atrule = dict[atruleName];
	        var descriptors = null;

	        if (atrule.descriptors) {
	            descriptors = Object.create(null);

	            for (var descriptor in atrule.descriptors) {
	                descriptors[descriptor] = atrule.descriptors[descriptor].syntax;
	            }
	        }

	        result[atruleName.substr(1)] = {
	            prelude: atrule.syntax.trim().match(/^@\S+\s+([^;\{]*)/)[1].trim() || null,
	            descriptors
	        };
	    }

	    return result;
	}

	function buildDictionary(dict, patchDict) {
	    var result = {};

	    // copy all syntaxes for an original dict
	    for (var key in dict) {
	        result[key] = dict[key].syntax;
	    }

	    // apply a patch
	    for (var key in patchDict) {
	        if (key in dict) {
	            if (patchDict[key].syntax) {
	                result[key] = patchDict[key].syntax;
	            } else {
	                delete result[key];
	            }
	        } else {
	            if (patchDict[key].syntax) {
	                result[key] = patchDict[key].syntax;
	            }
	        }
	    }

	    return result;
	}

	var data = {
	    types: buildDictionary(mdnSyntaxes, patch$2.syntaxes),
	    atrules: preprocessAtrules(mdnAtrules),
	    properties: buildDictionary(mdnProperties, patch$2.properties)
	};

	var cmpChar$3 = tokenizer.cmpChar;
	var isDigit$4 = tokenizer.isDigit;
	var TYPE$9 = tokenizer.TYPE;

	var WHITESPACE$4 = TYPE$9.WhiteSpace;
	var COMMENT$3 = TYPE$9.Comment;
	var IDENT$3 = TYPE$9.Ident;
	var NUMBER$3 = TYPE$9.Number;
	var DIMENSION$2 = TYPE$9.Dimension;
	var PLUSSIGN$3 = 0x002B;    // U+002B PLUS SIGN (+)
	var HYPHENMINUS$3 = 0x002D; // U+002D HYPHEN-MINUS (-)
	var N$4 = 0x006E;           // U+006E LATIN SMALL LETTER N (n)
	var DISALLOW_SIGN$1 = true;
	var ALLOW_SIGN$1 = false;

	function checkInteger$1(offset, disallowSign) {
	    var pos = this.scanner.tokenStart + offset;
	    var code = this.scanner.source.charCodeAt(pos);

	    if (code === PLUSSIGN$3 || code === HYPHENMINUS$3) {
	        if (disallowSign) {
	            this.error('Number sign is not allowed');
	        }
	        pos++;
	    }

	    for (; pos < this.scanner.tokenEnd; pos++) {
	        if (!isDigit$4(this.scanner.source.charCodeAt(pos))) {
	            this.error('Integer is expected', pos);
	        }
	    }
	}

	function checkTokenIsInteger(disallowSign) {
	    return checkInteger$1.call(this, 0, disallowSign);
	}

	function expectCharCode(offset, code) {
	    if (!cmpChar$3(this.scanner.source, this.scanner.tokenStart + offset, code)) {
	        var msg = '';

	        switch (code) {
	            case N$4:
	                msg = 'N is expected';
	                break;
	            case HYPHENMINUS$3:
	                msg = 'HyphenMinus is expected';
	                break;
	        }

	        this.error(msg, this.scanner.tokenStart + offset);
	    }
	}

	// ... <signed-integer>
	// ... ['+' | '-'] <signless-integer>
	function consumeB$1() {
	    var offset = 0;
	    var sign = 0;
	    var type = this.scanner.tokenType;

	    while (type === WHITESPACE$4 || type === COMMENT$3) {
	        type = this.scanner.lookupType(++offset);
	    }

	    if (type !== NUMBER$3) {
	        if (this.scanner.isDelim(PLUSSIGN$3, offset) ||
	            this.scanner.isDelim(HYPHENMINUS$3, offset)) {
	            sign = this.scanner.isDelim(PLUSSIGN$3, offset) ? PLUSSIGN$3 : HYPHENMINUS$3;

	            do {
	                type = this.scanner.lookupType(++offset);
	            } while (type === WHITESPACE$4 || type === COMMENT$3);

	            if (type !== NUMBER$3) {
	                this.scanner.skip(offset);
	                checkTokenIsInteger.call(this, DISALLOW_SIGN$1);
	            }
	        } else {
	            return null;
	        }
	    }

	    if (offset > 0) {
	        this.scanner.skip(offset);
	    }

	    if (sign === 0) {
	        type = this.scanner.source.charCodeAt(this.scanner.tokenStart);
	        if (type !== PLUSSIGN$3 && type !== HYPHENMINUS$3) {
	            this.error('Number sign is expected');
	        }
	    }

	    checkTokenIsInteger.call(this, sign !== 0);
	    return sign === HYPHENMINUS$3 ? '-' + this.consume(NUMBER$3) : this.consume(NUMBER$3);
	}

	// An+B microsyntax https://www.w3.org/TR/css-syntax-3/#anb
	var AnPlusB = {
	    name: 'AnPlusB',
	    structure: {
	        a: [String, null],
	        b: [String, null]
	    },
	    parse: function() {
	        /* eslint-disable brace-style*/
	        var start = this.scanner.tokenStart;
	        var a = null;
	        var b = null;

	        // <integer>
	        if (this.scanner.tokenType === NUMBER$3) {
	            checkTokenIsInteger.call(this, ALLOW_SIGN$1);
	            b = this.consume(NUMBER$3);
	        }

	        // -n
	        // -n <signed-integer>
	        // -n ['+' | '-'] <signless-integer>
	        // -n- <signless-integer>
	        // <dashndashdigit-ident>
	        else if (this.scanner.tokenType === IDENT$3 && cmpChar$3(this.scanner.source, this.scanner.tokenStart, HYPHENMINUS$3)) {
	            a = '-1';

	            expectCharCode.call(this, 1, N$4);

	            switch (this.scanner.getTokenLength()) {
	                // -n
	                // -n <signed-integer>
	                // -n ['+' | '-'] <signless-integer>
	                case 2:
	                    this.scanner.next();
	                    b = consumeB$1.call(this);
	                    break;

	                // -n- <signless-integer>
	                case 3:
	                    expectCharCode.call(this, 2, HYPHENMINUS$3);

	                    this.scanner.next();
	                    this.scanner.skipSC();

	                    checkTokenIsInteger.call(this, DISALLOW_SIGN$1);

	                    b = '-' + this.consume(NUMBER$3);
	                    break;

	                // <dashndashdigit-ident>
	                default:
	                    expectCharCode.call(this, 2, HYPHENMINUS$3);
	                    checkInteger$1.call(this, 3, DISALLOW_SIGN$1);
	                    this.scanner.next();

	                    b = this.scanner.substrToCursor(start + 2);
	            }
	        }

	        // '+'? n
	        // '+'? n <signed-integer>
	        // '+'? n ['+' | '-'] <signless-integer>
	        // '+'? n- <signless-integer>
	        // '+'? <ndashdigit-ident>
	        else if (this.scanner.tokenType === IDENT$3 || (this.scanner.isDelim(PLUSSIGN$3) && this.scanner.lookupType(1) === IDENT$3)) {
	            var sign = 0;
	            a = '1';

	            // just ignore a plus
	            if (this.scanner.isDelim(PLUSSIGN$3)) {
	                sign = 1;
	                this.scanner.next();
	            }

	            expectCharCode.call(this, 0, N$4);

	            switch (this.scanner.getTokenLength()) {
	                // '+'? n
	                // '+'? n <signed-integer>
	                // '+'? n ['+' | '-'] <signless-integer>
	                case 1:
	                    this.scanner.next();
	                    b = consumeB$1.call(this);
	                    break;

	                // '+'? n- <signless-integer>
	                case 2:
	                    expectCharCode.call(this, 1, HYPHENMINUS$3);

	                    this.scanner.next();
	                    this.scanner.skipSC();

	                    checkTokenIsInteger.call(this, DISALLOW_SIGN$1);

	                    b = '-' + this.consume(NUMBER$3);
	                    break;

	                // '+'? <ndashdigit-ident>
	                default:
	                    expectCharCode.call(this, 1, HYPHENMINUS$3);
	                    checkInteger$1.call(this, 2, DISALLOW_SIGN$1);
	                    this.scanner.next();

	                    b = this.scanner.substrToCursor(start + sign + 1);
	            }
	        }

	        // <ndashdigit-dimension>
	        // <ndash-dimension> <signless-integer>
	        // <n-dimension>
	        // <n-dimension> <signed-integer>
	        // <n-dimension> ['+' | '-'] <signless-integer>
	        else if (this.scanner.tokenType === DIMENSION$2) {
	            var code = this.scanner.source.charCodeAt(this.scanner.tokenStart);
	            var sign = code === PLUSSIGN$3 || code === HYPHENMINUS$3;

	            for (var i = this.scanner.tokenStart + sign; i < this.scanner.tokenEnd; i++) {
	                if (!isDigit$4(this.scanner.source.charCodeAt(i))) {
	                    break;
	                }
	            }

	            if (i === this.scanner.tokenStart + sign) {
	                this.error('Integer is expected', this.scanner.tokenStart + sign);
	            }

	            expectCharCode.call(this, i - this.scanner.tokenStart, N$4);
	            a = this.scanner.source.substring(start, i);

	            // <n-dimension>
	            // <n-dimension> <signed-integer>
	            // <n-dimension> ['+' | '-'] <signless-integer>
	            if (i + 1 === this.scanner.tokenEnd) {
	                this.scanner.next();
	                b = consumeB$1.call(this);
	            } else {
	                expectCharCode.call(this, i - this.scanner.tokenStart + 1, HYPHENMINUS$3);

	                // <ndash-dimension> <signless-integer>
	                if (i + 2 === this.scanner.tokenEnd) {
	                    this.scanner.next();
	                    this.scanner.skipSC();
	                    checkTokenIsInteger.call(this, DISALLOW_SIGN$1);
	                    b = '-' + this.consume(NUMBER$3);
	                }
	                // <ndashdigit-dimension>
	                else {
	                    checkInteger$1.call(this, i - this.scanner.tokenStart + 2, DISALLOW_SIGN$1);
	                    this.scanner.next();
	                    b = this.scanner.substrToCursor(i + 1);
	                }
	            }
	        } else {
	            this.error();
	        }

	        if (a !== null && a.charCodeAt(0) === PLUSSIGN$3) {
	            a = a.substr(1);
	        }

	        if (b !== null && b.charCodeAt(0) === PLUSSIGN$3) {
	            b = b.substr(1);
	        }

	        return {
	            type: 'AnPlusB',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            a: a,
	            b: b
	        };
	    },
	    generate: function(node) {
	        var a = node.a !== null && node.a !== undefined;
	        var b = node.b !== null && node.b !== undefined;

	        if (a) {
	            this.chunk(
	                node.a === '+1' ? '+n' : // eslint-disable-line operator-linebreak, indent
	                node.a ===  '1' ?  'n' : // eslint-disable-line operator-linebreak, indent
	                node.a === '-1' ? '-n' : // eslint-disable-line operator-linebreak, indent
	                node.a + 'n'             // eslint-disable-line operator-linebreak, indent
	            );

	            if (b) {
	                b = String(node.b);
	                if (b.charAt(0) === '-' || b.charAt(0) === '+') {
	                    this.chunk(b.charAt(0));
	                    this.chunk(b.substr(1));
	                } else {
	                    this.chunk('+');
	                    this.chunk(b);
	                }
	            }
	        } else {
	            this.chunk(String(node.b));
	        }
	    }
	};

	var TYPE$a = tokenizer.TYPE;

	var WhiteSpace = TYPE$a.WhiteSpace;
	var Semicolon = TYPE$a.Semicolon;
	var LeftCurlyBracket = TYPE$a.LeftCurlyBracket;
	var Delim = TYPE$a.Delim;
	var EXCLAMATIONMARK$1 = 0x0021; // U+0021 EXCLAMATION MARK (!)

	function getOffsetExcludeWS() {
	    if (this.scanner.tokenIndex > 0) {
	        if (this.scanner.lookupType(-1) === WhiteSpace) {
	            return this.scanner.tokenIndex > 1
	                ? this.scanner.getTokenStart(this.scanner.tokenIndex - 1)
	                : this.scanner.firstCharOffset;
	        }
	    }

	    return this.scanner.tokenStart;
	}

	// 0, 0, false
	function balanceEnd() {
	    return 0;
	}

	// LEFTCURLYBRACKET, 0, false
	function leftCurlyBracket(tokenType) {
	    return tokenType === LeftCurlyBracket ? 1 : 0;
	}

	// LEFTCURLYBRACKET, SEMICOLON, false
	function leftCurlyBracketOrSemicolon(tokenType) {
	    return tokenType === LeftCurlyBracket || tokenType === Semicolon ? 1 : 0;
	}

	// EXCLAMATIONMARK, SEMICOLON, false
	function exclamationMarkOrSemicolon(tokenType, source, offset) {
	    if (tokenType === Delim && source.charCodeAt(offset) === EXCLAMATIONMARK$1) {
	        return 1;
	    }

	    return tokenType === Semicolon ? 1 : 0;
	}

	// 0, SEMICOLON, true
	function semicolonIncluded(tokenType) {
	    return tokenType === Semicolon ? 2 : 0;
	}

	var Raw = {
	    name: 'Raw',
	    structure: {
	        value: String
	    },
	    parse: function(startToken, mode, excludeWhiteSpace) {
	        var startOffset = this.scanner.getTokenStart(startToken);
	        var endOffset;

	        this.scanner.skip(
	            this.scanner.getRawLength(startToken, mode || balanceEnd)
	        );

	        if (excludeWhiteSpace && this.scanner.tokenStart > startOffset) {
	            endOffset = getOffsetExcludeWS.call(this);
	        } else {
	            endOffset = this.scanner.tokenStart;
	        }

	        return {
	            type: 'Raw',
	            loc: this.getLocation(startOffset, endOffset),
	            value: this.scanner.source.substring(startOffset, endOffset)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    },

	    mode: {
	        default: balanceEnd,
	        leftCurlyBracket: leftCurlyBracket,
	        leftCurlyBracketOrSemicolon: leftCurlyBracketOrSemicolon,
	        exclamationMarkOrSemicolon: exclamationMarkOrSemicolon,
	        semicolonIncluded: semicolonIncluded
	    }
	};

	var TYPE$b = tokenizer.TYPE;
	var rawMode = Raw.mode;

	var ATKEYWORD = TYPE$b.AtKeyword;
	var SEMICOLON = TYPE$b.Semicolon;
	var LEFTCURLYBRACKET$1 = TYPE$b.LeftCurlyBracket;
	var RIGHTCURLYBRACKET$1 = TYPE$b.RightCurlyBracket;

	function consumeRaw(startToken) {
	    return this.Raw(startToken, rawMode.leftCurlyBracketOrSemicolon, true);
	}

	function isDeclarationBlockAtrule() {
	    for (var offset = 1, type; type = this.scanner.lookupType(offset); offset++) {
	        if (type === RIGHTCURLYBRACKET$1) {
	            return true;
	        }

	        if (type === LEFTCURLYBRACKET$1 ||
	            type === ATKEYWORD) {
	            return false;
	        }
	    }

	    return false;
	}

	var Atrule = {
	    name: 'Atrule',
	    structure: {
	        name: String,
	        prelude: ['AtrulePrelude', 'Raw', null],
	        block: ['Block', null]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var name;
	        var nameLowerCase;
	        var prelude = null;
	        var block = null;

	        this.eat(ATKEYWORD);

	        name = this.scanner.substrToCursor(start + 1);
	        nameLowerCase = name.toLowerCase();
	        this.scanner.skipSC();

	        // parse prelude
	        if (this.scanner.eof === false &&
	            this.scanner.tokenType !== LEFTCURLYBRACKET$1 &&
	            this.scanner.tokenType !== SEMICOLON) {
	            if (this.parseAtrulePrelude) {
	                prelude = this.parseWithFallback(this.AtrulePrelude.bind(this, name), consumeRaw);

	                // turn empty AtrulePrelude into null
	                if (prelude.type === 'AtrulePrelude' && prelude.children.head === null) {
	                    prelude = null;
	                }
	            } else {
	                prelude = consumeRaw.call(this, this.scanner.tokenIndex);
	            }

	            this.scanner.skipSC();
	        }

	        switch (this.scanner.tokenType) {
	            case SEMICOLON:
	                this.scanner.next();
	                break;

	            case LEFTCURLYBRACKET$1:
	                if (this.atrule.hasOwnProperty(nameLowerCase) &&
	                    typeof this.atrule[nameLowerCase].block === 'function') {
	                    block = this.atrule[nameLowerCase].block.call(this);
	                } else {
	                    // TODO: should consume block content as Raw?
	                    block = this.Block(isDeclarationBlockAtrule.call(this));
	                }

	                break;
	        }

	        return {
	            type: 'Atrule',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            prelude: prelude,
	            block: block
	        };
	    },
	    generate: function(node) {
	        this.chunk('@');
	        this.chunk(node.name);

	        if (node.prelude !== null) {
	            this.chunk(' ');
	            this.node(node.prelude);
	        }

	        if (node.block) {
	            this.node(node.block);
	        } else {
	            this.chunk(';');
	        }
	    },
	    walkContext: 'atrule'
	};

	var TYPE$c = tokenizer.TYPE;

	var SEMICOLON$1 = TYPE$c.Semicolon;
	var LEFTCURLYBRACKET$2 = TYPE$c.LeftCurlyBracket;

	var AtrulePrelude = {
	    name: 'AtrulePrelude',
	    structure: {
	        children: [[]]
	    },
	    parse: function(name) {
	        var children = null;

	        if (name !== null) {
	            name = name.toLowerCase();
	        }

	        this.scanner.skipSC();

	        if (this.atrule.hasOwnProperty(name) &&
	            typeof this.atrule[name].prelude === 'function') {
	            // custom consumer
	            children = this.atrule[name].prelude.call(this);
	        } else {
	            // default consumer
	            children = this.readSequence(this.scope.AtrulePrelude);
	        }

	        this.scanner.skipSC();

	        if (this.scanner.eof !== true &&
	            this.scanner.tokenType !== LEFTCURLYBRACKET$2 &&
	            this.scanner.tokenType !== SEMICOLON$1) {
	            this.error('Semicolon or block is expected');
	        }

	        if (children === null) {
	            children = this.createList();
	        }

	        return {
	            type: 'AtrulePrelude',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node);
	    },
	    walkContext: 'atrulePrelude'
	};

	var TYPE$d = tokenizer.TYPE;

	var IDENT$4 = TYPE$d.Ident;
	var STRING = TYPE$d.String;
	var COLON = TYPE$d.Colon;
	var LEFTSQUAREBRACKET$1 = TYPE$d.LeftSquareBracket;
	var RIGHTSQUAREBRACKET$1 = TYPE$d.RightSquareBracket;
	var DOLLARSIGN = 0x0024;       // U+0024 DOLLAR SIGN ($)
	var ASTERISK$1 = 0x002A;         // U+002A ASTERISK (*)
	var EQUALSSIGN = 0x003D;       // U+003D EQUALS SIGN (=)
	var CIRCUMFLEXACCENT = 0x005E; // U+005E (^)
	var VERTICALLINE$1 = 0x007C;     // U+007C VERTICAL LINE (|)
	var TILDE = 0x007E;            // U+007E TILDE (~)

	function getAttributeName() {
	    if (this.scanner.eof) {
	        this.error('Unexpected end of input');
	    }

	    var start = this.scanner.tokenStart;
	    var expectIdent = false;
	    var checkColon = true;

	    if (this.scanner.isDelim(ASTERISK$1)) {
	        expectIdent = true;
	        checkColon = false;
	        this.scanner.next();
	    } else if (!this.scanner.isDelim(VERTICALLINE$1)) {
	        this.eat(IDENT$4);
	    }

	    if (this.scanner.isDelim(VERTICALLINE$1)) {
	        if (this.scanner.source.charCodeAt(this.scanner.tokenStart + 1) !== EQUALSSIGN) {
	            this.scanner.next();
	            this.eat(IDENT$4);
	        } else if (expectIdent) {
	            this.error('Identifier is expected', this.scanner.tokenEnd);
	        }
	    } else if (expectIdent) {
	        this.error('Vertical line is expected');
	    }

	    if (checkColon && this.scanner.tokenType === COLON) {
	        this.scanner.next();
	        this.eat(IDENT$4);
	    }

	    return {
	        type: 'Identifier',
	        loc: this.getLocation(start, this.scanner.tokenStart),
	        name: this.scanner.substrToCursor(start)
	    };
	}

	function getOperator() {
	    var start = this.scanner.tokenStart;
	    var code = this.scanner.source.charCodeAt(start);

	    if (code !== EQUALSSIGN &&        // =
	        code !== TILDE &&             // ~=
	        code !== CIRCUMFLEXACCENT &&  // ^=
	        code !== DOLLARSIGN &&        // $=
	        code !== ASTERISK$1 &&          // *=
	        code !== VERTICALLINE$1         // |=
	    ) {
	        this.error('Attribute selector (=, ~=, ^=, $=, *=, |=) is expected');
	    }

	    this.scanner.next();

	    if (code !== EQUALSSIGN) {
	        if (!this.scanner.isDelim(EQUALSSIGN)) {
	            this.error('Equal sign is expected');
	        }

	        this.scanner.next();
	    }

	    return this.scanner.substrToCursor(start);
	}

	// '[' <wq-name> ']'
	// '[' <wq-name> <attr-matcher> [ <string-token> | <ident-token> ] <attr-modifier>? ']'
	var AttributeSelector = {
	    name: 'AttributeSelector',
	    structure: {
	        name: 'Identifier',
	        matcher: [String, null],
	        value: ['String', 'Identifier', null],
	        flags: [String, null]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var name;
	        var matcher = null;
	        var value = null;
	        var flags = null;

	        this.eat(LEFTSQUAREBRACKET$1);
	        this.scanner.skipSC();

	        name = getAttributeName.call(this);
	        this.scanner.skipSC();

	        if (this.scanner.tokenType !== RIGHTSQUAREBRACKET$1) {
	            // avoid case `[name i]`
	            if (this.scanner.tokenType !== IDENT$4) {
	                matcher = getOperator.call(this);

	                this.scanner.skipSC();

	                value = this.scanner.tokenType === STRING
	                    ? this.String()
	                    : this.Identifier();

	                this.scanner.skipSC();
	            }

	            // attribute flags
	            if (this.scanner.tokenType === IDENT$4) {
	                flags = this.scanner.getTokenValue();
	                this.scanner.next();

	                this.scanner.skipSC();
	            }
	        }

	        this.eat(RIGHTSQUAREBRACKET$1);

	        return {
	            type: 'AttributeSelector',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            matcher: matcher,
	            value: value,
	            flags: flags
	        };
	    },
	    generate: function(node) {
	        var flagsPrefix = ' ';

	        this.chunk('[');
	        this.node(node.name);

	        if (node.matcher !== null) {
	            this.chunk(node.matcher);

	            if (node.value !== null) {
	                this.node(node.value);

	                // space between string and flags is not required
	                if (node.value.type === 'String') {
	                    flagsPrefix = '';
	                }
	            }
	        }

	        if (node.flags !== null) {
	            this.chunk(flagsPrefix);
	            this.chunk(node.flags);
	        }

	        this.chunk(']');
	    }
	};

	var TYPE$e = tokenizer.TYPE;
	var rawMode$1 = Raw.mode;

	var WHITESPACE$5 = TYPE$e.WhiteSpace;
	var COMMENT$4 = TYPE$e.Comment;
	var SEMICOLON$2 = TYPE$e.Semicolon;
	var ATKEYWORD$1 = TYPE$e.AtKeyword;
	var LEFTCURLYBRACKET$3 = TYPE$e.LeftCurlyBracket;
	var RIGHTCURLYBRACKET$2 = TYPE$e.RightCurlyBracket;

	function consumeRaw$1(startToken) {
	    return this.Raw(startToken, null, true);
	}
	function consumeRule() {
	    return this.parseWithFallback(this.Rule, consumeRaw$1);
	}
	function consumeRawDeclaration(startToken) {
	    return this.Raw(startToken, rawMode$1.semicolonIncluded, true);
	}
	function consumeDeclaration() {
	    if (this.scanner.tokenType === SEMICOLON$2) {
	        return consumeRawDeclaration.call(this, this.scanner.tokenIndex);
	    }

	    var node = this.parseWithFallback(this.Declaration, consumeRawDeclaration);

	    if (this.scanner.tokenType === SEMICOLON$2) {
	        this.scanner.next();
	    }

	    return node;
	}

	var Block = {
	    name: 'Block',
	    structure: {
	        children: [[
	            'Atrule',
	            'Rule',
	            'Declaration'
	        ]]
	    },
	    parse: function(isDeclaration) {
	        var consumer = isDeclaration ? consumeDeclaration : consumeRule;

	        var start = this.scanner.tokenStart;
	        var children = this.createList();

	        this.eat(LEFTCURLYBRACKET$3);

	        scan:
	        while (!this.scanner.eof) {
	            switch (this.scanner.tokenType) {
	                case RIGHTCURLYBRACKET$2:
	                    break scan;

	                case WHITESPACE$5:
	                case COMMENT$4:
	                    this.scanner.next();
	                    break;

	                case ATKEYWORD$1:
	                    children.push(this.parseWithFallback(this.Atrule, consumeRaw$1));
	                    break;

	                default:
	                    children.push(consumer.call(this));
	            }
	        }

	        if (!this.scanner.eof) {
	            this.eat(RIGHTCURLYBRACKET$2);
	        }

	        return {
	            type: 'Block',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk('{');
	        this.children(node, function(prev) {
	            if (prev.type === 'Declaration') {
	                this.chunk(';');
	            }
	        });
	        this.chunk('}');
	    },
	    walkContext: 'block'
	};

	var TYPE$f = tokenizer.TYPE;

	var LEFTSQUAREBRACKET$2 = TYPE$f.LeftSquareBracket;
	var RIGHTSQUAREBRACKET$2 = TYPE$f.RightSquareBracket;

	var Brackets = {
	    name: 'Brackets',
	    structure: {
	        children: [[]]
	    },
	    parse: function(readSequence, recognizer) {
	        var start = this.scanner.tokenStart;
	        var children = null;

	        this.eat(LEFTSQUAREBRACKET$2);

	        children = readSequence.call(this, recognizer);

	        if (!this.scanner.eof) {
	            this.eat(RIGHTSQUAREBRACKET$2);
	        }

	        return {
	            type: 'Brackets',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk('[');
	        this.children(node);
	        this.chunk(']');
	    }
	};

	var CDC = tokenizer.TYPE.CDC;

	var CDC_1 = {
	    name: 'CDC',
	    structure: [],
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        this.eat(CDC); // -->

	        return {
	            type: 'CDC',
	            loc: this.getLocation(start, this.scanner.tokenStart)
	        };
	    },
	    generate: function() {
	        this.chunk('-->');
	    }
	};

	var CDO = tokenizer.TYPE.CDO;

	var CDO_1 = {
	    name: 'CDO',
	    structure: [],
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        this.eat(CDO); // <!--

	        return {
	            type: 'CDO',
	            loc: this.getLocation(start, this.scanner.tokenStart)
	        };
	    },
	    generate: function() {
	        this.chunk('<!--');
	    }
	};

	var TYPE$g = tokenizer.TYPE;

	var IDENT$5 = TYPE$g.Ident;
	var FULLSTOP = 0x002E; // U+002E FULL STOP (.)

	// '.' ident
	var ClassSelector = {
	    name: 'ClassSelector',
	    structure: {
	        name: String
	    },
	    parse: function() {
	        if (!this.scanner.isDelim(FULLSTOP)) {
	            this.error('Full stop is expected');
	        }

	        this.scanner.next();

	        return {
	            type: 'ClassSelector',
	            loc: this.getLocation(this.scanner.tokenStart - 1, this.scanner.tokenEnd),
	            name: this.consume(IDENT$5)
	        };
	    },
	    generate: function(node) {
	        this.chunk('.');
	        this.chunk(node.name);
	    }
	};

	var TYPE$h = tokenizer.TYPE;

	var IDENT$6 = TYPE$h.Ident;
	var PLUSSIGN$4 = 0x002B;        // U+002B PLUS SIGN (+)
	var SOLIDUS = 0x002F;         // U+002F SOLIDUS (/)
	var GREATERTHANSIGN$1 = 0x003E; // U+003E GREATER-THAN SIGN (>)
	var TILDE$1 = 0x007E;           // U+007E TILDE (~)

	// + | > | ~ | /deep/
	var Combinator = {
	    name: 'Combinator',
	    structure: {
	        name: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var code = this.scanner.source.charCodeAt(this.scanner.tokenStart);

	        switch (code) {
	            case GREATERTHANSIGN$1:
	            case PLUSSIGN$4:
	            case TILDE$1:
	                this.scanner.next();
	                break;

	            case SOLIDUS:
	                this.scanner.next();

	                if (this.scanner.tokenType !== IDENT$6 || this.scanner.lookupValue(0, 'deep') === false) {
	                    this.error('Identifier `deep` is expected');
	                }

	                this.scanner.next();

	                if (!this.scanner.isDelim(SOLIDUS)) {
	                    this.error('Solidus is expected');
	                }

	                this.scanner.next();
	                break;

	            default:
	                this.error('Combinator is expected');
	        }

	        return {
	            type: 'Combinator',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: this.scanner.substrToCursor(start)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.name);
	    }
	};

	var TYPE$i = tokenizer.TYPE;

	var COMMENT$5 = TYPE$i.Comment;
	var ASTERISK$2 = 0x002A;        // U+002A ASTERISK (*)
	var SOLIDUS$1 = 0x002F;         // U+002F SOLIDUS (/)

	// '/*' .* '*/'
	var Comment = {
	    name: 'Comment',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var end = this.scanner.tokenEnd;

	        this.eat(COMMENT$5);

	        if ((end - start + 2) >= 2 &&
	            this.scanner.source.charCodeAt(end - 2) === ASTERISK$2 &&
	            this.scanner.source.charCodeAt(end - 1) === SOLIDUS$1) {
	            end -= 2;
	        }

	        return {
	            type: 'Comment',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.source.substring(start + 2, end)
	        };
	    },
	    generate: function(node) {
	        this.chunk('/*');
	        this.chunk(node.value);
	        this.chunk('*/');
	    }
	};

	var isCustomProperty$1 = names.isCustomProperty;
	var TYPE$j = tokenizer.TYPE;
	var rawMode$2 = Raw.mode;

	var IDENT$7 = TYPE$j.Ident;
	var HASH$1 = TYPE$j.Hash;
	var COLON$1 = TYPE$j.Colon;
	var SEMICOLON$3 = TYPE$j.Semicolon;
	var DELIM$2 = TYPE$j.Delim;
	var EXCLAMATIONMARK$2 = 0x0021; // U+0021 EXCLAMATION MARK (!)
	var NUMBERSIGN$2 = 0x0023;      // U+0023 NUMBER SIGN (#)
	var DOLLARSIGN$1 = 0x0024;      // U+0024 DOLLAR SIGN ($)
	var AMPERSAND$1 = 0x0026;       // U+0026 ANPERSAND (&)
	var ASTERISK$3 = 0x002A;        // U+002A ASTERISK (*)
	var PLUSSIGN$5 = 0x002B;        // U+002B PLUS SIGN (+)
	var SOLIDUS$2 = 0x002F;         // U+002F SOLIDUS (/)

	function consumeValueRaw(startToken) {
	    return this.Raw(startToken, rawMode$2.exclamationMarkOrSemicolon, true);
	}

	function consumeCustomPropertyRaw(startToken) {
	    return this.Raw(startToken, rawMode$2.exclamationMarkOrSemicolon, false);
	}

	function consumeValue() {
	    var startValueToken = this.scanner.tokenIndex;
	    var value = this.Value();

	    if (value.type !== 'Raw' &&
	        this.scanner.eof === false &&
	        this.scanner.tokenType !== SEMICOLON$3 &&
	        this.scanner.isDelim(EXCLAMATIONMARK$2) === false &&
	        this.scanner.isBalanceEdge(startValueToken) === false) {
	        this.error();
	    }

	    return value;
	}

	var Declaration = {
	    name: 'Declaration',
	    structure: {
	        important: [Boolean, String],
	        property: String,
	        value: ['Value', 'Raw']
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var startToken = this.scanner.tokenIndex;
	        var property = readProperty$1.call(this);
	        var customProperty = isCustomProperty$1(property);
	        var parseValue = customProperty ? this.parseCustomProperty : this.parseValue;
	        var consumeRaw = customProperty ? consumeCustomPropertyRaw : consumeValueRaw;
	        var important = false;
	        var value;

	        this.scanner.skipSC();
	        this.eat(COLON$1);

	        if (!customProperty) {
	            this.scanner.skipSC();
	        }

	        if (parseValue) {
	            value = this.parseWithFallback(consumeValue, consumeRaw);
	        } else {
	            value = consumeRaw.call(this, this.scanner.tokenIndex);
	        }

	        if (this.scanner.isDelim(EXCLAMATIONMARK$2)) {
	            important = getImportant.call(this);
	            this.scanner.skipSC();
	        }

	        // Do not include semicolon to range per spec
	        // https://drafts.csswg.org/css-syntax/#declaration-diagram

	        if (this.scanner.eof === false &&
	            this.scanner.tokenType !== SEMICOLON$3 &&
	            this.scanner.isBalanceEdge(startToken) === false) {
	            this.error();
	        }

	        return {
	            type: 'Declaration',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            important: important,
	            property: property,
	            value: value
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.property);
	        this.chunk(':');
	        this.node(node.value);

	        if (node.important) {
	            this.chunk(node.important === true ? '!important' : '!' + node.important);
	        }
	    },
	    walkContext: 'declaration'
	};

	function readProperty$1() {
	    var start = this.scanner.tokenStart;

	    // hacks
	    if (this.scanner.tokenType === DELIM$2) {
	        switch (this.scanner.source.charCodeAt(this.scanner.tokenStart)) {
	            case ASTERISK$3:
	            case DOLLARSIGN$1:
	            case PLUSSIGN$5:
	            case NUMBERSIGN$2:
	            case AMPERSAND$1:
	                this.scanner.next();
	                break;

	            // TODO: not sure we should support this hack
	            case SOLIDUS$2:
	                this.scanner.next();
	                if (this.scanner.isDelim(SOLIDUS$2)) {
	                    this.scanner.next();
	                }
	                break;
	        }
	    }

	    if (this.scanner.tokenType === HASH$1) {
	        this.eat(HASH$1);
	    } else {
	        this.eat(IDENT$7);
	    }

	    return this.scanner.substrToCursor(start);
	}

	// ! ws* important
	function getImportant() {
	    this.eat(DELIM$2);
	    this.scanner.skipSC();

	    var important = this.consume(IDENT$7);

	    // store original value in case it differ from `important`
	    // for better original source restoring and hacks like `!ie` support
	    return important === 'important' ? true : important;
	}

	var TYPE$k = tokenizer.TYPE;
	var rawMode$3 = Raw.mode;

	var WHITESPACE$6 = TYPE$k.WhiteSpace;
	var COMMENT$6 = TYPE$k.Comment;
	var SEMICOLON$4 = TYPE$k.Semicolon;

	function consumeRaw$2(startToken) {
	    return this.Raw(startToken, rawMode$3.semicolonIncluded, true);
	}

	var DeclarationList = {
	    name: 'DeclarationList',
	    structure: {
	        children: [[
	            'Declaration'
	        ]]
	    },
	    parse: function() {
	        var children = this.createList();

	        
	        while (!this.scanner.eof) {
	            switch (this.scanner.tokenType) {
	                case WHITESPACE$6:
	                case COMMENT$6:
	                case SEMICOLON$4:
	                    this.scanner.next();
	                    break;

	                default:
	                    children.push(this.parseWithFallback(this.Declaration, consumeRaw$2));
	            }
	        }

	        return {
	            type: 'DeclarationList',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node, function(prev) {
	            if (prev.type === 'Declaration') {
	                this.chunk(';');
	            }
	        });
	    }
	};

	var consumeNumber$3 = utils.consumeNumber;
	var TYPE$l = tokenizer.TYPE;

	var DIMENSION$3 = TYPE$l.Dimension;

	var Dimension = {
	    name: 'Dimension',
	    structure: {
	        value: String,
	        unit: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var numberEnd = consumeNumber$3(this.scanner.source, start);

	        this.eat(DIMENSION$3);

	        return {
	            type: 'Dimension',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.source.substring(start, numberEnd),
	            unit: this.scanner.source.substring(numberEnd, this.scanner.tokenStart)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	        this.chunk(node.unit);
	    }
	};

	var TYPE$m = tokenizer.TYPE;

	var RIGHTPARENTHESIS$2 = TYPE$m.RightParenthesis;

	// <function-token> <sequence> )
	var _Function = {
	    name: 'Function',
	    structure: {
	        name: String,
	        children: [[]]
	    },
	    parse: function(readSequence, recognizer) {
	        var start = this.scanner.tokenStart;
	        var name = this.consumeFunctionName();
	        var nameLowerCase = name.toLowerCase();
	        var children;

	        children = recognizer.hasOwnProperty(nameLowerCase)
	            ? recognizer[nameLowerCase].call(this, recognizer)
	            : readSequence.call(this, recognizer);

	        if (!this.scanner.eof) {
	            this.eat(RIGHTPARENTHESIS$2);
	        }

	        return {
	            type: 'Function',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.name);
	        this.chunk('(');
	        this.children(node);
	        this.chunk(')');
	    },
	    walkContext: 'function'
	};

	var TYPE$n = tokenizer.TYPE;

	var HASH$2 = TYPE$n.Hash;

	// '#' ident
	var HexColor = {
	    name: 'HexColor',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        this.eat(HASH$2);

	        return {
	            type: 'HexColor',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.substrToCursor(start + 1)
	        };
	    },
	    generate: function(node) {
	        this.chunk('#');
	        this.chunk(node.value);
	    }
	};

	var TYPE$o = tokenizer.TYPE;

	var IDENT$8 = TYPE$o.Ident;

	var Identifier = {
	    name: 'Identifier',
	    structure: {
	        name: String
	    },
	    parse: function() {
	        return {
	            type: 'Identifier',
	            loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
	            name: this.consume(IDENT$8)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.name);
	    }
	};

	var TYPE$p = tokenizer.TYPE;

	var HASH$3 = TYPE$p.Hash;

	// <hash-token>
	var IdSelector = {
	    name: 'IdSelector',
	    structure: {
	        name: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        // TODO: check value is an ident
	        this.eat(HASH$3);

	        return {
	            type: 'IdSelector',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: this.scanner.substrToCursor(start + 1)
	        };
	    },
	    generate: function(node) {
	        this.chunk('#');
	        this.chunk(node.name);
	    }
	};

	var TYPE$q = tokenizer.TYPE;

	var IDENT$9 = TYPE$q.Ident;
	var NUMBER$4 = TYPE$q.Number;
	var DIMENSION$4 = TYPE$q.Dimension;
	var LEFTPARENTHESIS$2 = TYPE$q.LeftParenthesis;
	var RIGHTPARENTHESIS$3 = TYPE$q.RightParenthesis;
	var COLON$2 = TYPE$q.Colon;
	var DELIM$3 = TYPE$q.Delim;

	var MediaFeature = {
	    name: 'MediaFeature',
	    structure: {
	        name: String,
	        value: ['Identifier', 'Number', 'Dimension', 'Ratio', null]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var name;
	        var value = null;

	        this.eat(LEFTPARENTHESIS$2);
	        this.scanner.skipSC();

	        name = this.consume(IDENT$9);
	        this.scanner.skipSC();

	        if (this.scanner.tokenType !== RIGHTPARENTHESIS$3) {
	            this.eat(COLON$2);
	            this.scanner.skipSC();

	            switch (this.scanner.tokenType) {
	                case NUMBER$4:
	                    if (this.lookupNonWSType(1) === DELIM$3) {
	                        value = this.Ratio();
	                    } else {
	                        value = this.Number();
	                    }

	                    break;

	                case DIMENSION$4:
	                    value = this.Dimension();
	                    break;

	                case IDENT$9:
	                    value = this.Identifier();

	                    break;

	                default:
	                    this.error('Number, dimension, ratio or identifier is expected');
	            }

	            this.scanner.skipSC();
	        }

	        this.eat(RIGHTPARENTHESIS$3);

	        return {
	            type: 'MediaFeature',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            value: value
	        };
	    },
	    generate: function(node) {
	        this.chunk('(');
	        this.chunk(node.name);
	        if (node.value !== null) {
	            this.chunk(':');
	            this.node(node.value);
	        }
	        this.chunk(')');
	    }
	};

	var TYPE$r = tokenizer.TYPE;

	var WHITESPACE$7 = TYPE$r.WhiteSpace;
	var COMMENT$7 = TYPE$r.Comment;
	var IDENT$a = TYPE$r.Ident;
	var LEFTPARENTHESIS$3 = TYPE$r.LeftParenthesis;

	var MediaQuery = {
	    name: 'MediaQuery',
	    structure: {
	        children: [[
	            'Identifier',
	            'MediaFeature',
	            'WhiteSpace'
	        ]]
	    },
	    parse: function() {
	        this.scanner.skipSC();

	        var children = this.createList();
	        var child = null;
	        var space = null;

	        scan:
	        while (!this.scanner.eof) {
	            switch (this.scanner.tokenType) {
	                case COMMENT$7:
	                    this.scanner.next();
	                    continue;

	                case WHITESPACE$7:
	                    space = this.WhiteSpace();
	                    continue;

	                case IDENT$a:
	                    child = this.Identifier();
	                    break;

	                case LEFTPARENTHESIS$3:
	                    child = this.MediaFeature();
	                    break;

	                default:
	                    break scan;
	            }

	            if (space !== null) {
	                children.push(space);
	                space = null;
	            }

	            children.push(child);
	        }

	        if (child === null) {
	            this.error('Identifier or parenthesis is expected');
	        }

	        return {
	            type: 'MediaQuery',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node);
	    }
	};

	var COMMA$1 = tokenizer.TYPE.Comma;

	var MediaQueryList = {
	    name: 'MediaQueryList',
	    structure: {
	        children: [[
	            'MediaQuery'
	        ]]
	    },
	    parse: function(relative) {
	        var children = this.createList();

	        this.scanner.skipSC();

	        while (!this.scanner.eof) {
	            children.push(this.MediaQuery(relative));

	            if (this.scanner.tokenType !== COMMA$1) {
	                break;
	            }

	            this.scanner.next();
	        }

	        return {
	            type: 'MediaQueryList',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node, function() {
	            this.chunk(',');
	        });
	    }
	};

	var Nth = {
	    name: 'Nth',
	    structure: {
	        nth: ['AnPlusB', 'Identifier'],
	        selector: ['SelectorList', null]
	    },
	    parse: function(allowOfClause) {
	        this.scanner.skipSC();

	        var start = this.scanner.tokenStart;
	        var end = start;
	        var selector = null;
	        var query;

	        if (this.scanner.lookupValue(0, 'odd') || this.scanner.lookupValue(0, 'even')) {
	            query = this.Identifier();
	        } else {
	            query = this.AnPlusB();
	        }

	        this.scanner.skipSC();

	        if (allowOfClause && this.scanner.lookupValue(0, 'of')) {
	            this.scanner.next();

	            selector = this.SelectorList();

	            if (this.needPositions) {
	                end = this.getLastListNode(selector.children).loc.end.offset;
	            }
	        } else {
	            if (this.needPositions) {
	                end = query.loc.end.offset;
	            }
	        }

	        return {
	            type: 'Nth',
	            loc: this.getLocation(start, end),
	            nth: query,
	            selector: selector
	        };
	    },
	    generate: function(node) {
	        this.node(node.nth);
	        if (node.selector !== null) {
	            this.chunk(' of ');
	            this.node(node.selector);
	        }
	    }
	};

	var NUMBER$5 = tokenizer.TYPE.Number;

	var _Number = {
	    name: 'Number',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        return {
	            type: 'Number',
	            loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
	            value: this.consume(NUMBER$5)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    }
	};

	// '/' | '*' | ',' | ':' | '+' | '-'
	var Operator = {
	    name: 'Operator',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        this.scanner.next();

	        return {
	            type: 'Operator',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.substrToCursor(start)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    }
	};

	var TYPE$s = tokenizer.TYPE;

	var LEFTPARENTHESIS$4 = TYPE$s.LeftParenthesis;
	var RIGHTPARENTHESIS$4 = TYPE$s.RightParenthesis;

	var Parentheses = {
	    name: 'Parentheses',
	    structure: {
	        children: [[]]
	    },
	    parse: function(readSequence, recognizer) {
	        var start = this.scanner.tokenStart;
	        var children = null;

	        this.eat(LEFTPARENTHESIS$4);

	        children = readSequence.call(this, recognizer);

	        if (!this.scanner.eof) {
	            this.eat(RIGHTPARENTHESIS$4);
	        }

	        return {
	            type: 'Parentheses',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk('(');
	        this.children(node);
	        this.chunk(')');
	    }
	};

	var consumeNumber$4 = utils.consumeNumber;
	var TYPE$t = tokenizer.TYPE;

	var PERCENTAGE$1 = TYPE$t.Percentage;

	var Percentage = {
	    name: 'Percentage',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var numberEnd = consumeNumber$4(this.scanner.source, start);

	        this.eat(PERCENTAGE$1);

	        return {
	            type: 'Percentage',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.source.substring(start, numberEnd)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	        this.chunk('%');
	    }
	};

	var TYPE$u = tokenizer.TYPE;

	var IDENT$b = TYPE$u.Ident;
	var FUNCTION$1 = TYPE$u.Function;
	var COLON$3 = TYPE$u.Colon;
	var RIGHTPARENTHESIS$5 = TYPE$u.RightParenthesis;

	// : [ <ident> | <function-token> <any-value>? ) ]
	var PseudoClassSelector = {
	    name: 'PseudoClassSelector',
	    structure: {
	        name: String,
	        children: [['Raw'], null]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var children = null;
	        var name;
	        var nameLowerCase;

	        this.eat(COLON$3);

	        if (this.scanner.tokenType === FUNCTION$1) {
	            name = this.consumeFunctionName();
	            nameLowerCase = name.toLowerCase();

	            if (this.pseudo.hasOwnProperty(nameLowerCase)) {
	                this.scanner.skipSC();
	                children = this.pseudo[nameLowerCase].call(this);
	                this.scanner.skipSC();
	            } else {
	                children = this.createList();
	                children.push(
	                    this.Raw(this.scanner.tokenIndex, null, false)
	                );
	            }

	            this.eat(RIGHTPARENTHESIS$5);
	        } else {
	            name = this.consume(IDENT$b);
	        }

	        return {
	            type: 'PseudoClassSelector',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk(':');
	        this.chunk(node.name);

	        if (node.children !== null) {
	            this.chunk('(');
	            this.children(node);
	            this.chunk(')');
	        }
	    },
	    walkContext: 'function'
	};

	var TYPE$v = tokenizer.TYPE;

	var IDENT$c = TYPE$v.Ident;
	var FUNCTION$2 = TYPE$v.Function;
	var COLON$4 = TYPE$v.Colon;
	var RIGHTPARENTHESIS$6 = TYPE$v.RightParenthesis;

	// :: [ <ident> | <function-token> <any-value>? ) ]
	var PseudoElementSelector = {
	    name: 'PseudoElementSelector',
	    structure: {
	        name: String,
	        children: [['Raw'], null]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var children = null;
	        var name;
	        var nameLowerCase;

	        this.eat(COLON$4);
	        this.eat(COLON$4);

	        if (this.scanner.tokenType === FUNCTION$2) {
	            name = this.consumeFunctionName();
	            nameLowerCase = name.toLowerCase();

	            if (this.pseudo.hasOwnProperty(nameLowerCase)) {
	                this.scanner.skipSC();
	                children = this.pseudo[nameLowerCase].call(this);
	                this.scanner.skipSC();
	            } else {
	                children = this.createList();
	                children.push(
	                    this.Raw(this.scanner.tokenIndex, null, false)
	                );
	            }

	            this.eat(RIGHTPARENTHESIS$6);
	        } else {
	            name = this.consume(IDENT$c);
	        }

	        return {
	            type: 'PseudoElementSelector',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk('::');
	        this.chunk(node.name);

	        if (node.children !== null) {
	            this.chunk('(');
	            this.children(node);
	            this.chunk(')');
	        }
	    },
	    walkContext: 'function'
	};

	var isDigit$5 = tokenizer.isDigit;
	var TYPE$w = tokenizer.TYPE;

	var NUMBER$6 = TYPE$w.Number;
	var DELIM$4 = TYPE$w.Delim;
	var SOLIDUS$3 = 0x002F;  // U+002F SOLIDUS (/)
	var FULLSTOP$1 = 0x002E; // U+002E FULL STOP (.)

	// Terms of <ratio> should be a positive numbers (not zero or negative)
	// (see https://drafts.csswg.org/mediaqueries-3/#values)
	// However, -o-min-device-pixel-ratio takes fractional values as a ratio's term
	// and this is using by various sites. Therefore we relax checking on parse
	// to test a term is unsigned number without an exponent part.
	// Additional checking may be applied on lexer validation.
	function consumeNumber$5() {
	    this.scanner.skipWS();

	    var value = this.consume(NUMBER$6);

	    for (var i = 0; i < value.length; i++) {
	        var code = value.charCodeAt(i);
	        if (!isDigit$5(code) && code !== FULLSTOP$1) {
	            this.error('Unsigned number is expected', this.scanner.tokenStart - value.length + i);
	        }
	    }

	    if (Number(value) === 0) {
	        this.error('Zero number is not allowed', this.scanner.tokenStart - value.length);
	    }

	    return value;
	}

	// <positive-integer> S* '/' S* <positive-integer>
	var Ratio = {
	    name: 'Ratio',
	    structure: {
	        left: String,
	        right: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var left = consumeNumber$5.call(this);
	        var right;

	        this.scanner.skipWS();

	        if (!this.scanner.isDelim(SOLIDUS$3)) {
	            this.error('Solidus is expected');
	        }
	        this.eat(DELIM$4);
	        right = consumeNumber$5.call(this);

	        return {
	            type: 'Ratio',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            left: left,
	            right: right
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.left);
	        this.chunk('/');
	        this.chunk(node.right);
	    }
	};

	var TYPE$x = tokenizer.TYPE;
	var rawMode$4 = Raw.mode;

	var LEFTCURLYBRACKET$4 = TYPE$x.LeftCurlyBracket;

	function consumeRaw$3(startToken) {
	    return this.Raw(startToken, rawMode$4.leftCurlyBracket, true);
	}

	function consumePrelude() {
	    var prelude = this.SelectorList();

	    if (prelude.type !== 'Raw' &&
	        this.scanner.eof === false &&
	        this.scanner.tokenType !== LEFTCURLYBRACKET$4) {
	        this.error();
	    }

	    return prelude;
	}

	var Rule = {
	    name: 'Rule',
	    structure: {
	        prelude: ['SelectorList', 'Raw'],
	        block: ['Block']
	    },
	    parse: function() {
	        var startToken = this.scanner.tokenIndex;
	        var startOffset = this.scanner.tokenStart;
	        var prelude;
	        var block;

	        if (this.parseRulePrelude) {
	            prelude = this.parseWithFallback(consumePrelude, consumeRaw$3);
	        } else {
	            prelude = consumeRaw$3.call(this, startToken);
	        }

	        block = this.Block(true);

	        return {
	            type: 'Rule',
	            loc: this.getLocation(startOffset, this.scanner.tokenStart),
	            prelude: prelude,
	            block: block
	        };
	    },
	    generate: function(node) {
	        this.node(node.prelude);
	        this.node(node.block);
	    },
	    walkContext: 'rule'
	};

	var Selector = {
	    name: 'Selector',
	    structure: {
	        children: [[
	            'TypeSelector',
	            'IdSelector',
	            'ClassSelector',
	            'AttributeSelector',
	            'PseudoClassSelector',
	            'PseudoElementSelector',
	            'Combinator',
	            'WhiteSpace'
	        ]]
	    },
	    parse: function() {
	        var children = this.readSequence(this.scope.Selector);

	        // nothing were consumed
	        if (this.getFirstListNode(children) === null) {
	            this.error('Selector is expected');
	        }

	        return {
	            type: 'Selector',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node);
	    }
	};

	var TYPE$y = tokenizer.TYPE;

	var COMMA$2 = TYPE$y.Comma;

	var SelectorList = {
	    name: 'SelectorList',
	    structure: {
	        children: [[
	            'Selector',
	            'Raw'
	        ]]
	    },
	    parse: function() {
	        var children = this.createList();

	        while (!this.scanner.eof) {
	            children.push(this.Selector());

	            if (this.scanner.tokenType === COMMA$2) {
	                this.scanner.next();
	                continue;
	            }

	            break;
	        }

	        return {
	            type: 'SelectorList',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node, function() {
	            this.chunk(',');
	        });
	    },
	    walkContext: 'selector'
	};

	var STRING$1 = tokenizer.TYPE.String;

	var _String = {
	    name: 'String',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        return {
	            type: 'String',
	            loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
	            value: this.consume(STRING$1)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    }
	};

	var TYPE$z = tokenizer.TYPE;

	var WHITESPACE$8 = TYPE$z.WhiteSpace;
	var COMMENT$8 = TYPE$z.Comment;
	var ATKEYWORD$2 = TYPE$z.AtKeyword;
	var CDO$1 = TYPE$z.CDO;
	var CDC$1 = TYPE$z.CDC;
	var EXCLAMATIONMARK$3 = 0x0021; // U+0021 EXCLAMATION MARK (!)

	function consumeRaw$4(startToken) {
	    return this.Raw(startToken, null, false);
	}

	var StyleSheet = {
	    name: 'StyleSheet',
	    structure: {
	        children: [[
	            'Comment',
	            'CDO',
	            'CDC',
	            'Atrule',
	            'Rule',
	            'Raw'
	        ]]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var children = this.createList();
	        var child;

	        
	        while (!this.scanner.eof) {
	            switch (this.scanner.tokenType) {
	                case WHITESPACE$8:
	                    this.scanner.next();
	                    continue;

	                case COMMENT$8:
	                    // ignore comments except exclamation comments (i.e. /*! .. */) on top level
	                    if (this.scanner.source.charCodeAt(this.scanner.tokenStart + 2) !== EXCLAMATIONMARK$3) {
	                        this.scanner.next();
	                        continue;
	                    }

	                    child = this.Comment();
	                    break;

	                case CDO$1: // <!--
	                    child = this.CDO();
	                    break;

	                case CDC$1: // -->
	                    child = this.CDC();
	                    break;

	                // CSS Syntax Module Level 3
	                // §2.2 Error handling
	                // At the "top level" of a stylesheet, an <at-keyword-token> starts an at-rule.
	                case ATKEYWORD$2:
	                    child = this.parseWithFallback(this.Atrule, consumeRaw$4);
	                    break;

	                // Anything else starts a qualified rule ...
	                default:
	                    child = this.parseWithFallback(this.Rule, consumeRaw$4);
	            }

	            children.push(child);
	        }

	        return {
	            type: 'StyleSheet',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node);
	    },
	    walkContext: 'stylesheet'
	};

	var TYPE$A = tokenizer.TYPE;

	var IDENT$d = TYPE$A.Ident;
	var ASTERISK$4 = 0x002A;     // U+002A ASTERISK (*)
	var VERTICALLINE$2 = 0x007C; // U+007C VERTICAL LINE (|)

	function eatIdentifierOrAsterisk() {
	    if (this.scanner.tokenType !== IDENT$d &&
	        this.scanner.isDelim(ASTERISK$4) === false) {
	        this.error('Identifier or asterisk is expected');
	    }

	    this.scanner.next();
	}

	// ident
	// ident|ident
	// ident|*
	// *
	// *|ident
	// *|*
	// |ident
	// |*
	var TypeSelector = {
	    name: 'TypeSelector',
	    structure: {
	        name: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        if (this.scanner.isDelim(VERTICALLINE$2)) {
	            this.scanner.next();
	            eatIdentifierOrAsterisk.call(this);
	        } else {
	            eatIdentifierOrAsterisk.call(this);

	            if (this.scanner.isDelim(VERTICALLINE$2)) {
	                this.scanner.next();
	                eatIdentifierOrAsterisk.call(this);
	            }
	        }

	        return {
	            type: 'TypeSelector',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: this.scanner.substrToCursor(start)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.name);
	    }
	};

	var isHexDigit$4 = tokenizer.isHexDigit;
	var cmpChar$4 = tokenizer.cmpChar;
	var TYPE$B = tokenizer.TYPE;
	var NAME$3 = tokenizer.NAME;

	var IDENT$e = TYPE$B.Ident;
	var NUMBER$7 = TYPE$B.Number;
	var DIMENSION$5 = TYPE$B.Dimension;
	var PLUSSIGN$6 = 0x002B;     // U+002B PLUS SIGN (+)
	var HYPHENMINUS$4 = 0x002D;  // U+002D HYPHEN-MINUS (-)
	var QUESTIONMARK$2 = 0x003F; // U+003F QUESTION MARK (?)
	var U$1 = 0x0075;            // U+0075 LATIN SMALL LETTER U (u)

	function eatHexSequence(offset, allowDash) {
	    for (var pos = this.scanner.tokenStart + offset, len = 0; pos < this.scanner.tokenEnd; pos++) {
	        var code = this.scanner.source.charCodeAt(pos);

	        if (code === HYPHENMINUS$4 && allowDash && len !== 0) {
	            if (eatHexSequence.call(this, offset + len + 1, false) === 0) {
	                this.error();
	            }

	            return -1;
	        }

	        if (!isHexDigit$4(code)) {
	            this.error(
	                allowDash && len !== 0
	                    ? 'HyphenMinus' + (len < 6 ? ' or hex digit' : '') + ' is expected'
	                    : (len < 6 ? 'Hex digit is expected' : 'Unexpected input'),
	                pos
	            );
	        }

	        if (++len > 6) {
	            this.error('Too many hex digits', pos);
	        }    }

	    this.scanner.next();
	    return len;
	}

	function eatQuestionMarkSequence(max) {
	    var count = 0;

	    while (this.scanner.isDelim(QUESTIONMARK$2)) {
	        if (++count > max) {
	            this.error('Too many question marks');
	        }

	        this.scanner.next();
	    }
	}

	function startsWith$1(code) {
	    if (this.scanner.source.charCodeAt(this.scanner.tokenStart) !== code) {
	        this.error(NAME$3[code] + ' is expected');
	    }
	}

	// https://drafts.csswg.org/css-syntax/#urange
	// Informally, the <urange> production has three forms:
	// U+0001
	//      Defines a range consisting of a single code point, in this case the code point "1".
	// U+0001-00ff
	//      Defines a range of codepoints between the first and the second value, in this case
	//      the range between "1" and "ff" (255 in decimal) inclusive.
	// U+00??
	//      Defines a range of codepoints where the "?" characters range over all hex digits,
	//      in this case defining the same as the value U+0000-00ff.
	// In each form, a maximum of 6 digits is allowed for each hexadecimal number (if you treat "?" as a hexadecimal digit).
	//
	// <urange> =
	//   u '+' <ident-token> '?'* |
	//   u <dimension-token> '?'* |
	//   u <number-token> '?'* |
	//   u <number-token> <dimension-token> |
	//   u <number-token> <number-token> |
	//   u '+' '?'+
	function scanUnicodeRange() {
	    var hexLength = 0;

	    // u '+' <ident-token> '?'*
	    // u '+' '?'+
	    if (this.scanner.isDelim(PLUSSIGN$6)) {
	        this.scanner.next();

	        if (this.scanner.tokenType === IDENT$e) {
	            hexLength = eatHexSequence.call(this, 0, true);
	            if (hexLength > 0) {
	                eatQuestionMarkSequence.call(this, 6 - hexLength);
	            }
	            return;
	        }

	        if (this.scanner.isDelim(QUESTIONMARK$2)) {
	            this.scanner.next();
	            eatQuestionMarkSequence.call(this, 5);
	            return;
	        }

	        this.error('Hex digit or question mark is expected');
	        return;
	    }

	    // u <number-token> '?'*
	    // u <number-token> <dimension-token>
	    // u <number-token> <number-token>
	    if (this.scanner.tokenType === NUMBER$7) {
	        startsWith$1.call(this, PLUSSIGN$6);
	        hexLength = eatHexSequence.call(this, 1, true);

	        if (this.scanner.isDelim(QUESTIONMARK$2)) {
	            eatQuestionMarkSequence.call(this, 6 - hexLength);
	            return;
	        }

	        if (this.scanner.tokenType === DIMENSION$5 ||
	            this.scanner.tokenType === NUMBER$7) {
	            startsWith$1.call(this, HYPHENMINUS$4);
	            eatHexSequence.call(this, 1, false);
	            return;
	        }

	        return;
	    }

	    // u <dimension-token> '?'*
	    if (this.scanner.tokenType === DIMENSION$5) {
	        startsWith$1.call(this, PLUSSIGN$6);
	        hexLength = eatHexSequence.call(this, 1, true);

	        if (hexLength > 0) {
	            eatQuestionMarkSequence.call(this, 6 - hexLength);
	        }

	        return;
	    }

	    this.error();
	}

	var UnicodeRange = {
	    name: 'UnicodeRange',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        // U or u
	        if (!cmpChar$4(this.scanner.source, start, U$1)) {
	            this.error('U is expected');
	        }

	        if (!cmpChar$4(this.scanner.source, start + 1, PLUSSIGN$6)) {
	            this.error('Plus sign is expected');
	        }

	        this.scanner.next();
	        scanUnicodeRange.call(this);

	        return {
	            type: 'UnicodeRange',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.substrToCursor(start)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    }
	};

	var isWhiteSpace$2 = tokenizer.isWhiteSpace;
	var cmpStr$4 = tokenizer.cmpStr;
	var TYPE$C = tokenizer.TYPE;

	var FUNCTION$3 = TYPE$C.Function;
	var URL$2 = TYPE$C.Url;
	var RIGHTPARENTHESIS$7 = TYPE$C.RightParenthesis;

	// <url-token> | <function-token> <string> )
	var Url = {
	    name: 'Url',
	    structure: {
	        value: ['String', 'Raw']
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var value;

	        switch (this.scanner.tokenType) {
	            case URL$2:
	                var rawStart = start + 4;
	                var rawEnd = this.scanner.tokenEnd - 1;

	                while (rawStart < rawEnd && isWhiteSpace$2(this.scanner.source.charCodeAt(rawStart))) {
	                    rawStart++;
	                }

	                while (rawStart < rawEnd && isWhiteSpace$2(this.scanner.source.charCodeAt(rawEnd - 1))) {
	                    rawEnd--;
	                }

	                value = {
	                    type: 'Raw',
	                    loc: this.getLocation(rawStart, rawEnd),
	                    value: this.scanner.source.substring(rawStart, rawEnd)
	                };

	                this.eat(URL$2);
	                break;

	            case FUNCTION$3:
	                if (!cmpStr$4(this.scanner.source, this.scanner.tokenStart, this.scanner.tokenEnd, 'url(')) {
	                    this.error('Function name must be `url`');
	                }

	                this.eat(FUNCTION$3);
	                this.scanner.skipSC();
	                value = this.String();
	                this.scanner.skipSC();
	                this.eat(RIGHTPARENTHESIS$7);
	                break;

	            default:
	                this.error('Url or Function is expected');
	        }

	        return {
	            type: 'Url',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: value
	        };
	    },
	    generate: function(node) {
	        this.chunk('url');
	        this.chunk('(');
	        this.node(node.value);
	        this.chunk(')');
	    }
	};

	var Value = {
	    name: 'Value',
	    structure: {
	        children: [[]]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var children = this.readSequence(this.scope.Value);

	        return {
	            type: 'Value',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node);
	    }
	};

	var WHITESPACE$9 = tokenizer.TYPE.WhiteSpace;
	var SPACE$2 = Object.freeze({
	    type: 'WhiteSpace',
	    loc: null,
	    value: ' '
	});

	var WhiteSpace$1 = {
	    name: 'WhiteSpace',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        this.eat(WHITESPACE$9);
	        return SPACE$2;

	        // return {
	        //     type: 'WhiteSpace',
	        //     loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
	        //     value: this.consume(WHITESPACE)
	        // };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    }
	};

	var node = {
	    AnPlusB: AnPlusB,
	    Atrule: Atrule,
	    AtrulePrelude: AtrulePrelude,
	    AttributeSelector: AttributeSelector,
	    Block: Block,
	    Brackets: Brackets,
	    CDC: CDC_1,
	    CDO: CDO_1,
	    ClassSelector: ClassSelector,
	    Combinator: Combinator,
	    Comment: Comment,
	    Declaration: Declaration,
	    DeclarationList: DeclarationList,
	    Dimension: Dimension,
	    Function: _Function,
	    HexColor: HexColor,
	    Identifier: Identifier,
	    IdSelector: IdSelector,
	    MediaFeature: MediaFeature,
	    MediaQuery: MediaQuery,
	    MediaQueryList: MediaQueryList,
	    Nth: Nth,
	    Number: _Number,
	    Operator: Operator,
	    Parentheses: Parentheses,
	    Percentage: Percentage,
	    PseudoClassSelector: PseudoClassSelector,
	    PseudoElementSelector: PseudoElementSelector,
	    Ratio: Ratio,
	    Raw: Raw,
	    Rule: Rule,
	    Selector: Selector,
	    SelectorList: SelectorList,
	    String: _String,
	    StyleSheet: StyleSheet,
	    TypeSelector: TypeSelector,
	    UnicodeRange: UnicodeRange,
	    Url: Url,
	    Value: Value,
	    WhiteSpace: WhiteSpace$1
	};

	var lexer = {
	    generic: true,
	    types: data.types,
	    atrules: data.atrules,
	    properties: data.properties,
	    node: node
	};

	var cmpChar$5 = tokenizer.cmpChar;
	var cmpStr$5 = tokenizer.cmpStr;
	var TYPE$D = tokenizer.TYPE;

	var IDENT$f = TYPE$D.Ident;
	var STRING$2 = TYPE$D.String;
	var NUMBER$8 = TYPE$D.Number;
	var FUNCTION$4 = TYPE$D.Function;
	var URL$3 = TYPE$D.Url;
	var HASH$4 = TYPE$D.Hash;
	var DIMENSION$6 = TYPE$D.Dimension;
	var PERCENTAGE$2 = TYPE$D.Percentage;
	var LEFTPARENTHESIS$5 = TYPE$D.LeftParenthesis;
	var LEFTSQUAREBRACKET$3 = TYPE$D.LeftSquareBracket;
	var COMMA$3 = TYPE$D.Comma;
	var DELIM$5 = TYPE$D.Delim;
	var NUMBERSIGN$3 = 0x0023;  // U+0023 NUMBER SIGN (#)
	var ASTERISK$5 = 0x002A;    // U+002A ASTERISK (*)
	var PLUSSIGN$7 = 0x002B;    // U+002B PLUS SIGN (+)
	var HYPHENMINUS$5 = 0x002D; // U+002D HYPHEN-MINUS (-)
	var SOLIDUS$4 = 0x002F;     // U+002F SOLIDUS (/)
	var U$2 = 0x0075;           // U+0075 LATIN SMALL LETTER U (u)

	var _default = function defaultRecognizer(context) {
	    switch (this.scanner.tokenType) {
	        case HASH$4:
	            return this.HexColor();

	        case COMMA$3:
	            context.space = null;
	            context.ignoreWSAfter = true;
	            return this.Operator();

	        case LEFTPARENTHESIS$5:
	            return this.Parentheses(this.readSequence, context.recognizer);

	        case LEFTSQUAREBRACKET$3:
	            return this.Brackets(this.readSequence, context.recognizer);

	        case STRING$2:
	            return this.String();

	        case DIMENSION$6:
	            return this.Dimension();

	        case PERCENTAGE$2:
	            return this.Percentage();

	        case NUMBER$8:
	            return this.Number();

	        case FUNCTION$4:
	            return cmpStr$5(this.scanner.source, this.scanner.tokenStart, this.scanner.tokenEnd, 'url(')
	                ? this.Url()
	                : this.Function(this.readSequence, context.recognizer);

	        case URL$3:
	            return this.Url();

	        case IDENT$f:
	            // check for unicode range, it should start with u+ or U+
	            if (cmpChar$5(this.scanner.source, this.scanner.tokenStart, U$2) &&
	                cmpChar$5(this.scanner.source, this.scanner.tokenStart + 1, PLUSSIGN$7)) {
	                return this.UnicodeRange();
	            } else {
	                return this.Identifier();
	            }

	        case DELIM$5:
	            var code = this.scanner.source.charCodeAt(this.scanner.tokenStart);

	            if (code === SOLIDUS$4 ||
	                code === ASTERISK$5 ||
	                code === PLUSSIGN$7 ||
	                code === HYPHENMINUS$5) {
	                return this.Operator(); // TODO: replace with Delim
	            }

	            // TODO: produce a node with Delim node type

	            if (code === NUMBERSIGN$3) {
	                this.error('Hex or identifier is expected', this.scanner.tokenStart + 1);
	            }

	            break;
	    }
	};

	var atrulePrelude = {
	    getNode: _default
	};

	var TYPE$E = tokenizer.TYPE;

	var DELIM$6 = TYPE$E.Delim;
	var IDENT$g = TYPE$E.Ident;
	var DIMENSION$7 = TYPE$E.Dimension;
	var PERCENTAGE$3 = TYPE$E.Percentage;
	var NUMBER$9 = TYPE$E.Number;
	var HASH$5 = TYPE$E.Hash;
	var COLON$5 = TYPE$E.Colon;
	var LEFTSQUAREBRACKET$4 = TYPE$E.LeftSquareBracket;
	var NUMBERSIGN$4 = 0x0023;      // U+0023 NUMBER SIGN (#)
	var ASTERISK$6 = 0x002A;        // U+002A ASTERISK (*)
	var PLUSSIGN$8 = 0x002B;        // U+002B PLUS SIGN (+)
	var SOLIDUS$5 = 0x002F;         // U+002F SOLIDUS (/)
	var FULLSTOP$2 = 0x002E;        // U+002E FULL STOP (.)
	var GREATERTHANSIGN$2 = 0x003E; // U+003E GREATER-THAN SIGN (>)
	var VERTICALLINE$3 = 0x007C;    // U+007C VERTICAL LINE (|)
	var TILDE$2 = 0x007E;           // U+007E TILDE (~)

	function getNode(context) {
	    switch (this.scanner.tokenType) {
	        case LEFTSQUAREBRACKET$4:
	            return this.AttributeSelector();

	        case HASH$5:
	            return this.IdSelector();

	        case COLON$5:
	            if (this.scanner.lookupType(1) === COLON$5) {
	                return this.PseudoElementSelector();
	            } else {
	                return this.PseudoClassSelector();
	            }

	        case IDENT$g:
	            return this.TypeSelector();

	        case NUMBER$9:
	        case PERCENTAGE$3:
	            return this.Percentage();

	        case DIMENSION$7:
	            // throws when .123ident
	            if (this.scanner.source.charCodeAt(this.scanner.tokenStart) === FULLSTOP$2) {
	                this.error('Identifier is expected', this.scanner.tokenStart + 1);
	            }
	            break;

	        case DELIM$6:
	            var code = this.scanner.source.charCodeAt(this.scanner.tokenStart);

	            switch (code) {
	                case PLUSSIGN$8:
	                case GREATERTHANSIGN$2:
	                case TILDE$2:
	                    context.space = null;
	                    context.ignoreWSAfter = true;
	                    return this.Combinator();

	                case SOLIDUS$5:  // /deep/
	                    return this.Combinator();

	                case FULLSTOP$2:
	                    return this.ClassSelector();

	                case ASTERISK$6:
	                case VERTICALLINE$3:
	                    return this.TypeSelector();

	                case NUMBERSIGN$4:
	                    return this.IdSelector();
	            }

	            break;
	    }
	}
	var selector = {
	    getNode: getNode
	};

	// https://drafts.csswg.org/css-images-4/#element-notation
	// https://developer.mozilla.org/en-US/docs/Web/CSS/element
	var element = function() {
	    this.scanner.skipSC();

	    var children = this.createSingleNodeList(
	        this.IdSelector()
	    );

	    this.scanner.skipSC();

	    return children;
	};

	// legacy IE function
	// expression( <any-value> )
	var expression = function() {
	    return this.createSingleNodeList(
	        this.Raw(this.scanner.tokenIndex, null, false)
	    );
	};

	var TYPE$F = tokenizer.TYPE;
	var rawMode$5 = Raw.mode;

	var COMMA$4 = TYPE$F.Comma;

	// var( <ident> , <value>? )
	var _var = function() {
	    var children = this.createList();

	    this.scanner.skipSC();

	    // NOTE: Don't check more than a first argument is an ident, rest checks are for lexer
	    children.push(this.Identifier());

	    this.scanner.skipSC();

	    if (this.scanner.tokenType === COMMA$4) {
	        children.push(this.Operator());
	        children.push(this.parseCustomProperty
	            ? this.Value(null)
	            : this.Raw(this.scanner.tokenIndex, rawMode$5.exclamationMarkOrSemicolon, false)
	        );
	    }

	    return children;
	};

	var value = {
	    getNode: _default,
	    '-moz-element': element,
	    'element': element,
	    'expression': expression,
	    'var': _var
	};

	var scope = {
	    AtrulePrelude: atrulePrelude,
	    Selector: selector,
	    Value: value
	};

	var fontFace = {
	    parse: {
	        prelude: null,
	        block: function() {
	            return this.Block(true);
	        }
	    }
	};

	var TYPE$G = tokenizer.TYPE;

	var STRING$3 = TYPE$G.String;
	var IDENT$h = TYPE$G.Ident;
	var URL$4 = TYPE$G.Url;
	var FUNCTION$5 = TYPE$G.Function;
	var LEFTPARENTHESIS$6 = TYPE$G.LeftParenthesis;

	var _import = {
	    parse: {
	        prelude: function() {
	            var children = this.createList();

	            this.scanner.skipSC();

	            switch (this.scanner.tokenType) {
	                case STRING$3:
	                    children.push(this.String());
	                    break;

	                case URL$4:
	                case FUNCTION$5:
	                    children.push(this.Url());
	                    break;

	                default:
	                    this.error('String or url() is expected');
	            }

	            if (this.lookupNonWSType(0) === IDENT$h ||
	                this.lookupNonWSType(0) === LEFTPARENTHESIS$6) {
	                children.push(this.WhiteSpace());
	                children.push(this.MediaQueryList());
	            }

	            return children;
	        },
	        block: null
	    }
	};

	var media = {
	    parse: {
	        prelude: function() {
	            return this.createSingleNodeList(
	                this.MediaQueryList()
	            );
	        },
	        block: function() {
	            return this.Block(false);
	        }
	    }
	};

	var page = {
	    parse: {
	        prelude: function() {
	            return this.createSingleNodeList(
	                this.SelectorList()
	            );
	        },
	        block: function() {
	            return this.Block(true);
	        }
	    }
	};

	var TYPE$H = tokenizer.TYPE;

	var WHITESPACE$a = TYPE$H.WhiteSpace;
	var COMMENT$9 = TYPE$H.Comment;
	var IDENT$i = TYPE$H.Ident;
	var FUNCTION$6 = TYPE$H.Function;
	var COLON$6 = TYPE$H.Colon;
	var LEFTPARENTHESIS$7 = TYPE$H.LeftParenthesis;

	function consumeRaw$5() {
	    return this.createSingleNodeList(
	        this.Raw(this.scanner.tokenIndex, null, false)
	    );
	}

	function parentheses() {
	    this.scanner.skipSC();

	    if (this.scanner.tokenType === IDENT$i &&
	        this.lookupNonWSType(1) === COLON$6) {
	        return this.createSingleNodeList(
	            this.Declaration()
	        );
	    }

	    return readSequence.call(this);
	}

	function readSequence() {
	    var children = this.createList();
	    var space = null;
	    var child;

	    this.scanner.skipSC();

	    scan:
	    while (!this.scanner.eof) {
	        switch (this.scanner.tokenType) {
	            case WHITESPACE$a:
	                space = this.WhiteSpace();
	                continue;

	            case COMMENT$9:
	                this.scanner.next();
	                continue;

	            case FUNCTION$6:
	                child = this.Function(consumeRaw$5, this.scope.AtrulePrelude);
	                break;

	            case IDENT$i:
	                child = this.Identifier();
	                break;

	            case LEFTPARENTHESIS$7:
	                child = this.Parentheses(parentheses, this.scope.AtrulePrelude);
	                break;

	            default:
	                break scan;
	        }

	        if (space !== null) {
	            children.push(space);
	            space = null;
	        }

	        children.push(child);
	    }

	    return children;
	}

	var supports = {
	    parse: {
	        prelude: function() {
	            var children = readSequence.call(this);

	            if (this.getFirstListNode(children) === null) {
	                this.error('Condition is expected');
	            }

	            return children;
	        },
	        block: function() {
	            return this.Block(false);
	        }
	    }
	};

	var atrule = {
	    'font-face': fontFace,
	    'import': _import,
	    'media': media,
	    'page': page,
	    'supports': supports
	};

	var dir = {
	    parse: function() {
	        return this.createSingleNodeList(
	            this.Identifier()
	        );
	    }
	};

	var has$1 = {
	    parse: function() {
	        return this.createSingleNodeList(
	            this.SelectorList()
	        );
	    }
	};

	var lang = {
	    parse: function() {
	        return this.createSingleNodeList(
	            this.Identifier()
	        );
	    }
	};

	var selectorList = {
	    parse: function selectorList() {
	        return this.createSingleNodeList(
	            this.SelectorList()
	        );
	    }
	};

	var matches = selectorList;

	var not = selectorList;

	var ALLOW_OF_CLAUSE = true;

	var nthWithOfClause = {
	    parse: function nthWithOfClause() {
	        return this.createSingleNodeList(
	            this.Nth(ALLOW_OF_CLAUSE)
	        );
	    }
	};

	var nthChild = nthWithOfClause;

	var nthLastChild = nthWithOfClause;

	var DISALLOW_OF_CLAUSE = false;

	var nth$1 = {
	    parse: function nth() {
	        return this.createSingleNodeList(
	            this.Nth(DISALLOW_OF_CLAUSE)
	        );
	    }
	};

	var nthLastOfType = nth$1;

	var nthOfType = nth$1;

	var slotted = {
	    parse: function compoundSelector() {
	        return this.createSingleNodeList(
	            this.Selector()
	        );
	    }
	};

	var pseudo = {
	    'dir': dir,
	    'has': has$1,
	    'lang': lang,
	    'matches': matches,
	    'not': not,
	    'nth-child': nthChild,
	    'nth-last-child': nthLastChild,
	    'nth-last-of-type': nthLastOfType,
	    'nth-of-type': nthOfType,
	    'slotted': slotted
	};

	var parser = {
	    parseContext: {
	        default: 'StyleSheet',
	        stylesheet: 'StyleSheet',
	        atrule: 'Atrule',
	        atrulePrelude: function(options) {
	            return this.AtrulePrelude(options.atrule ? String(options.atrule) : null);
	        },
	        mediaQueryList: 'MediaQueryList',
	        mediaQuery: 'MediaQuery',
	        rule: 'Rule',
	        selectorList: 'SelectorList',
	        selector: 'Selector',
	        block: function() {
	            return this.Block(true);
	        },
	        declarationList: 'DeclarationList',
	        declaration: 'Declaration',
	        value: 'Value'
	    },
	    scope: scope,
	    atrule: atrule,
	    pseudo: pseudo,
	    node: node
	};

	var walker = {
	    node: node
	};

	function merge() {
	    var dest = {};

	    for (var i = 0; i < arguments.length; i++) {
	        var src = arguments[i];
	        for (var key in src) {
	            dest[key] = src[key];
	        }
	    }

	    return dest;
	}

	var syntax = create$5.create(
	    merge(
	        lexer,
	        parser,
	        walker
	    )
	);

	var lib = syntax;

	class Sheet {
		constructor(url, hooks) {

			if (hooks) {
				this.hooks = hooks;
			} else {
				this.hooks = {};
				this.hooks.onUrl = new Hook(this);
				this.hooks.onAtPage = new Hook(this);
				this.hooks.onAtMedia = new Hook(this);
				this.hooks.onRule = new Hook(this);
				this.hooks.onDeclaration = new Hook(this);
				this.hooks.onSelector = new Hook(this);
				this.hooks.onPseudoSelector = new Hook(this);

				this.hooks.onContent = new Hook(this);
				this.hooks.onImport = new Hook(this);

				this.hooks.beforeTreeParse = new Hook(this);
				this.hooks.beforeTreeWalk = new Hook(this);
				this.hooks.afterTreeWalk = new Hook(this);
			}

			try {
				this.url = new URL(url, window.location.href);
			} catch (e) {
				this.url = new URL(window.location.href);
			}
		}



		// parse
		async parse(text) {
			this.text = text;

			await this.hooks.beforeTreeParse.trigger(this.text, this);

			// send to csstree
			this.ast = lib.parse(this._text);

			await this.hooks.beforeTreeWalk.trigger(this.ast);

			// Replace urls
			this.replaceUrls(this.ast);

			// Scope
			this.id = UUID();
			// this.addScope(this.ast, this.uuid);

			// Replace IDs with data-id
			this.replaceIds(this.ast);

			this.imported = [];

			// Trigger Hooks
			this.urls(this.ast);
			this.rules(this.ast);
			this.atrules(this.ast);

			await this.hooks.afterTreeWalk.trigger(this.ast, this);

			// return ast
			return this.ast;
		}



		insertRule(rule) {
			let inserted = this.ast.children.appendData(rule);
			inserted.forEach((item) => {
				this.declarations(item);
			});
		}

		urls(ast) {
			lib.walk(ast, {
				visit: "Url",
				enter: (node, item, list) => {
					this.hooks.onUrl.trigger(node, item, list);
				}
			});
		}

		atrules(ast) {
			lib.walk(ast, {
				visit: "Atrule",
				enter: (node, item, list) => {
					const basename = lib.keyword(node.name).basename;

					if (basename === "page") {
						this.hooks.onAtPage.trigger(node, item, list);
						this.declarations(node, item, list);
					}

					if (basename === "media") {
						this.hooks.onAtMedia.trigger(node, item, list);
						this.declarations(node, item, list);
					}

					if (basename === "import") {
						this.hooks.onImport.trigger(node, item, list);
						this.imports(node, item, list);
					}
				}
			});
		}


		rules(ast) {
			lib.walk(ast, {
				visit: "Rule",
				enter: (ruleNode, ruleItem, rulelist) => {
					// console.log("rule", ruleNode);

					this.hooks.onRule.trigger(ruleNode, ruleItem, rulelist);
					this.declarations(ruleNode, ruleItem, rulelist);
					this.onSelector(ruleNode, ruleItem, rulelist);

				}
			});
		}

		declarations(ruleNode, ruleItem, rulelist) {
			lib.walk(ruleNode, {
				visit: "Declaration",
				enter: (declarationNode, dItem, dList) => {
					// console.log(declarationNode);

					this.hooks.onDeclaration.trigger(declarationNode, dItem, dList, {ruleNode, ruleItem, rulelist});

					if (declarationNode.property === "content") {
						lib.walk(declarationNode, {
							visit: "Function",
							enter: (funcNode, fItem, fList) => {
								this.hooks.onContent.trigger(funcNode, fItem, fList, {declarationNode, dItem, dList}, {ruleNode, ruleItem, rulelist});
							}
						});
					}

				}
			});
		}

		// add pseudo elements to parser
		onSelector(ruleNode, ruleItem, rulelist) {
			lib.walk(ruleNode, {
				visit: "Selector",
				enter: (selectNode, selectItem, selectList) => {
					// console.log(selectNode);
					this.hooks.onSelector.trigger(selectNode, selectItem, selectList, {ruleNode, ruleItem, rulelist});

					if (selectNode.children.forEach(node => {if (node.type === "PseudoElementSelector") {
						lib.walk(node, {
							visit: "PseudoElementSelector",
							enter: (pseudoNode, pItem, pList) => {
								this.hooks.onPseudoSelector.trigger(pseudoNode, pItem, pList, {selectNode, selectItem, selectList}, {ruleNode, ruleItem, rulelist});
							}
						});
					}}));
					// else {
					// 	console.log("dommage");
					// }

				}
			});
		}

		replaceUrls(ast) {
			lib.walk(ast, {
				visit: "Url",
				enter: (node, item, list) => {
					let content = node.value.value;
					if ((node.value.type === "Raw" && content.startsWith("data:")) || (node.value.type === "String" && (content.startsWith("\"data:") || content.startsWith("'data:")))) ; else {
						let href = content.replace(/["']/g, "");
						let url = new URL(href, this.url);
						node.value.value = url.toString();
					}
				}
			});
		}

		addScope(ast, id) {
			// Get all selector lists
			// add an id
			lib.walk(ast, {
				visit: "Selector",
				enter: (node, item, list) => {
					let children = node.children;
					children.prepend(children.createItem({
						type: "WhiteSpace",
						value: " "
					}));
					children.prepend(children.createItem({
						type: "IdSelector",
						name: id,
						loc: null,
						children: null
					}));
				}
			});
		}

		getNamedPageSelectors(ast) {
			let namedPageSelectors = {};
			lib.walk(ast, {
				visit: "Rule",
				enter: (node, item, list) => {
					lib.walk(node, {
						visit: "Declaration",
						enter: (declaration, dItem, dList) => {
							if (declaration.property === "page") {
								let value = declaration.value.children.first();
								let name = value.name;
								let selector = lib.generate(node.prelude);
								namedPageSelectors[name] = {
									name: name,
									selector: selector
								};

								// dList.remove(dItem);

								// Add in page break
								declaration.property = "break-before";
								value.type = "Identifier";
								value.name = "always";

							}
						}
					});
				}
			});
			return namedPageSelectors;
		}

		replaceIds(ast) {
			lib.walk(ast, {
				visit: "Rule",
				enter: (node, item, list) => {

					lib.walk(node, {
						visit: "IdSelector",
						enter: (idNode, idItem, idList) => {
							let name = idNode.name;
							idNode.flags = null;
							idNode.matcher = "=";
							idNode.name = {type: "Identifier", loc: null, name: "data-id"};
							idNode.type = "AttributeSelector";
							idNode.value = {type: "String", loc: null, value: `"${name}"`};
						}
					});
				}
			});
		}

		imports(node, item, list) {
			// console.log("import", node, item, list);
			let queries = [];
			lib.walk(node, {
				visit: "MediaQuery",
				enter: (mqNode, mqItem, mqList) => {
					lib.walk(mqNode, {
						visit: "Identifier",
						enter: (identNode, identItem, identList) => {
							queries.push(identNode.name);
						}
					});
				}
			});

			// Just basic media query support for now
			let shouldNotApply = queries.some((query, index) => {
				let q = query;
				if (q === "not") {
					q = queries[index + 1];
					return !(q === "screen" || q === "speech");
				} else {
					return (q === "screen" || q === "speech");
				}
			});

			if (shouldNotApply) {
				return;
			}

			lib.walk(node, {
				visit: "String",
				enter: (urlNode, urlItem, urlList) => {
					let href = urlNode.value.replace(/["']/g, "");
					let url = new URL(href, this.url);
					let value = url.toString();

					this.imported.push(value);

					// Remove the original
					list.remove(item);
				}
			});
		}

		set text(t) {
			this._text = t;
		}

		get text() {
			return this._text;
		}

		// generate string
		toString(ast) {
			return lib.generate(ast || this.ast);
		}
	}

	var baseStyles = `
:root {
	--pagedjs-width: 8.5in;
	--pagedjs-height: 11in;
	--pagedjs-width-right: 8.5in;
	--pagedjs-height-right: 11in;
	--pagedjs-width-left: 8.5in;
	--pagedjs-height-left: 11in;
	--pagedjs-pagebox-width: 8.5in;
	--pagedjs-pagebox-height: 11in;
	--pagedjs-margin-top: 1in;
	--pagedjs-margin-right: 1in;
	--pagedjs-margin-bottom: 1in;
	--pagedjs-margin-left: 1in;
	--pagedjs-padding-top: 0mm;
	--pagedjs-padding-right: 0mm;
	--pagedjs-padding-bottom: 0mm;
	--pagedjs-padding-left: 0mm;
	--pagedjs-border-top: 0mm;
	--pagedjs-border-right: 0mm;
	--pagedjs-border-bottom: 0mm;
	--pagedjs-border-left: 0mm;
	--pagedjs-bleed-top: 0mm;
	--pagedjs-bleed-right: 0mm;
	--pagedjs-bleed-bottom: 0mm;
	--pagedjs-bleed-left: 0mm;
	--pagedjs-bleed-right-top: 0mm;
	--pagedjs-bleed-right-right: 0mm;
	--pagedjs-bleed-right-bottom: 0mm;
	--pagedjs-bleed-right-left: 0mm;
	--pagedjs-bleed-left-top: 0mm;
	--pagedjs-bleed-left-right: 0mm;
	--pagedjs-bleed-left-bottom: 0mm;
	--pagedjs-bleed-left-left: 0mm;
	--pagedjs-crop-color: black;
	--pagedjs-crop-offset: 2mm;
	--pagedjs-crop-stroke: 1px;
	--pagedjs-cross-size: 5mm;
	--pagedjs-mark-cross-display: none;
	--pagedjs-mark-crop-display: none;
	--pagedjs-page-count: 0;
	--pagedjs-page-counter-increment: 1;
}

@page {
	size: letter;
	margin: 0;
}

.pagedjs_sheet {
	box-sizing: border-box;
	width: var(--pagedjs-width);
	height: var(--pagedjs-height);
	overflow: hidden;
	position: relative;
	display: grid;
	grid-template-columns: [bleed-left] var(--pagedjs-bleed-left) [sheet-center] calc(var(--pagedjs-width) - var(--pagedjs-bleed-left) - var(--pagedjs-bleed-right)) [bleed-right] var(--pagedjs-bleed-right);
	grid-template-rows: [bleed-top] var(--pagedjs-bleed-top) [sheet-middle] calc(var(--pagedjs-height) - var(--pagedjs-bleed-top) - var(--pagedjs-bleed-bottom)) [bleed-bottom] var(--pagedjs-bleed-bottom);
}

.pagedjs_right_page .pagedjs_sheet {
	width: var(--pagedjs-width-right);
	height: var(--pagedjs-height-right);
	grid-template-columns: [bleed-left] var(--pagedjs-bleed-right-left) [sheet-center] calc(var(--pagedjs-width) - var(--pagedjs-bleed-right-left) - var(--pagedjs-bleed-right-right)) [bleed-right] var(--pagedjs-bleed-right-right);
	grid-template-rows: [bleed-top] var(--pagedjs-bleed-right-top) [sheet-middle] calc(var(--pagedjs-height) - var(--pagedjs-bleed-right-top) - var(--pagedjs-bleed-right-bottom)) [bleed-bottom] var(--pagedjs-bleed-right-bottom);
}

.pagedjs_left_page .pagedjs_sheet {
	width: var(--pagedjs-width-left);
	height: var(--pagedjs-height-left);
	grid-template-columns: [bleed-left] var(--pagedjs-bleed-left-left) [sheet-center] calc(var(--pagedjs-width) - var(--pagedjs-bleed-left-left) - var(--pagedjs-bleed-left-right)) [bleed-right] var(--pagedjs-bleed-left-right);
	grid-template-rows: [bleed-top] var(--pagedjs-bleed-left-top) [sheet-middle] calc(var(--pagedjs-height) - var(--pagedjs-bleed-left-top) - var(--pagedjs-bleed-left-bottom)) [bleed-bottom] var(--pagedjs-bleed-left-bottom);
}

.pagedjs_bleed {
	display: flex;
	align-items: center;
	justify-content: center;
	flex-wrap: nowrap;
	overflow: hidden;
}

.pagedjs_bleed-top {
	grid-column: bleed-left / -1;
	grid-row: bleed-top;
	flex-direction: row;
}

.pagedjs_bleed-bottom {
	grid-column: bleed-left / -1;
	grid-row: bleed-bottom;
	flex-direction: row;
}

.pagedjs_bleed-left {
	grid-column: bleed-left;
	grid-row: bleed-top / -1;
	flex-direction: column;
}

.pagedjs_bleed-right {
	grid-column: bleed-right;
	grid-row: bleed-top / -1;
	flex-direction: column;
}

.pagedjs_marks-crop {
	display: var(--pagedjs-mark-crop-display);
	flex-grow: 0;
	flex-shrink: 0;
	z-index: 9999999999;
}

.pagedjs_bleed-top .pagedjs_marks-crop:nth-child(1),
.pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(1) {
	width: calc(var(--pagedjs-bleed-left) - var(--pagedjs-crop-stroke));
	border-right: var(--pagedjs-crop-stroke) solid var(--pagedjs-crop-color);
}

.pagedjs_right_page .pagedjs_bleed-top .pagedjs_marks-crop:nth-child(1),
.pagedjs_right_page .pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(1) {
	width: calc(var(--pagedjs-bleed-right-left) - var(--pagedjs-crop-stroke));
}

.pagedjs_left_page .pagedjs_bleed-top .pagedjs_marks-crop:nth-child(1),
.pagedjs_left_page .pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(1) {
	width: calc(var(--pagedjs-bleed-left-left) - var(--pagedjs-crop-stroke));
}

.pagedjs_bleed-top .pagedjs_marks-crop:nth-child(3),
.pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(3) {
	width: calc(var(--pagedjs-bleed-right) - var(--pagedjs-crop-stroke));
	border-left: var(--pagedjs-crop-stroke) solid var(--pagedjs-crop-color);
}

.pagedjs_right_page .pagedjs_bleed-top .pagedjs_marks-crop:nth-child(3),
.pagedjs_right_page .pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(3) {
	width: calc(var(--pagedjs-bleed-right-right) - var(--pagedjs-crop-stroke));
}

.pagedjs_left_page .pagedjs_bleed-top .pagedjs_marks-crop:nth-child(3),
.pagedjs_left_page .pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(3) {
	width: calc(var(--pagedjs-bleed-left-right) - var(--pagedjs-crop-stroke));
}

.pagedjs_bleed-top .pagedjs_marks-crop {
	align-self: flex-start;
	height: calc(var(--pagedjs-bleed-top) - var(--pagedjs-crop-offset));
}

.pagedjs_right_page .pagedjs_bleed-top .pagedjs_marks-crop {
	height: calc(var(--pagedjs-bleed-right-top) - var(--pagedjs-crop-offset));
}

.pagedjs_left_page .pagedjs_bleed-top .pagedjs_marks-crop {
	height: calc(var(--pagedjs-bleed-left-top) - var(--pagedjs-crop-offset));
}

.pagedjs_bleed-bottom .pagedjs_marks-crop {
	align-self: flex-end;
	height: calc(var(--pagedjs-bleed-bottom) - var(--pagedjs-crop-offset));
}

.pagedjs_right_page .pagedjs_bleed-bottom .pagedjs_marks-crop {
	height: calc(var(--pagedjs-bleed-right-bottom) - var(--pagedjs-crop-offset));
}

.pagedjs_left_page .pagedjs_bleed-bottom .pagedjs_marks-crop {
	height: calc(var(--pagedjs-bleed-left-bottom) - var(--pagedjs-crop-offset));
}

.pagedjs_bleed-left .pagedjs_marks-crop:nth-child(1),
.pagedjs_bleed-right .pagedjs_marks-crop:nth-child(1) {
	height: calc(var(--pagedjs-bleed-top) - var(--pagedjs-crop-stroke));
	border-bottom: var(--pagedjs-crop-stroke) solid var(--pagedjs-crop-color);
}

.pagedjs_right_page .pagedjs_bleed-left .pagedjs_marks-crop:nth-child(1),
.pagedjs_right_page .pagedjs_bleed-right .pagedjs_marks-crop:nth-child(1) {
	height: calc(var(--pagedjs-bleed-right-top) - var(--pagedjs-crop-stroke));
}

.pagedjs_left_page .pagedjs_bleed-left .pagedjs_marks-crop:nth-child(1),
.pagedjs_left_page .pagedjs_bleed-right .pagedjs_marks-crop:nth-child(1) {
	height: calc(var(--pagedjs-bleed-left-top) - var(--pagedjs-crop-stroke));
}

.pagedjs_bleed-left .pagedjs_marks-crop:nth-child(3),
.pagedjs_bleed-right .pagedjs_marks-crop:nth-child(3) {
	height: calc(var(--pagedjs-bleed-bottom) - var(--pagedjs-crop-stroke));
	border-top: var(--pagedjs-crop-stroke) solid var(--pagedjs-crop-color);
}

.pagedjs_right_page .pagedjs_bleed-left .pagedjs_marks-crop:nth-child(3),
.pagedjs_right_page .pagedjs_bleed-right .pagedjs_marks-crop:nth-child(3) {
	height: calc(var(--pagedjs-bleed-right-bottom) - var(--pagedjs-crop-stroke));
}

.pagedjs_left_page .pagedjs_bleed-left .pagedjs_marks-crop:nth-child(3),
.pagedjs_left_page .pagedjs_bleed-right .pagedjs_marks-crop:nth-child(3) {
	height: calc(var(--pagedjs-bleed-left-bottom) - var(--pagedjs-crop-stroke));
}

.pagedjs_bleed-left .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-left) - var(--pagedjs-crop-offset));
	align-self: flex-start;
}

.pagedjs_right_page .pagedjs_bleed-left .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-right-left) - var(--pagedjs-crop-offset));
}

.pagedjs_left_page .pagedjs_bleed-left .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-left-left) - var(--pagedjs-crop-offset));
}

.pagedjs_bleed-right .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-right) - var(--pagedjs-crop-offset));
	align-self: flex-end;
}

.pagedjs_right_page .pagedjs_bleed-right .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-right-right) - var(--pagedjs-crop-offset));
}

.pagedjs_left_page .pagedjs_bleed-right .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-left-right) - var(--pagedjs-crop-offset));
}

.pagedjs_marks-middle {
	display: flex;
	flex-grow: 1;
	flex-shrink: 0;
	align-items: center;
	justify-content: center;
}

.pagedjs_marks-cross {
	display: var(--pagedjs-mark-cross-display);
	background-image: url(data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz48IURPQ1RZUEUgc3ZnIFBVQkxJQyAiLS8vVzNDLy9EVEQgU1ZHIDEuMS8vRU4iICJodHRwOi8vd3d3LnczLm9yZy9HcmFwaGljcy9TVkcvMS4xL0RURC9zdmcxMS5kdGQiPjxzdmcgdmVyc2lvbj0iMS4xIiBpZD0iTGF5ZXJfMSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgeD0iMHB4IiB5PSIwcHgiIHdpZHRoPSIzMi41MzdweCIgaGVpZ2h0PSIzMi41MzdweCIgdmlld0JveD0iMC4xMDQgMC4xMDQgMzIuNTM3IDMyLjUzNyIgZW5hYmxlLWJhY2tncm91bmQ9Im5ldyAwLjEwNCAwLjEwNCAzMi41MzcgMzIuNTM3IiB4bWw6c3BhY2U9InByZXNlcnZlIj48cGF0aCBmaWxsPSJub25lIiBzdHJva2U9IiNGRkZGRkYiIHN0cm9rZS13aWR0aD0iMy4zODkzIiBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiIGQ9Ik0yOS45MzEsMTYuMzczYzAsNy40ODktNi4wNjgsMTMuNTYtMTMuNTU4LDEzLjU2Yy03LjQ4MywwLTEzLjU1Ny02LjA3Mi0xMy41NTctMTMuNTZjMC03LjQ4Niw2LjA3NC0xMy41NTQsMTMuNTU3LTEzLjU1NEMyMy44NjIsMi44MTksMjkuOTMxLDguODg3LDI5LjkzMSwxNi4zNzN6Ii8+PGxpbmUgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjRkZGRkZGIiBzdHJva2Utd2lkdGg9IjMuMzg5MyIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiB4MT0iMC4xMDQiIHkxPSIxNi4zNzMiIHgyPSIzMi42NDIiIHkyPSIxNi4zNzMiLz48bGluZSBmaWxsPSJub25lIiBzdHJva2U9IiNGRkZGRkYiIHN0cm9rZS13aWR0aD0iMy4zODkzIiBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiIHgxPSIxNi4zNzMiIHkxPSIwLjEwNCIgeDI9IjE2LjM3MyIgeTI9IjMyLjY0MiIvPjxwYXRoIGZpbGw9Im5vbmUiIHN0cm9rZT0iI0ZGRkZGRiIgc3Ryb2tlLXdpZHRoPSIzLjM4OTMiIHN0cm9rZS1taXRlcmxpbWl0PSIxMCIgZD0iTTI0LjUwOCwxNi4zNzNjMCw0LjQ5Ni0zLjYzOCw4LjEzNS04LjEzNSw4LjEzNWMtNC40OTEsMC04LjEzNS0zLjYzOC04LjEzNS04LjEzNWMwLTQuNDg5LDMuNjQ0LTguMTM1LDguMTM1LTguMTM1QzIwLjg2OSw4LjIzOSwyNC41MDgsMTEuODg0LDI0LjUwOCwxNi4zNzN6Ii8+PHBhdGggZmlsbD0ibm9uZSIgc3Ryb2tlPSIjMDAwMDAwIiBzdHJva2Utd2lkdGg9IjAuNjc3OCIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiBkPSJNMjkuOTMxLDE2LjM3M2MwLDcuNDg5LTYuMDY4LDEzLjU2LTEzLjU1OCwxMy41NmMtNy40ODMsMC0xMy41NTctNi4wNzItMTMuNTU3LTEzLjU2YzAtNy40ODYsNi4wNzQtMTMuNTU0LDEzLjU1Ny0xMy41NTRDMjMuODYyLDIuODE5LDI5LjkzMSw4Ljg4NywyOS45MzEsMTYuMzczeiIvPjxsaW5lIGZpbGw9Im5vbmUiIHN0cm9rZT0iIzAwMDAwMCIgc3Ryb2tlLXdpZHRoPSIwLjY3NzgiIHN0cm9rZS1taXRlcmxpbWl0PSIxMCIgeDE9IjAuMTA0IiB5MT0iMTYuMzczIiB4Mj0iMzIuNjQyIiB5Mj0iMTYuMzczIi8+PGxpbmUgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjMDAwMDAwIiBzdHJva2Utd2lkdGg9IjAuNjc3OCIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiB4MT0iMTYuMzczIiB5MT0iMC4xMDQiIHgyPSIxNi4zNzMiIHkyPSIzMi42NDIiLz48cGF0aCBkPSJNMjQuNTA4LDE2LjM3M2MwLDQuNDk2LTMuNjM4LDguMTM1LTguMTM1LDguMTM1Yy00LjQ5MSwwLTguMTM1LTMuNjM4LTguMTM1LTguMTM1YzAtNC40ODksMy42NDQtOC4xMzUsOC4xMzUtOC4xMzVDMjAuODY5LDguMjM5LDI0LjUwOCwxMS44ODQsMjQuNTA4LDE2LjM3MyIvPjxsaW5lIGZpbGw9Im5vbmUiIHN0cm9rZT0iI0ZGRkZGRiIgc3Ryb2tlLXdpZHRoPSIwLjY3NzgiIHN0cm9rZS1taXRlcmxpbWl0PSIxMCIgeDE9IjguMjM5IiB5MT0iMTYuMzczIiB4Mj0iMjQuNTA4IiB5Mj0iMTYuMzczIi8+PGxpbmUgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjRkZGRkZGIiBzdHJva2Utd2lkdGg9IjAuNjc3OCIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiB4MT0iMTYuMzczIiB5MT0iOC4yMzkiIHgyPSIxNi4zNzMiIHkyPSIyNC41MDgiLz48L3N2Zz4=);
  background-repeat: no-repeat;
  background-position: 50% 50%;
  background-size: var(--pagedjs-cross-size);

  z-index: 2147483647;
	width: var(--pagedjs-cross-size);
	height: var(--pagedjs-cross-size);
}

.pagedjs_pagebox {
	box-sizing: border-box;
	width: var(--pagedjs-pagebox-width);
	height: var(--pagedjs-pagebox-height);
	position: relative;
	display: grid;
	grid-template-columns: [left] var(--pagedjs-margin-left) [center] calc(var(--pagedjs-pagebox-width) - var(--pagedjs-margin-left) - var(--pagedjs-margin-right)) [right] var(--pagedjs-margin-right);
	grid-template-rows: [header] var(--pagedjs-margin-top) [page] calc(var(--pagedjs-pagebox-height) - var(--pagedjs-margin-top) - var(--pagedjs-margin-bottom)) [footer] var(--pagedjs-margin-bottom);
	grid-column: sheet-center;
	grid-row: sheet-middle;
}

.pagedjs_pagebox * {
	box-sizing: border-box;
}

.pagedjs_margin-top {
	width: calc(var(--pagedjs-pagebox-width) - var(--pagedjs-margin-left) - var(--pagedjs-margin-right));
	height: var(--pagedjs-margin-top);
	grid-column: center;
	grid-row: header;
	flex-wrap: nowrap;
	display: grid;
	grid-template-columns: repeat(3, 1fr);
	grid-template-rows: 100%;
}

.pagedjs_margin-top-left-corner-holder {
	width: var(--pagedjs-margin-left);
	height: var(--pagedjs-margin-top);
	display: flex;
	grid-column: left;
	grid-row: header;
}

.pagedjs_margin-top-right-corner-holder {
	width: var(--pagedjs-margin-right);
	height: var(--pagedjs-margin-top);
	display: flex;
	grid-column: right;
	grid-row: header;
}

.pagedjs_margin-top-left-corner {
	width: var(--pagedjs-margin-left);
}

.pagedjs_margin-top-right-corner {
	width: var(--pagedjs-margin-right);
}

.pagedjs_margin-right {
	height: calc(var(--pagedjs-pagebox-height) - var(--pagedjs-margin-top) - var(--pagedjs-margin-bottom));
	width: var(--pagedjs-margin-right);
	right: 0;
	grid-column: right;
	grid-row: page;
	display: grid;
	grid-template-rows: repeat(3, 33.3333%);
	grid-template-columns: 100%;
}

.pagedjs_margin-bottom {
	width: calc(var(--pagedjs-pagebox-width) - var(--pagedjs-margin-left) - var(--pagedjs-margin-right));
	height: var(--pagedjs-margin-bottom);
	grid-column: center;
	grid-row: footer;
	display: grid;
	grid-template-columns: repeat(3, 1fr);
	grid-template-rows: 100%;
}

.pagedjs_margin-bottom-left-corner-holder {
	width: var(--pagedjs-margin-left);
	height: var(--pagedjs-margin-bottom);
	display: flex;
	grid-column: left;
	grid-row: footer;
}

.pagedjs_margin-bottom-right-corner-holder {
	width: var(--pagedjs-margin-right);
	height: var(--pagedjs-margin-bottom);
	display: flex;
	grid-column: right;
	grid-row: footer;
}

.pagedjs_margin-bottom-left-corner {
	width: var(--pagedjs-margin-left);
}

.pagedjs_margin-bottom-right-corner {
	width: var(--pagedjs-margin-right);
}



.pagedjs_margin-left {
	height: calc(var(--pagedjs-pagebox-height) - var(--pagedjs-margin-top) - var(--pagedjs-margin-bottom));
	width: var(--pagedjs-margin-left);
	grid-column: left;
	grid-row: page;
	display: grid;
	grid-template-rows: repeat(3, 33.33333%);
	grid-template-columns: 100%;
}

.pagedjs_pages .pagedjs_pagebox .pagedjs_margin:not(.hasContent) {
	visibility: hidden;
}

.pagedjs_pagebox > .pagedjs_area {
	grid-column: center;
	grid-row: page;
	width: 100%;
	height: 100%;
	padding: var(--pagedjs-padding-top) var(--pagedjs-padding-right) var(--pagedjs-padding-bottom) var(--pagedjs-padding-left);
	border-top: var(--pagedjs-border-top);
	border-right: var(--pagedjs-border-right);
	border-bottom: var(--pagedjs-border-bottom);
	border-left: var(--pagedjs-border-left);
}

.pagedjs_pagebox > .pagedjs_area > .pagedjs_page_content {
	width: 100%;
	height: 100%;
	position: relative;
	column-fill: auto;
}

.pagedjs_page {
	counter-increment: page var(--pagedjs-page-counter-increment);
	width: var(--pagedjs-width);
	height: var(--pagedjs-height);
}

.pagedjs_page.pagedjs_right_page {
	width: var(--pagedjs-width-right);
	height: var(--pagedjs-height-right);
}

.pagedjs_page.pagedjs_left_page {
	width: var(--pagedjs-width-left);
	height: var(--pagedjs-height-left);
}

.pagedjs_pages {
	counter-reset: pages var(--pagedjs-page-count);
}

.pagedjs_pagebox .pagedjs_margin-top-left-corner,
.pagedjs_pagebox .pagedjs_margin-top-right-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-left-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-right-corner,
.pagedjs_pagebox .pagedjs_margin-top-left,
.pagedjs_pagebox .pagedjs_margin-top-right,
.pagedjs_pagebox .pagedjs_margin-bottom-left,
.pagedjs_pagebox .pagedjs_margin-bottom-right,
.pagedjs_pagebox .pagedjs_margin-top-center,
.pagedjs_pagebox .pagedjs_margin-bottom-center,
.pagedjs_pagebox .pagedjs_margin-top-center,
.pagedjs_pagebox .pagedjs_margin-bottom-center,
.pagedjs_margin-right-middle,
.pagedjs_margin-left-middle  {
	display: flex;
	align-items: center;
}

.pagedjs_margin-right-top,
.pagedjs_margin-left-top  {
	display: flex;
	align-items: flex-top;
}


.pagedjs_margin-right-bottom,
.pagedjs_margin-left-bottom  {
	display: flex;
	align-items: flex-end;
}



/*
.pagedjs_pagebox .pagedjs_margin-top-center,
.pagedjs_pagebox .pagedjs_margin-bottom-center {
	height: 100%;
	display: none;
	align-items: center;
	flex: 1 0 33%;
	margin: 0 auto;
}

.pagedjs_pagebox .pagedjs_margin-top-left-corner,
.pagedjs_pagebox .pagedjs_margin-top-right-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-right-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-left-corner {
	display: none;
	align-items: center;
}

.pagedjs_pagebox .pagedjs_margin-left-top,
.pagedjs_pagebox .pagedjs_margin-right-top {
	display: none;
	align-items: flex-start;
}

.pagedjs_pagebox .pagedjs_margin-right-middle,
.pagedjs_pagebox .pagedjs_margin-left-middle {
	display: none;
	align-items: center;
}

.pagedjs_pagebox .pagedjs_margin-left-bottom,
.pagedjs_pagebox .pagedjs_margin-right-bottom {
	display: none;
	align-items: flex-end;
}
*/

.pagedjs_pagebox .pagedjs_margin-top-left,
.pagedjs_pagebox .pagedjs_margin-top-right-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-left,
.pagedjs_pagebox .pagedjs_margin-bottom-right-corner { text-align: left; }

.pagedjs_pagebox .pagedjs_margin-top-left-corner,
.pagedjs_pagebox .pagedjs_margin-top-right,
.pagedjs_pagebox .pagedjs_margin-bottom-left-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-right { text-align: right; }

.pagedjs_pagebox .pagedjs_margin-top-center,
.pagedjs_pagebox .pagedjs_margin-bottom-center,
.pagedjs_pagebox .pagedjs_margin-left-top,
.pagedjs_pagebox .pagedjs_margin-left-middle,
.pagedjs_pagebox .pagedjs_margin-left-bottom,
.pagedjs_pagebox .pagedjs_margin-right-top,
.pagedjs_pagebox .pagedjs_margin-right-middle,
.pagedjs_pagebox .pagedjs_margin-right-bottom { text-align: center; }

.pagedjs_pages .pagedjs_margin .pagedjs_margin-content {
	width: 100%;
}

.pagedjs_pages .pagedjs_margin-left .pagedjs_margin-content::after,
.pagedjs_pages .pagedjs_margin-top .pagedjs_margin-content::after,
.pagedjs_pages .pagedjs_margin-right .pagedjs_margin-content::after,
.pagedjs_pages .pagedjs_margin-bottom .pagedjs_margin-content::after {
	display: block;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-to] {
	margin-bottom: unset;
	padding-bottom: unset;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-from] {
	text-indent: unset;
	margin-top: unset;
	padding-top: unset;
	initial-letter: unset;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-from] > *::first-letter,
.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-from]::first-letter {
	color: unset;
	font-size: unset;
	font-weight: unset;
	font-family: unset;
	color: unset;
	line-height: unset;
	float: unset;
	padding: unset;
	margin: unset;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-to]:after,
.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-to]::after {
	content: unset;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-from]:before,
.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-from]::before {
	content: unset;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div li[data-split-from]:first-of-type {
	list-style: none;
}

/*
[data-page]:not([data-split-from]),
[data-break-before="page"]:not([data-split-from]),
[data-break-before="always"]:not([data-split-from]),
[data-break-before="left"]:not([data-split-from]),
[data-break-before="right"]:not([data-split-from]),
[data-break-before="recto"]:not([data-split-from]),
[data-break-before="verso"]:not([data-split-from])
{
	break-before: column;
}

[data-page]:not([data-split-to]),
[data-break-after="page"]:not([data-split-to]),
[data-break-after="always"]:not([data-split-to]),
[data-break-after="left"]:not([data-split-to]),
[data-break-after="right"]:not([data-split-to]),
[data-break-after="recto"]:not([data-split-to]),
[data-break-after="verso"]:not([data-split-to])
{
	break-after: column;
}
*/

.pagedjs_clear-after::after {
	content: none !important;
}

[data-align-last-split-element='justify'] {
	text-align-last: justify;
}


@media print {
	html {
		width: 100%;
		height: 100%;
	}
	body {
		margin: 0;
		padding: 0;
		width: 100% !important;
		height: 100% !important;
		min-width: 100%;
		max-width: 100%;
		min-height: 100%;
		max-height: 100%;
	}
	.pagedjs_pages {
		width: auto;
		display: block !important;
		transform: none !important;
		height: 100% !important;
		min-height: 100%;
		max-height: 100%;
		overflow: visible;
	}
	.pagedjs_page {
		margin: 0;
		padding: 0;
		max-height: 100%;
		min-height: 100%;
		height: 100% !important;
		page-break-after: always;
		break-after: page;
	}
	.pagedjs_sheet {
		margin: 0;
		padding: 0;
		max-height: 100%;
		min-height: 100%;
		height: 100% !important;
	}
}
`;

	async function request(url, options={}) {
		return new Promise(function(resolve, reject) {
			let request = new XMLHttpRequest();

			request.open(options.method || "get", url, true);

			for (let i in options.headers) {
				request.setRequestHeader(i, options.headers[i]);
			}

			request.withCredentials = options.credentials === "include";

			request.onload = () => {
				// Chrome returns a status code of 0 for local files
				const status = request.status === 0 && url.startsWith("file://") ? 200 : request.status;
				resolve(new Response(request.responseText, {status}));
			};

			request.onerror = reject;

			request.send(options.body || null);
		});
	}

	class Polisher {
		constructor(setup) {
			this.sheets = [];
			this.inserted = [];

			this.hooks = {};
			this.hooks.onUrl = new Hook(this);
			this.hooks.onAtPage = new Hook(this);
			this.hooks.onAtMedia = new Hook(this);
			this.hooks.onRule = new Hook(this);
			this.hooks.onDeclaration = new Hook(this);
			this.hooks.onContent = new Hook(this);
			this.hooks.onSelector = new Hook(this);
			this.hooks.onPseudoSelector = new Hook(this);

			this.hooks.onImport = new Hook(this);

			this.hooks.beforeTreeParse = new Hook(this);
			this.hooks.beforeTreeWalk = new Hook(this);
			this.hooks.afterTreeWalk = new Hook(this);

			if (setup !== false) {
				this.setup();
			}
		}

		setup() {
			this.base = this.insert(baseStyles);
			this.styleEl = document.createElement("style");
			document.head.appendChild(this.styleEl);
			this.styleSheet = this.styleEl.sheet;
			return this.styleSheet;
		}

		async add() {
			let fetched = [];
			let urls = [];

			for (var i = 0; i < arguments.length; i++) {
				let f;

				if (typeof arguments[i] === "object") {
					for (let url in arguments[i]) {
						let obj = arguments[i];
						f = new Promise(function(resolve, reject) {
							urls.push(url);
							resolve(obj[url]);
						});
					}
				} else {
					urls.push(arguments[i]);
					f = request(arguments[i]).then((response) => {
						return response.text();
					});
				}


				fetched.push(f);
			}

			return await Promise.all(fetched)
				.then(async (originals) => {
					let text = "";
					for (let index = 0; index < originals.length; index++) {
						text = await this.convertViaSheet(originals[index], urls[index]);
						this.insert(text);
					}
					return text;
				});
		}

		async convertViaSheet(cssStr, href) {
			let sheet = new Sheet(href, this.hooks);
			await sheet.parse(cssStr);

			// Insert the imported sheets first
			for (let url of sheet.imported) {
				let str = await request(url).then((response) => {
					return response.text();
				});
				let text = await this.convertViaSheet(str, url);
				this.insert(text);
			}

			this.sheets.push(sheet);

			if (typeof sheet.width !== "undefined") {
				this.width = sheet.width;
			}
			if (typeof sheet.height !== "undefined") {
				this.height = sheet.height;
			}
			if (typeof sheet.orientation !== "undefined") {
				this.orientation = sheet.orientation;
			}
			return sheet.toString();
		}

		insert(text){
			let head = document.querySelector("head");
			let style = document.createElement("style");
			style.type = "text/css";
			style.setAttribute("data-pagedjs-inserted-styles", "true");

			style.appendChild(document.createTextNode(text));

			head.appendChild(style);

			this.inserted.push(style);
			return style;
		}

		destroy() {
			this.styleEl.remove();
			this.inserted.forEach((s) => {
				s.remove();
			});
			this.sheets = [];
		}
	}

	class Handler {
		constructor(chunker, polisher, caller) {
			let hooks = Object.assign({}, chunker && chunker.hooks, polisher && polisher.hooks, caller && caller.hooks);
			this.chunker = chunker;
			this.polisher = polisher;
			this.caller = caller;

			for (let name in hooks) {
				if (name in this) {
					let hook = hooks[name];
					hook.register(this[name].bind(this));
				}
			}
		}
	}

	eventEmitter(Handler.prototype);

	// https://www.w3.org/TR/css3-page/#page-size-prop

	var pageSizes = {
		"A0": {
			width: {
				value: 841,
				unit: "mm"
			},
			height: {
				value: 1189,
				unit: "mm"
			}
		},
		"A1": {
			width: {
				value: 594,
				unit: "mm"
			},
			height: {
				value: 841,
				unit: "mm"
			}
		},
		"A2": {
			width: {
				value: 420,
				unit: "mm"
			},
			height: {
				value: 594,
				unit: "mm"
			}
		},
		"A3": {
			width: {
				value: 297,
				unit: "mm"
			},
			height: {
				value: 420,
				unit: "mm"
			}
		},
		"A4": {
			width: {
				value: 210,
				unit: "mm"
			},
			height: {
				value: 297,
				unit: "mm"
			}
		},
		"A5": {
			width: {
				value: 148,
				unit: "mm"
			},
			height: {
				value: 210,
				unit: "mm"
			}
		},
		"A6": {
			width: {
				value: 105,
				unit: "mm"
			},
			height: {
				value: 148,
				unit: "mm"
			}
		},
		"A7": {
			width: {
				value: 74,
				unit: "mm"
			},
			height: {
				value: 105,
				unit: "mm"
			}
		},
		"A8": {
			width: {
				value: 52,
				unit: "mm"
			},
			height: {
				value: 74,
				unit: "mm"
			}
		},
		"A9": {
			width: {
				value: 37,
				unit: "mm"
			},
			height: {
				value: 52,
				unit: "mm"
			}
		},
		"A10": {
			width: {
				value: 26,
				unit: "mm"
			},
			height: {
				value: 37,
				unit: "mm"
			}
		},
		"B4": {
			width: {
				value: 250,
				unit: "mm"
			},
			height: {
				value: 353,
				unit: "mm"
			}
		},
		"B5": {
			width: {
				value: 176,
				unit: "mm"
			},
			height: {
				value: 250,
				unit: "mm"
			}
		},
		"letter": {
			width: {
				value: 8.5,
				unit: "in"
			},
			height: {
				value: 11,
				unit: "in"
			}
		},
		"legal": {
			width: {
				value: 8.5,
				unit: "in"
			},
			height: {
				value: 14,
				unit: "in"
			}
		},
		"ledger": {
			width: {
				value: 11,
				unit: "in"
			},
			height: {
				value: 17,
				unit: "in"
			}
		}
	};

	class AtPage extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.pages = {};

			this.width = undefined;
			this.height = undefined;
			this.orientation = undefined;
			this.marginalia = {};
		}

		pageModel(selector) {
			return {
				selector: selector,
				name: undefined,
				psuedo: undefined,
				nth: undefined,
				marginalia: {},
				width: undefined,
				height: undefined,
				orientation: undefined,
				margin: {
					top: {},
					right: {},
					left: {},
					bottom: {}
				},
				padding: {
					top: {},
					right: {},
					left: {},
					bottom: {}
				},
				border: {
					top: {},
					right: {},
					left: {},
					bottom: {}
				},
				backgroundOrigin: undefined,
				block: {},
				marks: undefined
			};
		}

		// Find and Remove @page rules
		onAtPage(node, item, list) {
			let page, marginalia;
			let selector = "";
			let named, psuedo, nth;
			let needsMerge = false;

			if (node.prelude) {
				named = this.getTypeSelector(node);
				psuedo = this.getPsuedoSelector(node);
				nth = this.getNthSelector(node);
				selector = lib.generate(node.prelude);
			} else {
				selector = "*";
			}

			if (selector in this.pages) {
				// this.pages[selector] = Object.assign(this.pages[selector], page);
				// console.log("after", selector, this.pages[selector]);

				// this.pages[selector].added = false;
				page = this.pages[selector];
				marginalia = this.replaceMarginalia(node);
				needsMerge = true;
			} else {
				page = this.pageModel(selector);
				marginalia = this.replaceMarginalia(node);
				this.pages[selector] = page;
			}

			page.name = named;
			page.psuedo = psuedo;
			page.nth = nth;

			if (needsMerge) {
				page.marginalia = Object.assign(page.marginalia, marginalia);
			} else {
				page.marginalia = marginalia;
			}

			let declarations = this.replaceDeclarations(node);

			if (declarations.size) {
				page.size = declarations.size;
				page.width = declarations.size.width;
				page.height = declarations.size.height;
				page.orientation = declarations.size.orientation;
				page.format = declarations.size.format;
			}

			if (declarations.bleed && declarations.bleed[0] != "auto") {
				switch (declarations.bleed.length) {
					case 4: // top right bottom left
						page.bleed = {
							top: declarations.bleed[0],
							right: declarations.bleed[1],
							bottom: declarations.bleed[2],
							left: declarations.bleed[3]
						};
						break;
					case 3: // top right bottom right
						page.bleed = {
							top: declarations.bleed[0],
							right: declarations.bleed[1],
							bottom: declarations.bleed[2],
							left: declarations.bleed[1]
						};
						break;
					case 2: // top right top right
						page.bleed = {
							top: declarations.bleed[0],
							right: declarations.bleed[1],
							bottom: declarations.bleed[0],
							left: declarations.bleed[1]
						};
						break;
					default:
						page.bleed = {
							top: declarations.bleed[0],
							right: declarations.bleed[0],
							bottom: declarations.bleed[0],
							left: declarations.bleed[0]
						};
				}
			}

			if (declarations.marks) {
				if (!declarations.bleed || declarations.bleed && declarations.bleed[0] === "auto") {
					// Spec say 6pt, but needs more space for marks
					page.bleed = {
						top: { value: 6, unit: "mm" },
						right: { value: 6, unit: "mm" },
						bottom: { value: 6, unit: "mm" },
						left: { value: 6, unit: "mm" }
					};
				}

				page.marks = declarations.marks;
			}

			if (declarations.margin) {
				page.margin = declarations.margin;
			}
			if (declarations.padding) {
				page.padding = declarations.padding;
			}

			if (declarations.border) {
				page.border = declarations.border;
			}

			if (declarations.marks) {
				page.marks = declarations.marks;
			}

			if (needsMerge) {
				page.block.children.appendList(node.block.children);
			} else {
				page.block = node.block;
			}

			// Remove the rule
			list.remove(item);
		}

		/* Handled in breaks */
		/*
		afterParsed(parsed) {
			for (let b in this.named) {
				// Find elements
				let elements = parsed.querySelectorAll(b);
				// Add break data
				for (var i = 0; i < elements.length; i++) {
					elements[i].setAttribute("data-page", this.named[b]);
				}
			}
		}
		*/

		afterTreeWalk(ast, sheet) {
			this.addPageClasses(this.pages, ast, sheet);

			if ("*" in this.pages) {
				let width = this.pages["*"].width;
				let height = this.pages["*"].height;
				let format = this.pages["*"].format;
				let orientation = this.pages["*"].orientation;
				let bleed = this.pages["*"].bleed;
				let marks = this.pages["*"].marks;
				let bleedverso = undefined;
				let bleedrecto = undefined;

				if (":left" in this.pages) {
					bleedverso = this.pages[":left"].bleed;
				}

				if (":right" in this.pages) {
					bleedrecto = this.pages[":right"].bleed;
				}

				if ((width && height) &&
					(this.width !== width || this.height !== height)) {
					this.width = width;
					this.height = height;
					this.format = format;
					this.orientation = orientation;

					this.addRootVars(ast, width, height, orientation, bleed, bleedrecto, bleedverso, marks);
					this.addRootPage(ast, this.pages["*"].size, bleed, bleedrecto, bleedverso);

					this.emit("size", { width, height, orientation, format, bleed });
					this.emit("atpages", this.pages);
				}

			}
		}

		getTypeSelector(ast) {
			// Find page name
			let name;

			lib.walk(ast, {
				visit: "TypeSelector",
				enter: (node, item, list) => {
					name = node.name;
				}
			});

			return name;
		}

		getPsuedoSelector(ast) {
			// Find if it has :left & :right & :black & :first
			let name;
			lib.walk(ast, {
				visit: "PseudoClassSelector",
				enter: (node, item, list) => {
					if (node.name !== "nth") {
						name = node.name;
					}
				}
			});

			return name;
		}

		getNthSelector(ast) {
			// Find if it has :nth
			let nth;
			lib.walk(ast, {
				visit: "PseudoClassSelector",
				enter: (node, item, list) => {
					if (node.name === "nth" && node.children) {
						let raw = node.children.first();
						nth = raw.value;
					}
				}
			});

			return nth;
		}

		replaceMarginalia(ast) {
			let parsed = {};

			lib.walk(ast.block, {
				visit: "Atrule",
				enter: (node, item, list) => {
					let name = node.name;
					if (name === "top") {
						name = "top-center";
					}
					if (name === "right") {
						name = "right-middle";
					}
					if (name === "left") {
						name = "left-middle";
					}
					if (name === "bottom") {
						name = "bottom-center";
					}
					parsed[name] = node.block;
					list.remove(item);
				}
			});

			return parsed;
		}

		replaceDeclarations(ast) {
			let parsed = {};

			lib.walk(ast.block, {
				visit: "Declaration",
				enter: (declaration, dItem, dList) => {
					let prop = lib.property(declaration.property).name;
					// let value = declaration.value;

					if (prop === "marks") {
						parsed.marks = [];
						lib.walk(declaration, {
							visit: "Identifier",
							enter: (ident) => {
								parsed.marks.push(ident.name);
							}
						});
						dList.remove(dItem);
					} else if (prop === "margin") {
						parsed.margin = this.getMargins(declaration);
						dList.remove(dItem);

					} else if (prop.indexOf("margin-") === 0) {
						let m = prop.substring("margin-".length);
						if (!parsed.margin) {
							parsed.margin = {
								top: {},
								right: {},
								left: {},
								bottom: {}
							};
						}
						parsed.margin[m] = declaration.value.children.first();
						dList.remove(dItem);

					} else if (prop === "padding") {
						parsed.padding = this.getPaddings(declaration.value);
						dList.remove(dItem);

					} else if (prop.indexOf("padding-") === 0) {
						let p = prop.substring("padding-".length);
						if (!parsed.padding) {
							parsed.padding = {
								top: {},
								right: {},
								left: {},
								bottom: {}
							};
						}
						parsed.padding[p] = declaration.value.children.first();
						dList.remove(dItem);
					}

					else if (prop === "border") {
						if (!parsed.border) {
							parsed.border = {
								top: {},
								right: {},
								left: {},
								bottom: {}
							};
						}
						parsed.border.top = lib.generate(declaration.value);
						parsed.border.right = lib.generate(declaration.value);
						parsed.border.left = lib.generate(declaration.value);
						parsed.border.bottom = lib.generate(declaration.value);

						dList.remove(dItem);

					}

					else if (prop.indexOf("border-") === 0) {
						if (!parsed.border) {
							parsed.border = {
								top: {},
								right: {},
								left: {},
								bottom: {}
							};
						}
						let p = prop.substring("border-".length);

						parsed.border[p] = lib.generate(declaration.value);
						dList.remove(dItem);

					}

					else if (prop === "size") {
						parsed.size = this.getSize(declaration);
						dList.remove(dItem);
					} else if (prop === "bleed") {
						parsed.bleed = [];

						lib.walk(declaration, {
							enter: (subNode) => {
								switch (subNode.type) {
									case "String": // bleed: "auto"
										if (subNode.value.indexOf("auto") > -1) {
											parsed.bleed.push("auto");
										}
										break;
									case "Dimension": // bleed: 1in 2in, bleed: 20px ect.
										parsed.bleed.push({
											value: subNode.value,
											unit: subNode.unit
										});
										break;
									case "Number":
										parsed.bleed.push({
											value: subNode.value,
											unit: "px"
										});
										break;
									// ignore
								}

							}
						});

						dList.remove(dItem);
					}

				}
			});

			return parsed;

		}
		getSize(declaration) {
			let width, height, orientation, format;

			// Get size: Xmm Ymm
			lib.walk(declaration, {
				visit: "Dimension",
				enter: (node, item, list) => {
					let { value, unit } = node;
					if (typeof width === "undefined") {
						width = { value, unit };
					} else if (typeof height === "undefined") {
						height = { value, unit };
					}
				}
			});

			// Get size: "A4"
			lib.walk(declaration, {
				visit: "String",
				enter: (node, item, list) => {
					let name = node.value.replace(/["|']/g, "");
					let s = pageSizes[name];
					if (s) {
						width = s.width;
						height = s.height;
					}
				}
			});

			// Get Format or Landscape or Portrait
			lib.walk(declaration, {
				visit: "Identifier",
				enter: (node, item, list) => {
					let name = node.name;
					if (name === "landscape" || name === "portrait") {
						orientation = node.name;
					} else if (name !== "auto") {
						let s = pageSizes[name];
						if (s) {
							width = s.width;
							height = s.height;
						}
						format = name;
					}
				}
			});

			return {
				width,
				height,
				orientation,
				format
			};
		}

		getMargins(declaration) {
			let margins = [];
			let margin = {
				top: {},
				right: {},
				left: {},
				bottom: {}
			};

			lib.walk(declaration, {
				enter: (node) => {
					switch (node.type) {
						case "Dimension": // margin: 1in 2in, margin: 20px, etc...
							margins.push(node);
							break;
						case "Number": // margin: 0
							margins.push({value: node.value, unit: "px"});
							break;
						// ignore
					}
				}
			});

			if (margins.length === 1) {
				for (let m in margin) {
					margin[m] = margins[0];
				}
			} else if (margins.length === 2) {
				margin.top = margins[0];
				margin.right = margins[1];
				margin.bottom = margins[0];
				margin.left = margins[1];
			} else if (margins.length === 3) {
				margin.top = margins[0];
				margin.right = margins[1];
				margin.bottom = margins[2];
				margin.left = margins[1];
			} else if (margins.length === 4) {
				margin.top = margins[0];
				margin.right = margins[1];
				margin.bottom = margins[2];
				margin.left = margins[3];
			}

			return margin;
		}

		getPaddings(declaration) {
			let paddings = [];
			let padding = {
				top: {},
				right: {},
				left: {},
				bottom: {}
			};

			lib.walk(declaration, {
				enter: (node) => {
					switch (node.type) {
						case "Dimension": // padding: 1in 2in, padding: 20px, etc...
							paddings.push(node);
							break;
						case "Number": // padding: 0
							paddings.push({value: node.value, unit: "px"});
							break;
						// ignore
					}
				}
			});
			if (paddings.length === 1) {
				for (let p in padding) {
					padding[p] = paddings[0];
				}
			} else if (paddings.length === 2) {

				padding.top = paddings[0];
				padding.right = paddings[1];
				padding.bottom = paddings[0];
				padding.left = paddings[1];
			} else if (paddings.length === 3) {

				padding.top = paddings[0];
				padding.right = paddings[1];
				padding.bottom = paddings[2];
				padding.left = paddings[1];
			} else if (paddings.length === 4) {

				padding.top = paddings[0];
				padding.right = paddings[1];
				padding.bottom = paddings[2];
				padding.left = paddings[3];
			}
			return padding;
		}

		// get values for the border on the @page to pass them to the element with the .pagedjs_area class
		getBorders(declaration) {
			let border = {
				top: {},
				right: {},
				left: {},
				bottom: {}
			};

			if (declaration.prop == "border") {
				border.top = lib.generate(declaration.value);
				border.right = lib.generate(declaration.value);
				border.bottom = lib.generate(declaration.value);
				border.left = lib.generate(declaration.value);

			}
			else if (declaration.prop == "border-top") {
				border.top = lib.generate(declaration.value);
			}
			else if (declaration.prop == "border-right") {
				border.right = lib.generate(declaration.value);

			}
			else if (declaration.prop == "border-bottom") {
				border.bottom = lib.generate(declaration.value);

			}
			else if (declaration.prop == "border-left") {
				border.left = lib.generate(declaration.value);
			}

			return border;
		}


		addPageClasses(pages, ast, sheet) {
			// First add * page
			if ("*" in pages) {
				let p = this.createPage(pages["*"], ast.children, sheet);
				sheet.insertRule(p);
			}
			// Add :left & :right
			if (":left" in pages) {
				let left = this.createPage(pages[":left"], ast.children, sheet);
				sheet.insertRule(left);
			}
			if (":right" in pages) {
				let right = this.createPage(pages[":right"], ast.children, sheet);
				sheet.insertRule(right);
			}
			// Add :first & :blank
			if (":first" in pages) {
				let first = this.createPage(pages[":first"], ast.children, sheet);
				sheet.insertRule(first);
			}
			if (":blank" in pages) {
				let blank = this.createPage(pages[":blank"], ast.children, sheet);
				sheet.insertRule(blank);
			}
			// Add nth pages
			for (let pg in pages) {
				if (pages[pg].nth) {
					let nth = this.createPage(pages[pg], ast.children, sheet);
					sheet.insertRule(nth);
				}
			}

			// Add named pages
			for (let pg in pages) {
				if (pages[pg].name) {
					let named = this.createPage(pages[pg], ast.children, sheet);
					sheet.insertRule(named);
				}
			}

		}

		createPage(page, ruleList, sheet) {

			let selectors = this.selectorsForPage(page);
			let children = page.block.children.copy();
			let block = {
				type: "Block",
				loc: 0,
				children: children
			};


			let rule = this.createRule(selectors, block);

			this.addMarginVars(page.margin, children, children.first());
			this.addPaddingVars(page.padding, children, children.first());
			this.addBorderVars(page.border, children, children.first());


			if (page.width) {
				this.addDimensions(page.width, page.height, page.orientation, children, children.first());
			}

			if (page.marginalia) {
				this.addMarginaliaStyles(page, ruleList, rule, sheet);
				this.addMarginaliaContent(page, ruleList, rule, sheet);
			}
			return rule;
		}

		addMarginVars(margin, list, item) {
			// variables for margins
			for (let m in margin) {
				if (typeof margin[m].value !== "undefined") {
					let value = margin[m].value + (margin[m].unit || "");
					let mVar = list.createItem({
						type: "Declaration",
						property: "--pagedjs-margin-" + m,
						value: {
							type: "Raw",
							value: value
						}
					});
					list.append(mVar, item);

				}
			}
		}

		addPaddingVars(padding, list, item) {
			// variables for padding
			for (let p in padding) {

				if (typeof padding[p].value !== "undefined") {
					let value = padding[p].value + (padding[p].unit || "");
					let pVar = list.createItem({
						type: "Declaration",
						property: "--pagedjs-padding-" + p,
						value: {
							type: "Raw",
							value: value
						}
					});

					list.append(pVar, item);
				}

			}
		}

		addBorderVars(border, list, item) {
			// variables for borders
			for (let b in border) {
				if (typeof border[b] !== "undefined") {
					let value = border[b];
					let bVar = list.createItem({
						type: "Declaration",
						property: "--pagedjs-border-" + b,
						value: {
							type: "Raw",
							value: value
						}
					});
					list.append(bVar, item);
				}

			}
		}

		addDimensions(width, height, orientation, list, item) {
			let widthString, heightString;

			widthString = CSSValueToString(width);
			heightString = CSSValueToString(height);

			if (orientation && orientation !== "portrait") {
				// reverse for orientation
				[widthString, heightString] = [heightString, widthString];
			}

			// width variable
			let wVar = this.createVariable("--pagedjs-pagebox-width", widthString);
			list.appendData(wVar);

			// height variable
			let hVar = this.createVariable("--pagedjs-pagebox-height", heightString);
			list.appendData(hVar);

			// let w = this.createDimension("width", width);
			// let h = this.createDimension("height", height);
			// list.appendData(w);
			// list.appendData(h);
		}

		addMarginaliaStyles(page, list, item, sheet) {
			for (let loc in page.marginalia) {
				let block = lib.clone(page.marginalia[loc]);
				let hasContent = false;

				if (block.children.isEmpty()) {
					continue;
				}

				lib.walk(block, {
					visit: "Declaration",
					enter: (node, item, list) => {
						if (node.property === "content") {
							if (node.value.children && node.value.children.first().name === "none") {
								hasContent = false;
							} else {
								hasContent = true;
							}
							list.remove(item);
						}
						if (node.property === "vertical-align") {
							lib.walk(node, {
								visit: "Identifier",
								enter: (identNode, identItem, identlist) => {
									let name = identNode.name;
									if (name === "top") {
										identNode.name = "flex-start";
									} else if (name === "middle") {
										identNode.name = "center";
									} else if (name === "bottom") {
										identNode.name = "flex-end";
									}
								}
							});
							node.property = "align-items";
						}

						if (node.property === "width" &&
							(loc === "top-left" ||
								loc === "top-center" ||
								loc === "top-right" ||
								loc === "bottom-left" ||
								loc === "bottom-center" ||
								loc === "bottom-right")) {
							let c = lib.clone(node);
							c.property = "max-width";
							list.appendData(c);
						}

						if (node.property === "height" &&
							(loc === "left-top" ||
								loc === "left-middle" ||
								loc === "left-bottom" ||
								loc === "right-top" ||
								loc === "right-middle" ||
								loc === "right-bottom")) {
							let c = lib.clone(node);
							c.property = "max-height";
							list.appendData(c);
						}
					}
				});

				let marginSelectors = this.selectorsForPageMargin(page, loc);
				let marginRule = this.createRule(marginSelectors, block);

				list.appendData(marginRule);

				let sel = lib.generate({
					type: "Selector",
					children: marginSelectors
				});

				this.marginalia[sel] = {
					page: page,
					selector: sel,
					block: page.marginalia[loc],
					hasContent: hasContent
				};

			}
		}

		addMarginaliaContent(page, list, item, sheet) {
			let displayNone;
			// Just content
			for (let loc in page.marginalia) {
				let content = lib.clone(page.marginalia[loc]);
				lib.walk(content, {
					visit: "Declaration",
					enter: (node, item, list) => {
						if (node.property !== "content") {
							list.remove(item);
						}

						if (node.value.children && node.value.children.first().name === "none") {
							displayNone = true;
						}
					}
				});

				if (content.children.isEmpty()) {
					continue;
				}

				let displaySelectors = this.selectorsForPageMargin(page, loc);
				let displayDeclaration;

				displaySelectors.insertData({
					type: "Combinator",
					name: ">"
				});

				displaySelectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_margin-content"
				});

				displaySelectors.insertData({
					type: "Combinator",
					name: ">"
				});

				displaySelectors.insertData({
					type: "TypeSelector",
					name: "*"
				});

				if (displayNone) {
					displayDeclaration = this.createDeclaration("display", "none");
				} else {
					displayDeclaration = this.createDeclaration("display", "block");
				}

				let displayRule = this.createRule(displaySelectors, [displayDeclaration]);
				sheet.insertRule(displayRule);

				// insert content rule
				let contentSelectors = this.selectorsForPageMargin(page, loc);

				contentSelectors.insertData({
					type: "Combinator",
					name: ">"
				});

				contentSelectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_margin-content"
				});

				contentSelectors.insertData({
					type: "PseudoElementSelector",
					name: "after",
					children: null
				});

				let contentRule = this.createRule(contentSelectors, content);
				sheet.insertRule(contentRule);
			}
		}

		addRootVars(ast, width, height, orientation, bleed, bleedrecto, bleedverso, marks) {
			let rules = [];
			let selectors = new lib.List();
			selectors.insertData({
				type: "PseudoClassSelector",
				name: "root",
				children: null
			});

			let widthString, heightString;
			let widthStringRight, heightStringRight;
			let widthStringLeft, heightStringLeft;

			if (!bleed) {
				widthString = CSSValueToString(width);
				heightString = CSSValueToString(height);
				widthStringRight = CSSValueToString(width);
				heightStringRight = CSSValueToString(height);
				widthStringLeft = CSSValueToString(width);
				heightStringLeft = CSSValueToString(height);
			} else {
				widthString = `calc( ${CSSValueToString(width)} + ${CSSValueToString(bleed.left)} + ${CSSValueToString(bleed.right)} )`;
				heightString = `calc( ${CSSValueToString(height)} + ${CSSValueToString(bleed.top)} + ${CSSValueToString(bleed.bottom)} )`;

				widthStringRight = `calc( ${CSSValueToString(width)} + ${CSSValueToString(bleed.left)} + ${CSSValueToString(bleed.right)} )`;
				heightStringRight = `calc( ${CSSValueToString(height)} + ${CSSValueToString(bleed.top)} + ${CSSValueToString(bleed.bottom)} )`;

				widthStringLeft = `calc( ${CSSValueToString(width)} + ${CSSValueToString(bleed.left)} + ${CSSValueToString(bleed.right)} )`;
				heightStringLeft = `calc( ${CSSValueToString(height)} + ${CSSValueToString(bleed.top)} + ${CSSValueToString(bleed.bottom)} )`;

				let bleedTop = this.createVariable("--pagedjs-bleed-top", CSSValueToString(bleed.top));
				let bleedRight = this.createVariable("--pagedjs-bleed-right", CSSValueToString(bleed.right));
				let bleedBottom = this.createVariable("--pagedjs-bleed-bottom", CSSValueToString(bleed.bottom));
				let bleedLeft = this.createVariable("--pagedjs-bleed-left", CSSValueToString(bleed.left));

				let bleedTopRecto = this.createVariable("--pagedjs-bleed-right-top", CSSValueToString(bleed.top));
				let bleedRightRecto = this.createVariable("--pagedjs-bleed-right-right", CSSValueToString(bleed.right));
				let bleedBottomRecto = this.createVariable("--pagedjs-bleed-right-bottom", CSSValueToString(bleed.bottom));
				let bleedLeftRecto = this.createVariable("--pagedjs-bleed-right-left", CSSValueToString(bleed.left));

				let bleedTopVerso = this.createVariable("--pagedjs-bleed-left-top", CSSValueToString(bleed.top));
				let bleedRightVerso = this.createVariable("--pagedjs-bleed-left-right", CSSValueToString(bleed.right));
				let bleedBottomVerso = this.createVariable("--pagedjs-bleed-left-bottom", CSSValueToString(bleed.bottom));
				let bleedLeftVerso = this.createVariable("--pagedjs-bleed-left-left", CSSValueToString(bleed.left));

				if (bleedrecto) {
					bleedTopRecto = this.createVariable("--pagedjs-bleed-right-top", CSSValueToString(bleedrecto.top));
					bleedRightRecto = this.createVariable("--pagedjs-bleed-right-right", CSSValueToString(bleedrecto.right));
					bleedBottomRecto = this.createVariable("--pagedjs-bleed-right-bottom", CSSValueToString(bleedrecto.bottom));
					bleedLeftRecto = this.createVariable("--pagedjs-bleed-right-left", CSSValueToString(bleedrecto.left));

					widthStringRight = `calc( ${CSSValueToString(width)} + ${CSSValueToString(bleedrecto.left)} + ${CSSValueToString(bleedrecto.right)} )`;
					heightStringRight = `calc( ${CSSValueToString(height)} + ${CSSValueToString(bleedrecto.top)} + ${CSSValueToString(bleedrecto.bottom)} )`;
				}
				if (bleedverso) {
					bleedTopVerso = this.createVariable("--pagedjs-bleed-left-top", CSSValueToString(bleedverso.top));
					bleedRightVerso = this.createVariable("--pagedjs-bleed-left-right", CSSValueToString(bleedverso.right));
					bleedBottomVerso = this.createVariable("--pagedjs-bleed-left-bottom", CSSValueToString(bleedverso.bottom));
					bleedLeftVerso = this.createVariable("--pagedjs-bleed-left-left", CSSValueToString(bleedverso.left));

					widthStringLeft = `calc( ${CSSValueToString(width)} + ${CSSValueToString(bleedverso.left)} + ${CSSValueToString(bleedverso.right)} )`;
					heightStringLeft = `calc( ${CSSValueToString(height)} + ${CSSValueToString(bleedverso.top)} + ${CSSValueToString(bleedverso.bottom)} )`;
				}

				let pageWidthVar = this.createVariable("--pagedjs-width", CSSValueToString(width));
				let pageHeightVar = this.createVariable("--pagedjs-height", CSSValueToString(height));

				rules.push(
					bleedTop,
					bleedRight,
					bleedBottom,
					bleedLeft,
					bleedTopRecto,
					bleedRightRecto,
					bleedBottomRecto,
					bleedLeftRecto,
					bleedTopVerso,
					bleedRightVerso,
					bleedBottomVerso,
					bleedLeftVerso,
					pageWidthVar,
					pageHeightVar
				);
			}

			if (marks) {
				marks.forEach((mark) => {
					let markDisplay = this.createVariable("--pagedjs-mark-" + mark + "-display", "block");
					rules.push(markDisplay);
				});
			}

			// orientation variable
			if (orientation) {
				let oVar = this.createVariable("--pagedjs-orientation", orientation);
				rules.push(oVar);

				if (orientation !== "portrait") {
					// reverse for orientation
					[widthString, heightString] = [heightString, widthString];
					[widthStringRight, heightStringRight] = [heightStringRight, widthStringRight];
					[widthStringLeft, heightStringLeft] = [heightStringLeft, widthStringLeft];
				}
			}

			let wVar = this.createVariable("--pagedjs-width", widthString);
			let hVar = this.createVariable("--pagedjs-height", heightString);

			let wVarR = this.createVariable("--pagedjs-width-right", widthStringRight);
			let hVarR = this.createVariable("--pagedjs-height-right", heightStringRight);

			let wVarL = this.createVariable("--pagedjs-width-left", widthStringLeft);
			let hVarL = this.createVariable("--pagedjs-height-left", heightStringLeft);

			rules.push(wVar, hVar, wVarR, hVarR, wVarL, hVarL);

			let rule = this.createRule(selectors, rules);

			ast.children.appendData(rule);
		}

		/*
		@page {
			size: var(--pagedjs-width) var(--pagedjs-height);
			margin: 0;
			padding: 0;
		}
		*/
		addRootPage(ast, size, bleed, bleedrecto, bleedverso) {
			let { width, height, orientation, format } = size;
			let children = new lib.List();
			let childrenLeft = new lib.List();
			let childrenRight = new lib.List();
			let dimensions = new lib.List();
			let dimensionsLeft = new lib.List();
			let dimensionsRight = new lib.List();

			if (bleed) {
				let widthCalculations = new lib.List();
				let heightCalculations = new lib.List();

				// width
				widthCalculations.appendData({
					type: "Dimension",
					unit: width.unit,
					value: width.value
				});

				widthCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculations.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculations.appendData({
					type: "Dimension",
					unit: bleed.left.unit,
					value: bleed.left.value
				});

				widthCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculations.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculations.appendData({
					type: "Dimension",
					unit: bleed.right.unit,
					value: bleed.right.value
				});

				// height
				heightCalculations.appendData({
					type: "Dimension",
					unit: height.unit,
					value: height.value
				});

				heightCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculations.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculations.appendData({
					type: "Dimension",
					unit: bleed.top.unit,
					value: bleed.top.value
				});

				heightCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculations.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculations.appendData({
					type: "Dimension",
					unit: bleed.bottom.unit,
					value: bleed.bottom.value
				});

				dimensions.appendData({
					type: "Function",
					name: "calc",
					children: widthCalculations
				});

				dimensions.appendData({
					type: "WhiteSpace",
					value: " "
				});

				dimensions.appendData({
					type: "Function",
					name: "calc",
					children: heightCalculations
				});

			} else if (format) {
				dimensions.appendData({
					type: "Identifier",
					name: format
				});

				if (orientation) {
					dimensions.appendData({
						type: "WhiteSpace",
						value: " "
					});

					dimensions.appendData({
						type: "Identifier",
						name: orientation
					});
				}
			} else {
				dimensions.appendData({
					type: "Dimension",
					unit: width.unit,
					value: width.value
				});

				dimensions.appendData({
					type: "WhiteSpace",
					value: " "
				});

				dimensions.appendData({
					type: "Dimension",
					unit: height.unit,
					value: height.value
				});
			}

			children.appendData({
				type: "Declaration",
				property: "size",
				loc: null,
				value: {
					type: "Value",
					children: dimensions
				}
			});

			children.appendData({
				type: "Declaration",
				property: "margin",
				loc: null,
				value: {
					type: "Value",
					children: [{
						type: "Dimension",
						unit: "px",
						value: 0
					}]
				}
			});

			children.appendData({
				type: "Declaration",
				property: "padding",
				loc: null,
				value: {
					type: "Value",
					children: [{
						type: "Dimension",
						unit: "px",
						value: 0
					}]
				}
			});

			children.appendData({
				type: "Declaration",
				property: "padding",
				loc: null,
				value: {
					type: "Value",
					children: [{
						type: "Dimension",
						unit: "px",
						value: 0
					}]
				}
			});

			let rule = ast.children.createItem({
				type: "Atrule",
				prelude: null,
				name: "page",
				block: {
					type: "Block",
					loc: null,
					children: children
				}
			});

			ast.children.append(rule);

			if (bleedverso) {
				let widthCalculationsLeft = new lib.List();
				let heightCalculationsLeft = new lib.List();

				// width
				widthCalculationsLeft.appendData({
					type: "Dimension",
					unit: width.unit,
					value: width.value
				});

				widthCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsLeft.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsLeft.appendData({
					type: "Dimension",
					unit: bleedverso.left.unit,
					value: bleedverso.left.value
				});

				widthCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsLeft.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsLeft.appendData({
					type: "Dimension",
					unit: bleedverso.right.unit,
					value: bleedverso.right.value
				});

				// height
				heightCalculationsLeft.appendData({
					type: "Dimension",
					unit: height.unit,
					value: height.value
				});

				heightCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsLeft.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsLeft.appendData({
					type: "Dimension",
					unit: bleedverso.top.unit,
					value: bleedverso.top.value
				});

				heightCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsLeft.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsLeft.appendData({
					type: "Dimension",
					unit: bleedverso.bottom.unit,
					value: bleedverso.bottom.value
				});

				dimensionsLeft.appendData({
					type: "Function",
					name: "calc",
					children: widthCalculationsLeft
				});

				dimensionsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				dimensionsLeft.appendData({
					type: "Function",
					name: "calc",
					children: heightCalculationsLeft
				});

				childrenLeft.appendData({
					type: "Declaration",
					property: "size",
					loc: null,
					value: {
						type: "Value",
						children: dimensionsLeft
					}
				});

				let ruleLeft = ast.children.createItem({
					type: "Atrule",
					prelude: null,
					name: "page :left",
					block: {
						type: "Block",
						loc: null,
						children: childrenLeft
					}
				});

				ast.children.append(ruleLeft);

			}

			if (bleedrecto) {
				let widthCalculationsRight = new lib.List();
				let heightCalculationsRight = new lib.List();

				// width
				widthCalculationsRight.appendData({
					type: "Dimension",
					unit: width.unit,
					value: width.value
				});

				widthCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsRight.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsRight.appendData({
					type: "Dimension",
					unit: bleedrecto.left.unit,
					value: bleedrecto.left.value
				});

				widthCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsRight.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsRight.appendData({
					type: "Dimension",
					unit: bleedrecto.right.unit,
					value: bleedrecto.right.value
				});

				// height
				heightCalculationsRight.appendData({
					type: "Dimension",
					unit: height.unit,
					value: height.value
				});

				heightCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsRight.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsRight.appendData({
					type: "Dimension",
					unit: bleedrecto.top.unit,
					value: bleedrecto.top.value
				});

				heightCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsRight.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsRight.appendData({
					type: "Dimension",
					unit: bleedrecto.bottom.unit,
					value: bleedrecto.bottom.value
				});

				dimensionsRight.appendData({
					type: "Function",
					name: "calc",
					children: widthCalculationsRight
				});

				dimensionsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				dimensionsRight.appendData({
					type: "Function",
					name: "calc",
					children: heightCalculationsRight
				});

				childrenRight.appendData({
					type: "Declaration",
					property: "size",
					loc: null,
					value: {
						type: "Value",
						children: dimensionsRight
					}
				});

				let ruleRight = ast.children.createItem({
					type: "Atrule",
					prelude: null,
					name: "page :right",
					block: {
						type: "Block",
						loc: null,
						children: childrenRight
					}
				});

				ast.children.append(ruleRight);

			}
		}

		getNth(nth) {
			let n = nth.indexOf("n");
			let plus = nth.indexOf("+");
			let splitN = nth.split("n");
			let splitP = nth.split("+");
			let a = null;
			let b = null;
			if (n > -1) {
				a = splitN[0];
				if (plus > -1) {
					b = splitP[1];
				}
			} else {
				b = nth;
			}

			return {
				type: "Nth",
				loc: null,
				selector: null,
				nth: {
					type: "AnPlusB",
					loc: null,
					a: a,
					b: b
				}
			};
		}

		addPageAttributes(page, start, pages) {
			let named = start.dataset.page;

			if (named) {
				page.name = named;
				page.element.classList.add("pagedjs_named_page");
				page.element.classList.add("pagedjs_" + named + "_page");

				if (!start.dataset.splitFrom) {
					page.element.classList.add("pagedjs_" + named + "_first_page");
				}
			}
		}

		getStartElement(content, breakToken) {
			let node = breakToken && breakToken.node;

			if (!content && !breakToken) {
				return;
			}

			// No break
			if (!node) {
				return content.children[0];
			}

			// Top level element
			if (node.nodeType === 1 && node.parentNode.nodeType === 11) {
				return node;
			}

			// Named page
			if (node.nodeType === 1 && node.dataset.page) {
				return node;
			}

			// Get top level Named parent
			let fragment = rebuildAncestors(node);
			let pages = fragment.querySelectorAll("[data-page]");

			if (pages.length) {
				return pages[pages.length - 1];
			} else {
				return fragment.children[0];
			}
		}

		beforePageLayout(page, contents, breakToken, chunker) {
			let start = this.getStartElement(contents, breakToken);
			if (start) {
				this.addPageAttributes(page, start, chunker.pages);
			}
			// page.element.querySelector('.paged_area').style.color = red;
		}

		afterPageLayout(fragment, page, breakToken, chunker) {
			for (let m in this.marginalia) {
				let margin = this.marginalia[m];
				let sels = m.split(" ");

				let content;
				if (page.element.matches(sels[0]) && margin.hasContent) {
					content = page.element.querySelector(sels[1]);
					content.classList.add("hasContent");
				}
			}

			// check center
			["top", "bottom"].forEach((loc) => {
				let marginGroup = page.element.querySelector(".pagedjs_margin-" + loc);
				let center = page.element.querySelector(".pagedjs_margin-" + loc + "-center");
				let left = page.element.querySelector(".pagedjs_margin-" + loc + "-left");
				let right = page.element.querySelector(".pagedjs_margin-" + loc + "-right");

				let centerContent = center.classList.contains("hasContent");
				let leftContent = left.classList.contains("hasContent");
				let rightContent = right.classList.contains("hasContent");
				let centerWidth, leftWidth, rightWidth;

				if (leftContent) {
					leftWidth = window.getComputedStyle(left)["max-width"];
				}

				if (rightContent) {
					rightWidth = window.getComputedStyle(right)["max-width"];
				}


				if (centerContent) {
					centerWidth = window.getComputedStyle(center)["max-width"];

					if (centerWidth === "none" || centerWidth === "auto") {
						if (!leftContent && !rightContent) {
							marginGroup.style["grid-template-columns"] = "0 1fr 0";
						} else if (leftContent) {
							if (!rightContent) {
								if (leftWidth !== "none" && leftWidth !== "auto") {
									marginGroup.style["grid-template-columns"] = leftWidth + " 1fr " + leftWidth;
								} else {
									marginGroup.style["grid-template-columns"] = "auto auto 1fr";
									left.style["white-space"] = "nowrap";
									center.style["white-space"] = "nowrap";
									let leftOuterWidth = left.offsetWidth;
									let centerOuterWidth = center.offsetWidth;
									let outerwidths = leftOuterWidth + centerOuterWidth;
									let newcenterWidth = centerOuterWidth * 100 / outerwidths;
									marginGroup.style["grid-template-columns"] = "minmax(16.66%, 1fr) minmax(33%, " + newcenterWidth + "%) minmax(16.66%, 1fr)";
									left.style["white-space"] = "normal";
									center.style["white-space"] = "normal";
								}
							} else {
								if (leftWidth !== "none" && leftWidth !== "auto") {
									if (rightWidth !== "none" && rightWidth !== "auto") {
										marginGroup.style["grid-template-columns"] = leftWidth + " 1fr " + rightWidth;
									} else {
										marginGroup.style["grid-template-columns"] = leftWidth + " 1fr " + leftWidth;
									}
								} else {
									if (rightWidth !== "none" && rightWidth !== "auto") {
										marginGroup.style["grid-template-columns"] = rightWidth + " 1fr " + rightWidth;
									} else {
										marginGroup.style["grid-template-columns"] = "auto auto 1fr";
										left.style["white-space"] = "nowrap";
										center.style["white-space"] = "nowrap";
										right.style["white-space"] = "nowrap";
										let leftOuterWidth = left.offsetWidth;
										let centerOuterWidth = center.offsetWidth;
										let rightOuterWidth = right.offsetWidth;
										let outerwidths = leftOuterWidth + centerOuterWidth + rightOuterWidth;
										let newcenterWidth = centerOuterWidth * 100 / outerwidths;
										if (newcenterWidth > 40) {
											marginGroup.style["grid-template-columns"] = "minmax(16.66%, 1fr) minmax(33%, " + newcenterWidth + "%) minmax(16.66%, 1fr)";
										} else {
											marginGroup.style["grid-template-columns"] = "repeat(3, 1fr)";
										}
										left.style["white-space"] = "normal";
										center.style["white-space"] = "normal";
										right.style["white-space"] = "normal";
									}
								}
							}
						} else {
							if (rightWidth !== "none" && rightWidth !== "auto") {
								marginGroup.style["grid-template-columns"] = rightWidth + " 1fr " + rightWidth;
							} else {
								marginGroup.style["grid-template-columns"] = "auto auto 1fr";
								right.style["white-space"] = "nowrap";
								center.style["white-space"] = "nowrap";
								let rightOuterWidth = right.offsetWidth;
								let centerOuterWidth = center.offsetWidth;
								let outerwidths = rightOuterWidth + centerOuterWidth;
								let newcenterWidth = centerOuterWidth * 100 / outerwidths;
								marginGroup.style["grid-template-columns"] = "minmax(16.66%, 1fr) minmax(33%, " + newcenterWidth + "%) minmax(16.66%, 1fr)";
								right.style["white-space"] = "normal";
								center.style["white-space"] = "normal";
							}
						}
					} else if (centerWidth !== "none" && centerWidth !== "auto") {
						if (leftContent && leftWidth !== "none" && leftWidth !== "auto") {
							marginGroup.style["grid-template-columns"] = leftWidth + " " + centerWidth + " 1fr";
						} else if (rightContent && rightWidth !== "none" && rightWidth !== "auto") {
							marginGroup.style["grid-template-columns"] = "1fr " + centerWidth + " " + rightWidth;
						} else {
							marginGroup.style["grid-template-columns"] = "1fr " + centerWidth + " 1fr";
						}

					}

				} else {
					if (leftContent) {
						if (!rightContent) {
							marginGroup.style["grid-template-columns"] = "1fr 0 0";
						} else {
							if (leftWidth !== "none" && leftWidth !== "auto") {
								if (rightWidth !== "none" && rightWidth !== "auto") {
									marginGroup.style["grid-template-columns"] = leftWidth + " 1fr " + rightWidth;
								} else {
									marginGroup.style["grid-template-columns"] = leftWidth + " 0 1fr";
								}
							} else {
								if (rightWidth !== "none" && rightWidth !== "auto") {
									marginGroup.style["grid-template-columns"] = "1fr 0 " + rightWidth;
								} else {
									marginGroup.style["grid-template-columns"] = "auto 1fr auto";
									left.style["white-space"] = "nowrap";
									right.style["white-space"] = "nowrap";
									let leftOuterWidth = left.offsetWidth;
									let rightOuterWidth = right.offsetWidth;
									let outerwidths = leftOuterWidth + rightOuterWidth;
									let newLeftWidth = leftOuterWidth * 100 / outerwidths;
									marginGroup.style["grid-template-columns"] = "minmax(16.66%, " + newLeftWidth + "%) 0 1fr";
									left.style["white-space"] = "normal";
									right.style["white-space"] = "normal";
								}
							}
						}
					} else {
						if (rightWidth !== "none" && rightWidth !== "auto") {
							marginGroup.style["grid-template-columns"] = "1fr 0 " + rightWidth;
						} else {
							marginGroup.style["grid-template-columns"] = "0 0 1fr";
						}
					}
				}
			});

			// check middle
			["left", "right"].forEach((loc) => {
				let middle = page.element.querySelector(".pagedjs_margin-" + loc + "-middle.hasContent");
				let marginGroup = page.element.querySelector(".pagedjs_margin-" + loc);
				let top = page.element.querySelector(".pagedjs_margin-" + loc + "-top");
				let bottom = page.element.querySelector(".pagedjs_margin-" + loc + "-bottom");
				let topContent = top.classList.contains("hasContent");
				let bottomContent = bottom.classList.contains("hasContent");
				let middleHeight, topHeight, bottomHeight;

				if (topContent) {
					topHeight = window.getComputedStyle(top)["max-height"];
				}

				if (bottomContent) {
					bottomHeight = window.getComputedStyle(bottom)["max-height"];
				}

				if (middle) {
					middleHeight = window.getComputedStyle(middle)["max-height"];

					if (middleHeight === "none" || middleHeight === "auto") {
						if (!topContent && !bottomContent) {
							marginGroup.style["grid-template-rows"] = "0 1fr 0";
						} else if (topContent) {
							if (!bottomContent) {
								if (topHeight !== "none" && topHeight !== "auto") {
									marginGroup.style["grid-template-rows"] = topHeight + " calc(100% - " + topHeight + "*2) " + topHeight;
								}
							} else {
								if (topHeight !== "none" && topHeight !== "auto") {
									if (bottomHeight !== "none" && bottomHeight !== "auto") {
										marginGroup.style["grid-template-rows"] = topHeight + " calc(100% - " + topHeight + " - " + bottomHeight + ") " + bottomHeight;
									} else {
										marginGroup.style["grid-template-rows"] = topHeight + " calc(100% - " + topHeight + "*2) " + topHeight;
									}
								} else {
									if (bottomHeight !== "none" && bottomHeight !== "auto") {
										marginGroup.style["grid-template-rows"] = bottomHeight + " calc(100% - " + bottomHeight + "*2) " + bottomHeight;
									}
								}
							}
						} else {
							if (bottomHeight !== "none" && bottomHeight !== "auto") {
								marginGroup.style["grid-template-rows"] = bottomHeight + " calc(100% - " + bottomHeight + "*2) " + bottomHeight;
							}
						}
					} else {
						if (topContent && topHeight !== "none" && topHeight !== "auto") {
							marginGroup.style["grid-template-rows"] = topHeight + " " + middleHeight + " calc(100% - (" + topHeight + " + " + middleHeight + "))";
						} else if (bottomContent && bottomHeight !== "none" && bottomHeight !== "auto") {
							marginGroup.style["grid-template-rows"] = "1fr " + middleHeight + " " + bottomHeight;
						} else {
							marginGroup.style["grid-template-rows"] = "calc((100% - " + middleHeight + ")/2) " + middleHeight + " calc((100% - " + middleHeight + ")/2)";
						}

					}

				} else {
					if (topContent) {
						if (!bottomContent) {
							marginGroup.style["grid-template-rows"] = "1fr 0 0";
						} else {
							if (topHeight !== "none" && topHeight !== "auto") {
								if (bottomHeight !== "none" && bottomHeight !== "auto") {
									marginGroup.style["grid-template-rows"] = topHeight + " 1fr " + bottomHeight;
								} else {
									marginGroup.style["grid-template-rows"] = topHeight + " 0 1fr";
								}
							} else {
								if (bottomHeight !== "none" && bottomHeight !== "auto") {
									marginGroup.style["grid-template-rows"] = "1fr 0 " + bottomHeight;
								} else {
									marginGroup.style["grid-template-rows"] = "1fr 0 1fr";
								}
							}
						}
					} else {
						if (bottomHeight !== "none" && bottomHeight !== "auto") {
							marginGroup.style["grid-template-rows"] = "1fr 0 " + bottomHeight;
						} else {
							marginGroup.style["grid-template-rows"] = "0 0 1fr";
						}
					}
				}



			});

		}

		// CSS Tree Helpers

		selectorsForPage(page) {
			let nthlist;
			let nth;

			let selectors = new lib.List();

			selectors.insertData({
				type: "ClassSelector",
				name: "pagedjs_page"
			});

			// Named page
			if (page.name) {
				selectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_named_page"
				});

				selectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_" + page.name + "_page"
				});
			}

			// PsuedoSelector
			if (page.psuedo && !(page.name && page.psuedo === "first")) {
				selectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_" + page.psuedo + "_page"
				});
			}

			if (page.name && page.psuedo === "first") {
				selectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_" + page.name + "_" + page.psuedo + "_page"
				});
			}

			// Nth
			if (page.nth) {
				nthlist = new lib.List();
				nth = this.getNth(page.nth);

				nthlist.insertData(nth);

				selectors.insertData({
					type: "PseudoClassSelector",
					name: "nth-of-type",
					children: nthlist
				});
			}

			return selectors;
		}

		selectorsForPageMargin(page, margin) {
			let selectors = this.selectorsForPage(page);

			selectors.insertData({
				type: "Combinator",
				name: " "
			});

			selectors.insertData({
				type: "ClassSelector",
				name: "pagedjs_margin-" + margin
			});

			return selectors;
		}

		createDeclaration(property, value, important) {
			let children = new lib.List();

			children.insertData({
				type: "Identifier",
				loc: null,
				name: value
			});

			return {
				type: "Declaration",
				loc: null,
				important: important,
				property: property,
				value: {
					type: "Value",
					loc: null,
					children: children
				}
			};
		}

		createVariable(property, value) {
			return {
				type: "Declaration",
				loc: null,
				property: property,
				value: {
					type: "Raw",
					value: value
				}
			};
		}

		createCalculatedDimension(property, items, important, operator = "+") {
			let children = new lib.List();
			let calculations = new lib.List();

			items.forEach((item, index) => {
				calculations.appendData({
					type: "Dimension",
					unit: item.unit,
					value: item.value
				});

				calculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				if (index + 1 < items.length) {
					calculations.appendData({
						type: "Operator",
						value: operator
					});

					calculations.appendData({
						type: "WhiteSpace",
						value: " "
					});
				}
			});

			children.insertData({
				type: "Function",
				loc: null,
				name: "calc",
				children: calculations
			});

			return {
				type: "Declaration",
				loc: null,
				important: important,
				property: property,
				value: {
					type: "Value",
					loc: null,
					children: children
				}
			};
		}

		createDimension(property, cssValue, important) {
			let children = new lib.List();

			children.insertData({
				type: "Dimension",
				loc: null,
				value: cssValue.value,
				unit: cssValue.unit
			});

			return {
				type: "Declaration",
				loc: null,
				important: important,
				property: property,
				value: {
					type: "Value",
					loc: null,
					children: children
				}
			};
		}

		createBlock(declarations) {
			let block = new lib.List();

			declarations.forEach((declaration) => {
				block.insertData(declaration);
			});

			return {
				type: "Block",
				loc: null,
				children: block
			};
		}

		createRule(selectors, block) {
			let selectorList = new lib.List();
			selectorList.insertData({
				type: "Selector",
				children: selectors
			});

			if (Array.isArray(block)) {
				block = this.createBlock(block);
			}

			return {
				type: "Rule",
				prelude: {
					type: "SelectorList",
					children: selectorList
				},
				block: block
			};
		}

	}

	class Breaks extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.breaks = {};
		}

		onDeclaration(declaration, dItem, dList, rule) {
			let property = declaration.property;

			if (property === "page") {
				let children = declaration.value.children.first();
				let value = children.name;
				let selector = lib.generate(rule.ruleNode.prelude);
				let name = value;

				let breaker = {
					property: property,
					value: value,
					selector: selector,
					name: name
				};

				selector.split(",").forEach((s) => {
					if (!this.breaks[s]) {
						this.breaks[s] = [breaker];
					} else {
						this.breaks[s].push(breaker);
					}
				});

				dList.remove(dItem);
			}

			if (property === "break-before" ||
					property === "break-after" ||
					property === "page-break-before" ||
					property === "page-break-after"
			) {
				let child = declaration.value.children.first();
				let value = child.name;
				let selector = lib.generate(rule.ruleNode.prelude);

				if (property === "page-break-before") {
					property = "break-before";
				} else if (property === "page-break-after") {
					property = "break-after";
				}

				let breaker = {
					property: property,
					value: value,
					selector: selector
				};

				selector.split(",").forEach((s) => {
					if (!this.breaks[s]) {
						this.breaks[s] = [breaker];
					} else {
						this.breaks[s].push(breaker);
					}
				});

				// Remove from CSS -- handle right / left in module
				dList.remove(dItem);
			}
		}

		afterParsed(parsed) {
			this.processBreaks(parsed, this.breaks);
		}

		processBreaks(parsed, breaks) {
			for (let b in breaks) {
				// Find elements
				let elements = parsed.querySelectorAll(b);
				// Add break data
				for (var i = 0; i < elements.length; i++) {
					for (let prop of breaks[b]) {

						if (prop.property === "break-after") {
							let nodeAfter = displayedElementAfter(elements[i], parsed);

							elements[i].setAttribute("data-break-after", prop.value);

							if (nodeAfter) {
								nodeAfter.setAttribute("data-previous-break-after", prop.value);
							}
						} else if (prop.property === "break-before") {
							let nodeBefore = displayedElementBefore(elements[i], parsed);

							// Breaks are only allowed between siblings, not between a box and its container.
							// If we cannot find a node before we should not break!
							// https://drafts.csswg.org/css-break-3/#break-propagation
							if (nodeBefore) {
								if (prop.value === "page" && needsPageBreak(elements[i], nodeBefore)) {
									// we ignore this explicit page break because an implicit page break is already needed
									continue;
								}
								elements[i].setAttribute("data-break-before", prop.value);
								nodeBefore.setAttribute("data-next-break-before", prop.value);
							}
						} else if (prop.property === "page") {
							elements[i].setAttribute("data-page", prop.value);

							let nodeAfter = displayedElementAfter(elements[i], parsed);

							if (nodeAfter) {
								nodeAfter.setAttribute("data-after-page", prop.value);
							}
						} else {
							elements[i].setAttribute("data-" + prop.property, prop.value);
						}
					}
				}
			}
		}

		mergeBreaks(pageBreaks, newBreaks) {
			for (let b in newBreaks) {
				if (b in pageBreaks) {
					pageBreaks[b] = pageBreaks[b].concat(newBreaks[b]);
				} else {
					pageBreaks[b] = newBreaks[b];
				}
			}
			return pageBreaks;
		}

		addBreakAttributes(pageElement, page) {
			let before = pageElement.querySelector("[data-break-before]");
			let after = pageElement.querySelector("[data-break-after]");
			let previousBreakAfter = pageElement.querySelector("[data-previous-break-after]");

			if (before) {
				if (before.dataset.splitFrom) {
					page.splitFrom = before.dataset.splitFrom;
					pageElement.setAttribute("data-split-from", before.dataset.splitFrom);
				} else if (before.dataset.breakBefore && before.dataset.breakBefore !== "avoid") {
					page.breakBefore = before.dataset.breakBefore;
					pageElement.setAttribute("data-break-before", before.dataset.breakBefore);
				}
			}

			if (after && after.dataset) {
				if (after.dataset.splitTo) {
					page.splitTo = after.dataset.splitTo;
					pageElement.setAttribute("data-split-to", after.dataset.splitTo);
				} else if (after.dataset.breakAfter && after.dataset.breakAfter !== "avoid") {
					page.breakAfter = after.dataset.breakAfter;
					pageElement.setAttribute("data-break-after", after.dataset.breakAfter);
				}
			}

			if (previousBreakAfter && previousBreakAfter.dataset) {
				if (previousBreakAfter.dataset.previousBreakAfter && previousBreakAfter.dataset.previousBreakAfter !== "avoid") {
					page.previousBreakAfter = previousBreakAfter.dataset.previousBreakAfter;
				}
			}
		}

		afterPageLayout(pageElement, page) {
			this.addBreakAttributes(pageElement, page);
		}
	}

	class PrintMedia extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}

		onAtMedia(node, item, list) {
			let media = this.getMediaName(node);
			let rules;

			if (media === "print") {
				rules = node.block.children;

				// Remove rules from the @media block
				node.block.children = new lib.List();

				// Append rules to the end of main rules list
				list.appendList(rules);
			}

		}

		getMediaName(node) {
			let media = "";

			if (typeof node.prelude === "undefined" ||
					node.prelude.type !== "AtrulePrelude" ) {
				return;
			}

			lib.walk(node.prelude, {
				visit: "Identifier",
				enter: (identNode, iItem, iList) => {
					media = identNode.name;
				}
			});
			return media;
		}


	}

	class Splits extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}

		afterPageLayout(pageElement, page, breakToken, chunker) {
			let splits = Array.from(pageElement.querySelectorAll("[data-split-from]"));
			let pages = pageElement.parentNode;
			let index = Array.prototype.indexOf.call(pages.children, pageElement);
			let prevPage;

			if (index === 0) {
				return;
			}

			prevPage = pages.children[index - 1];

			let from; // Capture the last from element
			splits.forEach((split) => {
				let ref = split.dataset.ref;
				from = prevPage.querySelector("[data-ref='"+ ref +"']:not([data-split-to])");

				if (from) {
					from.dataset.splitTo = ref;

					if (!from.dataset.splitFrom) {
						from.dataset.splitOriginal = true;
					}
				}
			});

			// Fix alignment on the deepest split element
			if (from) {
				this.handleAlignment(from);
			}
		}

		handleAlignment(node) {
			let styles = window.getComputedStyle(node);
			let align = styles["text-align"];
			let alignLast = styles["text-align-last"];
			node.dataset.lastSplitElement = "true";
			if (align === "justify" && alignLast === "auto") {
				node.dataset.alignLastSplitElement = "justify";
			} else {
				node.dataset.alignLastSplitElement = alignLast;
			}
		}

	}

	class Counters extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;
			this.counters = {};
			this.resetCountersMap = new Map();
		}

		onDeclaration(declaration, dItem, dList, rule) {
			let property = declaration.property;

			if (property === "counter-increment") {
				let inc = this.handleIncrement(declaration, rule);
				if (inc) {
					dList.remove(dItem);
				}
			} else if (property === "counter-reset") {
				let reset = this.handleReset(declaration, rule);
				if (reset) {
					dList.remove(dItem);
				}
			}
		}

		onContent(funcNode, fItem, fList, declaration, rule) {
			if (funcNode.name === "counter") ;
		}

		afterParsed(parsed) {
			this.processCounters(parsed, this.counters);
			this.scopeCounters(this.counters);
		}

		addCounter(name) {
			if (name in this.counters) {
				return this.counters[name];
			}

			this.counters[name] = {
				name: name,
				increments: {},
				resets: {}
			};

			return this.counters[name];
		}

		handleIncrement(declaration, rule) {
			const identifier = declaration.value.children.first();
			const number = declaration.value.children.getSize() > 1 ? declaration.value.children.last().value : 1;
			const name = identifier && identifier.name;

			if (name === "page" || name.indexOf("target-counter-") === 0) {
				return;
			}

			let selector = lib.generate(rule.ruleNode.prelude);

			let counter;
			if (!(name in this.counters)) {
				counter = this.addCounter(name);
			} else {
				counter = this.counters[name];
			}

			return counter.increments[selector] = {
				selector: selector,
				number
			};
		}

		handleReset(declaration, rule) {
			let identifier = declaration.value.children.first();
			let number = declaration.value.children.getSize() > 1
								&& declaration.value.children.last().value;
			let name = identifier && identifier.name;
			let selector = lib.generate(rule.ruleNode.prelude);
			let counter;

			if (!(name in this.counters)) {
				counter = this.addCounter(name);
			} else {
				counter = this.counters[name];
			}

			return counter.resets[selector] = {
				selector: selector,
				number: number || 0
			};
		}

		processCounters(parsed, counters) {
			let counter;
			for (let c in counters) {
				counter = this.counters[c];
				this.processCounterIncrements(parsed, counter);
				this.processCounterResets(parsed, counter);
				if (c !== "page") {
					this.addCounterValues(parsed, counter);
				}
			}
		}

		scopeCounters(counters) {
			let countersArray = [];
			for (let c in counters) {
				if(c !== "page") {
					countersArray.push(`${counters[c].name} 0`);
				}
			}
			// Add to pages to allow cross page scope
			this.insertRule(`.pagedjs_pages { counter-reset: ${countersArray.join(" ")} page 0 pages var(--pagedjs-page-count)}`);
		}

		insertRule(rule) {
			this.styleSheet.insertRule(rule, this.styleSheet.cssRules.length);
		}

		processCounterIncrements(parsed, counter) {
			let increment;
			for (let inc in counter.increments) {
				increment = counter.increments[inc];
				// Find elements for increments
				let incrementElements = parsed.querySelectorAll(increment.selector);
				// Add counter data
				for (let i = 0; i < incrementElements.length; i++) {
					incrementElements[i].setAttribute("data-counter-"+ counter.name +"-increment", increment.number);
					incrementElements[i].setAttribute("data-counter-increment", counter.name);
				}
			}
		}

		processCounterResets(parsed, counter) {
			let reset;
			for (let r in counter.resets) {
				reset = counter.resets[r];
				// Find elements for resets
				let resetElements = parsed.querySelectorAll(reset.selector);
				// Add counter data
				for (var i = 0; i < resetElements.length; i++) {
					resetElements[i].setAttribute("data-counter-"+ counter.name +"-reset", reset.number);
					resetElements[i].setAttribute("data-counter-reset", counter.name);
				}
			}
		}

		addCounterValues(parsed, counter) {
			const counterName = counter.name;
			const elements = parsed.querySelectorAll("[data-counter-"+ counterName +"-reset], [data-counter-"+ counterName +"-increment]");

			let count = 0;
			let element;
			let increment, reset;
			let resetValue, incrementValue, resetDelta;
			let incrementArray;

			for (let i = 0; i < elements.length; i++) {
				element = elements[i];
				resetDelta = 0;
				incrementArray = [];

				if (element.hasAttribute("data-counter-"+ counterName +"-reset")) {
					reset = element.getAttribute("data-counter-"+ counterName +"-reset");
					resetValue = parseInt(reset);

					// Use negative increment value inplace of reset
					resetDelta = resetValue - count;
					incrementArray.push(`${counterName} ${resetDelta}`);

					count = resetValue;
				}

				if (element.hasAttribute("data-counter-"+ counterName +"-increment")) {

					increment = element.getAttribute("data-counter-"+ counterName +"-increment");
					incrementValue = parseInt(increment);

					count += incrementValue;

					element.setAttribute("data-counter-"+counterName+"-value", count);

					incrementArray.push(`${counterName} ${incrementValue}`);
				}

				if (incrementArray.length > 0) {
					this.incrementCounterForElement(element, incrementArray);
				}

			}
		}

		incrementCounterForElement(element, incrementArray) {
			if (!element || !incrementArray || incrementArray.length === 0) return;

			const ref = element.dataset.ref;
			const prevIncrements = Array.from(this.styleSheet.cssRules).filter((rule) => {
				return rule.selectorText === `[data-ref="${element.dataset.ref}"]:not([data-split-from])`
							 && rule.style[0] === "counter-increment";
			});

			const increments = [];
			for (let styleRule of prevIncrements) {
				let values = styleRule.style.counterIncrement.split(" ");
				for (let i = 0; i < values.length; i+=2) {
					increments.push(values[i] + " " + values[i+1]);
				}
			}

			Array.prototype.push.apply(increments, incrementArray);

			this.insertRule(`[data-ref="${ref}"]:not([data-split-from]) { counter-increment: ${increments.join(" ")} }`);
		}

		afterPageLayout(pageElement, page) {
			let pgreset = pageElement.querySelectorAll("[data-counter-page-reset]");
			pgreset.forEach((reset) => {
				const ref = reset.dataset && reset.dataset.ref;
				if (ref && this.resetCountersMap.has(ref)) ; else {
					if (ref) {
						this.resetCountersMap.set(ref, "");
					}
					let value = reset.dataset.counterPageReset;
					this.styleSheet.insertRule(`[data-page-number="${pageElement.dataset.pageNumber}"] { counter-increment: none; counter-reset: page ${value}; }`, this.styleSheet.cssRules.length);
				}
			});
		}

	}

	class Lists extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}
		afterParsed(content) {
			const orderedLists = content.querySelectorAll("ol");

			for (var list of orderedLists) {
				this.addDataNumbers(list);
			}
		}

		afterPageLayout(pageElement, page, breakToken, chunker) {
			var orderedLists = pageElement.getElementsByTagName("ol");
			for (var list of orderedLists) {
				if (list.hasChildNodes()) {
					list.start = list.firstElementChild.dataset.itemNum;
				}
				else {
					list.parentNode.removeChild(list);
				}
			}
		}

		addDataNumbers(list) {
			let start = 1;
			if (list.hasAttribute("start")) {
				start = parseInt(list.getAttribute("start"), 10);
				if (isNaN(start)) {
					start = 1;
				}
			}
			let items = list.children;
			for (var i = 0; i < items.length; i++) {
				items[i].setAttribute("data-item-num", i + start);
			}
		}

	}

	class PositionFixed extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
			this.styleSheet = polisher.styleSheet;
			this.fixedElementsSelector = [];
			this.fixedElements = [];
		}

		onDeclaration(declaration, dItem, dList, rule) {
			if (declaration.property === "position" && declaration.value.children.first().name === "fixed") {
				let selector = lib.generate(rule.ruleNode.prelude);
				this.fixedElementsSelector.push(selector);
				dList.remove(dItem);
			}
		}

		afterParsed(fragment) {
			this.fixedElementsSelector.forEach(fixedEl => {
				fragment.querySelectorAll(`${fixedEl}`).forEach(el => {
					el.style.setProperty("position", "absolute");
					this.fixedElements.push(el);
					el.remove();
				});
			});
		}

		afterPageLayout(pageElement, page, breakToken) {
			this.fixedElements.forEach(el => {
				const clone = el.cloneNode(true);
				pageElement.querySelector(".pagedjs_pagebox").insertAdjacentElement("afterbegin", clone);
			});
		}
	}

	class PageCounterIncrement extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;
			this.pageCounter = {
				name: "page",
				increments: {},
				resets: {}
			};
		}

		onDeclaration(declaration, dItem, dList, rule) {
			const property = declaration.property;

			if (property === "counter-increment") {
				let inc = this.handleIncrement(declaration, rule);
				if (inc) {
					dList.remove(dItem);
				}
			}
		}

		afterParsed(_) {
			for (const inc in this.pageCounter.increments) {
				const increment = this.pageCounter.increments[inc];
				this.insertRule(`${increment.selector} { --pagedjs-page-counter-increment: ${increment.number} }`);
			}
		}

		handleIncrement(declaration, rule) {
			const identifier = declaration.value.children.first();
			const number = declaration.value.children.getSize() > 1 ? declaration.value.children.last().value : 1;
			const name = identifier && identifier.name;

			if (name.indexOf("target-counter-") === 0) {
				return;
			}
			// A counter named page is automatically created and incremented by 1 on every page of the document,
			// unless the counter-increment property in the page context explicitly specifies a different increment for the page counter.
			// https://www.w3.org/TR/css-page-3/#page-based-counters
			if (name !== "page") {
				return;
			}
			// the counter-increment property is not defined on the page context (i.e. @page rule), ignoring...
			if (rule.ruleNode.name === "page" && rule.ruleNode.type === "Atrule") {
				return;
			}
			const selector = lib.generate(rule.ruleNode.prelude);
			return this.pageCounter.increments[selector] = {
				selector: selector,
				number
			};
		}

		insertRule(rule) {
			this.styleSheet.insertRule(rule, this.styleSheet.cssRules.length);
		}
	}

	class NthOfType extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;
			this.selectors = {};
		}

		onRule(ruleNode, ruleItem, rulelist) {
			let selector = lib.generate(ruleNode.prelude);
			if (selector.match(/:(first|last|nth)-of-type/)) {
				
				let declarations = lib.generate(ruleNode.block);
				declarations = declarations.replace(/[{}]/g,"");

				let uuid = "nth-of-type-" + UUID();

				selector.split(",").forEach((s) => {
					if (!this.selectors[s]) {
						this.selectors[s] = [uuid, declarations];
					} else {
						this.selectors[s][1] = `${this.selectors[s][1]};${declarations}` ;
					}
				});

				rulelist.remove(ruleItem);
			}
		}

		afterParsed(parsed) {
			this.processSelectors(parsed, this.selectors);
		}

		processSelectors(parsed, selectors) {
			// add the new attributes to matching elements
			for (let s in selectors) {
				let elements = parsed.querySelectorAll(s);

				for (var i = 0; i < elements.length; i++) {
					let dataNthOfType = elements[i].getAttribute("data-nth-of-type");

					if (dataNthOfType && dataNthOfType != "") {
						dataNthOfType = `${dataNthOfType},${selectors[s][0]}`;
						elements[i].setAttribute("data-nth-of-type", dataNthOfType);
					} else {
						elements[i].setAttribute("data-nth-of-type", selectors[s][0]);
					}
				}

				let rule = `*[data-nth-of-type*='${selectors[s][0]}'] { ${selectors[s][1]}; }`;
				this.styleSheet.insertRule(rule, this.styleSheet.cssRules.length);
			}
		}
	}

	class Following extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;
			this.selectors = {};
		}

		onRule(ruleNode, ruleItem, rulelist) {
			let selector = lib.generate(ruleNode.prelude);
			if (selector.match(/\+/)) {
				
				let declarations = lib.generate(ruleNode.block);
				declarations = declarations.replace(/[{}]/g,"");

				let uuid = "following-" + UUID();

				selector.split(",").forEach((s) => {
					if (!this.selectors[s]) {
						this.selectors[s] = [uuid, declarations];
					} else {
						this.selectors[s][1] = `${this.selectors[s][1]};${declarations}` ;
					}
				});

				rulelist.remove(ruleItem);
			}
		}

		afterParsed(parsed) {
			this.processSelectors(parsed, this.selectors);
		}

		processSelectors(parsed, selectors) {
			// add the new attributes to matching elements
			for (let s in selectors) {
				let elements = parsed.querySelectorAll(s);

				for (var i = 0; i < elements.length; i++) {
					let dataFollowing = elements[i].getAttribute("data-following");

					if (dataFollowing && dataFollowing != "") {
						dataFollowing = `${dataFollowing},${selectors[s][0]}`;
						elements[i].setAttribute("data-following", dataFollowing);
					} else {
						elements[i].setAttribute("data-following", selectors[s][0]);
					}
				}

				let rule = `*[data-following*='${selectors[s][0]}'] { ${selectors[s][1]}; }`;
				this.styleSheet.insertRule(rule, this.styleSheet.cssRules.length);
			}
		}
	}

	var pagedMediaHandlers = [
		AtPage,
		Breaks,
		PrintMedia,
		Splits,
		Counters,
		Lists,
		PositionFixed,
		PageCounterIncrement,
		NthOfType,
		Following
	];

	class RunningHeaders extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.runningSelectors = {};
			this.elements = {};
		}

		onDeclaration(declaration, dItem, dList, rule) {
			if (declaration.property === "position") {
				let selector = lib.generate(rule.ruleNode.prelude);
				let identifier = declaration.value.children.first().name;

				if (identifier === "running") {
					let value;
					lib.walk(declaration, {
						visit: "Function",
						enter: (node, item, list) => {
							value = node.children.first().name;
						}
					});

					this.runningSelectors[value] = {
						identifier: identifier,
						value: value,
						selector: selector
					};
				}
			}

			if (declaration.property === "content") {

				lib.walk(declaration, {
					visit: "Function",
					enter: (funcNode, fItem, fList) => {

						if (funcNode.name.indexOf("element") > -1) {

							let selector = lib.generate(rule.ruleNode.prelude);

							let func = funcNode.name;

							let value = funcNode.children.first().name;

							let args = [value];

							// we only handle first for now
							let style = "first";

							selector.split(",").forEach((s) => {
								// remove before / after
								s = s.replace(/::after|::before/, "");

								this.elements[s] = {
									func: func,
									args: args,
									value: value,
									style: style ,
									selector: s,
									fullSelector: selector
								};
							});
						}

					}
				});
			}
		}

		afterParsed(fragment) {
			for (let name of Object.keys(this.runningSelectors)) {
				let set = this.runningSelectors[name];
				let selected = Array.from(fragment.querySelectorAll(set.selector));

				if (set.identifier === "running") {
					for (let header of selected) {
						header.style.display = "none";
					}
				}

			}
		}

		afterPageLayout(fragment) {
			for (let name of Object.keys(this.runningSelectors)) {
				let set = this.runningSelectors[name];
				let selected = fragment.querySelector(set.selector);
				if (selected) {
					// let cssVar;
					if (set.identifier === "running") {
						// cssVar = selected.textContent.replace(/\\([\s\S])|(["|'])/g,"\\$1$2");
						// this.styleSheet.insertRule(`:root { --string-${name}: "${cssVar}"; }`, this.styleSheet.cssRules.length);
						// fragment.style.setProperty(`--string-${name}`, `"${cssVar}"`);
						set.first = selected;
					} else {
						console.warn(set.value + "needs css replacement");
					}
				}
			}

			// move elements
			if (!this.orderedSelectors) {
				this.orderedSelectors = this.orderSelectors(this.elements);
			}

			for (let selector of this.orderedSelectors) {
				if (selector) {

					let el = this.elements[selector];
					let selected = fragment.querySelector(selector);
					if (selected) {
						let running = this.runningSelectors[el.args[0]];
						if (running && running.first) {
							selected.innerHTML = ""; // Clear node
							// selected.classList.add("pagedjs_clear-after"); // Clear ::after
							let clone = running.first.cloneNode(true);
							clone.style.display = null;
							selected.appendChild(clone);
						}
					}
				}
			}
		}

		/**
		* Assign a weight to @page selector classes
		* 1) page
		* 2) left & right
		* 3) blank
		* 4) first & nth
		* 5) named page
		* 6) named left & right
		* 7) named first & nth
		* @param {string} [s] selector string
		* @return {int} weight
		*/
		pageWeight(s) {
			let weight = 1;
			let selector = s.split(" ");
			let parts = selector.length && selector[0].split(".");

			parts.shift(); // remove empty first part

			switch (parts.length) {
				case 4:
					if (parts[3] === "pagedjs_first_page") {
						weight = 7;
					} else if (parts[3] === "pagedjs_left_page" || parts[3] === "pagedjs_right_page") {
						weight = 6;
					}
					break;
				case 3:
					if (parts[1] === "pagedjs_named_page") {
						if (parts[2].indexOf(":nth-of-type") > -1) {
							weight = 7;
						} else {
							weight = 5;
						}
					}
					break;
				case 2:
					if (parts[1] === "pagedjs_first_page") {
						weight = 4;
					} else if (parts[1] === "pagedjs_blank_page") {
						weight = 3;
					} else if (parts[1] === "pagedjs_left_page" || parts[1] === "pagedjs_right_page") {
						weight = 2;
					}
					break;
				default:
					if (parts[0].indexOf(":nth-of-type") > -1) {
						weight = 4;
					} else {
						weight = 1;
					}
			}

			return weight;
		}

		/**
		* Orders the selectors based on weight
		*
		* Does not try to deduplicate base on specifity of the selector
		* Previous matched selector will just be overwritten
		* @param {obj} [obj] selectors object
		* @return {Array} orderedSelectors
		*/
		orderSelectors(obj) {
			let selectors = Object.keys(obj);
			let weighted = {
				1: [],
				2: [],
				3: [],
				4: [],
				5: [],
				6: [],
				7: []
			};

			let orderedSelectors = [];

			for (let s of selectors) {
				let w = this.pageWeight(s);
				weighted[w].unshift(s);
			}

			for (var i = 1; i <= 7; i++) {
				orderedSelectors = orderedSelectors.concat(weighted[i]);
			}

			return orderedSelectors;
		}

		beforeTreeParse(text, sheet) {
			// element(x) is parsed as image element selector, so update element to element-ident
			sheet.text = text.replace(/element[\s]*\(([^|^#)]*)\)/g, "element-ident($1)");
		}
	}

	function cleanPseudoContent(el, trim = "\"' ") {
		if(el == null) return;
		return el
			.replace(new RegExp(`^[${trim}]+`), "")
			.replace(new RegExp(`[${trim}]+$`), "")
			.replace(/["']/g, match => {
				return "\\" + match;
			})
			.replace(/[\n]/g, match => {
				return "\\00000A";
			});
	}

	function cleanSelector(el) {
		if(el == null) return;
		return el
			.replace(new RegExp("::footnote-call", "g"), "")
			.replace(new RegExp("::footnote-marker", "g"), "");
	}

	class StringSets extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.stringSetSelectors = {};
			this.type;
			// pageLastString = last string variable defined on the page 
			this.pageLastString;

		}
		
		onDeclaration(declaration, dItem, dList, rule) {
			if (declaration.property === "string-set") {
				let selector = lib.generate(rule.ruleNode.prelude);

				let identifier = declaration.value.children.first().name;

				let value;
				lib.walk(declaration, {
					visit: "Function",
					enter: (node, item, list) => {
						value = lib.generate(node);
					}
				});

				this.stringSetSelectors[identifier] = {
					identifier,
					value,
					selector
				};
			}
		}

		onContent(funcNode, fItem, fList, declaration, rule) {

			if (funcNode.name === "string") {
				let identifier = funcNode.children && funcNode.children.first().name;
				this.type = funcNode.children.last().name;
				funcNode.name = "var";
				funcNode.children = new lib.List();

	 
				if(this.type === "first" || this.type === "last" || this.type === "start" || this.type === "first-except"){
					funcNode.children.append(
						funcNode.children.createItem({
							type: "Identifier",
							loc: null,
							name: "--pagedjs-string-" + this.type + "-" + identifier
						})
					);
				}else {
					funcNode.children.append(
						funcNode.children.createItem({
							type: "Identifier",
							loc: null,
							name: "--pagedjs-string-first-" + identifier
						})
					);
				}
			}
		}

		afterPageLayout(fragment) {

		
			if ( this.pageLastString === undefined )
			{
				this.pageLastString = {};
			}
		
			
			for (let name of Object.keys(this.stringSetSelectors)) {
		
				let set = this.stringSetSelectors[name];
				let selected = fragment.querySelectorAll(set.selector);

				// Get the last found string for the current identifier
				let stringPrevPage = ( name in this.pageLastString ) ? this.pageLastString[name] : "";

				let varFirst, varLast, varStart, varFirstExcept;

				if(selected.length == 0){
					// if there is no sel. on the page
					varFirst = stringPrevPage;
					varLast = stringPrevPage;
					varStart = stringPrevPage;
					varFirstExcept = stringPrevPage;
				}else {

					selected.forEach((sel) => {
						// push each content into the array to define in the variable the first and the last element of the page.
						this.pageLastString[name] = selected[selected.length - 1].textContent;
					
					});	

					/* FIRST */
		
					varFirst = selected[0].textContent;


					/* LAST */

					varLast = selected[selected.length - 1].textContent;


					/* START */

					// Hack to find if the sel. is the first elem of the page / find a better way 
					let selTop = selected[0].getBoundingClientRect().top;
					let pageContent = selected[0].closest(".pagedjs_page_content");
					let pageContentTop = pageContent.getBoundingClientRect().top;

					if(selTop == pageContentTop){
						varStart = varFirst;
					}else {
						varStart = stringPrevPage;
					}

					/* FIRST EXCEPT */

					varFirstExcept = "";
					
				}

				fragment.style.setProperty(`--pagedjs-string-first-${name}`, `"${cleanPseudoContent(varFirst)}`);
				fragment.style.setProperty(`--pagedjs-string-last-${name}`, `"${cleanPseudoContent(varLast)}`);
				fragment.style.setProperty(`--pagedjs-string-start-${name}`, `"${cleanPseudoContent(varStart)}`);
				fragment.style.setProperty(`--pagedjs-string-first-except-${name}`, `"${cleanPseudoContent(varFirstExcept)}`);
				
		
			}
		}
		

	}

	class TargetCounters extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;

			this.counterTargets = {};
		}

		onContent(funcNode, fItem, fList, declaration, rule) {
			if (funcNode.name === "target-counter") {
				let selector = lib.generate(rule.ruleNode.prelude);

				let first = funcNode.children.first();
				let func = first.name;

				let value = lib.generate(funcNode);

				let args = [];

				first.children.forEach((child) => {
					if (child.type === "Identifier") {

						args.push(child.name);
					}
				});

				let counter;
				let style;
				let styleIdentifier;

				funcNode.children.forEach((child) => {
					if (child.type === "Identifier") {
						if (!counter) {
							counter = child.name;
						} else if (!style) {
							styleIdentifier = lib.clone(child);
							style = child.name;
						}
					}
				});

				let variable = "target-counter-" + UUID();

				selector.split(",").forEach((s) => {
					this.counterTargets[s] = {
						func: func,
						args: args,
						value: value,
						counter: counter,
						style: style,
						selector: s,
						fullSelector: selector,
						variable: variable
					};
				});

				// Replace with counter
				funcNode.name = "counter";
				funcNode.children = new lib.List();
				funcNode.children.appendData({
					type: "Identifier",
					loc: 0,
					name: variable
				});

				if (styleIdentifier) {
					funcNode.children.appendData({type: "Operator", loc: null, value: ","});
					funcNode.children.appendData(styleIdentifier);
				}
			}
		}

		afterPageLayout(fragment, page, breakToken, chunker) {
			Object.keys(this.counterTargets).forEach((name) => {
				let target = this.counterTargets[name];
				let split = target.selector.split("::");
				let query = split[0];

				let queried = chunker.pagesArea.querySelectorAll(query + ":not([data-" + target.variable + "])");

				queried.forEach((selected, index) => {
					// TODO: handle func other than attr
					if (target.func !== "attr") {
						return;
					}
					let val = attr(selected, target.args);
					let element = chunker.pagesArea.querySelector(querySelectorEscape(val));

					if (element) {
						let selector = UUID();
						selected.setAttribute("data-" + target.variable, selector);
						// TODO: handle other counter types (by query)
						let pseudo = "";
						if (split.length > 1) {
							pseudo += "::" + split[1];
						}
						if (target.counter === "page") {
							let pages = chunker.pagesArea.querySelectorAll(".pagedjs_page");
							let pg = 0;
							for (let i = 0; i < pages.length; i++) {
								let styles = window.getComputedStyle(pages[i]);
								let reset = styles["counter-reset"].replace("page", "").trim();
								let increment = styles["counter-increment"].replace("page", "").trim();

								if (reset !== "none") {
									pg = parseInt(reset);
								}
								if (increment !== "none") {
									pg += parseInt(increment);
								}

								if (pages[i].contains(element)) {
									break;
								}
							}

							this.styleSheet.insertRule(`[data-${target.variable}="${selector}"]${pseudo} { counter-reset: ${target.variable} ${pg}; }`, this.styleSheet.cssRules.length);
						} else {
							let value = element.getAttribute(`data-counter-${target.counter}-value`);
							if (value) {
								this.styleSheet.insertRule(`[data-${target.variable}="${selector}"]${pseudo} { counter-reset: ${target.variable} ${target.variable} ${parseInt(value)}; }`, this.styleSheet.cssRules.length);
							}
						}
					}
				});
			});
		}
	}

	// import { nodeAfter } from "../../utils/dom";

	class TargetText extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;
			this.textTargets = {};
			this.beforeContent = "";
			this.afterContent = "";
			this.selector = {};
		}

		onContent(funcNode, fItem, fList, declaration, rule) {
			if (funcNode.name === "target-text") {
				this.selector = lib.generate(rule.ruleNode.prelude);
				let first = funcNode.children.first();
				let last = funcNode.children.last();
				let func = first.name;

				let value = lib.generate(funcNode);

				let args = [];

				first.children.forEach(child => {
					if (child.type === "Identifier") {
						args.push(child.name);
					}
				});

				let style;
				if (last !== first) {
					style = last.name;
				}

				let variable = "--pagedjs-" + UUID();

				this.selector.split(",").forEach(s => {
					this.textTargets[s] = {
						func: func,
						args: args,
						value: value,
						style: style || "content",
						selector: s,
						fullSelector: this.selector,
						variable: variable
					};
				});

				// Replace with variable
				funcNode.name = "var";
				funcNode.children = new lib.List();
				funcNode.children.appendData({
					type: "Identifier",
					loc: 0,
					name: variable
				});
			}
		}

		//   parse this on the ONCONTENT : get all before and after and replace the value with a variable
		onPseudoSelector(pseudoNode, pItem, pList, selector, rule) {
			// console.log(pseudoNode);
			// console.log(rule);

			rule.ruleNode.block.children.forEach(properties => {
				if (pseudoNode.name === "before" && properties.property === "content") {
					// let beforeVariable = "--pagedjs-" + UUID();

					let contenu = properties.value.children;
					contenu.forEach(prop => {
						if (prop.type === "String") {
							this.beforeContent = prop.value;
						}
					});
				} else if (pseudoNode.name === "after" && properties.property === "content") {
					properties.value.children.forEach(prop => {
						if (prop.type === "String") {
							this.afterContent = prop.value;
						}
					});
				}
			});
		}

		afterParsed(fragment) {
			Object.keys(this.textTargets).forEach(name => {
				let target = this.textTargets[name];
				let split = target.selector.split("::");
				let query = split[0];
				let queried = fragment.querySelectorAll(query);
				let textContent;
				queried.forEach((selected, index) => {
					let val = attr(selected, target.args);
					let element = fragment.querySelector(querySelectorEscape(val));
					if (element) {
						// content & first-letter & before & after refactorized
						if (target.style) {
							this.selector = UUID();
							selected.setAttribute("data-target-text", this.selector);

							let psuedo = "";
							if (split.length > 1) {
								psuedo += "::" + split[1];
							}
							
							if (target.style === "before" || target.style === "after") {
								const pseudoType = `${target.style}Content`;
								textContent = cleanPseudoContent(this[pseudoType]);
							} else {
								textContent = cleanPseudoContent(element.textContent, " ");
							}
							textContent = target.style === "first-letter" ? textContent.charAt(0) : textContent;
							this.styleSheet.insertRule(`[data-target-text="${this.selector}"]${psuedo} { ${target.variable}: "${textContent}" }`);
						} else {
							console.warn("missed target", val);
						}
					}
				});
			});
		}
	}

	var generatedContentHandlers = [
		RunningHeaders,
		StringSets,
		TargetCounters,
		TargetText
	];

	class WhiteSpaceFilter extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}

		filter(content) {

			filterTree(content, (node) => {
				return this.filterEmpty(node);
			}, NodeFilter.SHOW_TEXT);

		}

		filterEmpty(node) {
			if (node.textContent.length > 1 && isIgnorable(node)) {

				// Do not touch the content if text is pre-formatted
				let parent = node.parentNode;
				let pre = isElement(parent) && parent.closest("pre");
				if (pre) {
					return NodeFilter.FILTER_REJECT;
				}

				const previousSibling = previousSignificantNode(node);
				const nextSibling = nextSignificantNode(node);

				if (nextSibling === null && previousSibling === null) {
					// we should not remove a Node that does not have any siblings.
					node.textContent = " ";
					return NodeFilter.FILTER_REJECT;
				}
				if (nextSibling === null) {
					// we can safely remove this node
					return NodeFilter.FILTER_ACCEPT;
				}
				if (previousSibling === null) {
					// we can safely remove this node
					return NodeFilter.FILTER_ACCEPT;
				}

				// replace the content with a single space
				node.textContent = " ";

				// TODO: we also need to preserve sequences of white spaces when the parent has "white-space" rule:
				// pre
				// Sequences of white space are preserved. Lines are only broken at newline characters in the source and at <br> elements.
				//
				// pre-wrap
				// Sequences of white space are preserved. Lines are broken at newline characters, at <br>, and as necessary to fill line boxes.
				//
				// pre-line
				// Sequences of white space are collapsed. Lines are broken at newline characters, at <br>, and as necessary to fill line boxes.
				//
				// break-spaces
				// The behavior is identical to that of pre-wrap, except that:
				// - Any sequence of preserved white space always takes up space, including at the end of the line.
				// - A line breaking opportunity exists after every preserved white space character, including between white space characters.
				// - Such preserved spaces take up space and do not hang, and thus affect the box’s intrinsic sizes (min-content size and max-content size).
				//
				// See: https://developer.mozilla.org/en-US/docs/Web/CSS/white-space#Values

				return NodeFilter.FILTER_REJECT;
			} else {
				return NodeFilter.FILTER_REJECT;
			}
		}

	}

	class CommentsFilter extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}

		filter(content) {
			filterTree(content, null, NodeFilter.SHOW_COMMENT);
		}

	}

	class ScriptsFilter extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}

		filter(content) {
			content.querySelectorAll("script").forEach( script => { script.remove(); });
		}

	}

	var clearCut = createCommonjsModule(function (module, exports) {
	/**
	 * Originally ported from https://github.com/keeganstreet/specificity/blob/866bf7ab4e7f62a7179c15b13a95af4e1c7b1afa/specificity.js
	 *
	 * Calculates the specificity of CSS selectors
	 * http://www.w3.org/TR/css3-selectors/#specificity
	 *
	 * Returns a selector integer value
	 */

	// The following regular expressions assume that selectors matching the preceding regular expressions have been removed
	var attributeRegex = /(\[[^\]]+\])/g;
	var idRegex = /(#[^\s\+>~\.\[:]+)/g;
	var classRegex = /(\.[^\s\+>~\.\[:]+)/g;
	var pseudoElementRegex = /(::[^\s\+>~\.\[:]+|:first-line|:first-letter|:before|:after)/g;
	var pseudoClassRegex = /(:[^\s\+>~\.\[:]+)/g;
	var elementRegex = /([^\s\+>~\.\[:]+)/g;
	var notRegex = /:not\(([^\)]*)\)/g;
	var ruleRegex = /\{[^]*/gm;
	var separatorRegex = /[\*\s\+>~]/g;
	var straysRegex = /[#\.]/g;

	// Find matches for a regular expression in a string and push their details to parts
	// Type is "a" for IDs, "b" for classes, attributes and pseudo-classes and "c" for elements and pseudo-elements
	var findMatch = function(regex, type, types, selector) {
	  var matches = selector.match(regex);
	  if (matches) {
	    for (var i = 0; i < matches.length; i++) {
	      types[type]++;
	      // Replace this simple selector with whitespace so it won't be counted in further simple selectors
	      selector = selector.replace(matches[i], ' ');
	    }
	  }

	  return selector;
	};

	// Calculate the specificity for a selector by dividing it into simple selectors and counting them
	var calculate = function(selector) {
	  var commaIndex = selector.indexOf(',');
	  if (commaIndex !== -1) {
	    selector = selector.substring(0, commaIndex);
	  }

	  var  types = {
	    a: 0,
	    b: 0,
	    c: 0
	  };

	  // Remove the negation psuedo-class (:not) but leave its argument because specificity is calculated on its argument
	  selector = selector.replace(notRegex, ' $1 ');

	  // Remove anything after a left brace in case a user has pasted in a rule, not just a selector
	  selector = selector.replace(ruleRegex, ' ');

	  // Add attribute selectors to parts collection (type b)
	  selector = findMatch(attributeRegex, 'b', types, selector);

	  // Add ID selectors to parts collection (type a)
	  selector = findMatch(idRegex, 'a', types, selector);

	  // Add class selectors to parts collection (type b)
	  selector = findMatch(classRegex, 'b', types, selector);

	  // Add pseudo-element selectors to parts collection (type c)
	  selector = findMatch(pseudoElementRegex, 'c', types, selector);

	  // Add pseudo-class selectors to parts collection (type b)
	  selector = findMatch(pseudoClassRegex, 'b', types, selector);

	  // Remove universal selector and separator characters
	  selector = selector.replace(separatorRegex, ' ');

	  // Remove any stray dots or hashes which aren't attached to words
	  // These may be present if the user is live-editing this selector
	  selector = selector.replace(straysRegex, ' ');

	  // The only things left should be element selectors (type c)
	  findMatch(elementRegex, 'c', types, selector);

	  return (types.a * 100) + (types.b * 10) + (types.c * 1);
	};

	var specificityCache = {};

	exports.calculateSpecificity = function(selector) {
	  var specificity = specificityCache[selector];
	  if (specificity === undefined) {
	    specificity = calculate(selector);
	    specificityCache[selector] = specificity;
	  }
	  return specificity;
	};

	var validSelectorCache = {};
	var testSelectorElement = null;

	exports.isSelectorValid = function(selector) {
	  var valid = validSelectorCache[selector];
	  if (valid === undefined) {
	    if (testSelectorElement == null) {
	      testSelectorElement = document.createElement('div');
	    }

	    try {
	      testSelectorElement.querySelector(selector);
	      valid = true;
	    } catch (error) {
	      valid = false;
	    }
	    validSelectorCache[selector] = valid;
	  }
	  return valid;
	};

	exports.validateSelector = function(selector) {
	  if (!exports.isSelectorValid(selector)) {
	    var error = new SyntaxError(selector + ' is not a valid selector');
	    error.code = 'EBADSELECTOR';
	    throw error;
	  }
	};
	});
	var clearCut_1 = clearCut.calculateSpecificity;
	var clearCut_2 = clearCut.isSelectorValid;
	var clearCut_3 = clearCut.validateSelector;

	class UndisplayedFilter extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
			this.displayRules = {};
		}

		onDeclaration(declaration, dItem, dList, rule) {
			if (declaration.property === "display") {
				let selector = lib.generate(rule.ruleNode.prelude);
				let value = declaration.value.children.first().name;

				selector.split(",").forEach((s) => {
					this.displayRules[s] = {
						value: value,
						selector: s,
						specificity: clearCut_1(s),
						important: declaration.important
					};
				});
			}
		}

		filter(content) {
			let { matches, selectors } = this.sortDisplayedSelectors(content, this.displayRules);

			// Find matching elements that have display styles
			for (let i = 0; i < matches.length; i++) {
				let element = matches[i];
				let selector = selectors[i];
				let displayValue = selector[selector.length-1].value;
				if(this.removable(element) && displayValue === "none") {
					element.dataset.undisplayed = "undisplayed";
				}
			}

			// Find elements that have inline styles
			let styledElements = content.querySelectorAll("[style]");
			for (let i = 0; i < styledElements.length; i++) {
				let element = styledElements[i];
				if (this.removable(element)) {
					element.dataset.undisplayed = "undisplayed";
				}
			}
		}

		sorter(a, b) {
			if (a.important && !b.important) {
				return 1;
			}

			if (b.important && !a.important) {
				return -1;
			}

			return a.specificity - b.specificity;
		}

		sortDisplayedSelectors(content, displayRules=[]) {
			let matches = [];
			let selectors = [];
			for (let d in displayRules) {
				let displayItem = displayRules[d];
				let selector = displayItem.selector;
				let query = [];
				try {
					try {
						query = content.querySelectorAll(selector);
					} catch (e) {
						query = content.querySelectorAll(cleanSelector(selector));
					}
				} catch (e) {
					query = [];
				}
				let elements = Array.from(query);
				for (let e of elements) {
					if (matches.includes(e)) {
						let index = matches.indexOf(e);
						selectors[index].push(displayItem);
						selectors[index] = selectors[index].sort(this.sorter);
					} else {
						matches.push(e);
						selectors.push([displayItem]);
					}
				}
			}

			return { matches, selectors };
		}

		removable(element) {
			if (element.style &&
					element.style.display !== "" &&
					element.style.display !== "none") {
				return false;
			}

			return true;
		}
	}

	var filters = [
		WhiteSpaceFilter,
		CommentsFilter,
		ScriptsFilter,
		UndisplayedFilter
	];

	var isImplemented$3 = function () {
		var from = Array.from, arr, result;
		if (typeof from !== "function") return false;
		arr = ["raz", "dwa"];
		result = from(arr);
		return Boolean(result && (result !== arr) && (result[1] === "dwa"));
	};

	var validTypes = { object: true, symbol: true };

	var isImplemented$4 = function () {
		var symbol;
		if (typeof Symbol !== 'function') return false;
		symbol = Symbol('test symbol');
		try { String(symbol); } catch (e) { return false; }

		// Return 'true' also for polyfills
		if (!validTypes[typeof Symbol.iterator]) return false;
		if (!validTypes[typeof Symbol.toPrimitive]) return false;
		if (!validTypes[typeof Symbol.toStringTag]) return false;

		return true;
	};

	var isSymbol = function (x) {
		if (!x) return false;
		if (typeof x === 'symbol') return true;
		if (!x.constructor) return false;
		if (x.constructor.name !== 'Symbol') return false;
		return (x[x.constructor.toStringTag] === 'Symbol');
	};

	var validateSymbol = function (value) {
		if (!isSymbol(value)) throw new TypeError(value + " is not a symbol");
		return value;
	};

	var create$6 = Object.create, defineProperties = Object.defineProperties
	  , defineProperty = Object.defineProperty, objPrototype = Object.prototype
	  , NativeSymbol, SymbolPolyfill, HiddenSymbol, globalSymbols = create$6(null)
	  , isNativeSafe;

	if (typeof Symbol === 'function') {
		NativeSymbol = Symbol;
		try {
			String(NativeSymbol());
			isNativeSafe = true;
		} catch (ignore) {}
	}

	var generateName = (function () {
		var created = create$6(null);
		return function (desc) {
			var postfix = 0, name, ie11BugWorkaround;
			while (created[desc + (postfix || '')]) ++postfix;
			desc += (postfix || '');
			created[desc] = true;
			name = '@@' + desc;
			defineProperty(objPrototype, name, d_1.gs(null, function (value) {
				// For IE11 issue see:
				// https://connect.microsoft.com/IE/feedbackdetail/view/1928508/
				//    ie11-broken-getters-on-dom-objects
				// https://github.com/medikoo/es6-symbol/issues/12
				if (ie11BugWorkaround) return;
				ie11BugWorkaround = true;
				defineProperty(this, name, d_1(value));
				ie11BugWorkaround = false;
			}));
			return name;
		};
	}());

	// Internal constructor (not one exposed) for creating Symbol instances.
	// This one is used to ensure that `someSymbol instanceof Symbol` always return false
	HiddenSymbol = function Symbol(description) {
		if (this instanceof HiddenSymbol) throw new TypeError('Symbol is not a constructor');
		return SymbolPolyfill(description);
	};

	// Exposed `Symbol` constructor
	// (returns instances of HiddenSymbol)
	var polyfill = SymbolPolyfill = function Symbol(description) {
		var symbol;
		if (this instanceof Symbol) throw new TypeError('Symbol is not a constructor');
		if (isNativeSafe) return NativeSymbol(description);
		symbol = create$6(HiddenSymbol.prototype);
		description = (description === undefined ? '' : String(description));
		return defineProperties(symbol, {
			__description__: d_1('', description),
			__name__: d_1('', generateName(description))
		});
	};
	defineProperties(SymbolPolyfill, {
		for: d_1(function (key) {
			if (globalSymbols[key]) return globalSymbols[key];
			return (globalSymbols[key] = SymbolPolyfill(String(key)));
		}),
		keyFor: d_1(function (s) {
			var key;
			validateSymbol(s);
			for (key in globalSymbols) if (globalSymbols[key] === s) return key;
		}),

		// To ensure proper interoperability with other native functions (e.g. Array.from)
		// fallback to eventual native implementation of given symbol
		hasInstance: d_1('', (NativeSymbol && NativeSymbol.hasInstance) || SymbolPolyfill('hasInstance')),
		isConcatSpreadable: d_1('', (NativeSymbol && NativeSymbol.isConcatSpreadable) ||
			SymbolPolyfill('isConcatSpreadable')),
		iterator: d_1('', (NativeSymbol && NativeSymbol.iterator) || SymbolPolyfill('iterator')),
		match: d_1('', (NativeSymbol && NativeSymbol.match) || SymbolPolyfill('match')),
		replace: d_1('', (NativeSymbol && NativeSymbol.replace) || SymbolPolyfill('replace')),
		search: d_1('', (NativeSymbol && NativeSymbol.search) || SymbolPolyfill('search')),
		species: d_1('', (NativeSymbol && NativeSymbol.species) || SymbolPolyfill('species')),
		split: d_1('', (NativeSymbol && NativeSymbol.split) || SymbolPolyfill('split')),
		toPrimitive: d_1('', (NativeSymbol && NativeSymbol.toPrimitive) || SymbolPolyfill('toPrimitive')),
		toStringTag: d_1('', (NativeSymbol && NativeSymbol.toStringTag) || SymbolPolyfill('toStringTag')),
		unscopables: d_1('', (NativeSymbol && NativeSymbol.unscopables) || SymbolPolyfill('unscopables'))
	});

	// Internal tweaks for real symbol producer
	defineProperties(HiddenSymbol.prototype, {
		constructor: d_1(SymbolPolyfill),
		toString: d_1('', function () { return this.__name__; })
	});

	// Proper implementation of methods exposed on Symbol.prototype
	// They won't be accessible on produced symbol instances as they derive from HiddenSymbol.prototype
	defineProperties(SymbolPolyfill.prototype, {
		toString: d_1(function () { return 'Symbol (' + validateSymbol(this).__description__ + ')'; }),
		valueOf: d_1(function () { return validateSymbol(this); })
	});
	defineProperty(SymbolPolyfill.prototype, SymbolPolyfill.toPrimitive, d_1('', function () {
		var symbol = validateSymbol(this);
		if (typeof symbol === 'symbol') return symbol;
		return symbol.toString();
	}));
	defineProperty(SymbolPolyfill.prototype, SymbolPolyfill.toStringTag, d_1('c', 'Symbol'));

	// Proper implementaton of toPrimitive and toStringTag for returned symbol instances
	defineProperty(HiddenSymbol.prototype, SymbolPolyfill.toStringTag,
		d_1('c', SymbolPolyfill.prototype[SymbolPolyfill.toStringTag]));

	// Note: It's important to define `toPrimitive` as last one, as some implementations
	// implement `toPrimitive` natively without implementing `toStringTag` (or other specified symbols)
	// And that may invoke error in definition flow:
	// See: https://github.com/medikoo/es6-symbol/issues/13#issuecomment-164146149
	defineProperty(HiddenSymbol.prototype, SymbolPolyfill.toPrimitive,
		d_1('c', SymbolPolyfill.prototype[SymbolPolyfill.toPrimitive]));

	var es6Symbol = isImplemented$4() ? Symbol : polyfill;

	var objToString = Object.prototype.toString
	  , id = objToString.call(
		(function () {
			return arguments;
		})()
	);

	var isArguments = function (value) {
		return objToString.call(value) === id;
	};

	var objToString$1 = Object.prototype.toString, id$1 = objToString$1.call(noop);

	var isFunction = function (value) {
		return typeof value === "function" && objToString$1.call(value) === id$1;
	};

	var isImplemented$5 = function () {
		var sign = Math.sign;
		if (typeof sign !== "function") return false;
		return (sign(10) === 1) && (sign(-20) === -1);
	};

	var shim$3 = function (value) {
		value = Number(value);
		if (isNaN(value) || (value === 0)) return value;
		return value > 0 ? 1 : -1;
	};

	var sign = isImplemented$5()
		? Math.sign
		: shim$3;

	var abs = Math.abs, floor = Math.floor;

	var toInteger = function (value) {
		if (isNaN(value)) return 0;
		value = Number(value);
		if ((value === 0) || !isFinite(value)) return value;
		return sign(value) * floor(abs(value));
	};

	var max$1 = Math.max;

	var toPosInteger = function (value) {
	 return max$1(0, toInteger(value));
	};

	var objToString$2 = Object.prototype.toString, id$2 = objToString$2.call("");

	var isString = function (value) {
		return (
			typeof value === "string" ||
			(value &&
				typeof value === "object" &&
				(value instanceof String || objToString$2.call(value) === id$2)) ||
			false
		);
	};

	var iteratorSymbol = es6Symbol.iterator
	  , isArray        = Array.isArray
	  , call           = Function.prototype.call
	  , desc           = { configurable: true, enumerable: true, writable: true, value: null }
	  , defineProperty$1 = Object.defineProperty;

	// eslint-disable-next-line complexity
	var shim$4 = function (arrayLike /*, mapFn, thisArg*/) {
		var mapFn = arguments[1]
		  , thisArg = arguments[2]
		  , Context
		  , i
		  , j
		  , arr
		  , length
		  , code
		  , iterator
		  , result
		  , getIterator
		  , value;

		arrayLike = Object(validValue(arrayLike));

		if (isValue(mapFn)) validCallable(mapFn);
		if (!this || this === Array || !isFunction(this)) {
			// Result: Plain array
			if (!mapFn) {
				if (isArguments(arrayLike)) {
					// Source: Arguments
					length = arrayLike.length;
					if (length !== 1) return Array.apply(null, arrayLike);
					arr = new Array(1);
					arr[0] = arrayLike[0];
					return arr;
				}
				if (isArray(arrayLike)) {
					// Source: Array
					arr = new Array(length = arrayLike.length);
					for (i = 0; i < length; ++i) arr[i] = arrayLike[i];
					return arr;
				}
			}
			arr = [];
		} else {
			// Result: Non plain array
			Context = this;
		}

		if (!isArray(arrayLike)) {
			if ((getIterator = arrayLike[iteratorSymbol]) !== undefined) {
				// Source: Iterator
				iterator = validCallable(getIterator).call(arrayLike);
				if (Context) arr = new Context();
				result = iterator.next();
				i = 0;
				while (!result.done) {
					value = mapFn ? call.call(mapFn, thisArg, result.value, i) : result.value;
					if (Context) {
						desc.value = value;
						defineProperty$1(arr, i, desc);
					} else {
						arr[i] = value;
					}
					result = iterator.next();
					++i;
				}
				length = i;
			} else if (isString(arrayLike)) {
				// Source: String
				length = arrayLike.length;
				if (Context) arr = new Context();
				for (i = 0, j = 0; i < length; ++i) {
					value = arrayLike[i];
					if (i + 1 < length) {
						code = value.charCodeAt(0);
						// eslint-disable-next-line max-depth
						if (code >= 0xd800 && code <= 0xdbff) value += arrayLike[++i];
					}
					value = mapFn ? call.call(mapFn, thisArg, value, j) : value;
					if (Context) {
						desc.value = value;
						defineProperty$1(arr, j, desc);
					} else {
						arr[j] = value;
					}
					++j;
				}
				length = j;
			}
		}
		if (length === undefined) {
			// Source: array or array-like
			length = toPosInteger(arrayLike.length);
			if (Context) arr = new Context(length);
			for (i = 0; i < length; ++i) {
				value = mapFn ? call.call(mapFn, thisArg, arrayLike[i], i) : arrayLike[i];
				if (Context) {
					desc.value = value;
					defineProperty$1(arr, i, desc);
				} else {
					arr[i] = value;
				}
			}
		}
		if (Context) {
			desc.value = null;
			arr.length = length;
		}
		return arr;
	};

	var from_1 = isImplemented$3()
		? Array.from
		: shim$4;

	var isImplemented$6 = function () {
		var numberIsNaN = Number.isNaN;
		if (typeof numberIsNaN !== "function") return false;
		return !numberIsNaN({}) && numberIsNaN(NaN) && !numberIsNaN(34);
	};

	var shim$5 = function (value) {
		// eslint-disable-next-line no-self-compare
		return value !== value;
	};

	var isNan = isImplemented$6()
		? Number.isNaN
		: shim$5;

	var indexOf$2           = Array.prototype.indexOf
	  , objHasOwnProperty = Object.prototype.hasOwnProperty
	  , abs$1               = Math.abs
	  , floor$1             = Math.floor;

	var eIndexOf = function (searchElement /*, fromIndex*/) {
		var i, length, fromIndex, val;
		if (!isNan(searchElement)) return indexOf$2.apply(this, arguments);

		length = toPosInteger(validValue(this).length);
		fromIndex = arguments[1];
		if (isNaN(fromIndex)) fromIndex = 0;
		else if (fromIndex >= 0) fromIndex = floor$1(fromIndex);
		else fromIndex = toPosInteger(this.length) - floor$1(abs$1(fromIndex));

		for (i = fromIndex; i < length; ++i) {
			if (objHasOwnProperty.call(this, i)) {
				val = this[i];
				if (isNan(val)) return i; // Jslint: ignore
			}
		}
		return -1;
	};

	var forEach$1 = Array.prototype.forEach
	  , splice  = Array.prototype.splice;

	// eslint-disable-next-line no-unused-vars
	var remove = function (itemToRemove /*, …item*/) {
		forEach$1.call(
			arguments,
			function (item) {
				var index = eIndexOf.call(this, item);
				if (index !== -1) splice.call(this, index, 1);
			},
			this
		);
	};

	var map = { function: true, object: true };

	var isObject$1 = function (value) {
		return (isValue(value) && map[typeof value]) || false;
	};

	var validObject = function (value) {
		if (!isObject$1(value)) throw new TypeError(value + " is not an Object");
		return value;
	};

	var emit           = eventEmitter.methods.emit

	  , defineProperty$2 = Object.defineProperty
	  , hasOwnProperty$6 = Object.prototype.hasOwnProperty
	  , getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;

	var pipe = function (e1, e2/*, name*/) {
		var pipes, pipe, desc, name;

		(validObject(e1) && validObject(e2));
		name = arguments[2];
		if (name === undefined) name = 'emit';

		pipe = {
			close: function () { remove.call(pipes, e2); }
		};
		if (hasOwnProperty$6.call(e1, '__eePipes__')) {
			(pipes = e1.__eePipes__).push(e2);
			return pipe;
		}
		defineProperty$2(e1, '__eePipes__', d_1('c', pipes = [e2]));
		desc = getOwnPropertyDescriptor(e1, name);
		if (!desc) {
			desc = d_1('c', undefined);
		} else {
			delete desc.get;
			delete desc.set;
		}
		desc.value = function () {
			var i, emitter, data = from_1(pipes);
			emit.apply(this, arguments);
			for (i = 0; (emitter = data[i]); ++i) emit.apply(emitter, arguments);
		};
		defineProperty$2(e1, name, desc);
		return pipe;
	};

	let registeredHandlers = [...pagedMediaHandlers, ...generatedContentHandlers, ...filters];

	class Handlers {
		constructor(chunker, polisher, caller) {

			registeredHandlers.forEach((Handler) => {
				let handler = new Handler(chunker, polisher, caller);
				pipe(handler, this);
			});
		}
	}

	eventEmitter(Handlers.prototype);

	function registerHandlers() {
		for (var i = 0; i < arguments.length; i++) {
			registeredHandlers.push(arguments[i]);
		}
	}

	function initializeHandlers(chunker, polisher, caller) {
		let handlers = new Handlers(chunker, polisher, caller);
		return handlers;
	}

	class Previewer {
		constructor(options) {
			// this.preview = this.getParams("preview") !== "false";

			this.settings = options || {};

			// Process styles
			this.polisher = new Polisher(false);

			// Chunk contents
			this.chunker = new Chunker(undefined, undefined, this.settings);

			// Hooks
			this.hooks = {};
			this.hooks.beforePreview = new Hook(this);
			this.hooks.afterPreview = new Hook(this);

			// default size
			this.size = {
				width: {
					value: 8.5,
					unit: "in"
				},
				height: {
					value: 11,
					unit: "in"
				},
				format: undefined,
				orientation: undefined
			};

			this.chunker.on("page", (page) => {
				this.emit("page", page);
			});

			this.chunker.on("rendering", () => {
				this.emit("rendering", this.chunker);
			});
		}

		initializeHandlers() {
			let handlers = initializeHandlers(this.chunker, this.polisher, this);

			handlers.on("size", (size) => {
				this.size = size;
				this.emit("size", size);
			});

			handlers.on("atpages", (pages) => {
				this.atpages = pages;
				this.emit("atpages", pages);
			});

			return handlers;
		}

		registerHandlers() {
			return registerHandlers.apply(registerHandlers, arguments);
		}

		getParams(name) {
			let param;
			let url = new URL(window.location);
			let params = new URLSearchParams(url.search);
			for(var pair of params.entries()) {
				if(pair[0] === name) {
					param = pair[1];
				}
			}

			return param;
		}

		wrapContent() {
			// Wrap body in template tag
			let body = document.querySelector("body");

			// Check if a template exists
			let template;
			template = body.querySelector(":scope > template[data-ref='pagedjs-content']");

			if (!template) {
				// Otherwise create one
				template = document.createElement("template");
				template.dataset.ref = "pagedjs-content";
				template.innerHTML = body.innerHTML;
				body.innerHTML = "";
				body.appendChild(template);
			}

			return template.content;
		}

		removeStyles(doc=document) {
			// Get all stylesheets
			let stylesheets = Array.from(doc.querySelectorAll("link[rel='stylesheet']"));
			let hrefs = stylesheets.map((sheet) => {
				sheet.remove();
				return sheet.href;
			});

			// Get inline styles
			let inlineStyles = Array.from(doc.querySelectorAll("style:not([data-pagedjs-inserted-styles])"));
			inlineStyles.forEach((inlineStyle) => {
				let obj = {};
				obj[window.location.href] = inlineStyle.textContent;
				hrefs.push(obj);
				inlineStyle.remove();
			});

			return hrefs;
		}

		async preview(content, stylesheets, renderTo) {

			await this.hooks.beforePreview.trigger(content, renderTo);

			if (!content) {
				content = this.wrapContent();
			}

			if (!stylesheets) {
				stylesheets = this.removeStyles();
			}

			this.polisher.setup();

			this.handlers = this.initializeHandlers();

			await this.polisher.add(...stylesheets);

			let startTime = performance.now();

			// Render flow
			let flow = await this.chunker.flow(content, renderTo);

			let endTime = performance.now();

			flow.performance = (endTime - startTime);
			flow.size = this.size;

			this.emit("rendered", flow);

			await this.hooks.afterPreview.trigger(flow.pages);

			return flow;
		}
	}

	eventEmitter(Previewer.prototype);

	var Paged = /*#__PURE__*/Object.freeze({
		__proto__: null,
		Chunker: Chunker,
		Polisher: Polisher,
		Previewer: Previewer,
		Handler: Handler,
		registerHandlers: registerHandlers,
		initializeHandlers: initializeHandlers
	});

	window.Paged = Paged;

	let ready = new Promise(function(resolve, reject){
		if (document.readyState === "interactive" || document.readyState === "complete") {
			resolve(document.readyState);
			return;
		}

		document.onreadystatechange = function ($) {
			if (document.readyState === "interactive") {
				resolve(document.readyState);
			}
		};
	});

	let config = window.PagedConfig || {
		auto: true,
		before: undefined,
		after: undefined,
		content: undefined,
		stylesheets: undefined,
		renderTo: undefined,
		settings: undefined
	};

	let previewer = new Previewer(config.settings);

	ready.then(async function () {
		let done;
		if (config.before) {
			await config.before();
		}

		if(config.auto !== false) {
			done = await previewer.preview(config.content, config.stylesheets, config.renderTo);
		}


		if (config.after) {
			await config.after(done);
		}
	});

	return previewer;

})));
</script>
<script>// Hooks for paged.js
{
  // Utils
  let pandocMeta, pandocMetaToString;
  {
    let el = document.getElementById('pandoc-meta');
    pandocMeta = el ? JSON.parse(el.firstChild.data) : {};
  }

  pandocMetaToString = meta => {
    let el = document.createElement('div');
    el.innerHTML = meta;
    return el.innerText;
  };

  let isString = value => {
    return typeof value === 'string' || value instanceof String;
  };

  let isArray = value => {
    return value && typeof value === 'object' && value.constructor === Array;
  };

  // This hook is an attempt to fix https://github.com/rstudio/pagedown/issues/131
  // Sometimes, the {break-after: avoid;} declaration applied on headers
  // lead to duplicated headers. I hate this bug.
  // This is linked to the way the HTML source is written
  // When we have the \n character like this: <div>\n<h1>...</h1>
  // the header may be duplicated.
  // But, if we have <div><h1>...</h1> without any \n, the problem disappear
  // I think this handler can fix most of cases
  // Obviously, we cannot suppress all the \n in the HTML document
  // because carriage returns are important in <pre> elements.
  // Tested with Chrome 76.0.3809.100/Windows
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
      this.carriageReturn = String.fromCharCode(10);
    }

    checkNode(node) {
      if (!node) return;
      if (node.nodeType !== 3) return;
      if (node.textContent === this.carriageReturn) {
        node.remove();
      }
    }

    afterParsed(parsed) {
      let template = document.querySelector('template').content;
      const breakAfterAvoidElements = template.querySelectorAll('[data-break-after="avoid"], [data-break-before="avoid"]');
      for (let el of breakAfterAvoidElements) {
        this.checkNode(el.previousSibling);
        this.checkNode(el.nextSibling);
      }
    }
  });

  // This hook creates a list of abbreviations
  // Note: we also could implement this feature using a Pandoc filter
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }
    beforeParsed(content) {
      // Find the abbreviation nodes
      const abbrNodeList = content.querySelectorAll('abbr');

      // Return early if there is no abbreviation
      if (abbrNodeList.length === 0) return;

      // Store unique values of abbreviations, see https://github.com/rstudio/pagedown/issues/218
      let abbreviations = [];
      for (const {title, innerHTML} of abbrNodeList.values()) {
        if (abbreviations.find(el => el.title === title && el.innerHTML === innerHTML)) {
          continue;
        }
        abbreviations.push({title: title, innerHTML: innerHTML});
      }

      const loaTitle = pandocMeta['loa-title'] ? pandocMetaToString(pandocMeta['loa-title']) : 'List of Abbreviations';
      const loaId = 'LOA';
      const tocList = content.querySelector('.toc ul');
      let listOfAbbreviations = document.createElement('div');
      let descriptionList = document.createElement('dl');
      content.appendChild(listOfAbbreviations);
      listOfAbbreviations.id = loaId;
      listOfAbbreviations.classList.add('section', 'front-matter', 'level1', 'loa');
      listOfAbbreviations.innerHTML = '<h1>' + loaTitle + '</h1>';
      listOfAbbreviations.appendChild(descriptionList);
      for(let abbr of abbreviations) {
        if(!abbr.title) continue;
        let term = document.createElement('dt');
        let definition = document.createElement('dd');
        descriptionList.appendChild(term);
        descriptionList.appendChild(definition);
        term.innerHTML = abbr.innerHTML;
        definition.innerText = abbr.title;
      }
      if (tocList) {
        const loaTOCItem = document.createElement('li');
        loaTOCItem.innerHTML = '<a href="#' + loaId + '">' + loaTitle + '</a>';
        tocList.appendChild(loaTOCItem);
      }
    }
  });

  // This hook moves the sections of class front-matter in the div.front-matter-container
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }

    beforeParsed(content) {
      const frontMatter = content.querySelector('.front-matter-container');
      if (!frontMatter) return;

      // move front matter sections in the front matter container
      const frontMatterSections = content.querySelectorAll('.level1.front-matter');
      for (const section of frontMatterSections) {
        frontMatter.appendChild(section);
      }

      // add the class front-matter-ref to any <a></a> element
      // referring to an entry in the front matter
      const anchors = content.querySelectorAll('a[href^="#"]:not([href*=":"])');
      for (const a of anchors) {
        const ref = a.getAttribute('href').replace(/^#/, '');
        const element = content.getElementById(ref);
        if (frontMatter.contains(element)) a.classList.add('front-matter-ref');
      }

      // update the toc, lof and lot for front matter sections
      const frontMatterSectionsLinks = content.querySelectorAll('.toc .front-matter-ref, .lof .front-matter-ref, .lot .front-matter-ref');
      for (let i = frontMatterSectionsLinks.length - 1; i >= 0; i--) {
        const listItem = frontMatterSectionsLinks[i].parentNode;
        const list = listItem.parentNode;
        list.insertBefore(listItem, list.firstChild);
      }
    }
  });

  // This hook expands the links in the lists of figures and tables
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }

    beforeParsed(content) {
      const items = content.querySelectorAll('.lof li, .lot li');
      for (const item of items) {
        const anchor = item.firstChild;
        anchor.innerText = item.innerText;
        item.innerText = '';
        item.append(anchor);
      }
    }
  });

  // This hook adds spans for leading symbols
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }

    beforeParsed(content) {
      const anchors = content.querySelectorAll('.toc a, .lof a, .lot a');
      for (const a of anchors) {
        a.innerHTML = a.innerHTML + '<span class="leaders"></span>';
      }
    }
  });

  // This hook appends short titles spans
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }

    beforeParsed(content) {
    /* A factory returning a function that appends short titles spans.
       The text content of these spans are reused for running titles (see default.css).
       Argument: level - An integer between 1 and 6.
    */
    function appendShortTitleSpans(level) {
      return () => {
        const divs = Array.from(content.querySelectorAll('.level' + level));

        function addSpan(div) {
          const mainHeader = div.getElementsByTagName('h' + level)[0];
          if (!mainHeader) return;
          const mainTitle = mainHeader.textContent;
          const spanSectionNumber = mainHeader.getElementsByClassName('header-section-number')[0];
          const mainNumber = !!spanSectionNumber ? spanSectionNumber.textContent : '';
          const runningTitle = 'shortTitle' in div.dataset ? mainNumber + ' ' + div.dataset.shortTitle : mainTitle;
          const span = document.createElement('span');
          span.className = 'shorttitle' + level;
          span.innerText = runningTitle;
          span.style.display = "none";
          mainHeader.appendChild(span);
          if (level == 1 && div.querySelector('.level2') === null) {
            let span2 = document.createElement('span');
            span2.className = 'shorttitle2';
            span2.innerText = ' ';
            span2.style.display = "none";
            span.insertAdjacentElement('afterend', span2);
          }
        }

        for (const div of divs) {
          addSpan(div);
        }
      };
    }

    appendShortTitleSpans(1)();
    appendShortTitleSpans(2)();
    }
  });

  // Footnotes support
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);

      this.splittedParagraphRefs = [];
    }

    beforeParsed(content) {
      // remove footnotes in toc, lof, lot
      // see https://github.com/rstudio/pagedown/issues/54
      let removeThese = content.querySelectorAll('.toc .footnote, .lof .footnote, .lot .footnote');
      for (const el of removeThese) {
        el.remove();
      }

      let footnotes = content.querySelectorAll('.footnote');

      for (let footnote of footnotes) {
        let parentElement = footnote.parentElement;
        let footnoteCall = document.createElement('a');
        let footnoteNumber = footnote.dataset.pagedownFootnoteNumber;

        footnoteCall.className = 'footnote-ref'; // same class as Pandoc
        footnoteCall.setAttribute('id', 'fnref' + footnoteNumber); // same notation as Pandoc
        footnoteCall.setAttribute('href', '#' + footnote.id);
        footnoteCall.innerHTML = '<sup>' + footnoteNumber +'</sup>';
        parentElement.insertBefore(footnoteCall, footnote);

        // Here comes a hack. Fortunately, it works with Chrome and FF.
        let handler = document.createElement('p');
        handler.className = 'footnoteHandler';
        parentElement.insertBefore(handler, footnote);
        handler.appendChild(footnote);
        handler.style.display = 'inline-block';
        handler.style.width = '100%';
        handler.style.float = 'right';
        handler.style.pageBreakInside = 'avoid';
      }
    }

    afterPageLayout(pageFragment, page, breakToken) {
      function hasItemParent(node) {
        if (node.parentElement === null) {
          return false;
        } else {
          if (node.parentElement.tagName === 'LI') {
            return true;
          } else {
            return hasItemParent(node.parentElement);
          }
        }
      }
      // If a li item is broken, we store the reference of the p child element
      // see https://github.com/rstudio/pagedown/issues/23#issue-376548000
      if (breakToken !== undefined) {
        if (breakToken.node.nodeName === "#text" && hasItemParent(breakToken.node)) {
          this.splittedParagraphRefs.push(breakToken.node.parentElement.dataset.ref);
        }
      }
    }

    afterRendered(pages) {
      for (let page of pages) {
        const footnotes = page.element.querySelectorAll('.footnote');
        if (footnotes.length === 0) {
          continue;
        }

        const pageContent = page.element.querySelector('.pagedjs_page_content');
        let hr = document.createElement('hr');
        let footnoteArea = document.createElement('div');

        pageContent.style.display = 'flex';
        pageContent.style.flexDirection = 'column';

        hr.className = 'footnote-break';
        hr.style.marginTop = 'auto';
        hr.style.marginBottom = 0;
        hr.style.marginLeft = 0;
        hr.style.marginRight = 'auto';
        pageContent.appendChild(hr);

        footnoteArea.className = 'footnote-area';
        pageContent.appendChild(footnoteArea);

        for (let footnote of footnotes) {
          let handler = footnote.parentElement;

          footnoteArea.appendChild(footnote);
          handler.parentNode.removeChild(handler);

          footnote.innerHTML = '<sup>' + footnote.dataset.pagedownFootnoteNumber + '</sup>' + footnote.innerHTML;
          footnote.style.fontSize = 'x-small';
          footnote.style.marginTop = 0;
          footnote.style.marginBottom = 0;
          footnote.style.paddingTop = 0;
          footnote.style.paddingBottom = 0;
          footnote.style.display = 'block';
        }
      }

      for (let ref of this.splittedParagraphRefs) {
        let paragraphFirstPage = document.querySelector('[data-split-to="' + ref + '"]');
        // We test whether the paragraph is empty
        // see https://github.com/rstudio/pagedown/issues/23#issue-376548000
        if (paragraphFirstPage.innerText === "") {
          paragraphFirstPage.parentElement.style.display = "none";
          let paragraphSecondPage = document.querySelector('[data-split-from="' + ref + '"]');
          paragraphSecondPage.parentElement.style.setProperty('list-style', 'inherit', 'important');
        }
      }
    }
  });

  // Support for "Chapter " label on section with class `.chapter`
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);

      this.options = pandocMeta['chapter_name'];

      let styles;
      if (isString(this.options)) {
        this.options = pandocMetaToString(this.options);
        styles = `
        :root {
          --chapter-name-before: "${this.options}";
        }
        `;
      }
      if (isArray(this.options)) {
        this.options = this.options.map(pandocMetaToString);
        styles = `
        :root {
          --chapter-name-before: "${this.options[0]}";
          --chapter-name-after: "${this.options[1]}";
        }
        `;
      }
      if (styles) polisher.insert(styles);
    }

    beforeParsed(content) {
      const tocAnchors = content.querySelectorAll('.toc a[href^="#"]:not([href*=":"]');
      for (const anchor of tocAnchors) {
        const ref = anchor.getAttribute('href').replace(/^#/, '');
        const element = content.getElementById(ref);
        if (element.classList.contains('chapter')) {
          anchor.classList.add('chapter-ref');
        }
      }
    }
  });

  // Main text line numbering,
  // see https://github.com/rstudio/pagedown/issues/115
  // Original idea: Julien Taquet, thanks!
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);

      // get the number-lines option from Pandoc metavariables
      this.options = pandocMeta['number-lines'];
      // quit early if the "number-lines" option is false or missing
      if (!this.options) return;
      // retrieve the selector if provided, otherwise use the default selector
      this.selector = this.options.selector ? pandocMetaToString(this.options.selector) : '.level1:not(.front-matter) h1, .level1 h2, .level1 h3, .level1 p';

      const styles = `
      :root {
        --line-numbers-padding-right: 10px;
        --line-numbers-font-size: 8pt;
      }
      .pagedown-linenumbers-container {
        position: absolute;
        margin-top: var(--pagedjs-margin-top);
        right: calc(var(--pagedjs-width) - var(--pagedjs-margin-left));
      }
      .maintextlinenumbers {
        position: absolute;
        right: 0;
        text-align: right;
        padding-right: var(--line-numbers-padding-right);
        font-size: var(--line-numbers-font-size);
      }
      `;
      polisher.insert(styles);

      this.resetLinesCounter();
    }

    appendLineNumbersContainer(page) {
      const pagebox = page.element.querySelector('.pagedjs_pagebox');
      const lineNumbersContainer = document.createElement('div');
      lineNumbersContainer.classList.add('pagedown-linenumbers-container');

      return pagebox.appendChild(lineNumbersContainer);
    }

    lineHeight(element) {
      // If the document stylesheet does not define a value for line-height,
      // Blink returns "normal". Therefore, parseInt may return NaN.
      return parseInt(getComputedStyle(element).lineHeight);
    }

    innerHeight(element) {
      let outerHeight = element.getBoundingClientRect().height;
      let {borderTopWidth,
           borderBottomWidth,
           paddingTop,
           paddingBottom} = getComputedStyle(element);

      borderTopWidth = parseFloat(borderTopWidth);
      borderBottomWidth = parseFloat(borderBottomWidth);
      paddingTop = parseFloat(paddingTop);
      paddingBottom = parseFloat(paddingBottom);

      return Math.round(outerHeight - borderTopWidth - borderBottomWidth - paddingTop - paddingBottom);
    }

    arrayOfInt(from, length) {
      // adapted from https://stackoverflow.com/a/50234108/6500804
      return Array.from(Array(length).keys(), n => n + from);
    }

    incrementLinesCounter(value) {
      this.linesCounter = this.linesCounter + value;
    }

    resetLinesCounter() {
      this.linesCounter = 0;
    }

    isDisplayMath(element) {
      const nodes = element.childNodes;
      if (nodes.length != 1) return false;
      return (nodes[0].nodeName === 'SPAN') && (nodes[0].classList.value === 'math display');
    }

    afterRendered(pages) {
      if (!this.options) return;

      for (let page of pages) {
        const lineNumbersContainer = this.appendLineNumbersContainer(page);
        const pageAreaY = page.area.getBoundingClientRect().y;
        let elementsToNumber = page.area.querySelectorAll(this.selector);

        for (let element of elementsToNumber) {
          // Do not add line numbers for display math environment
          if (this.isDisplayMath(element)) continue;

          // Try to retrieve line height
          const lineHeight = this.lineHeight(element);
          // Test against lineHeight method returns NaN
          if (!lineHeight) {
            console.warn('Failed to compute line height value on "' + page.id + '".');
            continue;
          }

          const innerHeight = this.innerHeight(element);

          // Number of lines estimation
          // There is no built-in method to detect the number of lines in a block.
          // The main caveat is that an actual line height can differ from
          // the line-height CSS property.
          // Mixed fonts, subscripts, superscripts, inline math... can increase
          // the actual line height.
          // Here, we divide the inner height of the block by the line-height
          // computed property and round to the floor to take into account that
          // sometimes the actual line height is greater than its property value.
          // This is far from perfect and can be easily broken especially by
          // inline math.
          const nLines = Math.floor(innerHeight / lineHeight);

          // do not add line numbers for void paragraphs
          if (nLines <= 0) continue;

          const linenumbers = document.createElement('div');
          lineNumbersContainer.appendChild(linenumbers);
          linenumbers.classList.add('maintextlinenumbers');

          const elementY = element.getBoundingClientRect().y;
          linenumbers.style.top = (elementY - pageAreaY) + 'px';

          const cs = getComputedStyle(element);
          const paddingTop = parseFloat(cs.paddingTop) + parseFloat(cs.borderTopWidth);
          linenumbers.style.paddingTop = paddingTop + 'px';

          linenumbers.style.lineHeight = cs.lineHeight;

          linenumbers.innerHTML = this.arrayOfInt(this.linesCounter + 1, nLines)
                                      .reduce((t, v) => t + '<br />' + v);
          this.incrementLinesCounter(nLines);
        }

        if (this.options['reset-page']) {
          this.resetLinesCounter();
        }
      }
    }
  });

  // Clean links to avoid impossible line breaking of long urls in a justified text
  // Author: Julien Taquet (Paged.js core team)
  // see https://github.com/spyrales/gouvdown/issues/37
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }
    beforeParsed(content) {
      // add wbr to / in links
      const links = content.querySelectorAll('a[href^="http"], a[href^="www"]');
      links.forEach(link => {
        // Rerun to avoid large spaces.
        // Break after a colon or a double slash (//)
        // or before a single slash (/), a tilde (~), a period, a comma, a hyphen,
        // an underline (_), a question mark, a number sign, or a percent symbol.
        const content = link.textContent;
        if (!(link.childElementCount === 0 && content.match(/^http|^www/))) return;
        let printableUrl = content.replace(/\/\//g, "//\u003Cwbr\u003E");
        printableUrl = printableUrl.replace(/\,/g, ",\u003Cwbr\u003E");
        // put wbr around everything.
        printableUrl = printableUrl.replace(
          /(\/|\~|\-|\.|\,|\_|\?|\#|\%)/g,
          "\u003Cwbr\u003E$1"
        );
        // turn hyphen in non breaking hyphen
        printableUrl = printableUrl.replace(/\-/g, "\u003Cwbr\u003E&#x2011;");
        link.setAttribute("data-print-url", printableUrl);
        link.innerHTML = printableUrl;
      });
    }
  });

  // Repeat table headers on multiple pages
  // Authors: Julien Taquet, Lucas Maciuga and Tafael Caixeta, see https://gitlab.coko.foundation/pagedjs/pagedjs/-/issues/84
  // TODO: remove this hook when Paged.js integrates this feature
  Paged.registerHandlers(class RepeatingTableHeadersHandler extends Paged.Handler {

    constructor(chunker, polisher, caller) {
        super(chunker, polisher, caller);
        this.splitTablesRefs = [];
    }

    afterPageLayout(pageElement, page, breakToken, chunker) {
        this.chunker = chunker;
        this.splitTablesRefs = [];

        if (breakToken) {
            const node = breakToken.node;
            const tables = this.findAllAncestors(node, "table");
            if (node.tagName === "TABLE") {
                tables.push(node);
            }

            if (tables.length > 0) {
                this.splitTablesRefs = tables.map(t => t.dataset.ref);

                //checks if split inside thead and if so, set breakToken to next sibling element
                let thead = node.tagName === "THEAD" ? node : this.findFirstAncestor(node, "thead");
                if (thead) {
                    let lastTheadNode = thead.hasChildNodes() ? thead.lastChild : thead;
                    breakToken.node = this.nodeAfter(lastTheadNode, chunker.source);
                }

                this.hideEmptyTables(pageElement, node);
            }
        }
    }

    hideEmptyTables(pageElement, breakTokenNode) {
        this.splitTablesRefs.forEach(ref => {
            let table = pageElement.querySelector("[data-ref='" + ref + "']");
            if (table) {
                let sourceBody = table.querySelector("tbody > tr");
                if (!sourceBody || this.refEquals(sourceBody.firstElementChild, breakTokenNode)) {
                    table.style.visibility = "hidden";
                    table.style.position = "absolute";
                    let lineSpacer = table.nextSibling;
                    if (lineSpacer) {
                        lineSpacer.style.visibility = "hidden";
                        lineSpacer.style.position = "absolute";
                    }
                }
            }
        });
    }

    refEquals(a, b) {
        return a && a.dataset && b && b.dataset && a.dataset.ref === b.dataset.ref;
    }

    findFirstAncestor(element, selector) {
        while (element.parentNode && element.parentNode.nodeType === 1) {
            if (element.parentNode.matches(selector)) {
                return element.parentNode;
            }
            element = element.parentNode;
        }
        return null;
    }

    findAllAncestors(element, selector) {
        const ancestors = [];
        while (element.parentNode && element.parentNode.nodeType === 1) {
            if (element.parentNode.matches(selector)) {
                ancestors.unshift(element.parentNode);
            }
            element = element.parentNode;
        }
        return ancestors;
    }

    // The addition of repeating Table Headers is done here because this hook is triggered before overflow handling
    layout(rendered, layout) {
        this.splitTablesRefs.forEach(ref => {
            const renderedTable = rendered.querySelector("[data-ref='" + ref + "']");
            if (renderedTable && renderedTable.hasAttribute("data-split-from")) {
                // this event can be triggered multiple times
                // added a flag repeated-headers to control when table headers already repeated in current page.
                if (!renderedTable.getAttribute("repeated-headers")) {
                    const sourceTable = this.chunker.source.querySelector("[data-ref='" + ref + "']");
                    this.repeatColgroup(sourceTable, renderedTable);
                    this.repeatTHead(sourceTable, renderedTable);
                    renderedTable.setAttribute("repeated-headers", true);
                }
            }
        });
    }

    repeatColgroup(sourceTable, renderedTable) {
        let colgroup = sourceTable.querySelectorAll("colgroup");
        let firstChild = renderedTable.firstChild;
        colgroup.forEach((colgroup) => {
            let clonedColgroup = colgroup.cloneNode(true);
            renderedTable.insertBefore(clonedColgroup, firstChild);
        });
    }

    repeatTHead(sourceTable, renderedTable) {
        let thead = sourceTable.querySelector("thead");
        if (thead) {
            let clonedThead = thead.cloneNode(true);
            renderedTable.insertBefore(clonedThead, renderedTable.firstChild);
        }
    }

    // the functions below are from pagedjs utils/dom.js
    nodeAfter(node, limiter) {
        if (limiter && node === limiter) {
            return;
        }
        let significantNode = this.nextSignificantNode(node);
        if (significantNode) {
            return significantNode;
        }
        if (node.parentNode) {
            while ((node = node.parentNode)) {
                if (limiter && node === limiter) {
                    return;
                }
                significantNode = this.nextSignificantNode(node);
                if (significantNode) {
                    return significantNode;
                }
            }
        }
    }

    nextSignificantNode(sib) {
        while ((sib = sib.nextSibling)) {
            if (!this.isIgnorable(sib)) return sib;
        }
        return null;
    }

    isIgnorable(node) {
        return (node.nodeType === 8) || // A comment node
            ((node.nodeType === 3) && this.isAllWhitespace(node)); // a text node, all whitespace
    }

    isAllWhitespace(node) {
        return !(/[^\t\n\r ]/.test(node.textContent));
    }
  });

}
</script>




<style type="text/css">#title-block-header, h1.title, .title { display: none !important; }
@page { size: 11in 8.5in; margin: 0; }
html, body { width: 11in; height: 8.5in; margin: 0; padding: 0; }
#sheet { width: 11in; height: 8.5in; margin: 0; padding: 0; box-sizing: border-box; }

#sheet .inner {
width: 10.75in;
height: 8.25in;
margin: 0.1in;
display: grid;
grid-template-columns: repeat(4, minmax(0, 1fr));
grid-template-rows: repeat(2, 1fr);
gap: 0.12in;
box-sizing: border-box;
break-inside: avoid;
page-break-inside: avoid;
font-family: -apple-system, system-ui, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
}
.cell { position: relative; overflow: hidden; break-inside: avoid; }
.cell.rotated > .panel { transform: rotate(180deg); transform-origin: center center; }
.panel {
border: 0.75pt solid #666;
padding: 0.22in;
height: 100%;
display: flex;
flex-direction: column;
justify-content: space-between;
line-height: 1.3;
font-size: 6pt;
}
.panel h2 { margin: 0 0 0.12in 0; font-size: 14pt; }

.panel .body { overflow-wrap: anywhere; word-break: normal; hyphens: auto; }
.panel .body img { max-width: 100%; height: auto; display: block; margin-top: 0.1in; }

.panel::before, .panel::after {
content: "";
position: absolute;
left: 50%; transform: translateX(-50%);
width: 0.25in; height: 0; border-top: 1px dashed #666;
}
.panel::before { top: -0.07in; }
.panel::after { bottom: -0.07in; }
.pagedjs_pages, .pagedjs_page, .pagedjs_area, .pagedjs_page_content { margin: 0 !important; padding: 0 !important; }
* { box-sizing: border-box; }
</style>

</head>

<body>

<div class="running-h1-title"></div>

<div class="running-h2-title"></div>



<div class="front-page">
</div>

<div class="front-matter-container">
</div>

<div class="main">
<!-- Edit your panel content directly in the HTML below. You can use text and <img> tags. -->
<div id="sheet">
  <div class="inner">
    <!-- Top row (rotated 180°): [Page 8] [Page 1] [Page 2] [Page 3] -->

    <div class="cell rotated">
      <div class="panel">
        <h3>GRID Magazine<br>Grooves, Research, Ideas, Data</h3>
        <div class="body">© 2025 GRID Magazine</div>
      </div>
    </div>

    <div class="cell rotated">
      <div class="panel">
        <h3>GRID Magazine<br>Issue 1</h3>
        <div class="body"><br><img role="img" aria-label="agnes" src="data:image/jpeg;base64,/9j/4QC8RXhpZgAASUkqAAgAAAAGABIBAwABAAAAAQAAABoBBQABAAAAVgAAABsBBQABAAAAXgAAACgBAwABAAAAAgAAABMCAwABAAAAAQAAAGmHBAABAAAAZgAAAAAAAABIAAAAAQAAAEgAAAABAAAABgAAkAcABAAAADAyMTABkQcABAAAAAECAwAAoAcABAAAADAxMDABoAMAAQAAAP//AAACoAQAAQAAAPQBAAADoAQAAQAAAPQBAAAAAAAA/9sAQwAGBAUGBQQGBgUGBwcGCAoQCgoJCQoUDg8MEBcUGBgXFBYWGh0lHxobIxwWFiAsICMmJykqKRkfLTAtKDAlKCko/9sAQwEHBwcKCAoTCgoTKBoWGigoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgo/8AAEQgB9AH0AwEiAAIRAQMRAf/EABoAAAMBAQEBAAAAAAAAAAAAAAABBAIFAwj/xABJEAABAgQCBAcKDQQDAQEBAQABABECBCExA0EFUWFxEhMUgZGx0RUiMjM0kpOhssEjJDVCQ1JTVGJjcnPhJUSi8ILC8YNkdKP/xAAXAQEBAQEAAAAAAAAAAAAAAAAAAQID/8QAHREBAQEAAgMBAQAAAAAAAAAAAAERAhIxQWEhA//aAAwDAQACEQMRAD8A+o0IXnFiMSHN7Mue402PWhePGVcuyIsVgSKnU6naK9xaiFPDi0Jq++iONLigU7QUIU4xfwoOKa09adoPfZmnRTHFir3tUuNOYCd4KRZNTDFLMwRxsVaCqd4KboU3GRVoEcbFZoU7wUpOpeNiByYbE4caLMBO8MU5pqbjS1AKbEcbFqCd4KdaMjqUwxYmqB0I42hpCyd4KUKYYtwwTGLegTsKEuleHGlrD1pDFLWTvBShTcac2rsW+NYW9aTlB7IU/GC4hrvKYxKHwulO0HuhT8aMhkjjS9G21TtBQheAxWyLb0uMB+bbar2goSU3GQ5wjfZa40ZYe26naGPdNTjFP1b7UhinIBO0FKFOcVvmhIYpyZk7wUpbF4DFNaDpKRxIjkE7QUJrwGIcoa51S4yhofOIZO0FCQuQCHC8OM/X5yYxalgW3p2g90Lw43Nj0rQxd6s5QeqF5caBr6EuNG22pO0HsheIxRYg9COOD0foTtB7IXjxoNQR0FMYsOZ9RTtEeqF5cdDrQcUVqehO0HqhePGw/WPQEcdDZynaLj2QvIY0OZPQlxsJBIPqTtB7IXiMaDJ3sUcdA7cIWdmTtDHsheIxoSKEL1FgciHVliGhKiFQ1JjOMWLU6qUuNTFj3jqWOSs8IVYFB2t0rO0WTbmXMN8zvWeFsKbXJvZIQ0Ym1Qgb0ccyH2b0mDJghAwTtSNXbNGtinYtR0ACwbUkItaC7FiK7Eq56kGodZQUhbciGhQAzKCcikc0dN9SDVNaQN3yRlVIbQEGobFkZUudSQ1OEtyDVWKNoSDVdIM+xBobEZZPZK4JdJjZwgZZMHMskxIypRA2C+1AcK7ArQNKiu9JhYoBOYCQG3JD3Z0gKmzoqHZA4aiu9GsBJ0IAFrujnHOjKhRltugHABAN0A031QHbNFQEBUEsmDRZhdjrT3uyBk70HnS15hFDYlBqrGyBQZOs1ruSrUgINU1opqKybBPXuQMkB6lMEkUKyAKkslTWEG3S4WSGZKrE0qgb0ogVtkk92ZBNOpAOG2J7aushs7BAZqOUGnej1SpRKmTpDM5oNEsgOxSY60BnFaoHkKBF2cJGlKJEsgb3brRRjRZB1atSISTUhFaDQ0GeStg8AbgoRV7q6DwIdy3wSmhNC6IFJjOcWKnYVUpcY/Cx19exY5KzsayQfYk5rVMP/ouuYGrcopXpRzpF22IBmH8pg0NNiN4SfUyB9OxAveqHvRJs9aB1uUnpTND9FkkGncFJgA+WtKrXqhqVNkGhYkpXtZIHWjoQMnIlMFnHQsh6sboDtUepBoUD5JE3RV6OimaAom1HWRmASyA7FA8jdBQw1lwij5ugY1e9I7UgSxclFcwEDP8A4gHXdIULuntq3WgHGTtmhzk6V0Maj3IGKijsk5zNbp5fykNQQPajfuQH6Eg7UdAzqGqiQs6bF/5RXsQAdAdmCQ2E9KNdC+50DqTnRAuWKNwS4Llyg0NjJZNz2TYMT71kO7EBBoWtdGuqWtkhzUQaAYUsgWZLLqQKEoGEPWqMiGBWXq2Zog1rskLFG/NLmQPcd6edbZJHMIQMjWdyGuB0uiqBsdkgCzNrSo1kG7IrsQKjUeyba0tb5IIpzoCEDK4ToQxSFqWTGtACtrK2HwRuUevoVkHgQ7lvh7KK7UJuhdENSYwHGxHOnUqtilxn4yMbelY5LGepZq51haGxG9lgIXNM0BjTJNrnJA3DpQZIrcJi/MgvmyHYVdQAzZkawQgWSyugHH+hBT6kZFAn3MimfMkGyyTFvWgWV0az6gmbetLagNw9SAScx1IbUc08ygHGZSfN9yT0q6AaVQaB1c6VxlRGvVvTLvRAdDoyaiQu2Y9aB/KB02OUZtzJZAhmyQ7F2ugY3JHYm5zARzVFUADqy2IrctqQHaiNw/hANkWSDsQwomDd2SGxuxA669l0rZJhg7MjMtdAVFUFxe6N2V0h6igCRUvkmLZoYNZG5AU1oOrJKuYom+vrQOjbCgbXSSuK2QMbqJlskAUrZIhwUALZ1sgC+tGt0OHNN6B19aVUByaI6EATQsasgaiyL5IGxAINvUirl01QgKkuU91s0DmojWf9KgMs0J1Y0ZLaqCiRqmAc0xs6lBmEb09bZp9SK2QZYtcK2A95DuHUoywVmGe8h3LfD2UIT50LogUuL42PVTqVWanxfGxONXUsclYYXaiG1OtOGoEqLAyHrQujI6lrm9SX+1QZyqnrdFqZJh2QZrkEZLWsOk93ZArM6Ks4RnRBI1oEHrqRQVYJvcFvUlvyUCyzQKirpl7jUkDVggYJIoUtye7JI8770AGoHCN5CTEdDXZNq+q6B3oTTNJBZ7BGuhZAUDtrAKH3IAG1BFWbUgdGGtkmug0NW6kZksLMqCF3ZHQgAO7p86gWdExmf5Wc3JWtdECobXQMwgGuxPO9UBcbAkXHMmOZJqmvrTAxrYpZtVky9Ge7FBs5LJAqsxTDWCyDS+26edAkD2aijU6DsQ6oK7Ua3RncJVyzUDGxFfUkmDqeiAQHeyCdQKYNmSAa9Emq2abmwKQfXeqof+2RS6M6ko2UQAz2pohoKb03oUGQKl31LVGYcyDFQsyA6BDaEwLFkG5dDvzICrkMgsBZG5qJMWNEBcbkq5XTq180+lBjJWweLh3KOJrhWQeBC/1VvgUIQhbQwpsV+Nje38KpSYxbGjGTrPLwoLsWulsO9ZJLlkPTNcxqqMmqkC/WEn2oNB80nq1aJOS6b6ntrQAdIXNEA0zfJIHag8JvGiwMPhwQCOIxQwgO1TrNV5cZNv5Lh+m/ha0iRxWFfx2H1qoRPVQScZO/dcLmxv4S4ydfybDH/wB/4VmdAehIb6qiU4k49JWBx+c3uXljTU1g4OJiRSkIhgDlsYW3MugDfJS6VbudMv8AZlPxWBjTnBcScHpx2JnGnc5OFmyxh2KqBuALZJgqaiQY03cykLH88diRx5y3I4fTjsVoLi6A4dUQxY84xJk4aX+HCzgTU1i4MGLDJDgRgGF8YZ7FZi+Jj/Seorw0X8nSrF/goeoKBcfOfch6eHsQMebqDJCn50KrDWDIGdqKiTjpsf2Qp+fClx859ypfx47FYDe6MjdBBgzkziwxmGSPexmA/DQioO5enKJvvmkTl9NClo3wJg68fE61YCglGPN5yR9NCjjpuryB1+OhVb0NEiRTWoJBMTX3GJv3oViCcmI8TFgEnE+GeDF8LCKkP1K4A1BspJPyuep9JD7AVBx81bkUWz4WFMTEzfkUXpYVVfMp2vqUEYmZk0EjFT82FBx5n7jHT8yDtVYN6WQHYlUQ8txeO4oyWJwzDw/GQ2dusr05RMu3IcT0sPakflcPbiM/1hVg0cBBIJiYFpHF9JCjlMwxJksWn5kPaq8rIBv7lBLyjHqeRYvpIe1ZincWHEgwzJ4vCjB4I4cFQK3farcjs9akxvlGUt4OJ1BVYYmZj7li+fB2o5Rj/csXb38Haqsyi1sudEScpmPuWL58PagTOO7CRxvPg7VWLlmohBBiT2Nh8HhyWMBFEIB30FSedepmsarSWO36oO1LSNpYf/og6yqrClkE0Mzjj+xxtXhQ9qfKMfKTxvOg7VVDzMh7vZBKJnGtyPGp+KHtWcScxMPDMeJK4oghDkvCW6Cqwz3DKfSR+ITFPmHqQUioBrZNuhYht0LT1ZjtQG0FFWYmqXPRAIY1HQg1DQbLoETOM1kbSimW9A3L60PsSJ2oGetARMrMPxUG4KKtVdh+Lg3Bb4FCEIW0NRY78dGcn9yuUOOfjEYWOSswtaqYsyTbUOsAFy6b0zolTnS3MoAGpq3OmLUdZvqWtdUAM6b6IBBcoBuBmki4l0i3F4P70D9KqDZG1FJpKIQYeDFEQIeOgck5OvQTWAw+HwW/WEM/FIYOll6lPyrA+2wmH4gtCZwavi4XniiaSPU69e1S6T+TZgl/AK9IpvAJrjYXnhS6UmME6OmAMWB+AW74VO5CRdD4IY6kw3OvCCawGA4/CJp88LQmMEg/DYXnhEetbsdq0wbevATGBljYe3vgmMfByxsK31wg1itxOIAD4JtuK8dGfJ8ramFD1Bax5jC4jE+Fwn4J+eNRXjo7GwhISwixYHGFC/fAZIq27hAZ6XXnDj4Rti4fnhHHYT+Mw/OCYj0BDuMqpEud68xi4TUxIG/UE+Owi/wkHnIPDRhAw8ev08ftFVAmwUOjcSAYeMTHACcbEI74a1Zx2GXPGQecKINuEQm4y3LAxcP7SG2tMYuHcRw+cg22fuUckfjU9X6SH2AqBHBXv4afiU0nFCJmeJihbjQb372FIsWOMwUgXs6zxkAqI4ekJiOByeFDTaiNiznMpOGcG1is8ZBVjDbWEcOGjRQ9IQTAg6Wf8j/srHqAHUPDg7qmo8n1/jKq4cNuFC+9UbcPXNJiXICRihbwg1roEYfJnbJTBvOlgpMc/wBQlafNxPcqTFDViGG1R48Q7oytR4OJnsCLFwINUE2deYiGsNvTEWRIRG9xRwnGdVgRBrjpQYhm16VQTaRPkwDPx8HWqxF3rgF1HPxB5Zz9PAqnBF//AFF9PQEtzJV7VjhgOBz19aOFevrRG96l0l5BMW8Ar3MWsltyl0iXkJh28DUqsWQu1RZMXPYvOF2D5rYJqLKI1X1pBtiHIr0pUqED1vZFNaQdq/ykDeodA8y4POgWqabkg9T0pa7hkDizL0V+D4qDcOpc45s66OF4mDcOpdOFKaE6oW0ChmPKI6VcN0K4KCYflGI2sdSxyVlMa0uYWQH2Lnoev3I/10nsEG9SgZ/lGTpBq1RV3QPrQ76vcgO5YpF97IsSaS4Jw8GEh/hoKEXrqXqJbBIL4OHX8IXlP+DgGvjoOtVA6jRNViGWwM8HC8wJcnl6vgYV/qBepysnRqZIPAysu9MHC8wKTSkrgjR8wRg4QIhJHeALpsGoxUWl/k+Zr8wpEesMrLgeIwbfZhMSku1MDB9GF6w5OgEOXARXjySVYnk+C7/UCXJJZvJ8H0cKoytQFAIyTU1JjycsMDFIl8EEQn6OG7Feej5OWikcCKKXwSThwnwAakZuqsfxGLX5kXUV56P8glgDUYUD9CKYkpWxl8HW3FhMScrfk2DX8sL3e+xA1HK6amvDkMoa8mwb/ZhIyUq1JbA9GFQbFjVGz3JpHM0dJS0WDiGKXwSRjRgd4CzRMyrMhJmplcDZ8GF56L8TjHPjsT2irWpk25NRMJCTH9rgejCRkJM3lMD0YVNv9ZFWruQTiQk2pLYFPywpZWSlYsecEUvgkDEADwO3eig2OulrFVLJeUTpP2o9mFIsAkJUOOTYHown3Pk3cyuD5gVZZ3/lIcGtfUhqXkEnbkmD5iO58m9ZXB80KoQ6h60rIjmCSle6hh5PhcDiHbgC/CIdlVyCUArK4PmLMJ/q0f7A9tVixJDoJuQSjD4rg+aEdz5Q15Ng+aFQKIe9E0Tdz5V4gZbCbLvVLjSUqJ+XgEvh8EwRkjg5jgrp0zdR43ynK/oxPckWVvufJtWXwn/SjufKZy2F5qpFnqmLbU1Evc+UvyfCbPvUdzpM/wBvhMNiqDm77Ui7WsmrrlT0hLQxy/BwcMPjQg0yrRVjR8p92wxzJT/hSj/bwj1FVHYf5QTDR8mPoMPoR3PlHPwEHQqS7bRsQNZTRN3OlAfEwNzqbSElLQSWNFBgwiKGFweddPWaqTSrcgxyc4U0lVQ6ss06UsgD/XQ3qRAMw5Z1k3prWhYvkg0csgNdUgWFrooQwZ0BmQAar2Rm4ZMO1GWRnUsgRdmyXTw/FwfpC5kWa6eH4uHYFvh7KboSQuiGoJh+Oj/3JXqKY8fHrWOSx5XtdkwyBszTGsvzrnAayNSWdqp9CQd7WTQVOuiAM9dU80WQG3YguASGSapqn/u1IItI+BgP9vh9ZVYtS6j0rwzhYAwuCIjjwcHhWzu1WTEM/wAEsZR/+aY0rcu2pNjbJScGfFfivRGiET7FuSP/AM0wVjnUmln7nTAdxwCPWENP3PJf81LpLlvIMfhiW4PBqxie+2iI6opkXQ2RUn9Qq/JHJ/EgcvJFJVv+SYKoXqCENdrqQd0K0lNtYwme6GQlOmNMR7zJPJsVvqHqK85DyGXGXFQ9S8Znl/J8XhQyjcCI+FFqKxJGeElg8CGV4PFws8UTs2aYvp0G1G60DQ1qowdIfUlXG2JDz+cEr50SIrpZgKobNSA6QIphynnxdiYOkM8OV1eHEPcmBaLAGDi7cbE9oqze65Oj4p04GJwIJZjixu8cV+EbUtdV8OfywpW32kQ9yYKzdkhdSCLSF+LlafmRdiRin2IGFKvYfCRdiYLQR0qORczE9WnHU82FLhT9+KlafmHsU8lFO8dN8HCly+KOE+JE3gw7LMyLHVqQiGhrmFJwp6jYUtu4w9iOFP1bBl/SnsRFhQ7V17FHwtIOfgZb0p7EhHP54Es/7h7EAG7rxAH6Ae0rcjdciGOd7qRvgYHCGDC44024Rra7qqGOfYvgS3pT2IKwgalLw56ry+A7/bHsRwp56S8v6Yj3JgrfKtFFi/KksKvxeJ7loxTwryfA9MexSxxzfdHAfAwuEMONhxpt3rmySLI6lqUdMbvUpBizr+TYPpj2I4ye+74NW+mPYhivI6gkAXcPrUfGT70lsF/3T2I4yeylsBv3j2JiDSPhyhr4+HL9Srq21q3XKncScMcoYpfBB44ENim7GlrKvjJ5vJcL038IufisZulnRtqlGJOgeSYW34b+EcZONWWwvTfwmIryupNKvyDH/S3rRxk591wvTfwptI4k0ZPG4yXghgYORiuwcVZqosdRtRom4NgkaOA6YskRkvn1Jka8kF8mdENXbYgQvqToyCMyTqTBL3TAtYbch2CbZuFkOA1epAWBdl0YPBG4dS57d6XuuhB4A3Bb4eyhCELojShmQTjRMP8AWVtlHj+Oi1OOpY5eFeW9BomM0xuXPF1miKiuSetEIRAL1Tc6kjQlkDOtOlAJbHKZY2ZI3YZ7EWJNJeDLMbTGH1lWQ89ApNI/2rW5RB71VDYuimKOCEF2o1kwaF0C1AUZAGXQotL/ACbMgM3B94Vj1O1R6WbudMXt7wirLAsk9KoatWugMzGyEA/haG2yyHq7UTALbER5TdZXH1cXF1FZkfIpcH7OFvNC1NNyTHt4EXUsyReSltmHDvsix7vSh/lGfrRR6pBEMsxayARZs0Ei9aJQkH3II9F+TRmvjsT2irG1bFJosjk0Y14uI/nlVnNBra1Ei1HKD4LZoYsHQFiT7lHJePnWB8dXzQrOc7VJItx87Utx59mFFiw6gkGY2RdPooiANkkbkn1IB1XKTlBLA3deM/kB/OiVgKihD6WxW+wh9qJV0ZAy2Ts6HAyQ1L9KBk7v1oEHNrqTE+VJfXxWJz1hVgGplHjA91Zcv9FidYRYts7JPtRqRltRDSDV9yBqDoI3OgjnweOk2+3A/wASrBbKoCj0h4+SD/Tj2YlWHyfUgYsWZ9qHrW6IXZFgxQBJUWl/k/HZvmj/ACCtKk0t5BjDNx7QSLFhoSSavrWb2WorlrEl6LL5DWiG3QgdaItrsUAXQGtwUZktRAsRXtQGbNUGdwgBjemSYsSkNWvqQGRe6vh8AbgufzLoweCOZb4BITdC2goo8duNi106lZRR47cbHXV1LHJXmMwEDaaMmzB0Z7FgIWsUw1UxtN9qWsqAfdqsjNqohzLetNBkUNG6EMKlMXWR1lkEelYxBBLYkT8GCYgNATryug6SlrCKN/24gOpa0g/ClNXKIM96rBLGqrSMaRlnrFHzYcXYjulL1PDjA/biHuVpdnqgPmSoiLunKD6SK/1I+xS6Tn5bE0fMQQ4kXCMNO8i17l1YYieEIgQx1u41qTTB/p2OOEbDO9QgR0lKkkQ4kT38XF2JDSUrXv4vMi7FfFcuTV0oXA4PCT2qIaSlRbELfoi7Ed0pX7U+ZF2K9y177Ui5OetGXMmtIyxlsYDFPCOHEPAiq4OxEnpCVEpgg4pBEEIPeRXA3KydJ5HMMTXDi6ilIk8kwGJ8XD1BF9PDulKuWxr/AIIuxPunKN43/GLsVosXfpQDelRZBH3Sk/tg/wCmJHdKTfyiFx+Eq0HWCkSaVN9aI5GjJ+Whl4xFjAHjYzWE2MZVfdKTH0wy+bEU9E+SGp8ZiG/4olUDVg6CTulJ548PQUDSkm7cfCP+JCtBNn6UB7El0EPdOTekxA72qppPSErDizhix4RwsV4aEOGhDrrVYtbepNHn4Wed2489QRYyNJSjtyiBMaSk6vMQetW5WostdmdBJ3Skq/GcOm1B0jJPSZwq1urAA1wkwqzDaiOVh6QlBpLEjMxA3EwgF798adCq7oyeczhNvRA3dbGt4mD2olYBqFEEndKSH9zhWpVB0lJH+6wa/iVlKsEmH1Qgk7pST1msHzlNiaQlDpPBiExhcEYUYcRWcw+5+hdMANYKXEYaVwaBuJjNvxBIsA0lJuSJnC85HdGTfyrC84BVcEUoOi6ODC1QGREp0lJAn41gv+pLulJfe8Bv1qwQQn5orsWThwO/Bh6Aiz8cydn5SLGkzDM4J4OM5aL8MQ6FWNIyj+VYNfx0WJ+GHj5HvRXHGX4YlbwISKwimwIJe6EllM4PnhEM/KfecHzgqBDD9WHoCfAgNoIW3JETcvlPvOD54Uuk5yWxJOOHCmMKKMkAARB34QyXS4EOcMPQo9LwQiRxCIYbwC34gqsXRUdnugXPYj5xDC90awpEFbuijIYsWsgWrcbUAHZ3NUxagCR50D/QqDdbcjK6YG2nUkdT2UCLVD7V0IfBG4Ln1ai6EHgDcF04FCEIW0NlHj+Ni1U6lZkpJjxpr/rLHJXmctRT6VnMp77BcwZopkEFnZggbLIEHer6089mSWZpVk0WfoFh22RzLPPnqWnbrsiItI3lAPvEHUVWG4JopdInvpR/t4feqgRXqdAxY6kkC/aUFGhzKPTAHc/He4AA6QrT4LUUOlyO52ONw/yCJFz1OSV0a96KMWRTyQBtO5KF08s3Rl4zp+JTF64UXUUSY+KYD/Zw9QWZ0jkUwdeHF7JW5UvKYLGvAhboQeqATXUEGr1HQg6qc5QIvUlMXcHMIyP+ugZOTdBFog/FTtxMTP8AGVaHal1FonyOr+MxPaiVj/yi0wa1s+tJ60NEx/tECzNVEB2BR6P8ZOMKcefZCsD2OtSaP8ZON9uR6oUFe0bEtZIQMmFbIqzoHYZo3WQ+s3RRqoI8P5VxqU4iDriVgLCqjwz/AFbHZqYEGW2JWA0QP1UzSyco1ug7UAQ5vRSYlNLYNLYMftQqvOr1UcZ/q2ER9jF7UKRYtDF27EZMFkVFBZPXraiIBkXYuitwUqgOXJQCLB3JbcgknT8Ykf3/APpErIVFPeUSDfbEf4xK0EWQBZAuj3o7EBrA6lHpbyGOvzofaCsGZcKLS3kGJ+qD2wkWLbxEVd7IG9EQZ2vqQG50QG7PRIZhG3XsWhVAhq96OeroYizdCBa3RmgBmlS6Ytzo3GqBXBC6EPghlzyLgroQ+CNwW+Hsp8yEkLohgKOYfjYlWpJjxsT7OpY5eFeYswATyFapZPVnTC5h3DDqWbUIWmu1khWuQQAZi/Ulr6EFnN0AXNCEDLNdZzIOpN0Oz7UEWlYTHDKwiKKAnHg76E1FDUPRPkeI4AnZliPw9iJ9uMk3zmIeqJVi2dEWJORYp/vZnph7ECUxW8smRv4J9ysySDEF3cIJBJYv32Yb/j2KXSsriiRxSZzHiA4NCIfrAanXWBUel/k7GA/C3nBAcjxc56Z2Ug7ECUxqjl0x0Q9ir+dFvTG5NEfI8a4n5nzYT7kxJ41Xn5nZ3sPYqw7XQCWOpNVzp2VxxKY5M7jxfBxFuDCHDGhonLyuPyfCInscAwQsODBSgpZUaQpITGzCj6luW8nwnfwIepB4CUxmfl2PfOGDsQZXHApPY1fwwdirGdQwTDZsgj5LMM4nsbzIOxISswWaexn/AEQdisObunDYNsRNcjRcvjmVDTuLCOFHQQQ/WOZHOqxK44FJ/Fp+CHsRonyIVHhxn/OJWC9GQ1HySYvy7FqfqQ09SBKzNXn8Sn5cKsBqaBAJvS6GozKzINJ7Fb9uGilkJeYOJNtORwtjkeLhqWHQusbWCj0fSOcIZ+URZ7IUNAlpjOejr+XCgS01fl0TC3wUCrJ6d6BqZEScmmhedj9FCgS01nOxeihVbGtqpttRdcnDl5k6SxwJyLhDCgeLi4dcTbMlXyeaby6L0MKWF8qTB/Kw26YlYDnXYiJOTzYBadi9FCgS02Xaei9DCrNZSO5BGMCbfy3/APxhU0WBMjSeG8533FRERcUNcPMuqD0lSRgd1sNyzYMXtBIsIYE3R503+yhRyebr8dL7cGFWayGZKr5bURHyebr8eDfsQ1Ryecr8dDfsQ9qtIHBIzCAXsmjkTeDN8fJ8KbBJxS3wI70iCIvtoq+TTTH46H/ZCJ0jlchX6U+xErXQRcRON5ZD6AdqOInKjlkOz4Adqss7I2/6EXUfEzf3uCv5I7VLpDCmoZUnEmYI4OHA44oB++Gbrq5FSaUfkRJ+vB7YRFhNT2IpXr1oLB2BZ0hsy2oHV6oN7ICHqbIAXLJ9SR11ZAzcIFlVkNmTRMPmUzZBkVoG7V0IfBG4KCjFdCHwRuC3w9gCEMhdEG5R4/jYuZWMo8duNifZ1LHJWKvuQGq+SVLBAewXPQwyQ3oL1Y1QHsGQFz60WtYoGpt6PnIC+X8pOdrrR5ulLXtuixHPvxklrMwOqJVm21RaUMUHJYoIDHEMeFoRR6HM0WhNTH3HHf8AXDX1oqqlE93OpeUY+cljefB2rPKsd6SEx50PagsJ6FJpYf0/FO2Ef5BBmsf7hj0H1oO1SaTmcWKSxITJ48A4UIcmH6w28yEdexLu6VGdScrx3rIY9/rQdqyZvGFOQTDHbB2oi4UJZA9ai5Xi2MjM9MHamJvGbyGZffB2or00j5BMt9lG1NhXpL+T4bN4A6lBPTeLFJzEJkpkAwRVeFgGNbreBNYowMMGSmS0MIccHUNqJi4PqKDel1JyrFJrIzP+PanyrFF5KZ6Ie1EVl82ZkxcOM6KLleK1ZKZ/x7U+WYvCpITVDqh7UC0R5DARnHH7cSsyOtcjRk1iQyUAEnMxVjqBCfnHbzKvlmKweSmn3Q9qLiwnXzoBu9lGZ3EsJGabcO1AnMR/I5rzR2oYscMf9ZS6OpFONflETdAS5ZG1JOa8wdqmkZqIGZ+KTJJx4iWhFLUNaFCOqWu9d6TjnF1GZyP7nNX+oD70csjfyOa9GO1EWiz5oB9Si5ZE9JOb1+AO1MThZuRzXmDtRcGCf6rM6hhYfXErKNSi5ODNkaQmDyWaL4cAbiw4YxZPbUqeWHKTnL1+D/lBYH4VdSL9qkE6b8km/RjtTE8WHxSb9GO1EVanyUuJ8qwH/wDPF7QSE8W8lmn/AGlLFOE6ThiMtM0wSG4uvhDLUkWOt/6gB9yjM7Q/FJt/20jO0pKzeX0RTEVnhcOHg8Hgu0TippkbX9Sdn2qQT9aSs56IoE8H8lnPQlFwp5uVyGrjT7EStBGYXIm53hTUiRLTYEOJEWOGQ/emgGaqE+M5abf9koYt3IBuo+XD7vNehKOXV8mmm/aIQ/VZO5RaW8jNfn4ftQrXLg/k816I1U2kZuHEl4YBg48D4mHWPDIA78Z5IR1cy9skZUKNd0huKRGsneiyExdtdkGjjWgA2pAzZ2QKUR0IEd5dMOzuhg7oBBsQ9kGXz2Loiw3Bc82Lj1roQ+CNwW/5gQnRC6IAo8duOi1qwKOY8bHzLHLwrzGaL1KQtaiYbNcw2DHUlRjWhQLOEZG6QCYfLnqhq1KUO6mpAC6Y2mqRufUijWD5IsRz78bJP9uPZiVgPQyj0g/GSR/PHVEq83N0UxvQ7CjoIQDQh62RkNu1KLTHkMdvCgz/ABhW1apDKHSzcijAA8ODL8QRV5uVlhnsQbl9aK1syKYZ2zdGuiAa3CGG1GU2kfk+as3FR+yV7YHiMNrcGHqC8dJfJ80w+ji6l7YAAwsNifBCDTjWjoRwSzh2dAugbUsiHWwoWS6CnBtJbJBHojyHDFGeP24lYSN6i0T5DBq4UY/yiVlaVFUAGTzoyy1eZMM7ZouG4YvmotHf3V34+M9Sss6l0f8A3X/9EeSIqFaoFyQ9ExtsllsdA21rOugTFy4YW3obagjwflSa/bw/+ytoxfXrUeC3dSbI+yw3r+pWawgEgzk0T2ZJZaggAApDTSkJH2EQ/wA1XtKkNdKwk/YH2kWKs1oPVkiDYm6YzqiDOgPYgu/WjM3QKHNkEU5SdkLtxkR/xiVbUcqSd8u0f+uP2CrLXZzdFM2sgbbbkUqCKFKiICKUUmlA8qAftcP2wqxZR6VfksOT4uH7YRYsrUHegFm3MjM31IGb7kRoZua3SyoS6etmdIPWuxADNwWGaNZL0SLVd0zvCALbEbKsiHUhhchAjYs9l0IfBFNSgpWq6EPg8wW+HsobahFULogKjmPHRbg6rUkz42Lm6ljl4WPMJjU6QqKILrmAvzIGbFArSqH6kAglnZBzL1ogmtEaAZ7IOxD0Je10r1YsjKSfJ46SANePHslVsauCoNJ4cOLFJwRAmE49akP3pzutdzZbOGL0kQ96NLRc09SbHa6j7nSzWj5sWLtR3NlsoY/SxdqIrFiS99Sj0q/IY2FeFBT/AJBB0dLasT0sXapNIyGBBKmIcY/DgviRGhiAzO1FjrkEUY67JPU09Sk7my2UMfpYu1B0dLuX4z0sdfWifiwZ0ruQaV9yj7nS/wBXFr+bH2oGjpfMYtPzY+1Fb0n8nTd/FR9RXtgvxOGSDWAdQXO0ho/BgkZmIHFeHDiIfGi1ZuV7YWjsA4cPjqgGmNEMt6J6X5G/QkKhwN9FGNHS7/TPk+NF2oGjcA0EWN6aLtQWAbPUgA6qvRSDRuAx77H9NF2oGjpfOLHyHjo+1AtE/J8F2eI/5FWa2XJ0VI4McjhxGLGcmJ2xoxaIjIqs6PwW8ZMenjHvQ/FZFM9VkDqUg0fg/Xx/TR9qO5+CH+EmfTR9qIsqxLqTR95mlTjx+5Z7n4VuNmfTRKWRkcOKGYJxMfx8YpjRZZls9qL+OtUAosHCk7n4VfhJkUfx0VPWlDIYVRxsxS3w8SEWZZMgGlGdScgw2pizLj86JLkGH9tNO/2xRRgF9KTWri8PriVgoDdxtXJwZGA6QmoeNmWEGH9NE9eFfWKUVQkIGL480B+/EgtyqyKMRkLqMSEFXx5r0xDIMjBVsaa9MUZV0tVio3HdYUPiDT/mnyCDKYmn/eKk5HD3UEJxplhgu/Gl/CZn1bEix1gRVm/hGd1HyCBn4+a1Px0SDo+F6TM36YoiwZ2ZJw/N0KQyEJf41Ng/vIEhDnMzfpSgJxuXSAo/Di9gqw2XImpMQzklDx80RFFHfFs0Pq7FUJGjCZm218ajSw0F/ciEijV96kMjqmZqv5qBIhy81NavGokxWPWpNK+TQMTXGw/aCZkRblM0D+6pp6VGFh4UXHzEbY2GODHGSPCQjqvc5XQ5Y0pZKzsyAbhkQ26QijOjOosk4GtA0hmC6YHQlrq2pAPV0A1KQzQLhBo+CfUuhC/BvkFzbAjYulD4PMFvh7BVCELogUeO/HRB9SsCjmPHRUGXUscvCx5vcBGdSkHYMtA6upc2mQKvf3Ji1GQHa5pel0hUknmojJ825D5pbUxcoAG6RqzOyDauSW1qIJJ/x8lT6f8A6xKsBhfn1qSe8fIMz8d6uBEqy7VsjRuXLCyA+YKNyCae5AHMZqPSvkZJDd/h+2FbTYodLeRGn0mH7QQi0uCSCimd0ZV1oFqIAbihiRW+SWa0X2oJNJfJs0aPxUXUVRheLgoKQjqU+lPk6aY0OHF1FU4Q+DhLluCEAaBMHdsQx5iGukQ5oyJhg3QD3w3hAtvonC75XQxDod+52E4NH9oq6+bKHQ/ybgu1ovaKtDMWKKA2VUE22IhGYTFqgohRZqPRh7yZ18fiP0qsnKtFJovwZmv0+I/nIiwOlruydKgPZAtzoCu1kE0QM25qIFQQSKosRy3ylOHXBh9USsB2hSS7d0pz9OGPVEqw2aFAojMOk5112Jh8nRARdlGC+lm//P8A9lXUi6kBfSsVLYFPPRYr3ouSQEC7IhPzXCIY2sjbkjWQnRqOzIIpsfH5D9UfP3hVYso5uk/IV+dG3mqwa/8AQig0FCkBnlqdauKJV50UEljmpNJ+Jw3+2w/aCr/26j0l4jCc/TYfthEWOasdiYtTqQ7UQNbhEFUs22p62QXFv/UDd2OxLmDpjbkgFAZMOdZHUtVNXSIBJQI7yukPBG5c2KgIF10hYPqW/wCZSQhC6IaimPHRcytCjmG46PcFjl4V5i5u25FMrIGZGSNdlzDFq69aA6Qdkhr5roGbVL60D1osbpoM7SE3veiNyR12QQaU4zjJPihCY+NpwyW8GK7VWv6g4PBlWZm4UXTZanvHSV3OL/1iVQFw5RUbz1+BLedEm8/T4OWf9cQ9ysa9CyCgkMU/lhytfxxdij0kZ3kvfwSwHDgtFFfhDJl2C6i0qfidbHEw/bCQlER0hUcXK+fF2IefYPhyvnRdisq5ZCKiMU/lhywb8yLsRwp534qWLX789ityugWtuqg5ekI57ufNcZhS3BOHE7YhJAbKl17Ycc/wQOKlR3o+ki7F6aU+TZrXxUXUVTAO8h1sOpBKYp9vFSpb8yLsQI5+5wZb0p7FWdQFiyLBGUgj0g9MCV9LF2I4WkHpgSxy8aR7lXUBz0ouXBzqiuToqOcEjhcDAwIoWLPikZm9FTw58ueIl/THsT0N8mYGvglukqyG29ERHEn3LYEt6U9i0MSfbyfAf9009Ss1tfJLqRdR8ZPNWXwLfbHsU2jo5wYePwZfBIONHfFzfdVdUi6j0WfgpjbMYh/yQPjJ0f22Bs+G/hEOLPEeS4Hpv4VYJrqKY1tS6IjOJPfdcGn55r6khizv3XB9OexXPd02cUQceWxJvl82RL4XC4OG442wY1Baue5VcdOt5Lg+m/hEvTSM6NcOH1FWCrsgjGLOj+1wvT/wlx06f7TC9MOxW2dHMUERxZxmMrh7Phv4UoxpvumWlYOGMAU47Lha29S63SpIaaYid25OB/kUWFxs79zgf98diOOnB/ZYb/vjsVm9Bu9O1FRcdPEl5PDoftx2I5ROsfiUB/8AuOxW5I37kTXHmceb5bJPKQiIGMiHjgX73WyrGLOGhkoPTA+5Ez8oyWwxn/FW70EXHzmclC37wT5RNgVkh6YK2rAZ7Umc3rmhqKHHmy7ydP3gp53FmYocIYsrxcHHYbxcaIvnDILqZs1VJpPxWD+/h+0gsbMPdDVSHg0umLMyIZZIDWckZl0wdb7UCyyqnlU0Q725kgHd73QMPXUkcmpVAq6b5BkGSAQuiLDcFznFXK6IsNwW+HsN0IQuiDNRzHjjaw6lWo5nxx3DqWOXhXmz51zRk3vQBvTzNQuYVckC2xM2Q+RdAZMBRGdboy2Ja3QGpENnKdcijfZBFO1mZMH7Ut5sSs1iii0hHDh48lFFFDDCMUuSbd5Fd17ibl78fg7e/CD2cGG9kbSvAzUuRXHwq18MI5VL5TGD6QIse+bFR6W8jzpiYef4gvflWA1cfC2fCQqLSkxgRSdMbCPwkB8MW4YSDpHNxmyK2LLx5XgEn4fBf9wI5VgM5x8L0g7UV7EZsdqd9e5eImMBvHYXnhLlOADTHwvPCDGlaaMmz+VF71RhvxcLWb3KHSkxgnR01CMXDMRw4g3DBqyqgmMHgh8XCdvrjUjL1z2oOXavMTGAfpsIj9YQcfBtx2Fb6wQepD3ZA3FeYxsLPFw9/CCQx8J6YkFfxjtRYn0O/c2X3FukqwZ1Kg0Ri4Xc2XfEgfglxwgMzkrBjYWWLBs74Ije4joTBva4XiMbCdhiQbe+C1xuHbjMPX4QQb1uKFSaLD4Uxq4/E9pUcZh34cFbd8pNG4mGMLH7+AE4+IQ8Q+tdBcdT03IerE2WeMw/rwecEhiQB+/hp+IIN5VWgcnuvIYuH9eGtLha4yDKOGlLhBNLMdJTta8HCpzFV6wFFKxQ90ZwiKG2HnsKtEcBd4oa2QLKqBbOqRihzihrtCOHC1IhalQgAQxchSQ/K0Yp5OPaKq4ULs8PqUkEUPdbEIIbiIc/xFIsWDPtTyLZp8KH6w6VnhQue+DcyIYdAzeyRIbwh0oeHIjWgkmmOkZFm+k9lWUG5RTPBGkpJiH+EzGoK193MmA2jJMZpFmokCGqaoH1updJ1wsACh4/D9pU96blS6RbgYH7+H0cJIsV5EUQTSqRotUzRBqAQBkyWR1Jh9aAaiNvQjNZALBroNGz0crKb/6yZzQLW2QXQFhzLnEBmK6Ist8PYdEJIXRDzUcz40tsVajmfHGuQWOfhWISBkjXRO1ASkFzBbmKKpdSYZkAkM6hOjU1OlVigeXqQEPRyUB2q/Sgh0hCI5iShiAMJxS4IcHvDkveGWwH8RheYF4z3lUgG+lJ/wACrDbPVdGnjFLS+WBg+YECVwG8ThV/LC9QtVtsRl4GUly3xfBb9AUmlJXAEsDDgYQPG4YpABThhdHpUek35PC/22H7YRY9+TYFWwcLzAlyWW+wwSf2wvYs9022oicyss3iMHzAgSkvX4vg+jC939SLvTYg52k5WXh0bMmHAwoYhhkuIAGNVTBJS3BDy2DYP8GFjS7dzJutOLPUq4A0IY5BNHgZSWLfFsFj+WECTlcpfB1eLHYvcM+5AayCcSUrnLYHowgyUqaGWwPRhUMinOg5miZOWi0bLmOXwYouC5JgB13oq+QyjF5TAb9AXnogjuZL/o95VjipzQTCRkwR8VwG/bCZkJNvJcDzAqddUZBiNiCXkMoQfi2D5gUujZOWjwsbhYGDERjRgPADaJl08n1qPRdMHFYGuPiG34iixrkEnnK4HowgaPk78lwb/UCqqxRkxAdkRKdHyZPk2C36Ag6Pk28kwG/QFTnvTDNegCDlysjKRT04OTYPBhEDDgWeElVjR8mKclwX/QKLEr8oTrfl5/hKtFBtOxBMNHybVlcHzAl3Nk8pXBp+BU1ZyCh9QCaJTo+Td+S4PmKWCRlDpTEhMvhcHiIYm4FATEQ++gXVYWBUcPytinVgQ+1EkXR3Okrcmwm/SkdGyRvK4PmK0eDQ7En5mQ1J3Nkq/FcJq/NSGjJHOVwr/VVgatrpvSoRHHmNHyY0hJwiWwhDEMRxwbsB2lWDRsllK4XQlMN3Tkv04mewKxBJ3MkR/bYdNiBo2StybCbnVbb3SbadaCXubJ5S2E42Keck5fBMvHh4MEEfHwBwNZXTBarhgo9JNwZe3lEBttRYs3vtQGSGf+86cObakQywB2orWqWtPJ9RQAer60qOwTGoE8yBtQD0IrdI7bhMjMDesjOiAIuDQGy6IsueXILZBdCGw3LfD2BCYQuiBlHNPxprkFWpZgtinV/Cxy8K8d560x7kDOhogbg4XMK1EPeiYc0RWtCgQzB60OmgDrQA1JZ0yTSzPQgknfKpHbinP8MSryuodJQxxTElDhxiCLjD33Bdu8Oui0Jea++7vgYSjS3akWbtUnEzdWnQ2fwAQJecfyyG+eBCjKx7KLSnk0H7uF7QT4icF52HZ8AFLpLBmhgQ8KbhI42AeJFO+Fb5UKRY6opvTHrURl5x35cKW+BHagYM4x+Ow+gHaiLDm5R71GMGdznINXiR2oMvOWE3B6AdqB6W+TJo58AquGjVyGa5WlMGbGjpnhTUMcPAqOKanTRUjBnXrNwM32De9FxbTUWStQ1CjODOuQJyD0L+9EODPD+7w/Qfyhis1pXVdOFmzZR8VPfe8N7eI/lHFTzeVYTfsfyijRHyZKu/ge9WVa1lytGYc2dHy5w5rCEJhcA4L0rm6o4qeMRaawWv4j+UFtc3RV7KPip6wmcH0Br60HDnmpM4L/sntRlYbvW6k0X4jFY/T4l/1JDCnj/c4OX0JHvU2jsOdOBHFBj4IBxY3fBJ+ca3s6Dq63Rv3KMQTwtMYHoT2pjDnj/cy9T9ie1BUg2oCpBhz1RymXb9k9qXFz4qZmXb9o9qLBKt3Qn2b6Mf4q4GtGs648thzvLZ4DGl3eBycKI/N1PSir4ufcjj5b0RHvRVmSULa7qTgT4+nlvRHtRwZ9qY0t6I9qMrhSjqOGulsY/kQD/IrPBn28dK7fg4u1SwQzvdLEAxpfhcVC/wZtwjk97pFkdaLZklvuo+DPj6WVJtXDiHvT4GkM8WV9HF2oq0anWQalznqUnA0hbjpX0cXagQ6SyxZPzI+1ImCYbunJu/g4nUFZ80CjrkY8M8dISr4ktw+DiGEiCJsr1rsVXBn3riyvmRdqGKxnVaZ6jNRET4HhytvqxdqGnwGEcqz/ViCGLQexRaSYiWY3x4B60NPghopXzYlPNCa4yVGNFgcA48HgAvfoQjqZU50B9frTajHLaiG7NXJEFcwaJ5FJAs3+hBp9T9iRzvZAsd6BrKAiHe0KAKOWQ4skH26kGfm710obDcFzg9Q4K6QsNy3w9gQkhdEGSlmPHRPqCqUkx43mWOXhXmGYsQgChqUDdTclWocrmAAtVNr2RqvqskXGdEBCaMKJ61mEM9dqY2oGQDQopz3slrCQfPcgkmz8bkT+bF7ESsamfao5wjlcj+5F7BVlWFkAAGzRra6QqC77U6OzjYgYvnWqi0qfi+G+eNhbfnBWCpUWlPEYYo/H4XtIsW7tborzJObVRmhDDV608jRIG9KJA0q9aoiTS7nRky31D7lZC3SpNMltFTRb6NVjMkV9SLDuTsSqiuT1TuGRCsM0yKEbEb7JUY6iixHodu5Us/1Bz3VkNmoo9Dt3MlW+zHWVYKamCIM6umNqQqh3CB79aj0X5NG/2uJ7ZVfPuCk0URyaMm/G4lf+RQVEU3bU7uPW6L70Pen8oAcyDVxkjfbqQM232QRynyhP6hFB7CszKkk6z0++UUHsBVjMUogTVOpkxVmuij6udApmWKA/2ykwh/Vsf9iDriVeW8KTD+Vsen0EGX4okWLKVZLejIgJ6xdEKo1IGuqCM+ZMWrZBFMOdKyX6MTqhVhsWCjx/lWUr9Hie5WA760sikMygu9bhPKjVvtSNtgRAMwbKTSN5UZcog96ryd6KSeNZQH7eD3pFiwagE9xSADbXdAaiICKEPXchrhkxQZVSejIAbHYp5bUBqhGboAZsKoGbi+tFLIq2fYgzrYitl0Ybcy55bUuhD4I5l04BshJC2h5qSZbjS+rtVajmX447gscvCvOhyCbb6JC5Qc6rmA6qOmTdrJHndAcEoEWyQG52T5hsS5s0AMymGetktfQlSrkoIdJ4kOFMSMcQi4IxIqQwkmsByutDSODcwzGf0EfYnOPyySd/Dj9kquHcNaKkGkMH6mO/7MaZ0hhH5mP6GJVZXFExUMD60RGdIYLVhx3/Zj7FLpCfwY8HDAGN47DNcKLKIbP/V1h/Kj0o/EYNx8PhvW9QkWF3QwKtDjj/4xoGkcB6Q41fyYuxWCzE3oEM2ZdFR90ZcCvHbPgouxPujL18c37EfYqss1p9vSURydKz+BiaPmYYeN4RgauFGNWZDBVQ6SlvzvQxdiNMP3LmKnwPeFYDS5Q/Eg0jL5nF9DGPcsjSMsXA430MXYrqXDo11KIiGkpWz4noouxM6SlQDWPZ8FF2KwGlSsxE8E1OtBytF6QloNGy0McUYiEADDDiNa5gKo6SlQaxRv+1F2J6IcaLlf24eZV736UEXdOVuY42/bj7E+6cpU8OL0cXYrHLEEvkiEnIn1oIxpKVNsSOh+zi7FJozSErBLxCLEifjIz4ERoYzqC67nInpUmii0rFX6TE9spFLulKfaFj+XF2Jd0pS3HHb3kXYrt5OpIEkmp1CqERDSco9cU+ZF2I7pSjF8arfUi7FZVqEtvTD1RHJldISsM3ORHFYRRQHwIsoQFUNJyZNccPuiRJPyyfDnw4fYCrhrCCCWZFSDScnbj4TT6sSBpOTucaHnESryNSirGpKCQaTk3pjw9BUkGkJUaSx8Q40PBiwoACxuCe0Lr3rVR4THScx+1APXEkIIdJyf28PQUHScnX4xDvYqsUJd0za7vtQRDSkkzcog3sUzpOTZjMwW1FWWBfNAsg5GLpGTi0lLxiYg4MMGICa0fg09SrOk5KrzOG+V6Ixm7rStfosT/qqzmERINJSVQJnCfeUd0ZKrzMHSexVgAbUECrAIsSDSUm5+MYXSp5mcl8fGlIMHFgji4+GkJyD1XTADZMo9IMMSTYAfGIeqJJhFkO5PXsSDtfUmKWfaiELJjVV9yQdicymd6ACYzcJG/OmMnKQI7DVM3sgtqCVXQDmoai6AsNwXOJ1ALojwRzLf8ymyEnQuiBSzHjmoaBVKWZ8adw96xy8K80C6WTlFKrmCuTIIRSyM6Gu9AHmdIAvtujNkawBYoA1BSy2rWSTajVBHNvyyRrURxeyVWNbFSTZ+OyLCpjjz/CVXv3BGhkfUgO5JZmtqO9Oju5dGu3SjJ7Nai0o/FYL/AG+G/nBWOKvdSaT8VgufpsP2kWKxlWqVedAYCgQGqz11IgLpgUS5xZN7sgj0x8mTLP4PvCspzKPTDdzJm/g69oVYPfRAO1EUC5LZpjJglnQh0BsskDtzJRWitZaG00KzF4MVdfUUSJdEN3Mlf24VXrpZR6HbuZKv9lC3QrNZLoAaqsghDitbJe5FMZbFHoofFD+5ie3ErIb9eSj0V5LvxIy3/KJEVi1DVMJZFmRkxIPuRdO1AAyNyNdqetL/ANREsn5bP28OD2AqzzqSTHx2etTEgfzAqxnsQG+qMkDnZLaSinC56VHhfKsyzeKg64lWLkhS4Ld1Zk1PweH1xIiupuUUsNSfSgOxbWgK1e2bJbGKYepok9N9EEeL8qyr5YeI3+KsF7KPGburK6uKxD7KsNAgcO5IZoLZs29DuSGQG7UotI1xZJ7HHh9mJWAVuH3qOf8AGyX74fzYkWLGYUvuQzECtUx4NEXdEHMUNR3SDgbFonI3QLLVVPJGQrQhEOo70C6UDY2906CmxK2XagRsV0YbDmXOyzK6ItzBb/mUIQhdEClmvGncFUpZrxri/B7Vjl4V5a3IAQGq+aBrzRmy5hZC90DYga/9CYZutAtbI3ugOMkWtmNSAF6dSNVEmNdSeVLoINI4YxpmTgMUcL4kdYDwTSDJbEhDcTE237xSmh8ckn+vH7KsGxGkvIA3lE16YlAkQ3lM1X84qpqu6OxGUhkQxAmZobeNKl0hJgYeE0xMxPjYYL4pNz1rqg61JpMjisBj/cYfXkiwuQh35RNP+8U+RQmvKZvWfhiq2AhAJqEgLtsZBLyICgmZv0pWeQ1pNTe34Yq40qc0nptZFcjSsnwZDHiMzNFoXY4jg1AqFXyE1abm/SfwjS/yZMbh7Ss169yCMSBr8bm+fF/hAkiC/K5v0n8K3NygNrRNRQyJ+9zfnjsRFJxcGJ5ybsfpB2K0NcFZjJ4uM7DsyKDl6Mk4otHy0XKpkPhwsIY2ApqZVciiq85N0y4Y7EaJhfRsqCfo4epWZNqKGo+RRuWnZvzoexLkcbl5yab9UPYrXvsQLEIaj5HiZTk1l86HsUujJWKKUBM1MQnhx2iH1zkQuteK+dVFokfEhmeHG/nRJqnyOOrTs15w7ECTxCazs10w9irKdWJcImpORxh3nZnV4Q7EjKYtSJ6Zv+HsVmxIn1ofrkykrimanAJ3HHBjhDjg1PBFTRViUxSaTszb8PYiSBM3P/uw+wFWGrrCFqPkeMQRy2Z5+CfcnyTGznpht0HYq95Q1tiIjEpjPSdx9XzOxTYUti905ocsx3GHAXaEOC+xmXWzKjl27pzQa2Hhg/5Ispckx3Px7H82HsTMrj/f5joh7FY+5kkRIJXHr8fx3/TB2IErj1HLsfzIexW1zbclWoz1pF1x8WVxxpPABnMZzhxkHgwZGGjMys5Lj5T2NX8EHYjFP9Wl6jxMZ9cKsG1qJp+oxKTFSJ7FP/CDsRySY+/Yr/og7FYNYzSIu7ISpOSzAdp7G38CHsU8zg4uHMyUWJNR4sJxwODFBCK8E1cVXUAOTdijnx8LI1vMD2YkhKsAHBRUXyRuaqBmGr1ogegu10EUOtAvQUyQObrQA2AJjMFI/wDqAgetI+tPOm9HCpTmQKIULLoQ+CNwUAzsXV8PgjcFv+YEIQuiBSzXjTuHvVSkmiRiGlhfpWOXhXnDm/WjeyAzMGdGvVdcwCxohA1lAtRkAHq1kEm/vSoKZp7AaIEa5ILuhgxSBLuixLNtyySv4cR/wKrYNUhRz0OLx0ti4WFxnFmJ4eEBQhs96OUzTeQR+lgQWMBUJGwZR8pmvuMfpYExNTL+QR+khQxXrJUekx3ks4/uMP2k+VTP3DE9LB2rxm45nHhwhDIxjg4kOJXFhLtVqZoR0Sa2RrUYmZlvIMW32kKOVTDkmQxHDfSQoLAwJHSgm7qTlcy5/p+L6SDtSE3MN5DjefB2pijTNNHTAP1R7QVuts1y5/EmpiUxMOGQxRFEAATiQFmL69ipE1MO5kcYZ+HAfemJivaiEalHyzHt3Px/Og7UcrxxEPiGO2vhQU9aIroBQjYlieLiI+qWHMVLyrHc/EcfzoO1KOaxzDEO5+PV/nQdqSLG9FfJkq32UOWwKtcuRxpjAlMDBikpgmCAQ0igyG9Ucsxq/EJlt8NfWmIsISzfWoxO4sQ8gmRzwdqIZzGr8Rmv8O1MVYxdy6i0SPiUN34cftxJwzmL9wmv8e1eEjjY+DLjDikpgkRRGhhziJ16imEdTNkhQVspBOYjVkpn/HtQJzEP9jNf4dqGK7ClWQK0o6j5biV+JTXRD2oE5iZyM10Q9qYYUiXmp8/mj2YVZuZcyXx8XDxpmKKSmuDiRiKGgcAACtdiohnYyG5FNP8Aph7UFmVkhQV/9UnLY85Kbt9UdqOWxGok5vzIe1DFhG9lHL/Kk3X6PD/7JieiFDJTfmDtU+FMYkM5j4xk5rgxwwAd6KEO9H2phjqbtdEhn0KPl0TEcjmx/wDMdqOXFm5FOa/AHamGLQxhQNjqITxbyObAH5YHvRy4v5DO+jHamGDEfuvgW8Tie1CrKDe65kWPiGfw8YSc1wIcOKE/BjMg2fYV78uv8Um9vwY7UwxYCbDMJ0rrUIn2LcknPRfymJ4l2lZv0SYYsyIDbMlHP1xZF78ePZiTE6GYys2/7f8AK8MXFimJiUEMtMQww4vDiMeHwQA0XakI6Ld64vkmBQlDiwTF0QqsUqpm+71oqHY2QD0dMVp0JG1UAEGiBjX0pHegOMg7oepNaIEWYroiy5xXRhsOZb/mUIQhdEClmm43m7VUpZnxpfUPescvCvEXq6dKsyQfPNMf7RcwVzeyTBmJYoNBTnRvQMe/Ws1qtZbrLI22KBj1ozIRuFOpLXrQFx1Js5okKDeiFACr6loMxzWSKUCbNa3UgBqcVCAKFgOhGxMNkgQzGSRqUzmjaCECh1f6ENvRVkxYuckC3WQGYtusmM0MQiwbX2IFv4SG6oQHRBVv4QHY12b1oZoyRYQzZJsnWgN7JUctZEAANgw3INrpjIEpDOt0BRrC6AL2oijZbkFxWqAFyaPuuk1LFMPV3QL7UCyq6bXAFUZX9SOtANkXZIO70tRNs/egGiBcyNlOxDGpIRTMVQBaqZBAGrrSFUIANziyD6jROwISGvbQIAaqWqnW7hI1GTpizZIAsCWsjVqSpUh79CB07XQOl0sqXTrmSkQ4OzagbVyT3LLBs1rI60AHd6oOY9yAaAUdB2ZpgRvdIUpVM3qgZoBi+6hdN0ucpsdSBNtR0JslVyyDORZ10obDcudQZ3XRFhuW/wCYEIQuiBSzPjSdgVSlmvGUZ2Cxy8K8si90c5RvugbWdcwgzF9ieb/6UZ0KKZ5oBuhJOjN/CW/cgK19aDZxc22Ih1unuyQZYhmIQM2u6YrdqIsb0QKEsKiuS1kUg9SbICB63yQWqlclkNrQKuTJ5ElN7UCXWdiBZhGbN0pgXqjegGSqNXUmAKhFM3QIhwQ6YJc6upGtkVpQIAZ0L3ujY3qQNbVSDuUDfayZtV0jcN1p7KIAAMdfWgQ3JJSNBQbEwTXoQDMLPqQauEWrToRvQIPnbcn1Ibo2oG8baIEHJLDYhxzo3ulrZ3sgdWLIGrUjYSUC1b2QCA7kJC2Yp0pi1ECNLO9gmGF7WQbAoO3eyA1oyPqRr1XQSboAbAnrACVhbJ7p7elAt4TBqGSizbUgPzoAbSEw9WboSzamuyKsLIETkbWTAruugWtXrQLlICla0TFrb0iCxrRELttQMDahi5OW9ZDtuWgHpqQLKupDgtdNIWCABpRAZ6vkgXpsT4NSSgRzqugLDcuc2sLoiw3Lf8wIQhdEClmvG3yCqUs1407ljl4V5BwMkte1MM1EiNtXXMMZinQjKq88XGw8GARYuJDBCS3CiLVOVV6a/UgOlFrssmMcPgfOIfm17Fsc90GXeqda6ikMw6GGtA8kQ5uyQvR0F9iAYsgUcOgE1coFzZAVAeuxZzp1LWTFFMwgYeoS56ukXaicLG7t1oDcijJZ3CKIHRiOhFiwKDkEWJYFkCGxnTelGQNZ9aOeyBi9EZuH7Uhm76kCr3QI1Nck7mo/hD1tagSLtXddA6kl0F6tT3oP8Je9A4bdSAWy3IbOmu90xW5CBI3tRD5vRAqOdAqk+vWjXqWiObUiwb3oM50OxPY6Mi+xAFC+tA73J6Ug1kPQ36Ec9UBnSyGLVTqc6JZVZANSiIRRmL7kBnalSnD70AaZ5oIoUr5p5ICjItqptQG5gEVzSBCt0NQMgDMmqd0Crm7I16roFm96YZm1oEG2050WrsToxrVAuWQGRSzzTN1mKMQv3sZpkLJg0cylndYwo4og5giANQ7W/wDF6Q622Gl0AHq+9PKiNoPMkxvqVCOYqugLDcuec3uugPct8AIQhbQKSa8danBCrUk0BxxfKELHLwryALAlNjkEqtTOyYaznpXMcuYlcWKahx5rHhGBhxcKGEQjvS2s3NTVtyqxpgw4MWJE+FhQisRDxxbAO2q3xMPHHGiMUUXzeFE/B3Cw33XrFC4Hq/hNEWjMc4mDixnDMMPCi4LA1A1k3L9iMeeiw4sJsKKGGKIcM4lODC16Z0ZlZBBDBAIYRQABMwQnIEEvZ7ZoPKWOJFhQxYj8I1rS+vmZe9i7sUdNVnWNqBi5d2TP8pDMJgAO7IA0Ytklrd0y7I1+pAG38JFi5YOE0ZnsQZ2htSYpCf8AaoySDNXWgYzokC7iqN2aBmdaB2LHNBFcmQRTK1UZZugBfcgUtmkNWSdxWyAO1AY36kwL19SKawgWW1MitCGshsnHWmBS4QL/AHeizshg2aGvUX1pAg1WB1lOjWRwSxLoEOoDpQKHnTDNbeg7crIIYOH6kCL1ZGdkEF7F3WgDm6DOTFAsUzDWqWtgehAC6YaoJqlmxCGQA2GqerWa2slrsgZ3QGeVCgZs2pMPza0DYgNd0c6W1O73SAejJa2TbU7DYkNbKh5VWYqQxGEAxAUfPetHPoSHUoJYBGMWGKGHEsRFwiKkt6r9K94jGIaAOYmBaw1lbrcHNAsa1yQeBgjHCMJNSCK5c6cQxIYYjDEIiQCA1i+WVsl7Bs3Y7Ew6CfDhxYeGAWhiLh4iSObX6k+DiHBPCI4ZAoDQbj01XsLt60a7ugwON4TtCIWYB7F82uswxYpw4SRUXGsP6ty9glrfmTQsOKKIEmEw1z961TtTDVSYVrVUBV4XPIbnXRFuZb4BIQhbQKWZB42moZb1UsxQQxViD+pSzREITqL7imx27aKricP6p84o4jDPzT5x7VjoqWHDjclixZkzBFqPQVVxGHlCfOKBg4eo+cU6fRJxcRdhFd7FPio28GJVHBw9R84rJl8M/X9JEE6fR4cVG1ID60HBjasJ6F7cmwz87F9JEgS2H9bF9JEnT6PHio3HelLi4/qxdC9+Twfmeki7VoYEAyi544inT6JeLizhPQnwSxcFVcTh6j0lMYcAtCOkp0+iEPqLbk2NKepXCGHUE+CNQTp9HOEJqKsmISxoX3K/gjUEcGHUnT6IGrUGmxEIOQPQr+BD9UJcGGvehOn0QsasDqT4JAFC+5WiAB2hCfBGoJ0+iEQxZA680xhlvBNa2VnAhzHrKRwoCLHziE6fRLxceUJ9aOKjFoSqTgQa4/PiCXJ4MjiekiToJxhx/VPQlxcX1T0KkYEADDh+kiWhgwaj5xTp9EnBiq4KRhNXB6LK3i4BYHpJQIIRYBOgirUe5ABGvoV7DUEMNQTp9HPhdiQ+paAOQPQreDDqCODDqTp9EQhiNGLMtcCOgEJYqo4cBNvWVk4MDfP8+IJ0+ifi8TIHbda4qOnenevTk8H18Uf/AEiS5LDliY4P7sSdPoxxWJmCkcOPOEvuXpyWH7XH9LEmJaEfPxvSRJ0HhxUde9PQyXAiYvCX3KoYEAzjP/MlMYUOo+cU6fRHwTVwWtYp8EtYtZWiCHV60cEagnT6IQMgCipyV3BGoJ8EbE6fRAxeoKA72oruCGsE2GoJ0+jn12psWNCr2GoJcEagnT6IQNmxBh1A7FdwRqCOCNQTp9EIBqGq+ooANexXcEagjgjUE6fREQdRSbYe1XsNQSMI1BOn0QiEk0HqTY1cFt11bwRqCBCMgE6fREAXzfckQasCruCNQTYagnT6IS9iC+5XPRLgw5gJrXGYgZCELQEIQgEa0IQCEIQCEIQPIpBCEAhCEAhCEAEZIQgEBCEAjWhCACEIQCEIQCNaEIBGtCEDyKQQhAIQhAIQhAICEIBCEIBCEIBCEIAIQhAIQhAIQhAIQhABCEIAIQhAJoQgSEIQCEIQDIQhAIQhB//Z" alt="agnes" style="width:100%;max-height:3.5in;object-fit:contain;display:block;margin:0.1in auto 0;&gt;&lt;/div&gt;
        &lt;div class=" body"><br>Agnes Martin, Untitled, 1973</div>

      </div>
    </div>

    <div class="cell rotated">
      <div class="panel">
        <h3>What is GRID Magazine?<br>The Light That Shines</h3>
        <div class="body"><br><img role="img" aria-label="cover" src="data:image/jpeg;base64,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//////////////////////////8D6AAAAAD/////////////////////////////A+gAAAAA/////////////////////////////wPoAAAAAP////////////////////////////8D6AAAOEJJTQQIAAAAAAAQAAAAAQAAAkAAAAJAAAAAADhCSU0EHgAAAAAABAAAAAA4QklNBBoAAAAAAvYAAAAIAAAAEAAAAAEAAAAAAABudWxsAAAAAwAAAAhiYXNlTmFtZVRFWFQAAAAFAFUAcwBlAHIAAAAAAAZib3VuZHNPYmpjAAAAAQAAAAAAAFJjdDEAAAAEAAAAAFRvcCBsb25nAAAAAAAAAABMZWZ0bG9uZwAAAAAAAAAAQnRvbWxvbmcAAAOJAAAAAFJnaHRsb25nAAAD6AAAAAZzbGljZXNWbExzAAAAAU9iamMAAAABAAAAAAAFc2xpY2UAAAASAAAAB3NsaWNlSURsb25nAAAAAAAAAAdncm91cElEbG9uZwAAAAAAAAAGb3JpZ2luZW51bQAAAAxFU2xpY2VPcmlnaW4AAAANYXV0b0dlbmVyYXRlZAAAAABUeXBlZW51bQAAAApFU2xpY2VUeXBlAAAAAEltZyAAAAAGYm91bmRzT2JqYwAAAAEAAAAAAABSY3QxAAAABAAAAABUb3AgbG9uZwAAAAAAAAAATGVmdGxvbmcAAAAAAAAAAEJ0b21sb25nAAADiQAAAABSZ2h0bG9uZwAAA+gAAAADdXJsVEVYVAAAAAEAAAAAAABudWxsVEVYVAAAAAEAAAAAAABNc2dlVEVYVAAAAAEAAAAAAAZhbHRUYWdURVhUAAAAAQAAAAAADmNlbGxUZXh0SXNIVE1MYm9vbAEAAAAIY2VsbFRleHRURVhUAAAAAQAAAAAACWhvcnpBbGlnbmVudW0AAAAPRVNsaWNlSG9yekFsaWduAAAAB2RlZmF1bHQAAAAJdmVydEFsaWduZW51bQAAAA9FU2xpY2VWZXJ0QWxpZ24AAAAHZGVmYXVsdAAAAAtiZ0NvbG9yVHlwZWVudW0AAAARRVNsaWNlQkdDb2xvclR5cGUAAAAATm9uZQAAAAl0b3BPdXRzZXRsb25nAAAAAAAAAApsZWZ0T3V0c2V0bG9uZwAAAAAAAAAMYm90dG9tT3V0c2V0bG9uZwAAAAAA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AP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAAAAAAAAAAAAAAAABFgAAAAQAAAAAQAAAAAADlRhcmdldFNldHRpbmdzAAAAFAAAAABDbHJUT2JqYwAAAAEAAAAAAApDb2xvclRhYmxlAAAAAgAAAABDbHJzVmxMcwAAAAAAAAAHaXNFeGFjdGJvb2wAAAAAAE10dENPYmpjAAAAAQAAAAAACk5hdGl2ZVF1YWQAAAADAAAAAEJsICBsb25nAAAA/wAAAABHcm4gbG9uZwAAAP8AAAAAUmQgIGxvbmcAAAD/AAAAAFRybnNib29sAQAAAAphdXRvUmVkdWNlYm9vbAAAAAARY29sb3JUYWJsZUNvbnRyb2xPYmpjAAAAAQAAAAAAEUNvbG9yVGFibGVDb250cm9sAAAAAgAAAAxsb2NrZWRDb2xvcnNWbExzAAAAAAAAAAxzaGlmdEVudHJpZXNWbExzAAAAAAAAAA9kaXRoZXJBbGdvcml0aG1lbnVtAAAAD0RpdGhlckFsZ29yaXRobQAAAABEZnNuAAAADWRpdGhlclBlcmNlbnRsb25nAAAAZAAAAApmaWxlRm9ybWF0ZW51bQAAAApGaWxlRm9ybWF0AAAAA0dJRgAAAAppbnRlcmxhY2VkYm9vbAAAAAAFbG9zc3lsb25nAAAAAAAAAAxub01hdHRlQ29sb3Jib29sAAAAAAludW1Db2xvcnNsb25nAAABAAAAABJyZWR1Y3Rpb25BbGdvcml0aG1lbnVtAAAAElJlZHVjdGlvbkFsZ29yaXRobQAAAABTZWxlAAAAFXJvbGxvdmVyTWFzdGVyUGFsZXR0ZWJvb2wAAAAAG3RyYW5zcGFyZW5jeURpdGhlckFsZ29yaXRobWVudW0AAAAPRGl0aGVyQWxnb3JpdGhtAAAAAE5vbmUAAAAYdHJhbnNwYXJlbmN5RGl0aGVyQW1vdW50bG9uZwAAAGQAAAAPd2ViU2hpZnRQZXJjZW50bG9uZwAAAAAAAAALem9uZWREaXRoZXJPYmpjAAAAAQAAAAAACVpvbmVkSW5mbwAAAAQAAAAJY2hhbm5lbElEbG9uZ/////8AAAANZW1waGFzaXplVGV4dGJvb2wAAAAAEGVtcGhhc2l6ZVZlY3RvcnNib29sAAAAAAVmbG9vcmxvbmcAAAAAAAAAFHpvbmVkSGlzdG9ncmFtV2VpZ2h0T2JqYwAAAAEAAAAAAAlab25lZEluZm8AAAAEAAAACWNoYW5uZWxJRGxvbmf/////AAAADWVtcGhhc2l6ZVRleHRib29sAAAAABBlbXBoYXNpemVWZWN0b3JzYm9vbAAAAAAFZmxvb3Jsb25nAAAAAAAAAAp6b25lZExvc3N5T2JqYwAAAAEAAAAAAAlab25lZEluZm8AAAAEAAAACWNoYW5uZWxJRGxvbmf/////AAAADWVtcGhhc2l6ZVRleHRib29sAAAAABBlbXBoYXNpemVWZWN0b3JzYm9vbAAAAAAFZmxvb3Jsb25nAAAAADhCSU0PoQAAAAAALW1zZXQAAAAQAAAAAQAAAAAABG51bGwAAAABAAAAB1ZlcnNpb25sb25nAAAAAAA4QklND6IAAAAAAAhtczR3AAAAAjhCSU0EBgAAAAAABwAIAAAAAQEA/+EM22h0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8APD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4gPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iQWRvYmUgWE1QIENvcmUgNS42LWMxNDAgNzkuMTYwNDUxLCAyMDE3LzA1LzA2LTAxOjA4OjIxICAgICAgICAiPiA8cmRmOlJERiB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiPiA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RFdnQ9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZUV2ZW50IyIgeG1sbnM6ZGM9Imh0dHA6Ly9wdXJsLm9yZy9kYy9lbGVtZW50cy8xLjEvIiB4bWxuczpwaG90b3Nob3A9Imh0dHA6Ly9ucy5hZG9iZS5jb20vcGhvdG9zaG9wLzEuMC8iIHhtbG5zOnhtcD0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wLyIgeG1wTU06RG9jdW1lbnRJRD0iNjc2ODc1RjFFRTNCMTZGOTY4MzlERTJFMzQyQjA1RjYiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6ZmNmYzU4NmUtZWFlOS00YTVlLTk2NjUtYTI1NTFiODVhYTUxIiB4bXBNTTpPcmlnaW5hbERvY3VtZW50SUQ9IjY3Njg3NUYxRUUzQjE2Rjk2ODM5REUyRTM0MkIwNUY2IiBkYzpmb3JtYXQ9ImltYWdlL2pwZWciIHBob3Rvc2hvcDpDb2xvck1vZGU9IjMiIHBob3Rvc2hvcDpJQ0NQcm9maWxlPSIiIHhtcDpDcmVhdGVEYXRlPSIyMDE4LTEyLTEyVDE0OjA3OjI4LTA1OjAwIiB4bXA6TW9kaWZ5RGF0ZT0iMjAxOC0xMi0xMlQxNDozNDozNC0wNTowMCIgeG1wOk1ldGFkYXRhRGF0ZT0iMjAxOC0xMi0xMlQxNDozNDozNC0wNTowMCI+IDx4bXBNTTpIaXN0b3J5PiA8cmRmOlNlcT4gPHJkZjpsaSBzdEV2dDphY3Rpb249InNhdmVkIiBzdEV2dDppbnN0YW5jZUlEPSJ4bXAuaWlkOmZjZmM1ODZlLWVhZTktNGE1ZS05NjY1LWEyNTUxYjg1YWE1MSIgc3RFdnQ6d2hlbj0iMjAxOC0xMi0xMlQxNDozNDozNC0wNTowMCIgc3RFdnQ6c29mdHdhcmVBZ2VudD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTggKE1hY2ludG9zaCkiIHN0RXZ0OmNoYW5nZWQ9Ii8iLz4gPC9yZGY6U2VxPiA8L3htcE1NOkhpc3Rvcnk+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDw/eHBhY2tldCBlbmQ9InciPz7/7gAOQWRvYmUAZEAAAAAB/9sAhAABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAgICAgICAgICAgIDAwMDAwMDAwMDAQEBAQEBAQEBAQECAgECAgMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwP/wAARCAOJA+gDAREAAhEBAxEB/90ABAB9/8QBogAAAAYCAwEAAAAAAAAAAAAABwgGBQQJAwoCAQALAQAABgMBAQEAAAAAAAAAAAAGBQQDBwIIAQkACgsQAAIBAwQBAwMCAwMDAgYJdQECAwQRBRIGIQcTIgAIMRRBMiMVCVFCFmEkMxdScYEYYpElQ6Gx8CY0cgoZwdE1J+FTNoLxkqJEVHNFRjdHYyhVVlcassLS4vJkg3SThGWjs8PT4yk4ZvN1Kjk6SElKWFlaZ2hpanZ3eHl6hYaHiImKlJWWl5iZmqSlpqeoqaq0tba3uLm6xMXGx8jJytTV1tfY2drk5ebn6Onq9PX29/j5+hEAAgEDAgQEAwUEBAQGBgVtAQIDEQQhEgUxBgAiE0FRBzJhFHEIQoEjkRVSoWIWMwmxJMHRQ3LwF+GCNCWSUxhjRPGisiY1GVQ2RWQnCnODk0Z0wtLi8lVldVY3hIWjs8PT4/MpGpSktMTU5PSVpbXF1eX1KEdXZjh2hpamtsbW5vZnd4eXp7fH1+f3SFhoeIiYqLjI2Oj4OUlZaXmJmam5ydnp+So6SlpqeoqaqrrK2ur6/9oADAMBAAIRAxEAPwDf49+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3XvfuvdYpY0k0awDpcOtzbS4/Sw/F1/wAffuvdcwihi+ldTAAtYaiFuVBa1yFLG39L+/de6//Q3+Pfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691Eg+/80n3RozB9vTeIQLMJvutVR94ZDIxQ05TxeID1A69V+PfuvdS/fuvdY5vL4pfB4zP438ImLCLy6T4/KUBcR67arc2+nv3XuuS6tK69OvSNem+nVb1ab86b/S/v3XuuXv3Xuve/de697917r3v3Xuve/de697917r3v3Xuve/de697917r3v3Xuve/de697917r3v3Xuve/de6/9Hf49+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3X//S3+Pfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691//09/j37r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvdf/9Tf49+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3X//V3+Pfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691//1t/j37r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+6914mwJP0HJ/wBh7917rw55H0Pv3Xuv/9ff49+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3X//Q3+Pfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691//0d/j37r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvdf/9Lf49+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3X//T3+Pfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691//1N/j37r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xv8Pz/xS3/Fffuvdf/V3+Pfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691//1t/j37r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvdf/9ff49+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3X//Q3+Pfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691//0d/j37r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvdf/9Lf49+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3X//T3+Pfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvddc3+vFvpb8/1vf8Ap7917r//1N/j37r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvdf/9Xf49+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3X//W3+Pfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691//19/j37r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvdf/9Df49+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3X//R3+Pfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Wrx8ad3fzaf5hHyt/mb726V/mSba+Knx9+MXzl7E+HXV3TmU+GvU/yK25W1XSOCwGK3bnancWd3H1xvvHVlfUZGkr5YVzVShyFdOCsdPHBB7917qwGn6G/nfbJptOB/mJfB7u2ol4kfuL+X1vrrz7XTLTyK1LJ1D8uPHO0qCSNhJCAqWI9Tak917qPLv7+e51A2SyW6fj7/Ll+a2BWkgXGYXojuHuz4cdkiu1sKhp6DvDb3yG69ylMsQUqf7wYxndiNKBQW917rH/AMOY/LzrKifIfKH+TX83tkY1Kunikzvxh3f8efm1i6SgqJoomy9Zt/q3svb3bL01Fqd6iGj2tWVapHqjikDKT7r3XdJ/woA/lJrlRgd1/K7/AET55fJFVYjvTo/5F9Fz0FfT+EVmJq6rtvqPZ2LGWoWmUSwJUO4X1jVH6/fuvdHo6M+dHws+Tc8VF8d/ln8cu7MrLCJjgese5uvd5blpkIRrV+2cHuCsz+NlVZVJjqKaJ11C4Fx7917o1Pv3Xuve/de697917r3v3Xuve/de697917r3v3Xuve/de697917r3v3Xuve/de697917r3v3Xuve/de697917r3v3Xuve/de697917r3v3Xuve/de697917r3v3Xuve/de697917r3v3Xuve/de697917r3v3Xuve/de697917r3v3Xuve/de697917r3v3Xuve/de697917r3v3Xuve/de697917r3v3Xuve/de697917r3v3Xuve/de697917r3v3Xuve/de697917r3v3Xuve/de697917r3v3Xuve/de697917r3v3Xuve/de697917r3v3Xuve/de697917r3v3Xuve/de697917r3v3Xuve/de6//S3+Pfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Wq/8Ay4fmv1l8Gv5G+/f5lm6uud/dlY/vv5j/ACf7xzuzurMRjq3sLfG9O8vnFuvonZjJHmMvRUVXV1NPjMKjzNUSSGjiRIUqJRHHJ7r3RntlfLH/AIUB974uLsXr7+Wn8QfjVsOt1V2C67+W/wAnt9VfduawpfVRy5Cg6r2FNiti5nIUwu1BmKaCpopG0SqdOpvde6W9J/NA/mC9dUzUvyP/AJHny+pMpiVnOcyvxS7a+PPyi2zlKSkk0DMbQhg3t11uav8A4nToZ4sZUUcFfCWWB9Tgv7917r1B/Pl6WxSzZDu74F/zcvi/tSlU/e7873/l6ds0ey6KbUUSmny/WlR2ZIZZX0hGSF4iXHr+tvde6cIf+FF38mStmhxeZ+YlLtaauV4pKTsfoT5M9fU8bASCWlyFTvrpbA42mkJicBJZQJLenUCCfde6DPc/Y/8Awmo/mJ5GPb+8N2fyxu4N9b5kgxOMq89W9S9e93ZeuyExpabHbX3XWnZHb9PmqueMCOLG1kdWzBGUfoPv3Xukl0n0rTfEf+dT038M/iv338r8B8eaH4Edp/Kvur43do95by+QHSEOPftXC9F9J4zreXvCr352D1pXNuzK5/LZMY7PqMgcRRIqJAlas/uvdbGnv3Xuve/de697917r3v3Xuve/de697917r3v3Xuve/de697917r3v3Xuve/de697917r3v3Xuve/de697917r3v3Xuve/de697917r3v3Xuve/de697917r3v3Xuve/de697917r3v3Xuve/de697917r3v3Xuve/de697917r3v3Xuve/de697917r3v3Xuve/de697917r3v3Xuve/de697917r3v3Xuve/de697917r3v3Xuve/de697917r3v3Xuve/de697917r3v3Xuve/de697917r3v3Xuve/de697917r3v3Xuve/de697917r3v3Xuve/de697917r3v3Xuve/de697917r3v3Xuv/T3+Pfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+690Afys7Hfp34u/JLt2LJnCy9WdB9w9jR5gFFOJk2R15uLcyZINKkkYNC2MEo1Ky+nkEce/de61ZPk5sru3Yn/CZ7+V/1H8avjf2P3t2D2BF/Lbzdf1l1ptXP5XI01VJWbX+UGeym6psPSVVRs3CZnf8AtiDH1uYqYvtaOty8ZlKBww917q0PG9gf8KOuxIZNx4b47fylvjpiq6ppxQ9dd3d3fJvtzsbA00EMn3ozW4+ktm0XXuZfITyR/byUk8JplikEkUutGX3XulZi6T/hRQsEuXzec/kuSVkOQYQ7Bxe2vnDDQ5HERqGQydrVe6JqrC5arkJVmGz8hBAoBCSm9/de6dm7X/nw7Egrd0bs+HH8uHvPDUrNKnWfQ3zB7u2F2nXU3kCmnxG4e8Pjniur6vJrESyLW12Lp5SNLTQ31D3Xus8v853ofriomxnze+OvzH/l/U8NRSYyXfPyf6Dr8l0BXZ2omSOLFY75FdF5bubpmMSSEGGfKZXFxSnSqnyMiN7r3SlxXbX8lb+aRjKrrGj3l8Cfl/UZCHI0w6+ydR1Lu7sKmSo0Q1WVwm1c0kfYmDn8rq0GVoYKeRJ1V4JxIgZfde6XXwo/lQ/FP4Bds9t9ufH6buM5TtfY/X/Wce3e0e3t19vYDrPrrrWqzddt3Y3V+S7Bnzu/cJtf73OySyUddm8nEjRRCAQKrK3uvdWWe/de697917r3v3Xuve/de697917r3v3Xuve/de697917r3v3Xuve/de697917r3v3Xuve/de697917r3v3Xuve/de697917r3v3Xuve/de697917r3v3Xuve/de697917r3v3Xuve/de697917r3v3Xuve/de697917r3v3Xuve/de697917r3v3Xuve/de697917r3v3Xuve/de697917r3v3Xuve/de697917r3v3Xuve/de697917r3v3Xuve/de697917r3v3Xuve/de697917r3v3Xuve/de697917r3v3Xuve/de697917r3v3Xuve/de697917r3v3Xuve/de697917r3v3Xuve/de6//1N/j37r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3XvfuvdVafzu9+YTrj+UT/MX3DuDIS4ygyPxM7f2HT1MURmaTN9p7Yq+sds48oFa0WW3Ju+kpXf/AHWkxa4tf37r3QQfyq/5lPw67K+JHwR6azPzF+G+S+UOe+PHTO0ch0p1t3hsar3NHvbD9a4JKvZuO2LU57+9VLuTGUtJ4arHGnZoq6GeGEyrEGPuvdFk7L3z/NA+ZP8ANS+aHSnwe+c+D+IfQ3wQ6y+Me0N4YXevxj63+QGzu4O9e5Ntbm7cyNJR5HPS4Pc2Agwuy8hjqLMz0WYE9FLFBGtIDM03v3XugF2L/OB+fPaH8rDO9wRYX4/7b+VvcH8wzZv8ub4Pdy7cwm5f9CPf2e3P3RgOspO8oevtz1m5cpg9vwUGL3WyJLV1cL1WGeQ0yJGaeT3Xuj3fy6fm986N0/Of5Ufy4vnJt3oDsTsL419R9ZdyN8lPizSbw2912KPtD+EnbvV3Zmy99Vlfk8F2dmcdX1GWx70TxUc+Lx87NEp8UkvuvdQO7f8AhRb/AC5+gt991bF7Hj+SsWO6D7gz/RfZ/ZWC+N3YG6On8Nvva+UpNu7oof8ASFhqaswc0WD3LV/wyaJilbJVraGnljkhkl917py/n09bfGPJfys/lz8gt89CdRdgdgbL6CzrdI9ibn67wEvYfXfYPYi4zY3XG79g7trcVBvHZ26MFurdWPrKNqWopphVQRo6kXQ+691cb1LseXrHqrrLrWfPZjdU3XvX2zNjzbn3Dkq3Mbg3HLtPbmNwEmezmXyU1TkcrmMw+PNRU1NRJJPPPIzuzMxJ917oQffuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvdf/9Xf49+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3XvfuvdBj3ZvPdPXPTPbnYWxtnxdhb22H1jv3eez9gz5lduw743TtfauVze39nzbgaiyS4KLcuWoYaJqw09QKUT+Txvp0n3XuqDPhl/Nr/AJqH8wTojr7v/wCOn8o3rHb/AFdvqiqavDdp9y/zAdq4Da27ptvbiy+0N10m0dnbW6N3N2TSxUe4cFVRJVZahool8REYqv1e/de6M7ub5K/zgc1hs9tvcv8AJf8AjnvvB1dEaPI4qb+Z3sitwW66OpbTPQDDbo+IcVPPAIj+5HXiGJ7cXvYe691Xttb4h/Jb5SfzRP5cPfnZ/wDJy6+/l6dUfEWf5G9mdtb5wPbvxI7Hl7O33uHrzCbd6OxdPXdEGi3nXxbD3zRnJ0qZKjiR/O8uiD7dlm917oePg12LT7R3N/wo7+S2LqZ8ht7ZHzH7eoochTVEaStuL41/E3YcW8MZS1LpNDDPhMtGKYFg4idAGX0ke/de6Jt1V0ZhsL/Ln/4SofHza6u24878y/i38t4cIIyKqbE4L4yfJf5X9tZjQhpgsGEyO+hJKSSQswJDm4b3XurIf5IOAqOxav8AmUfPDOiGuznzQ/mGd40mztwRwzK2Q+PPxYzVX8dukcWamcs1bFgm2rnVR0IiXzlFVSrD37r3VOGb+77t/lY/yzOpMdj6zJ/7P5/woE3pL3Hh56eirsluLrKi+e3y27c7KzuQp3aWl3Djtv4vrDG1FVLUmRXgplLLYKo917q+T+brr7dX4GfBbHHB11X8yPnX0xUb+wOYdddZ8dviLVVPzI7trqOGTVTzM69LYXC2mV4WlzsSFXZ0Rvde6uI9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3RQfm787fjH/Lt6Sf5B/LHsCXrzrV91YbY2NrqPbe4925fO7y3BS5XIYnbmFwO18ZlcnWZCpxuCrapiY0ghp6SWSSRFUn37r3VU+yv5/p75oaXcXxK/lSfzUPkR1/kqJavA9q0nQm1eu+sd0LKjSwTbY3fvDsKKizGOeNfVOoVlYgCM6lJ917oR67+ZH/NPrsGu4do/yI+16bERLPPlcn3J89vh10xQYPH08LSz5XKxV2a3TnqbHUaqz1DmgvHCpdQ5AQ+690XDsL+ax82ZaiggyneH8gP4G/cMGyWC+S38xPMfI3sqioV8f3FbjNrdd4b467YyMml3EKnN/wCei0shVg3v3Xui7ZP579F74rsniO9v+FLW8MxJXNNo2n/Lf+KHXmxsHi5CkiVtPg95Q9J/M3sLM0FGSEiqlz1wfWbO6BPde6TdLnvhJuLFLX7Q/m1f8KX+woJqk1abn2L1581MlS5KCpjCrHRNR/y/6DaxxqTQyOj0tNH6iyq5iEaL7r3XLGt0FEJKh/mH/wAK0d0Y/Usn3M3U/wAxqehNNGswkZKnAfEfAVSU1QrBmcsJV8Y0MnrDe691GzO6+nIdFZtDK/8ACvXu2hWkkjFVsXC/LvbmOgqZXKyQNUb0w3UbVuRphTKSdU8Uayjm7MB7r3Tj8c+k/lb8nPlr8aZfj9jP57PxK6N6Y7dwnd3yS7k/mafK/uijHa2xNiyxS4/4ydafHOs7R3lt3dUHdearoXz2UyMVLBh8Ni54lDSVP2k/uvdbgPv3Xuve/de697917r3v3Xuve/de697917r3v3Xuve/de697917r3v3Xuve/de697917r3v3Xuve/de697917r//1t/j37r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+690yblzWA23t7OZ/dWbxO2ts4bFV+Sz+4c9kaHD4XCYijppJ8hlMrlcnLBjsdj6GlRpJZp3WKNFLMQAffuvda3/AMPf5C2M6j6A2l0hsb+cn/MYynSmz6/cNdtjaXxd7s626L2BRYjeG6M9vaagoqrZe0N7bwo1yuT3HU1dXPSbip1ramaWaJIFdY0917o1lP8Ayc9/7Y/d65/nFfzhdvz61jWDfHyV617pxUWPIInpo6ftHozP5WSsN7x1U1dNLGSb6wFC+690T75KdJ/MT4M/IL+W7tbpX+ax82u48r8pPnJ191Jvrq/5Kf7Lx2jgst0Xg9obx7O78zePloOjNt5/G1VBtHZa0lPJTuBRyZNZPLEyrL7917otvS/YDbE/kv8A/Cj6esxjYgbc+bH85DrnDZSSv/in94srvuL+7eGyQqwxqp3TcW94sf5ZiWkal8hbSePde6OXvbFYXpP57fy7urMnDS1EH8rL+TN8rfkFXl6ryUklZWYz4/fGnBFaybTFTznb/Xm5lgrBEjrTS1Sk6JWU+690YT+VNUbf+Fv8hP4s9l5ulX+AdcfBOp+WG6YqaWSeWuTe2y9w/KDdlXNLPL5JMnlqndlVPUFnH+UyvyB7917qt34r9S5TaOd/4SvdHZSkqq6Wl6X+Y/zh7WocjCxlod/bs+M+O3RXVmSih8f2ldjO4/lrO0Tt+2JoSnqLD37r3VqlcuU7d/nrYGlqqPGZPYnwn/lqZbP46qdm/iO3+6fnB8gYME7xII0uW6m+JVRGWLunjyJAVWuffuvdXA+/de697917r3v3Xuve/de697917r3v3Xuve/de697917r3v3Xuve/de697917r3v3Xuve/de697917r3v3Xuve/de697917r3v3Xuve/de697917r3v3Xuve/de697917r3v3Xuve/de697917r3v3Xuve/de697917r3v3Xuve/de697917r3v3Xuve/de697917r3v3Xuve/de697917r3v3Xuve/de697917quL+cDtzr3c38rH+YXB2Ztzbe59uYf4a/JHdFJRbnxmKylNRbq2z1BvDNbMzmIjy8UkFFuzCbpo6Spw9XEUq6XJRwyU7pMqMPde6G74LU+7sJ8Gvh1Sdn6qLfuI+KHx7p+wxXJHRPSbuoOoNoxbs+8jKwxUjQZmKo8i2RYyCLAD37r3Wtz8dds/C7+bH8uPlv8AzKfn3vHorfXw52/v8/GT+XP093v2rgqbrufYfQ1VUYns35Iy7Ezu4cLtjIUfbm/qmqnw65eievgo5qyKoh8AopZfde6sTHyW/wCE2/xRlyDbW3v/AClutMpRSwHI0HS23/jVk90tWUzXp45cN09g8xuStykMg9MYhkqA5Fhci/uvdClRfzpvibk9vU2Q+Ofx9/mD/JfaEVM4oct8cP5cfyxyO0UmvI6YykzO8erOvNvLNUfrR0mFKwbV5bEn37r3TQv85bMyhGp/5Qv86edHnWHU3w72FQlFcqBO8eU+QFBMsA1rc6dQBPHpfT7r3SpxH81DuHdkc0ez/wCTp/Nelro5UiSPfnXfxP6tx8rOGYMMjvH5eUjeIIhu4hZVawYgsPfuvdTI/lF/N03/AFE9H17/ACsOqenKNistFub5WfPbY1IxgKo4iqtmfGbqn5DVEdXIJCCP4uFiZDy9wffuvdAb8P8A+YB/MU7Q/mVdp/A3vbo74Y5ja/QXVOB7I+RHcnxa7b7t3Nh+kc52bS5Ws6Y6jza9rdWbLfcvae8cfixk5aGnp6SiiwMslYKz7mlkx8nuvdXye/de697917r3v3Xuve/de697917r3v3Xuve/de697917r3v3Xuve/de697917r3v3Xuve/de697917r3v3Xuv//X3+Pfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3RIv5lvT25fkD/Lw+cXSmysFWbo3z2Z8UO/NpbC21j/ALX7/P79ynWW5YtkYaiNdU0VEKvJbrFHDGZZoow7jU6i7D3XutWbo74NbZxXx9+OsO9P+E2Xym2z2V1d0v1rszsrvX49/LPpf4ydxbv33tfZu38LvDeo251n8nuqewd7VO6s/BV1zNmlNUzTlnXyaynuvdClkI+o9tS0mNyHwV/4Vx4naFbKcRTbE25333xvDYtNNKy08lJJSbG+cu5s5QYmojkMJq6qoiofCzM8qKC4917o8P8AKq6F/lW9hd5djfIzoP4x/Mnpb5XfCyfK7B3rtf55b4+QtZ2l1Zk+79ipmKjOQbY7g7q7a2via/f3XUZP8RoZY5JMTXB3XxVELt7r3Vdfxer035/wnh+BOyN+4+pgz38y7+aH1Htff1T92Jcnko+2P5omd7Y3hlnNVGrZ0V/VHVVTFUR1JcVVAZC5KHT7917o3Hzu3/RVu8/+FLvauWgEC9G/yvOiPhPszNhozUjcXaPSXyN7kymLoJmWNopKncPyS2sPBG7NNUKnBfQvv3Xuj2fzFNh/6Gv5Pm2PhntvMy4fL9r7Z+G/8t/ai43XTVeVou79+9RfGbdWKx6RQkR+Tq7M5qaRbIopYJBcce/de6eqCl/j/wDPc27tPCYqgp+vfip/KTqYcXSYqkho8ftHdvyW+UeFxWNw0cVOEjgWTYPxhtS04URw04JUeoafde6cv5ZckPbPye/m7fLGfG5TG1m9vnKvxI25HkJ/NTT9d/Abq/avTsdZiRrPhosj3bn9/VRSy2knY83v7917q4f37r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3XvfuvdUv/wA4GGPvXI/Ab+XbFLjq+g+b3zF2hX93bPyVDLVQbs+IXxKxdZ8mO/8AFT1UVTSnGUOfzezdpbdqZC2meLcBprOZxFJ7r3Vu299kbV7H2Ru7rje2Gps/sjfm1c/sjd23ql6iCjzW1d0YirwOew08lFNTVUNNksRXSwOYpI5FVyVZTYj3XutT/H9Bf8Jk+j98776z6T/l9bl+XnYPUe4c1sfeuD6I+Kny5+ddBiewMA2rcGwMjvetxHY3Vz70wZkT72jmzAOP8irMYfoPde6sD6N+VHW/WGOpaX4ifyB/nH1iDAafCxYD4ofDj4m4pkrI5PGtdLvT5A9cZjBU1TKiioNVQJJEG1SpcaT7r3Q3r8xf5r+crZF2z/JqpdvYsOY4qnuj+Yr8eto5OS0kAEzYzp/ZPyEpIqZoZHa/3plDRlTGAQ3v3XulFB3F/OX3I8kWP+C3wS61Bjr3hq9+fP8A7Y3lGrxU5lx0M9JsX4Q08v8Alc4EUjrIREGL2YLpb3XukzXN/Ps3LkI4sfD/ACkOncHVQ0iz1lRXfML5BbhxDyi1fJTUS4z454bKT0yk+APLDGzga7rwfde6R2W+Df8AN57GylTP2J/Opi692tkqQQ1mxvi/8AOkuv5qOZtHkbFdkdt767y3nTqAGCughmuQ2oD0+/de6M3/AC6P5dezP5emyu5sXj+1uyPkD2l8iO7dyd891979xfwCbsffu8c/j8Xi6ekyFVgMbjqePAYKkxjPRUlnjp6mtq3j8aT+NPde6sS9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvdf/9Df49+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3XvfuvdU8/zmvkJ8mOiOqPhxt34o9t4/o7s75R/wAxr4rfESt7NyPWu0+2o9q7O7xqt54zP5iDY+81XC5efEvi6es8ZmpZZo6Z4UqIDKZU917rr/RH/PT2FQmk2n81f5dXfky+GNcl3l8KO6urMnJHHxJPI3S3yorcQlXUA+vTQmIEXVFHHv3XuuWP35/Pj2dQynd3xv8A5XXd1ZURNQ0UvVnyf+S/TEuPr2UNFn8th+x/jn2PS1OFUQsJKGmypqw8yKszLG8j+691WH8ncb8vPhb/AC4v58Hzm+QGx9gdKfIv5o7l2bgNidfdPdo5XtSh2Vt3PdX9M/DPr3M4jsP+7ex8rW74qs3ubIZSnCY+lNNUrBIIowTCnuvdHe+VHxr616ZH8gb4TdewV9Fsfpn51db1WzY2GLbOV+J+Kfwf+U+5YMpnxFTw0Ndkszk8bT1uYq44lklq55Z1ImdW9+690QXuzC1XbP8AL4/mEZnJVtLGf5j/APPY676U6/3JQzY2rOX612f82/i/8KcLPSV0c5Srx0+1/jRmainR7mL7l7pp1Ofde6tx/mOnGdi/Jr+Uh8bXqvHld3fOXI/JWtpRLPF5dlfDXoPtXsmsqnEIKyRQdp7h2ZDpcFDJUp9DZl917oLfiJ2VtHH/ACc/ns/OzdOcJ676z7k6++PGQliqVqTg9k/AP4o4DfXYTQp5Isfen7E7y3axOtZFmR4JipgHv3Xuh0/kpbL3Js/+Vx8PMlvWU1O+e4eusl8nd81cislRV7w+WW9d0fJfcUtSjqJop0yXazx+KS706xiEk+P37r3VpXv3Xuve/de697917r3v3Xuve/de697917r3v3Xuve/de697917r3v3Xuve/de697917r3v3Xuve/de697917r3v3Xuve/de697917r3v3Xuve/de697917r3v3Xuve/de697917r3v3Xuve/de697917r3v3Xuve/de697917r3v3Xuve/de697917r3v3Xuve/de697917r3v3Xuve/de697917r3v3Xuve/de6pr6uq6j5Ifzsvkf2HT1eVfrr+XV8TNhfFPCUlXj/Lt3K/Ib5cZ7C/InuTNbbzUczwNktk9QdfdfYrIQBRJHLmHSTlFC+690bP8AmKfNrZvwA+KXYfyC3HRS7n3fClNsXorqzG09Zkdz93/ITeyVOM6j6g2jg8THUZ3OZjd25VU1EVBBUVVNiqesrBG0dNJb3XuiufyZfixkP5dv8ubpvq75CbpwWE723rUbq79+Q9RuDNYPFGh7f7ozTbw3HgK2Vcg+Iev2Pj8hj8DVz0kr0dVV4554D4pkHv3Xujh7t/mGfAPYNTJR77+cfw+2VWQySRS0u7fkx0vtypilieSOWOSDMb1o5UkjkhdWBAIKkHkH37r3Ras7/PA/lPYSor6Sk+cHT++6vGLM9VS9NturvWp0wCMyNS0/TG29+TZAEyqE+3EvkZgFuePfuvdQYP52/wDLxr6IV+E3t8itzUzPJHHJtn4DfPvOxyvDK0NQsc+O+Ms9KzUzxsJBrumk3549+691hqv5umxt0S0OP+PHwo/mVfJXKZgrBiKjavws7P6V2SauoULRnNdm/LaH487DwWMeZrTVL1sn28as5RrKre690T35W/zVv5mnxwwfR+4tzfy2ukOrq7vP5J9W/HDrLpjsH5pUvZXyA7c3X2ZkqunSDZ+3OkOo9wdX7Upds4zHTVmTyeU3dUUdJA0ZKM7LHJ7r3WxZ7917r3v3Xuve/de697917r3v3Xuve/de697917r3v3Xuve/de697917r3v3Xuve/de697917r3v3Xuve/de697917r//0d/j37r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691X1/ML+DWd+cu0ehMZtP5D7t+NG+vjh8i9p/J7rTsbaOwev8Asmqouydj7P35tDbMuQ2t2TjsptjKY7HwdgVdQYJ4JI5Jo49SnSCPde6LJD/Lo/mK5imp339/PM+VeUy1LTSJDVdf/F74TdW4pqtxHaeqwuM6bzX31Mrxg+KaodwLgSDUxPuvdB73V8Sf5nnUHS3cfbEv887u6pPVnWO/uxcXHkfg58EWxaf3L2vltzPHuOCm6poqzOUEgxgWRI6qhfx6gsiEgj3XuikfO7uPsjv/APkE/AfuX5A6d3Zb5C9h/wAq3sD5E5nbuIoNtRjbnYndfTm+83lcbtygL4xGrK+ooaSKniEUJlqlkVI1AiX3Xuj6/JTcm3N3fzmvhftzJVFbCnws+Bnzc+aO4FWEjHPN2puLqD42bKjqK2VTS01Y23ot7SRXMblIZLMU1j37r3VY+3eu5sT/ACxP+E1uwZDWPV9rfzHvhN8gdx04lb+JSZLdO2fkP84M3Uv97Tw1ApqbeccT1Vo1IgLRggMG9+691b/QLT9pfznN7biqMniMhtr4Rfy9dq7ZFJVMGn2l2d82O69wbq3FkI1qacRUlU3V3xKw4ephl1rSZFo3sstj7r3VOmLy+4a//hOL3l2PtXELtLtz+bF8gO38q2P+3lq6vP5L+Z5876zqXDvTUwRZamrqPj/2NQeKyoxipQQA3Hv3Xuts3bO28Fs3be39obXxdJhNs7VwmK23t3DUEYhocRgsHQU+MxGLooRxFSUGPpY4o1/sogHv3Xunv37r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3QKfJHvrYfxa+P/AHP8j+z6t6PYHR/Wm8uz90tDJTpXVmL2dgq3NSYjEJVSwxVeezstItFj6fUHqq2oihQF3UH3XuiVfygOi95dHfBDrjcvdNHRUfyP+TmY3p80PlRlP4MduZGu7z+TucqO0tyUO5sdLIyUmY622xlsTs8qumKGk23DHGBHGvv3Xui2/wAznpT+Tj859w9MR/OP5j9WbJy3xl3Fmt27TwWN+bmyejnoMjnJdvT5Gq3NQJvTGV0VTEdsUwpshCaLJ0CmX7aqh8r3917qtSl2D/wkB6N3Ji4KX/ZVe9N710tRPBHiNwd9fzANz56pEZSebJ4zbVf8gZsuyRTelZ6d0jVR41URjT7r3RtNpd//AMn3r2opc78Wf5NPenYyPGlLS73+Ov8AJK7A2tSzuBC320u79/dGdTu02uGIySTzhbhXd7AsPde6Nztr+Zx2PNio8H1b/Ji/mlUMNFC8GGxG4Oqvif03tqNlAWCATbm+V+NXFUZnYKzijIRAXCsoF/de6lSfPf8AmTVcFVNg/wCR58ip2hNoItw/Mj4GbakqS0vjjAVu7sm0YABaQ2YIoFtVx7917pmoflt/Ol3nUigwH8n/AKd6kRrr/eHvP+ZF13laCJ2STS7YPo/pfsnIyQxuoLETh2DABRyy+690HfQHwz/mGd5fzF+vPm//ADN4/ijiNs/FLpXeWzPiJ018YN19m7023ge2O58hHS9m9x7qyPZu09r5Ft20/XFBFt0BEkopFaKemigkp5Jqn3Xur4/fuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvdf//S3+Pfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3XvfuvdUPVdB3j/ADHPkp88sc3zd76+Lnwx+GPau3/jXs7G/DjObF657C7G7c2v01sTtP5E7q7R7X3R132BvSlodh5/sqn25j8Zt6bEwCTFVEszSTagfde6YukMn2xuT/hN5vDePY/c2/e4+yexf5b3yg7Npu3O0MjJmN95LFdmdZdrb764O5MsaKjqcrXbT2XuHF4/7l4VmqEoRIy6mI9+690Vv5MQ0dT/ACO/5IPx/SlRMZ8k+1v5I3QtVRtWTiVMZVSdSdkZFaeqp5HmeWCj62kdnVyREjupuB7917oaO1N6VGe+X/8Awod7UqIa+lrPin/LK+PfQGzNwwLR05oo6/ob5U/KzeNHQmbVFVVEFd2dgqkTT2VXPjIKLx7r3TTs6HLbq7s/4THdJWw2Tx/XPxJ7V+UnYcLxytPTP1h8G+t+htg1tHTxxRx00FVvT5EzVMMkgQK+N0gaiB7917p1k7Thx3Un/Cmj5qbLrBjdy7Pz/dPTO1c/BUNDMlf8Iv5f+ycLQRUrVbSLT1OM7o3NuOKMBAr1JYqrBgW917pp7Q67r9nfE/8A4TW/ECKrjptxRfJv4C5Dde3qFKqk/j2A+IPxK373du/IPHGhqBTYbsLrvCZKcSG7yqvlJVpD7917rZR9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3VHH8xlaX5pfOD4YfypWkpq3quXHVH8xP5yYGeWBU3X8ePj3v3C4DoTqLJ4vJ4rIYndG0u5flLPj5s3SK8FXHjdoyNG+mR/fuvdAd/OI2vU/Of5zfyzf5Wu366rye1Kzf1d88Pmrs+bKV9NsnLfETpHK0+2MftPsjC4isx2T3Jhu5t/5Cq25jofM1JTZJUqKiFxGkkPuvdWq7R/ljfy3dgim/uX8Afhbtmak0GCtxHxg6UpMlrjUIs0uUj2V/Eaip0qAZZJXkNuWPv3Xujd0WM2X19hZhjsftfZG3aJGnqBRUmJ21haSNAzPNMII6Khp0UEks1gOffuvdF33d89fgx1/MtPvz5ofE7ZNQ0jwrBu75F9P7bmaaMyrJEsWZ3jROZIzA4ZbXBRr/Q+/de6Abe/85H+VH19Ekm4P5iXw+qpJWKR0Oz++evuxcu8gkMQiXCde5vdGXMzyjSqeDUzcAE+/de6RNR/OM+Mu4cPDnugeovnJ8tcPKactmfjd8HvkfujbccdWlVJTTR7y3nsTYOyslDPFSMytRZGpBVkI/WL+6903UP8yT5O9iwSf6DP5Pfz/wA1PE6rJWfILKfFf4rYFVZkUThuwPkHl951EKeRS4gwMswXVpjYqV9+690i/jp/Mu+V3Zv8wiD4Ed1/BHY3UGax3QFf8heyN69efMPGd/8A+hnbFVnZ9tbBwPZ2JxvRWwMLid69i5dEegxFPmaqrOMkOQQTUsUjr7r3V0nv3Xuve/de697917r3v3Xuve/de697917r3v3Xuve/de697917r3v3Xuve/de697917r3v3Xuve/de697917r3v3Xuv//T3+Pfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3VC8X8yP+ZR25318uevviB/Lo6Y7s6q+LHyOznxpyHYO/Pmfjem9yZbeW1di7J3rnK6o2XWdT7qlgxM9NvqjFLLFPIraipJdJfH7r3S9h+XP87it1wJ/Jz6Iw81AwFTW5f+Z5sqqoc54y/k/gUGI+ONVW0SVK6fG1cImja4ZCAGPuvdcKP52/zfqGSVN1fyJ9wzxQhIxV9c/zIfiLuqOpmKrqlgpd4w9ZVq0WskamQTDgmO1yPde6yUf8wD+avP5BU/yHO6KdxJaMRfPb4LSo8LehHd6nsWgEchlZQygOFS76rKR7917qSPmv/N93XUxYXZn8lWPYNbMwhqd29/fzCvjfidmYdnbQtSKLpTE917u3BFCw1SRw0dLePlZGayN7r3Sgm7B/nw1NaMbRfF/+VviwiPO+4sn8u/k5ksJMssipBQwUFB8TaTPR1tIl2lkeHwyj9BU+k+690rfh78ovm7uj5d93fEb5rdcfE7aG6eufj/1B8htrZ34v9l9tb6xmY21232D2x13RYnLQ9r9c9fZFMhiMn09kZaqWCnEMaVdIqmRnkMXuvdEf+N29Ml1R/K0/nJfJ2iytDRJvf5U/zkO7Os80ZqOlpq4bY7F7T6r2NJTVjCJaqoyW5ero6amMqiV5WSIA2W/uvdGM+VW0Nz/Fz/hPf3R1mxWi3f0n/Kcz/VNbJLFDC9JnNp/Fk7BylQIoAKZKynq6eWRAo8YmUcEce/de6L9/Mk6/weyOtP8AhPf1rtmKPFbX2D/NP+AO2cBRzSmaKlwmw/j73VBhcf5HlHmmSjwkUUTksxksfUeD7r3QO9xZ6moNq/8ACuLOmSgraan6wpsatW9UniqK2m/lL7Dwz4WWWNDploq5xTBNRYTsYyFYG/uvdOPwJ3AMh/Mn+MWQzuRY7W+NX/Cbv4yxZmvnAnp8JububtHa24tw12SMEkz4/IT7R6YopFiZTLLAJGHpCl/de6ItDv6t7G/4TbjJQVVD172J/OR+fe+NnpnNzDGw0O2q/wCan8xDd+NzGd3flZqulpaiKj6P29VOa+eVRTgQ6j4offuvdWU9od+9K/Jr/hQB/Lb6K6V7M6/3tQ/B74v/ADM763xTdd7u2/uXBYXc/b+09qdA7V2VkP7t1ddQYzdm2drVNXXfw6R46mnxmWjlaNY5Yy3uvdbHXv3Xuve/de697917r3v3Xuve/de697917r3v3Xuve/de697917r3v3Xuve/de61nu7e1v5vvzb/mLfLPqD+Wx8penPiv8bvg7jOmek+xc72x1PtvtWDtbvnsjbVT2rvzL7LSt2LuHKQZLqvbeVxWErqKpr8fRrU6XjSf7qSWD3XuhNxPw3/4UR4bTkp/5ynxu3bWxRMRtrcnwA65x+3amY3UJUZna1Vh9wRRIDqDxqDqABUi/v3Xulb/ALJn/Pt3nT0k25v503R/TNZTI4noOnP5bXVnYFFkHd3sarJdudgCpiMKqmnwU0QbUwYcBj7r3S1xvXn/AAoA6U+xwO3fkT/Le+dW3hTTyV29/kH1P3L8OO1kyEhh8EKY/wCP8/dvWGTxdONYOnG46drA6jfSPde6kH/oIryT11Yh/kr7NigjR8Zt2RPnL2TLlZBEXkgyG8El6sj28ss6+MSRYTK+NX16JCmiT3Xukd23/Nm+V/wr6xznan8wP+WF2V1z1d11uLZm3+zvkJ8dPkR8fe8umIMZvbe+1+tsBvnbO3Ny7u6q75lx2X3fuulT+EVO1FyNDHKC8kqK03v3Xur2/fuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3VG/8AK8yX+zPfNP8AmofzC6WrlynWu9O5dgfCD41V1RHS1FJU9UfCvAZXDdkb02XnaL/J81sXtH5Ab83BVUsylwTigAxC3PuvdKDtH+TTD2h8yvkT8wKf+YB86Omsl8jMB1Xtbceyfj1vrr3rGbCbX6mwX8KwOzsB2XUddbo7F2/sqoyU9VlZ8fhq3EGoyVbNNUy1DaCnuvdct3/ynPghsTa4yPyU+TXzX3dt6Klniyu5PkZ/NN+YWFxmUgW33TZerpe/diYIRhakiQRRwR2mNx6h7917op4+P3/CWTouSfJ7o3P/AC1czkcTVSVFT/ps+Uu0fkNuQ1dRFOrpUY/uTt3szcGTkkh8gELRTekEBbD37r3Sw2p82v8AhNNtqnq6Xq6l+BlVEgqFqsZ0l8QKHd1RJqWGOZP4T1X0dmqqpaqEcUaqsTGdjGihiyA+690Yfbv8zP4PbPoFyHxo+H3zQ7Mp181F5fjj/K2+UOBpYloo6UJCcrunpLrHCrTvHVKISKnxuqtpNh7917pZ0X8zbu7ekTL1R/KH/mabkqWlaCln7L2t8Xfj1iJ5NELxPLP3D8oNu5+ipXE41SS4tQlmBGpHVfde6RmV+Wn86XOY2uqdkfyhOm9mzrTyfw+Dt3+Y717VZuSpaOVYWqMF1j03uvACKCYo7oNxKZEDKHQkMPde6G/+V/8AB/dnw96f3ru3vvd2O7X+bXys39W9/fM3uOip1+03H2ruCAR47rvZdTNDHXUnTnSeBZMBtXHAQUNPTx1FTS0dAlc9HF7r3VmHv3Xuve/de697917r3v3Xuve/de697917r3v3Xuve/de697917r3v3Xuve/de697917r3v3Xuve/de697917r3v3Xuv/U3+Pfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9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tjaOErf5gnzC+ZXyy7DzWIxmQ7I2hh/kf2J8cfjbS7ykiiqspSdfdN/GDIdL0dLtLE17ywY5c1VZivNMdU87uwCe690K+xf5MP8AKt2B4Xofgn8fN41lOtQsWY7n2cvyB3CBVhlqS+5O9arsXPytKrFSXqWOmwvYAD3XujabA+I/xS6orqTKdW/GP49da5KgiEFBkdgdL9b7NrqKEXAhpKvbu2sdUU0QDGyoyjn37r3RhPfuvdAV3J8ovjV8doYpu/PkD0t0sKnH1GVo4e0uztl7Eq8jj6Uus9Vi6Hc2ZxtZlI0kjKD7eOUtINIBbj37r3RMx/OC+FOfSvj6cyHyB+TGVx1TLTTYj4z/ABF+UXdDSeBnSoqYNwbT6lqNlvRQOoDTHKCM6gVJHI917ovPyt/nDdrfHn4+dgfJDD/y0fk1T9c9cUjS5nPfJ3sDor4rU2ZyFdPR47ae3tk7Wrt89odw7s3RvXO5CHH43HRbThqqitkSEKJHVT7r3VuXRW9t89ldK9TdidndX1/SXY2+uudm7u3z09lc5TbmynV269xbfoMtntgZLcNHQYumzNftPJVclDNUpTU4lkhLeKO+ke691Wd8zv5yXV3w3+UOP+Ln+yufMr5Q7ox/TmL7q7VzHxD6bHd0PSm2N17ny+1diJ2Jh8bncbksVLuis27XTXfQ0FMaSRUmWqvF7r3Rhvg5/Mw+LX8wNuysL0hld/bd7M6XqsBSdv8ASPdPXO5+o+5et33TRS1+3qjcmyN1UlPUHH5aGnlEVVRy1dN5IyrSAlNXuvdWAe/de697917r3v3Xuve/de697917r3v3Xuve/de697917r3v3Xuve/de697917r3v3Xuve/de697917r/9Xf49+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+690CnyT7y238Y/jx3t8kN44zMZvafQfT/ZHcu5cLt0UDbgzOD6z2fmN5ZTE4JcrW47GPmclR4Z4KUVF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f3xD+DfUO/c/2t1/sLuOlopYF+SnyE7FzmyuvaHtrvTaRqp6bZtLQYeHA7Np5ZKqleoydTNVL7r3Vw3v3XuqMv5NDJ8g98/zHf5mqR0s+2fnP8tKraPQOfoapqmg3h8UPhhgm+OfT2+KKCo8eQwqb13Rht1ZFqKeGFrTLUAMs6t7917pv/lSbcpu7Pmp/N6/mISUs8mK7i+UmB+InTWSqIadsdkOp/g3syg6o3DuzZ1bE0slXt3f3bcmY8spcpPUYVWRVVRf3Xur3ffuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691/9bf49+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691Vv8Azofjp8mPlv8Ay1fkz8bfiSm05e5e38DtfadHT7xz/wDdjHV20JN87Zr+wMXS5qWGWgpMnmdm0NbRxfdGOnZZ2VnRip9+690SnoToz+fsvUHVvx+p94/y0P5ffSnWnWGwesdo5TqDZ3c/yt792VtfZO2MbtbD4vF47tPNba6QlrsPg6CKNZ6wZmJ6uAMyzQlvL7r3Q81X8u3+ZVm4ZMduT+ep8l5cRV8ZBNqfEX4SbHzbopEqDGbjwvU7ZDDOJ0Us0QOqO8f0Y+/de6bZv5NW88w61W5v5yX85muz6LDUNUbb+U3V+xcRBV6Jgamn2ttj4/UmLNHLUM7LTVQq4NKKhDBLn3XunGk/kyYOaqir+0/5nv8AOD7YpYDEFxG4/ndnut9u2iEKwibH9CbO6eNVMrQKwlnlln8hZg4LG/uvdFq7n+Kfx2+I9NHP2J/woh+fPxtxmXeSGLFd8/Pb487srMktMZFNJtWX5AdWbk3nJXU/7nkNNU1UzBbuD47j3Xuq995d9/8ACejZc9H5v5hH8xH5rfJqvmlwK776X+YPz77V+RG+KH7iolyGBpB0bufYfSmP2vWsDCKTGY7FUAikRaRE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eJwO3/lNh+mt7ZdaIQ7K+SWJrOmKyOsro4jHi/747gaXqquygqpftxBR7hqXlnFovIrIze691cdL291iOsMz3RQ762tneq8FtfcG86/fm287i9w7W/u1tahrshnstTZvEVVXjaulxtLjZzI0crBTEwJBB9+691p4H51/z8+7f5eHZ/8ANSqfkh8Jvg78Shs/tfuXq7atT0vmuzPkBLsLB7h3BhusNpVlJu/C5rr+pynYOWpaHF4mteo11v3tPVvDEswiHuvdWhZD5dfNXon/AITtb4+YXzOzmDrPmPX/ABJ3RvOmrsJtXH7Hlwu8O7pJcB8eqPce1KClw2Mo974I7928uZx9JSUV8nHNSRxCUan917owPcebk/k9fySWxnXsFRnt9/F74ndc9KdWigwy1FTu75FbroNrdNdb5WowAqEM43V3vvKhrq+njfUIqibTcgD37r3R3Pgb8UtvfB34cfHT4o7bqaPJQdK9Y4HbGez9DTz0lPvDf1Ssud7N34KWqmqKmmm392Nl8rmpY3d2SWvYEm3v3Xujb+/de697917r3v3Xuve/de697917r3v3Xuve/de697917r3v3Xuve/de697917r3v3Xuve/de697917r/9ff49+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3XvfuvdUXfzb+8vkv2T2V8dP5V3wN7CyvVHya+Vwru0+7O/tsTyDP/Er4VdcbhxWN3/23Smhq6XJ4vdnYu6KyPbW1pkaFKyuirKRaqgqZaatg917qs75A/HP+Sx8Lc3JXfNH+d18996fIHruiyOF2vuPen8yLtTf/AMk+j6xaOopc3HsXZHx9xS7y2fVV7wuslPkcPVpNKviZXYsre690U/E/IP8Akp5OkNT0z86P+FB3yh7ZzscdInbvTPan8wHLdy12KmlAjjjrMnt3rvZ1fipI41gCHFysyIoClhq9+690vBuT+TL4vEnSv/CgnC9q7ikkrM7KlT/M7Xt7fOLj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Its/Jf5YzfIHvBHpYchis30B8BcLjvkFnti56laJqinxvYHbp2TjhVRvG0bnRe0hK+6906/zEIB8jPm9/K7+D2MmrKvG4ru/PfzFu/YMHmcfDU4PqP4XYuKLqSn3hhZqyOrr9p9ifKzsraFPCnhkSofC1LA/5LIPfuvdXMe/de697917r3v3Xuve/de697917r3v3Xuve/de697917r3v3Xuve/de697917r3v3Xuve/de697917r3v3Xuv/0N/j37r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3XvfuvddEhQWYhVUEsxIAAAuSSeAAPfuvdalfX/ym3Ptn4hfzfP52OyKbI7t7X+a/cr/ABe/lzUG3wmfrs7111Vup/hr8Ma3ZO1txtRVUUu++/N1ZjeWfw1KP8sp1eoCSsgPv3XujM0PxR/lu/8ACdn+X5uD5a7t6U6/7F796r6727HvPu7OYv8AvF3X8hvkfuWnpsMuK2bvDeke7Ny7DoOzOxcm7vTYoLSYnEmSsqoZkoppT7r3TjsvuL/hRn8vesNobj2J8ePgV/Lg2/vzGYHJyZPvrevaXeff+0tr5vHU2SgzGE6u21tTGbEw26qemkUSYXdTQVNK8hpqqnp543MfuvdDkvx//n44WcPjv5ivwU3pCyw0rx7w+DG8durFFBGFbKRLtLvZ5JMlWONUsLSCmUk+PSLKPde6zrVf8KKNtDIYX+C/yc+2hLTPDt7fku4fmR01NQ1KUcapV7x2DFt3tuHJB60liuLzNMJVBXTBwx917rHB1j/woSy1FT5TL/K/+Vxs/O1nikyO0tp/F35D7n2phGPiWanw26dy92YzceZhjGtlkqqKmd2AFkDWT3XuokfwY/nGb8qzm+0f51w65eSBVh2F8Zfgd0FgNqYqpR5A1R/ert/Jdob1zxqImGpJmpooyo0JfUz+69031n8ub+axm6mtweb/AJ/Hdj7TaKNY8Vtr4NfDnaO+qagnDwlpuwMLgEyZqZVjkEdTHSQMrjULsvv3Xulntf4Hbd/l3fyt/nx1Ttzt3tHuvcPYuxvmn8h+w+3u067HN2DvDs/tXrHP125dw5KswFJjYErp5MVBI8yDzS1PknLBnsPde6ALp6qkqNz/APCZ3HPFE1EfiV2ZuRIljpUWmy+M/l+9f4Siq4RIPLGsWL3ZXwaYbG1Rz6AQfde6Of8AFaagn/mf/wA2A09TJJXUmA+AGOyFOeIaYJ052XkqQoDZjLPFlSXYeggKB6g9vde6TlOJcn/PfzH3c7yQbL/lJbaOBpXmlaOjn7M+Yu7V3ZU01Of2YZMhF1PhkmdfXIKaMHhF9+690QHuHuCr2R84f+FGfYyqlRWfHr+U58d6/CUSMtHFVxYPpT5bdseKtFOzy1lW+VymiOocLLFFJ41BXST7r3SU/lr5eVPnP/KL6ZrJFqIeo/8AhMZsbsGhEtOsc9Pmeyu1PiRsfJ1NwQ8f3FF1uI1VtWhVYcliffuvdVHfzKu2K6i+fne3yyo+uu7O++l9u/zs/gJ1BvTrvoraC7/fc8X8tb4uy783NsWegjtSVO8sl2339PDT4+tqKWCsWgngUhoKhvfuvdbAez/5kX84j5DUlPnvj3/JLynWOwslSw1mG3n81fljs3pXctZDVNM1OMh0nitj5vsTBSLSiOWQVJFi5QXIDH3Xul/jqT/hRp2NWzjNZz+UT8ZNp5CDyUjYLAfKv5F9qYGZJUApqsZTOdUdb13lQMxkjEgUFQFuSV917oC+2Oqfnn13lqd/lx/wpX6a+OmByKU0uX2LtP4nfDT4/VUVH4YP4jT7c7B7s7D33uylkcToYa14WMZkDGEhkVfde6r+3dtb+TjLn6jD95fz6/5lXzg3LW1FImQ2f058tO5O+9q1KSjTBiKTZHwZ6n3FjsbR1MwfUqTK4kZryKfp7r3TZi/il/I3qc1Dmtr/AMlb+bv8tc79xaDdm9/j/wDOPN4rJMxjiWV675RdxdY7CMcpa7GaOIhReQBQvv3Xuju9b/G7e2DrVj+I/wDwmr+EvQONmCDB9rfMntH4v7Q3pDFNDFBJNndpdB9Z/KXsOOlglYsaeXcMczRxuwjDyAH3Xuhew/wU/mqZ1BXV6/yOfjplmnaSE9M/AvtHtzJ42nM4khpm3Z2F2f1xT5iamGl/OuDx4kliUiKMEge690Iud+Cn85fJRzVNd/PiwuwcJSUI143rn+V58acFi8dSU0LtO75PfvZfYeRgp6WJBpdJ6dY40NxY+n3Xuq2O9ttJsiN4+/P+FdmR2bnsQzLWYXaFZ8Quus+ZYoYvuE/uH1puWLc9UV0A6DBOULgcs12917oDP5du7v5afY/80r4kZaT+dl8v/wCZv8jNkx984n439cd09XdnT9Y7V3PuLqvMvv8Az+N3nvDr6j2xj6yTY2CqpYpsXVxmWpoaYSThY4Ypfde6u5/mRT4/fn8xf+R50DX41ctS1/yf+SHycyESJNUviE+MXxW32+287VwR6Yaahp99doYuNKiVl01bwogcuV9+6900f8KEGWr+BWztsQFJM3vf5vfBDam2cc0kavmM9VfKHrnJQYyGJ211UslFi55PHGkr6Yi2nSrMvuvdXj+/de6oG7Ehl+ZX8/f4402wFr49j/yeOiu6N297b2gkkjxGT7z+d3X2D2d150QIZo4/vclheqMG276mqpjPTwLNHTTNFOVRvde6EH+frndz7k+Ee1vh/wBf5LJYbsT+Y58nOgfgvt3O4mikylRtjb3a27TuTtrdOQxsJ8s228T01sPcCZGU6Yoaeo1Oygg+/de6An+aH8RPjN1Lsz+Uv0d078depNr0+Z/mn/A7q7FVu2+ttsQ70xHWvU1NvHtHOij3XR4qLc0LPtTp77TJV33Qnkop5zK7B31e690Yn/hQL2bvjY38r3uvYHVeSixfanyq3R1L8N+v5XZvJU1/yX7I271rumgpoYUkrKmqret8rm0RadWnS/lQftn37r3VoPQPSGz/AI7dA9LfHPZv3ldsXo3qfrrp/ar5yQV2Rqtt9abUw+0cHUZSWQMtRXy0GFikla1jKSQALe/de6h/JvuI/Hf42/IP5ALhItynozpDtfuEbcmyBxMOf/0Z7Ez29P4LLlVpK9sbHlP4J4GqBBMYQ+vQ9tJ917rXq+PHzy/nn5zYnT/yu3d/KK+Lne/VHf8A1xsbsrBt8W+/8F1x3zgdo9k7Vpt3bdy25aDunMZOkzU0uIr6NanG006TQSS2eUaHCe690b2o/mlfO/HO1FnP5GfzOatraaFcXR7X7r+KG9gtdXOiUNPu44bs8tsrHVMZdmqa1D41W5jKamX3XumiX5y/zEchQzY+r/4T89lQ7Fpo5chWHdHzK+BeBoqSCClYVNZUYXcG+KXEQmFJipMlSh8Rc3ADL7917osO5uz/AIlbiirN479/4TCdwdkNDFFlc7uzYPw//lufI/H5KlnJjap2funY/de407KyEFXHLHPT4xp6iB4ysgV7ovuvdBhvDK/8JsoKqPcfe3wP7O+MG5MrEtblcB2R/Lo+eXRjbXadvH5sonX/AE9Tdf7ejh+rVdLV/awIuozKqXHuvdKzavVf/CU3ee4evdrbE7K+JeR3l2jnMVtvr/F7M+XfbdFvSr3LncnT4bB4uH+AdyUm5Nn57JZWrihpBVNQVLySL4zyD7917o/u4fg7/K464zWd2VvH5L9u7LXaq4U5/qndv82T5e4HHbTjyuNfJ4cZXa+a+VdJlcNFn8eTWxCpZRVRgSx3QX9+690OHQHXv8pH40TUtd0LJ8Kdkbl1uV33R776v3D2hk5KySV2bJ9qbm3HneyM/JNJVPpNXlKg/uNb9Rv7r3Vh+1N5bQ35h4txbH3Vtvee355p6eHObUzmM3Fh5qilfx1MEWTxFVWUUk1PJ6XUOWQ8EA+/de6B3vP5EfFPpuhq6D5J939AdYUEOEXdVXje6uxuvdoRf3eFZUY+LPvjd7ZigMuLbI08tPHUCMxtUI0asXBX37r3VSOR+QX/AAmW75zs8+8d4fya995+mdoTku1cL8SRVSurH00WX7IxFIteHec6TBNIHLNpvz7917rPg/5XHwx3zBW/JP8Ak1/KDGfB/sqorqigqezPg7u7ZXbXxS7AylBCGj233T8Y0z2b+P8Av2gwsWSaSOHHJt/L0zzxuKwKkSD3Xujdfy0flr318jsD8lerflLsbY+2vkP8NPkNlfjb2fu/qKrytX0121X0Wx9mdgYLsTYNNnnmzu1mzm2N70cuQwNZNVT4qZ01TXm8FP7r3QQ/zrZ9x9mfH3pH4J7Lr81i89/Mi+UvVXxN3Xmtq5Gnod1bS+PckWe7j+Um78RFUw1MFdFT9C9VZvE1EUkbRFc0oewNx7r3VvG3Nu4DaG38FtPauFxe29r7Xw2L27tvb2DoabF4XA4DCUUGNw+FxGNo44aPHYvF46mjgp4IkWOGKNUUBQB7917p59+691737r3Xvfuvde9+691737r3Xvfuvde9+691qedX7rn/AJwP/CgncHZOGrNv7p+D/wDJNw2Q2jseqVkyWI7E+YvbFHX4nMbsw94YoMkNmZnaFYIK2GerpqKbZeLq4AP4uJB7r3Vz/UkmQ+V/zI313/k8VKvQvw+rt39A/GSpq1DUfYfe2RgbAfKXvnExzY+nm/hmwxE3VuAqlllU1NLu9kLU9bTufde6IJtnatH/ADPv5z24e58vSw574ifyY6rOdJ9WpOIKvCdh/wAxvfFFgs73JuSOO0kdTF8ZtnLhcUaerhjqMfuw09dRTsnlUe690Zn48YpvmD/Mw+RfzEzcEtf0/wDBvH7i+A3xKSshaXD5Dt3IVGB3V87e7MBDldv088GTg3VQ7f6rhyGOrp6cnZuepm9UkqL7r3QafyZaWr7d7M/mr/O7O0tN/FflB/ME7A6q2NlqSdKmDL/Hv4TYmj+OvT9Sk0aeAO2UxW4pHEMk0BeUurlmf37r3S6+ClCvzO+XXyI/me550yvWW3pt3/CH+X/TirSvwqdHdU75qqD5EfIjCNQbky+ArK75Kd/7cqaHG5FKKirzszZuKBeSGucH3XumD4HHG/Mj+YV80P5mmMg+46o2TtXH/wAs74iboplrExnZXXPSXYGX7B+TfcOErhUVm3t2bO3n8k8kdu4LL4yVqeqo9juzEs+mP3XulF2XBD8y/wCbp1T1FIKTO9G/ytetqD5PdnUa5LH1uMrfm/8AIzHbg2T8Yts7g21X4qSY5jpnoGi3fvKnqqapD0VXu3CTMqs0RPuvdAvsqLA/OX+cd3b8jN7ZLE1Hxg/k27Rq+hOoa7I5GjOx6r5m9t7Qod6fJ/tCszH30OLpch0H1ZNidp1lJkkdcZkqmSsjaGaDUPde6Hb+Ulgst3Fj/kv/ADNt6YrJ4ncn8x3tHFb16kxGao8zh8ptj4Q9L4ut62+HGKr9v5PI5CixeT31sk5LsOqkoikVVLvkahqjFvde6ZusKms+Q388n5J7+pZcs3Xv8vX4Z9bfFejhrcW0eBrfkB8t90Yv5Idm5HbmZaAxZGt2x03sTYdFXRxSg0j5YpIpLjT7r3T/APy7wfkR8q/5i3z6y1JVy43cPdafA/431eTpcBW09N8d/g/W5za29tw7G3LjBLU1e1+1/lvuvsGvlXyGOaHE48tqMKafde6uA9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvdf/R3+Pfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691UV/OJ7y3xg+gts/Cv4+VsJ+YH8yTOZ/wCKvQtOldPSVeyNqZzblRP8jPkVXNjsjjs9R7X+PHTFVX5ieuoDLU0mWnxirG5mA9+690VzCdJ9ddp/zC/iB/Lt6voKep+H/wDI+6K6h777BwdbU4XLNl/lfvLaOW64+EG1d4Uc9JRZltz9Y9X4LcvZTZelZ4qnN1+OlqVExQn3Xuu93YKL+al/N0GyM9TDcvwR/k+ZjA7mz2N9VXsruz+ZXuzCtX7exOUqIpJ8TuSh+JXX2VFRU0cbQ1mI3VkWpa+OalqzCfde6MP8wO/fnR218w6H4I/y6969J9SZ3rroOh7++VXyL7j69yXb+K6zpOzt61mxuiOq9nbSwW68NRw9q7votm7s3JJTZ2H7V8PiqWRXRZwJvde6C6g/l/fzsa6siqt1/wA/2tp6QyRvNh9ifywfiVhI401xGaGny24s1uqrcmMOiPLEwUlWKGxVvde6Tu+fg180OuKGnzfeX/CiXvfYdHmq+qgfKZnpr4W9Q4bISPI8r0WBGX2oKLHVcFFIotTu4Rv3FjRSEX3Xui4dsdafHXrnb9TkvkX/AMKi/lZtradVS1EePj2f8svhr1duytkjjjmrFxFVtHqTLboztSsET+OLH0pqIyw0km4f3XumnoLof+S93hSJDhf53fyw+SuWqo4/8h7O/nFdm4je8kiu2isn2dht+dW5yOVmVgC+NWPk2Uce/de6L/8AzP8A4G/yT/iz8BvlV8gPi/luvtpfLzrTrnObq6t7f2T85e28n8gpu06/JYvFYzI1e5/9PWX3bvisky9TG4xleK2iaVFEcEZSNo/de6vm7kqNzba/ktdq1W6N4bj3rvHAfyvd81G4t/dglKndu7dzYr4o5STL7w3uxcpPuPPZSCStyR1Waplk559+690VDqyihxu//wDhOttenjEUuF+IXb2QWmrRLJlocVt/4W9P7YnZgYQ8awVu5qOOolkKASvGhGqRQPde6Oz8Jxjd1fIT+Zl2zRzYuWbOfL7bnUdsfRwLURUXQnxl6K2rJFk8okkk+QrF3Vl8v+02lKQHQFDmUn3Xug/6EqE33/N8/mI7qqIfJ/oT+LnwK+PuFrFkEkdPPubJ/JnvveOPISTTT1clPvvb00kboJPEYXuUdAPde6od+WnT3z/2V82v5+Gz9g/AT5C/ILG/zYvjn010Z8Ze4NiV3WFN0vtel218bMl01u7K9qbz3bvjB0vX1Jhqve8zUsFUsdXVVOLlKw+GZKse690Y6s+Ov83PpH+ZftXtj4tfEnprfuBxv8qD44fBfbHenyC71we0uluqdwbM3YOyd6ZPd+0OvKfNdz9lJSbrpaih/h+DoceJfNDUirWAKp917o2+0c9mv5EH8q/5E95/LTc+xe7+98v3V3v8hd0L1Lhs9tjFd5fJb5Q9o1+W2XsTCRZSnyu5PLntz5zH46orzRzyY3D00k5gliomL+690Ie0Omf55PfWxdo5vuX5x/Ff4U5PcuJw2c3T178ZPhxUdr7/ANmDKxRV+Q2QvZ/yB7w3tsf+82CgkFFUZOHatfRmqWV4I3QRSn3Xugr7I/l3/DLp2dq75u/zffntncbm46mq3ltP5KfzUM90J1pvinyFhNTVuw+ts90RgMJt1WGmCkw64+FUsHMjXZvde6CXAdrf8JSPjBiGyW285/Kk+52xFJJ/eXG4jqf5AdmzkuaSeePdsWM7N7Q3XkKpnJlkWrrKioDNI5cEt7917oxmB/nTfGMYPB4L4Q/Br+YZ8qtnVE8lDhK/4vfA7f8AsDqDF1DtZDW7u7uo+h9oYWgmlZNcsXlKK+tk0hivuvdPD/Pj+btvLIUsfVX8jbceF21koB9tvH5GfP3419V1GOnM7QM+V692Jiu493LTwAeQr+1JJGDoBOnV7r3TnDg/+FBfZtTU0+a37/Kq+KO2a55XpKzZGyvkz8puzsJCSv28M8m8M/0T11WVSK7eQrRyxs0aspAdkX3Xuknn/wCWP8xN5YSty3y3/ntfNw4yhjWpq8j8YtqfGv4L7fxCCZJLPX7d2Dv3KJjoppGRDW5OedoyiSzSlSz+690RrffxL/4Tm7XrIKP5m/zHKD5Xbr29LC2cx/y//mtbo7bz2WydFIJqat3b1vgO4cDh6yopqpGkSBsJHSCUm0PChfde6TW2P5ln/CYP48boaj+J3xn6n7j7L2tjrLU/Er+XvX7731T0rSI3ig7Hy3WO3hkBKq+R5lzUsR8RDya1C+/de6EL4M9ty/zaf5zFT84dv9Tdw9M/GH+XX8Tqbpzo/anfnWmT623vubvL5KZDcqb13/t/BTLW4bH4TF9bYSrwVXBDXzVMcaY+ZkjjrdC+690fbsWsod5f8KB/jBs9pqcVnSv8rD5P9weO0k9Rq7U+SnQvVdEjxkrDQLUQbbrmimBZ5hTzRlQFBHuvdJb+blSU3Yvyz/kfdB5aN58DuT+ZFH8gKqnpHlFfNmvih0V2Z2TtNilOHmlw9Jn8jFPWgqYdESeUqvPv3Xur0PfuvdUkfyVYZcy/81vs6pQzSdkfzkPmuuJyzrOWyW0+sn676f2+sM1Rd5aChk2HVJEFJjQl1UL+ke6908/IuKPub+dx/Lo6qFbXjH/Er4s/ML5qbkw6T07YbJbg7Mquvvid1RW5Silhd3rcJR7r3lLQsGBEju68wk+/de6zfIWSo71/nU/APpagqstDgPhd8bfkh87OyaV6Gom2xl9y9yCH4g/H3HTVixmjg3HQ0+U7EydMkja/DRO6Wt6vde6Rf8ySkPe/8y3+Sz8SKzEjM7H2/wB5d5fzBOxnpiBXbcyfw66okxnQ+VmdVlaLFVvcPcNOkocIkrwKobWFHv3XurzPfuvdVIfzyt+Z7bX8s35Cda7FipMj2v8ALNNk/CLp/blTW/YS7n7A+Xu98D0RBjKKYQzl6nH7a3nk8oyBbvBj5ACDyPde6UXzw7V3L8Jvhj1L8f8A4pRvS/IDujcHTnwE+F33uOqM7S7O39vLCNtXFdq7pp6Pb244H2t8fuqtq5nfGVepx8uPmh279vUeOOo1L7r3VVPym/lTfC74z9kfyjepvjb19BgfmL2B87OucjuD5QSbz3Vi/k12d1f0dsfeXyA+YHZ3Ze/8Rl6Gr7FzXZmI2OmPy8WTSbFxZHdiGlpoB4Yl917ow9d8Zei/5qX8xv5ub0+YuxsX3N8Tv5eU3T/xf+Pext171zMnTK9+VXXdP3z8suzN2bCpavEYKv3dtrHdlbO2v5cm1ZSJSYyo1RahG0fuvdV3/H7D5fKfyxfhT8VujKXK9DYf+dT/ADK+998wbM6/ydT1nnek/wCXxmuye3vkf2Lg+m6vDQyrtmHJfFfqjEYihhEapTUe7ZFC3jUH3XurIPjZ05jPhl/ObwvxC+P3bfyWb49bp/lqdgfIrfHR3cfyB7K786ywW9cR8l+uOsev9w9YR9wbi3lvDYm4aihyueXLGnyRoshTrTKYg8Wr37r3Qz/zBNhbb7q+dP8AKy+K9Ps7GHCZ/v7sP5896ZnAR43F5up258D9i43/AERUm65qenery+BzPyO7q2WZIalStVT4uWFZFUSRv7r3WuZ8Bv5XfxU/nHfzVf52fyB+dVHvzt+Dor5r5fqTr3Z+N31uHZu0Mjt3B7n7J2VhhuHK7XfC7zyQ2vsnq7B4zHUtNkqGClpEdZlqNcLQ+691sZ4//hO3/JYxqeOm+APU0i+RpL5DO9nZZ9TKFI8mV35WSeMBeFvpB5ABJPv3XuiJf8JtfjT1919vH+a/8h+kcPldgfG3tH549hdJ/GrrKgrs9/o5Tqj43ZDK4GHszZ9LlchXxZRd65jdE2PetMkssT4GSn1gIyD3XulV/MG+I3x/+Tn8/v8AlwYX5M9N7E7j65y/wq+TlTh9r7wx9JlMRld7dT7xwW4sd/fbB1Pkpd3bXwdDvqaSjxlbHJRGsq5pHSRQ6H3XurdOzvhD/La2V0/vXJdhfCP4cDqLYO3s52NujCZD4zdIT7ZoMbsrbmRrshmzhq3Z0eGjrMZt+mnSOZghjiJXWqE+/de6IH/wm++PVD0t/LN2r23NsnbPWme+bXaPaHzUzOw9oU0FDs7Ym3O480o6n2jtKngEVPj9qYXpjb233pKVI4Y6PzyRBPSXb3XuhG/kOR0e9Phx2p8raUZiP/Z9fnJ80vmHFTZvyGrpNvb47x3H171zTwNKzytix1X1dgno7kqtK8ax/tBB7917pUbrgpvkR/O06pwf2VNl9o/y2/hhvbtjI5bH5qJzt/5IfOvdf+ivYWEz2IjeUpk8T8duk951USyJFLHSbqikDGOYBvde6uC9+691737r3Xvfuvde9+691737r3Xvfuvde9+691r7/wDCgb5ed99Z9I9MfBX4S5CoT5y/zIux5eheqTh56ikz2yOro6FX7m7Sp81SJPJs2HAYnKUdFJm2VJMPRV9ZlKeSKbGeaH3XulH138Ott/yfv5aXX3wn+G5ef5J/IfeO2ukcJ2wtFPT5zdfyR7jxbUvZnyRzf2FFk58dg+kOs9tZvdlDRyLPHQ4PaVLj3llkLTy+690cv5Ldg9Z/ynP5YPZ+8eucVSY7Zvw++NM+E6h2/nZ56w7j3phMBTbN6f27uLJU9O9dl892P2bkMVR5CveN6muyGSkqZdcsjk+690VPaG1d1fyef5M2Nwm3cY2/fl+mx8PTGGtrYN453vf+ZL8td24vA0hyuXnloK7fce6vk92dT0wnmmaoTbVKitL4aXWvuvdLXuKsw/8AJf8A5LO7aPYeSfMb1+Nfxtm2nsXPjD5TcNf2n8t+z6kbfwG8cngpKyry2Wyncvym7ETM5WJZXfyZaoYWRbD3XugS3/15vT+Wf/Ji+NHwL6Demw3ys7i2v1P8E+osrtxs7JSY/wCUnyThyVX3n3vR1+Epq/J47H9ZnIb87QnrGXwQxYRjK6oSw917of8A+YNlf+G5P5Pu/etvinjs7Q7m6/6M6w+G3xRxmOr1qd6Rdg9oVuzvjF0tkaLIPFG+X3fhM7vCjy81QyGSqqKSWZwSze/de6N71jsno/8AlqfBbbO0Hr12z0L8L/jkZtx7jNAr1f8Ac7p/Y8+a3tvfJUOKpkfI7hzyYity1d4YjNW5CplYKZJLH3XuqlOt+7ewf5fH8pjtX509nbMrK/51/P7snK/InB9JV/8AGMpmM18r/mDWYPZnxH+MGH2/m2w+6fsOouuKXZe2cjiQy1dLSbbylSAr+QD3Xuk/3b8Ys38UP5Xnxg/lN7P3Tktx/JD+ZF21jfjp312zjavb2S3ruOq7zO6e9f5lvyOq4tyLQ1e7aHFdL4Xe1LQy1HlrKKKtwtM0jtFCr+691sGTzdadC9VTVEv92esOnemOvpJpNEdLgdm9edaddbcLvoihSKiw22dpbWw/CqqxU1LT2ACr7917rXp+NHdu6PiP/JD+Tv8AMfqNsZrB99fOHe/yE+d2xtk1NTLvmrqe3fm12HBsz4PbIxsEJqZavH1uzcp1hilpFDCmj1qVVUKj3XurqPgt8YMR8Lvh38b/AIs4ipoMkekupNo7Mz+exlJJQ0m7d80+OjrexN8ClmeSeGffW/a3JZiYSM0hmrnLszEk+690a/37r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691//0t/j37r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvdake6P5r3wh6I/m2fzHvkb81u2KfaO6PiL1fsT4c/CfpWo212DU9lbowwwtd218kt07L2WcFUberM93L2//CNt4XcInpIqjE4KGOaojoZhLJ7r3QofGzvns7+Xp/Km3X84e6NkS7v/AJkn81fvrI9wda9ELFU1e4d9fJX5UT022viJ8dsVT56vxOexuxOr+pcRgp6/FVlXTybdxlHlYIiaoIk/uvdWD9F7R2R/JQ/lbTZzt+vzHanZm0MTle2O+s7tiGu3R2N8qfmr3ruOnqc5iNsTDExZ7eu+O4+6900W1dsSVtMKlqVsclU0ccMjp7r3VZPyPf5f/Ev459b/ABU6o3Vh6v8AnW/zwu/8zufuztfbs9fLj/j/AIEbSwsHb+69nZlKncWdxXT3wt6MxuG2TtFkrnqYIYKjN40NkPLA/uvdDRgf+E9X8k/4qdbbW3D8kZc1W7/25hqaq3n8n+4/mp370huDd+58dCKjK73rZdsd9df7K200dY0ksEVLCq0cLBZJZnDTP7r3RHJuw/8AhJz0n2dX5Hdm8cX89e5KqmbDwZDsan+UH8yyooNvUEpFFgsBWbjxXb3VdDh8fPWsKWSJhVSmU/vShBo917oVen/m/wDyXcTmJ93fEb+Q38oey9z0UtSIdx/H7+UJs+oytDJRGKrKUm5stDtoYKOSYRHQKmnHkEetQQnv3Xuho7V+d/8ALB72M0HzW/kmfMvb++ZoDR7C278k/wCUxH2HvjsSrSmkkpcL1ZubYmL7WpEy8qh4UjqMriWjbUGZIzrPuvdEu7131/LR6J6U3d8kaz/hLr2js7pTq1dubh7I3/8AJL4/fET40vt7FV+58FtPa8+3tubr7P3Pvjd2bzW7txUNGmEp8fFW1JqF8sTAOq+691sTfzPNz19f/KL+fe76fFZbaGRyf8vX5MZ1cFm6Wngzu26jJ/HneNY+FzFGjVNLT5bFGoNPURqzpHMjAEgA+/de6L9symw+V+bn8pPalAs1Lkerf5Z/yi39UYZZKqshxmD3C3wU63w8lRXp5Ip5fumqYImmkbyiORhdgG9+690Mn8rbxy7Y+cdelLSU5yH80H53eSWnLmeukxHb1Rts1WQ1IiCrVcIIV0XX7eGK5LavfuvdNf8AK6iyO66/+Yn3zm3oa7Jd1fzLfkxi8Plo/FNlG2B8ZV2d8PtmYbI1S0dJJ9tiz0FWzUdOTKIIK3ljI8nv3XurVffuvde9+691T7/OV/lp9sfzNemOhevunPk5U/F7efRfya2B8iMRu87Tl3hQVGW2Ti9xYzEZFMZR5jb9cm59n1e4P4niHNWKR6iFop0BljqaX3XuqhO2Oif5TPQWdr9vfzIf5/fy/wDkdvKggqcXu7p3fH8wjcGH21hsrT6KTMCTo341NQb42dU1UsLxPSVtdIWVSlndGf37r3T10xlf5AmzMTiJvgd/J67r+dtRlKmOPGbs2J/Lu7X7egSeeZKinzmU+QPzvxmz9v0lDUVDrI2Tbccruh1qZAQG917qxnAd3fzEstkcVjeg/wCRn1n0XRw0q/3d7E+TPy3+NPXGG2r5FhpcfUf3D+Mu1PkRvsLSUsYNTSJ/DZoo0WON3bhfde6E3H7A/npdi0lbSb5+SH8tT4yQ1Uzx01T0h8cfkH8kt04uikiA8tPuHuDurpratVk6eS/jabbDQEkM8bAeM+691lq/5b/y07EwkeO70/nKfPLJ1rwiOvk+OOzviL8WcZMVqnqAKBttfHnee9sbGU0xswz8tQVU/ujVYe691Kpv5NHxzysKUvbfyH/mQfIGhQtKMb25/Mf+YMmJ+7YKn3qYjrztfr3FwVApzJFaKFIjHNIChuCvuvdVRd+bS/4Sn/EHtHcGxu88L0x2X3vtDMDbea653Vm/kv8AObtPHbiaJTLtas2/nM73nkKHJ0hu1TRVJhFJUFzOsczPf3Xult1984/5Ymxjipvj5/wn9+dFbiYJIKra27emf5MmAw2IyUpVGiymGzU9FtetEjAB2q5xCxtrd/q3v3XujVYT+aP8p+w6Z8B8Lv5IPzVxNcWkevz/AM1aLq3+X/1ZhMbBTzuc9V12azPYu7c0tMwUrQU+ESrkViGaCzMvuvdWB/y0vmvjv5inwb+PnzLxuxq7rVe6ttZ6tyWxa/JJmW25uPZm990dc7roaHMLSUBy+Dbc+z6uXHVT09PLUUEkMkkUTs0a+690UbqnDHPfz9fmJvHIRxVdV13/AC0PiD15t6skhUVGGwe/++PkXvXL4mlmRVJpcpm9qrVTatTNJEgvpQAe690wfMLHVu9f54v8mrDUayT0nT3TP8yfuzNQxyxqtLHuHrLqbpXD5OpjZleREqd71FMgXUdVSTaykj3Xuru554aaCapqJY4KeniknnmldY4oYYkMkssjsQqRxopJJ4AHv3XuqaP5AuQyW7f5ZfWfcOWpZaOu+RXdPy8+RXiqKdqWqlxncfyw7m3jt2uqIDLMI3ye2q+jqVUGyxyqD6gSfde64fHOuoe2P54v8yzfBo6ynqviv8SPgh8TKKrYn7LI1HZ1V3X8q90GIaNLT0NFvXb6GzXUPyCGFvde6z/y5aiDub51fziPlhS5GtyGCl+TPVnwX2PBkKWaA4nFfCDqDGU3Y0eJaa4fF1/fXc260LxWSWaiJNyt/fuvdIfCGXtT/hRhvnK4/IJJgviV/Kp2psbO0lCjVnh7B+SvyLrt601HnK2nkNNhaiPYnWtNU09DUKKirjqBUJ+1Hc+691eh7917qlb5oLSfJ3+aj/LU+HsWOxWe2v8AGBexP5pXelNlaGvvhZ+v8LuD47fESTD5JIWxrZvJdz9lZ7LrTSSLMINpySqrBSV917pQ4pqT5Lfzsd3VNXJR5rZX8sL4i7XweAx9TiyG298pfnllstmt1bhosozIs+X298YuosRQxhRIaWi3tVreMVR8vuvdY+pJ4/k1/N6+UXdeWWep6q/lv9J7O+IHUmTqpMLkdmH5C/IWgwvyB+XG6cLlFT7rD7t2b1hQdYbYyCGQ/bRzVsTlGkljHuvdVT7R37unbP8AIf7B3l1/hKfZnyd/nkfL7vPG9Rbf3JVVeO+67A/mdfJLeez9lbmpMljIjVUkOzfiWybvpqpwiRUmDDyeOMWX3XurAds9QbWx/wDOD+EHxr2LtStPTX8rP+VHvHMbHzsho8lDtXdXyH3z1/8AGfrDamVr2Y1cO4Knpb42bkmjYxxu1N5CDoncH3Xul78MPtPk3/NQ/mQ/NCnpsVNs/wCPGG60/lWdQZukM65PK5LpeuynfnyoqcnBVUieKGg7n7dx23qeSmlaGdtszeQa41Ce691L2TBVdqfzzvlVvPb2WpjN8S/5anQXQFNRV9LU12Hx/Yfyh7q7Q7xy1RXvTVNJJA67W6g2o1RSRMs81LLG/kQFL+691rmfyyqn+d5/Ka3F86utcp/KJ358vu3/AJEfIzIdxVXc+1u5Np9f9K5fJVMmYhyufw+4a3b2aiz2D3FXZX+JUNNJUYrIQQ1LRVcFLNHJGnuvdW2fy+/5y/zV+X20v5mu4/kB8K9t/FXbHwF6+7IwWZ3lQdh1O8xj/kl1XtzdOW7B6tyDVmLhwueq9r0eIir6x8fI8WHjanjqWqRkaaRfde6Pv/Ie6uxnUH8nn+XrtXE09TTU+a+OO0u16pauomqp5s13vUZLu/cVaZZyZPHkM/2HUzov6Y0kCr6VHv3XugQ3rmqjef8AwpH6N2KP36DpD+UJ3D2yxl0T01Dk+3/lTsvrcrSqwb7DK1dBspS7LpkkpVCn0fX3Xuh2/nqdj1HWX8ov555Ggo5cjld89F5bojCY2nbTU5DO/JPMYX4+YajplCuZZ5sl2bHpS3r+hKi7D3Xunj5w7r25/Lm/k69/VG1c5Ftug+MPwZy/VnVGWlSKnjg3fgeqYOoulKdYlkgjifI74qMNTIiEEPMFQE2B917ozvwP6QrfjR8JfiL8e8oIzmulfjX0l1luGWKmajSq3Ns3rnbuC3NX/auWenfIZ6iqZ2RiWVpCCSffuvdEo/lC1B7fofnh84ml2/l8R80/nn3Fn+o93YEtIm6vjd8asXtb4e9J5eSeUColpM5S9E5TNUeoKjUuYSSNdEgZ/de6uG9+691737r3Xvfuvde9+690W/5EfMP4p/EjBQ7j+TvyL6Z6HxdZFNLi/wDSj2JtfaGRz5gjlllp9sYTL5Knze6K4RwORTY6nqqhgjaUNjb3Xuq+qD+bTvDv1ZZf5en8vj5Z/MbbLwU9Xie893Y/bHw3+Mm5KCrlWmTJ7R7P+S9ftXe++8ZS1Lg1E23tn5gGBXkpxU6dB917pX/yuPmf8qfmLm/nJT/JLrXoLral+MHyqyXxe2vj+it5by7Bp23bsbY+19z9p4ncu9d247bSbprNrZPe+OoVraPBYSFqqOrhNM3hWaT3Xuiw/HXAYf5Qf8KBPnn8ishAc1g/5fHxh+PXwo6ryE9LBV7fpuxe6V3P3x3LlttVgaaKm3ntDH5KDb2TmURVaU2UkpZLxaQfde6Oxs+fEfJL+ZJ2duqcPktpfy7di4rpnZyvQeTFJ8lPkvtPA9ldv56ly8cogmz2xOg32dh4YrSSUcW78qjePz2f3XugC+eRq/l988vhL/LqwbVLde9YZnA/zKfmbUIMhFjarrHo3eMuF+LPTuTE2Gr9r7lpu5fkvRrl6/FVFRBUriNh1E6qysA3uvdCT35R0fyi/mbfFn47VeInzfWfwe2NX/zAe2J5KPF1u3Iu+N51G6uhfhdtfJVBqGyVLmqDH/6UN5QweNViq9uYqpN7xEe690A3zjmqfmT/ADTvgN/L/wAclRN1d8Xft/5p/wAqaulqK6jjqa3q7PZLr/4ddcNk6Jp8bVtmu7Kur3DmMDkY1++w+EhnjNkJ9+690KG1af8A2bv+b/vzfdbT1FV1D/Kk6spuouuag0Mxw2d+Z/y92hj93d25+gz9JlzQZHJdK/GOPa+3/s5qR5aGfsHJqZEcsnv3XumD5gS/7NL/ADVf5fPw1pqemy3X3xSxW7P5n/yLoMjQZRKA5zaS5ro/4UYvH5ygdaN9xU3dW489uz+G1TBDFtCGoKOVjt7r3T//ADSYofkt2B8N/wCWJTRSZHA/Lftap7d+UlJT0lRWQUfwq+JFTt/tHsfCZ2rxuWxuR23Q929xT7F2EtQQ6VlBnsnCqtokKe690zfI3FQ/Kz+cL8MfjxkqPK5Lqr4FdLb1/mIdk0cmMxuX2Jl+/ews3XfHT4f4fPSziSfDbx2Pj6fsfd+JK6ZhNQU8y2UXb3XulH15RTfKH+cN3V2xWRyVfVv8tPonE/Fnrda3FY+rxdV8pflbQbK71+Q+7dt7gieSoiyWx+h8T11tyaHh4ZM9konC35917pt/mrZHP/IjdPxf/lYbFyeYxjfOPdO59x/KjPbdqshR1+0PgD0NHg898iMbPmcBlqPN7RyHyDzW4Nv9aYyseCajqYty5FW/zLAe6908fLXGYPuz51/y5Pg7tylwdPsbo7Ibg/mKdzbTxDVODjwGyvjXS0/V3xL27Bj8ZHBh48Rl/kp2FR57H0JTQy9bzlAiwWf3Xureffuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvdf/09/j37r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3XvfuvdNc2DwtRlKfOVGHxc+ao6dqOkzE2PpJcpS0jyeZqWnyDwtVwU7TesorhS3Nr+/de6ojoHT58/zw6PdWGp/4v8AHb+Tl1hvPZku5SlTNgNz/PT5RYbG0e6Ns4eW8u3twS9GdGY2JMk6scht/cOXWF44zKjn3XulU+59ufzCf5hG8d07hy+35fgn/J137XrV1+QqtvVO0+0P5kuO2bFl9zbm3FW1s+Tho9tfAnrHc5SFZYsVPS7/ANxyVnml/gkOj3XugL+CfYu3t61XzW/4UOfLepyWx+rt1db7x2N8PcZn8bWUmT6s/lo9G5Kv3Pjd2x7XkSHKjsL5Ub6xFRuqbFutdUy3xsWMqJKeujgHuvdEB3P8Rvgz8cvif2N/O1/nP/GTdfyB+VvyG7Ty/aO2Pjl2VubNdkVXW+O7u7Jrar42/EjZHVm6Mvt7YWRyeyetZ8Yc1S5rGVc+HSkycCRPFR+CX3XurKunuxP5xEmCpqX4o/yjfgZ8DOmMSIKjH9Z/IH5DQ4bee8McY2li/g20fiX1VndndZ5GxeP7bMGoeJnUvb1ovuvdCdmuwP8AhRPnqmY7N+N38pjrukkAjpY+xfkV8oN/T0siRRtJU1dTsnp/a6VdPPIHCJHDFIhI1EhSze690xx7b/4UtV0cKV/aP8lbAtkyIcnJg+s/mnmJNrwuVR6zbX8Y3pSRZ+thSR3WPIJDCzxopIV2t7r3QG79/lwfNfv7e/TW4v5pX83LqPePx46N7w67+Qme+K3VXxv616R683huvqvLw53ZmL3z2tuLfNVvLI7HGZDLXYvI0lVTVUel0MNWlPU03uvdWG/zrc/Jtz+Uv/MJq4pTDLlPix2rtCOz6DPJvzAT7ISiA8Uxl+/bcPg8YGqXyaAVLBh7r3TDsnZVPB/OAqlwlbQ0+3+g/wCVX1p15DtnG05SmxL9xfJfeFVjXKGWQ46n/hHxzSOlhuxkjViT+0L+690uP5W2NiTo/vTdaxvT1PY3z9/mFbzrqP72Kup6Op/2cLt/ayR0ciJHPDBUUe14p2hnAmhmmkU+kL7917po/k5ZqLdP8vvq3ekNEKGPfvaHyy3/ABRGnanqJafe/wAve99z0VXXLJJLJLkauhykUk8hd/JKzMGIIPv3Xuib/MDrrGfzK/5qu2/gB2bkOxp/hv8AE74gTfJf5CbZ6w7T3v1lR9k/IXvff7dfdF9ado5nrnObZ3dDito9Y7P3HubH09NkaX7qauvMskSqPfuvdM3R3xT67+AX82v41/Gj4bdid6bM6J7L+HHyj7s71+NW6e9+yO6OroKnr3fnROwOp9+4TA9xbj3rnth5bI5zsPKU9TXY7IKMh/DqenMaRxz+b3XurhPmt2Tmemvht8tO3tu1f2G4eq/jP3v2NgK3ztTGkzeyerd1blxNQKhJYXgaHIYyNg4dSpFwQeffuvda538qio6Z/lXf8J5epv5gC/F/F9q9l0vWs3ffdOa2TjNnYvuffm3exe6quKt3HW7+3HRw1mQi666sz1NUrRzVKo1BhzDGRI5lb3Xuha7Z/wCFA3yb6A6gm+Ufe/8AJY+WnU/xPocttGlynau7e4+msXvfH43eubxeD2/WydLZAUO6hX5StzlHFBTvURwtPMUepiCM4917qxf+Yp81/kl0kPh/018JupurOyPlP84uwd27O6qxvyM3NuHYvXGxMD1509uXujfu89/Y3bkabuyibc21t8JLjaOekqTLKVV3n8VPN7r3Vfm3vmb/ADmfif8APH4D/Gf56VP8u7uDY3z43b2ltDGwfGek7q2dvvrCq6p2RT7z3NnKSu7Gkhxme29joMxSqqS0VRUVpTw+Sjkkjkk917pEdlfGXvf+Z/8AzZf5kHV1b/MU+efxM6M+Em2/hpsLY2wfiN3RX9T4fcu5e7+lcp2vv3JZ37aiqMdU1tBJLRDySU1VVSrVaWmSGKGIe690mv5Xfw0218WP58vzn2L1f3H8je3tmdI/AvoTavZ25PkN3Bne3N5bh7l753rjux6DObjzM1NisVHXtsnYRemp2pEMIqql6cJFM6e/de6bumO7ch8A/wCVH/Nb/mWdJdR9db/+Qtf/ADFfn923Xw9hY2bGUcxyfzYqenqyjymcwRpN0ZPbe19oYRMouMpshTJVVcL06zwM7Sr7r3RscL8Uv5+ndO29v73qf503x96UoN37ZxG46LE9H/y7+s+ycBBHnqKlyVNFi8527u0Zusx60lSDDVOVkkUgmME3HuvdBnvj+VR/OryO2tznPf8ACjTeFHQV+Lygys5+DPT2ycZDDW08yVROXwXaNFUbao9MzAS0hjalWxjsVX37r3Vwf8tT4u4T4W/BP4z/ABe292Hhe2cZ1B11DgP9JO3MfTYvA70yNfl8ruHN57EUNJls7DBQVmazNQY/8sqGdRqdtZYD3XuidfFyWLcv88b+bBlYqg6utfi5/Lc68qaZjJMTPu6j+SXYCSI7lFo0hpwl4kWRZDNrLK11PuvdJrc9XLk/+FJHUuGkFqfan8mPtrdFO6LFKWq9zfMzrrb80cwKGWlj+3xAZJNXrYFRxrv7r3Rtv5u3emU+Nn8sT51dzYCrmx25tq/Grs6i2jk6ddc2J3nvHAVGx9nZeNDFMrnE7o3LSVNmXQRFZiFuR7r3RdPhd84f5X3xH+AfxJ6yqP5hHwuj2r1L8feous23AnyP6hU7g3LtTYuGxW5qqLFQ7tkyTZ7JZ6kq6usokg+4p5nlDxJoYL7r3Rav5Xfyc612F8Df5mv82De25f777S7Y+YHzo+U9fmcc2NbJ1nTnRNVJ1J0x1vtjLTRUAzFPF1x05QQYJajQZKrLaQAZefde6KN/KI+fPykx3wY6bxPw4/lw95/PrL7pyO/u+/lV8lstvzrD4YdV7g7/APkR2PuvuLtja/T1Z31JQVveWT6t3Juuo2nWV+LpqTBtVYNRFXSQuk5917q2/wDlB9JfJPZu3Pmd8ifmX1HW9P8AyX+ZPzU7P7kym08/vLrzsTdO1OjcDg9p9cfHHq/Ib16zrMhtzLYXq/rza32GOVZ2fTJLUFUNSUHuvdXA+/de61zcRL/NC+Lfzp/mE987Z/lgZb5hH5R9k9W0nWnZmz/m78fOqtp7c+M3QmxJdmdXdeRbH7eyNNufbm9zns5uHceUWGFcZkcjuRx5o/tTJJ7r3Rmvhnh+6/i58Wvnv89fk901uyi+RnyC7R+QnzP3h8c9vy4DevZe0uu+rtg0ewfjv8bsXn9j1WfxG+N20fS/TmHEUtHrRs3naiJIlC6B7r3VIXXX8xv4qdb/AMlztT44dXfInbW//wCa/wDNna/a03ZfTuO2/n+uO+sp/MD/AJgG8avBdhYfIbUqMPhanB7i6V3h2gMPS1crQwR4jadLMrtCqFvde6sH+WuyO0/iD8sv5Ui7O+FHy1+WPw7/AJfvxX7B2p1jR/FTFbG3ll4PknldkbS+PHX1Z2bsjd+99pRxbb2F0NiM5JQ5NpwKbKbiWSJnanlUe690Lnxx3rv34l9Q/wA2b+bv83+kc58f949w72rO08d0xmt27Z3JvvDfGf4p9J4Dq/46bBzk23MzmtoYfsffu46PPVrUFHkaiiXI7njPmBkkb37r3TB/Iq+XXwlw3wX+M/SrfOz4y9l/KzsbGbi7u7q2uvdXXcPa+e76+R+99xd29l4yt2dU5qh3Nl9wbd3Xv2XDzeGkkYfYop+qk+690aTvP+S38Qu8O+Ozvk5FvD5Z9J97d0V2263tbsL46fLbvHp+t3ymztp43ZG1aDM4fb27G2ymO2/trEwU1LHTUUBjVWsfW+r3Xugp3B/Iw62TB1EnVnz+/mudR9lRU1W+I7QxXz47o3dkBlQpbDS7m2tvXK5raW6MFjJlCS480tKKykaSJ5lZxKnuvdJ7vH4a9Q/y0/5AfzZ+NuwqzKbqxW1fg38t67fG/wDcRNPu3t7tnsXqbe8m8Oxd21cFRU1f8W3ZuvLqIo3qal6DHx01Gs0kdMjH3XurSfhRszKdcfDT4kdeZyBKXN7D+MnQuzMxSxRxxR02U2v1XtTB5CCOKG0UaQ1dC6hV9IAsOPfuvdVDdW5AV3/Cnj5RwUrQ+HDfykeocZlFZi9R/Ep/kPQ5ii8XjYxwwDHZL9xZAJCxRl9JN/de6d/5/HZZ692T8AanfG2O2qv4xbf/AJg3Svd/yy3r1l1huLtrH7d6m+OVHuDtjDbX37tbbFBkMjHtffnZuHwaS1jJ4aaLHytZ5PFG/uvdEV+WP8zb4+fzoOwvhH/L0+Gm2u7e0NjdnfMTprtr5cbj3R0r2H1311jvi/8AHjKydw7s27nMtvbCYaKZ94bj2zi0pnZGpjPRinBNTU0it7r3WwV/Mr3l2t1//L6+aG7Oitv763P3TjvjV3BB1Tius8Jkdx77XsLL7Ky+F2ll9s4PEQVWUyOQ27nMjDkfHTxSS+OlYqjEBT7r3VZXxI/mN7d6R+P/AMe/i/8AHz+V5/N97W2h0n0l1l1htzfZ+GWE6T2huOj2Ns3F4AZx8v8AIft3qBZazO/wtq2omjSdJqmoP7sjsSfde6MLQfzXu4NxVDUm1v5Nv82eWogVpKw7y6x+LvXtGkRZYovschuH5YijyUzSt6o0cMievlQbe690jcj8iv56vemZl270p/Lz+MvwhwFG1LUVHbPzj+TGJ77qc7jK6d0lptpdOfD7I19Xj9zYmjCzOua3JTUTzP4g7LGXk917pQS/D3+czuuKGTdH85PrzreQRa5aHo3+W508XWqJ4jfOd19pdsRVmPRSfSmLpZmax8igFW917rPUfyqd87yA3J8vP5rf8xrumOipzLuXA7J7h2R8Lum8ljqWmYTDLbS+K2xOrc1TUWi7zltwaH0hn5BY+690WiiyP/Cbv+WxuCPN7Ui+HmS79fcEVLhqTaE03zc+aOa3pVyNRUtBg44KvvX5IHO5mufwtKZIIGl9VRKiRs6e690P3/DuHfXYUNbQfHH+TL/ND31uanYvSf6fuu+ovhvsavolqXpvuY93929s0+XgnlssiU8mFE/iYM6x2YD3Xult/Lj6w3b8C/gd3j3j8y9vbe6l7i7I7f8AmR/MJ+YeI25ujH7z21snO9h773j2Pk6XHbjxkhxGRp9n9N7ewlHM1NI1N56GQI7L6z7r3RYf5SmfT4f/AMnvs/8AmK/IyiFLvX5PVnyL/mq950VBkoJpcgvca13YOwNubcyWYkpQ8+W6hwu2qbH007oiZCsMS/W7e691Zt/Ly6V3B0R8T9kt2lQwYjvTt2r3P8mfk/UTU1Bj5v8AZhu/8vV9p9tUVdJRuaR6LYubz523jn1aYcLhKOJdKRKq+690Tv8Ak25Cm702n8xP5lmYFFNL8+/lR2Dufq7c1Tisnt7Kx/Db40zVHx0+LuDzGOy9VIKKnOD2Jnd1qyRwRzTbvqKizCXyN7r3Sj/lBVVP231J8hP5j25V+yzP8xDv/e/eW3azO4qDbuW218V+rI06J+Ju1s0oq5qWOCm6V63p90TyFltkd1Vzvyxt7r3RKPgL8h9l9VfE/wDmg/z7e9KYwYP5Udl9jdxdc0lXK229x5X4jfFnH5Hov4g9aQ0+5ZY6LG717MrsFWSY4IyU2Urd00TqD5V9+691Z/8Ayv8AoHc/xZ+EOxm72kosd8g+2qrfHy0+YW4K+hwuAkb5GfIbOZHt/uKPOtiqmbDCn65r88u2KaoSUxDD7fpeQqi3uvdF2/k1bey/b21vk3/M433j6qk3r/Ms7urOzOt6XLYmuwWe2r8K+oYKrqj4abMy+JnyFdjoq2v65xdVvCWpoxCldJu8ySqZASPde64/BGupfkD8y/5jX8yjecWMxnXe2dxp/L5+L+687jcdjIqP49/DfOboyXyI7Gw+84cjPi87sHtH5Xbi3KorrxqKTZNIHOmEH37r3QO/BXuraHV3xW/mKfzxO9qSfF4D5b7w3x8m9rUr4ZNsb3X4T/GrZs/U/wANtiVWLzOS/h8m+OwNjbUn3HQQx1KQVeR33Gg0zySlvde6P1/K3+Pu/fj/APDzZR7spaeL5L997l318rflTUR4+LGVLfIT5Hbmruzd8bdrKanrK6lK9X02Zotm0bQuITjNuUwRUUBR7r3Rb/gEsPyI/mF/zTfmzVmnzOA2b2V1/wDy2ugspkdvrQ5nbmyPiXgp91fIijwOXlgWor9r7u+U3a+bjlljdoamfbMP1+3Q+/de6V38sR6zvvsD5y/zB85JS5Kl+SnyLz/R/wAd8tjNxLn8A3w2+FeX3J0n1fXbegMYbCQdj9zjsXek6ar1S7kp3t444be691bj7917r3v3Xuve/de697917r3v3Xuve/de697917r3v3Xuve/de697917r3v3Xuve/de697917r3v3Xuve/de697917r//1N/j37r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691SVuT/hPL/Kv3T2D2F2JkenO1KGs7R3tuDsreu2tsfKn5QbL2Zlt/wC65kqtx7uG3todu4OKmy+XrQ0spjdYlL6ERYljjT3Xui0/M3499OdVbA+Nf8gr+XhtKl6BxXzVz+796/JKbYGU3DlNxdT/AAU2vXU9f8mOxNz7wzmS3ZvCfeXftT9n1xgMjuJq+lyf8Qqce08UdLCIvde6Md/MF672f2tuX+X1/J96r2vtmh6j31uzZ/cXyG60oqHG1e2Np/y9/gpX7JzsGwMphjXw5fBbZ7V7sXr7ZOOkhRxVULZKDmKKpeP3XuglTalH/Ne/mx7lzm6ppc18HP5NvYGI2vsza0Nasm2O7f5mVTiqLc2694ZxaUstfjPiBtfJ0OLix1UkFRS7srHmjmmoZqyll917p07R+cn80T5Y/Iz5D/Hz+Vh0l8ZcL0v8c+0x8fezfnb8mt8ZzNbWpe6Nt4TAZruPZnXHTGykpt0Z/cPV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5/nn2R1V8Aeo6urxtXlKaLNfKbdlNsbsHJzRUM1PU0ke1eiBu7NmqV1FJ/DPMzKqFl917pffO3tel/l2/wAujK4P42bbgpewMFsjq/4gfCDrLHS46SpyPdvYsm3+gvjRtDB4/NVdPHnafbGdytBkKylDtM+GxNXJyI2I917ojfzi6Fh+Jv8AKb+LX8pnofPZXH7l+V27+gf5a+K7EweGoFyQwXZwyG4/lz3dntuy1ci6tx9M7R39mMn4pJPHlMup1HVc+690NXza2fs7tvvz+XN/Kh60xOFwHU+Eze3/AJifIPrzAR7ZXbW3/h18FcltOLpbqrLbJylPKlVsrs/5SV+w8ZTU1MgX+E7Yyi2McLKfde6Op/Me+VFT8Kfg58lfkxiKFMtvPrjrevi6rwUuIrs/BuXuze9dj+vejtrVeGxc9NksjQbn7e3ZhKCojgkSXwVDlSCL+/de6Ixndq5/+UV/JLh612RlspuD5G7X6hxXWW19yUVZX7uz3Yfz4+Wm9Kba0O9qWTPTzZrcEG5flf3LJm3ikaaanxGtVUxwAD3XurOviT8dtrfEb4v/AB/+MGzKgV+3OheodhdWUWZagpcXU7kn2dtygw+T3bkqGi/yWDM7uy1NPk67QSGrKuRrkkk+690Yb37r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3X/1d/j37r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3WpRsX427t/nRfzQvn58m5vlz8suhvil8OMpt74J/GLOfELuyu6gzO6e3Ng0UG6u+t5w7jx1PmsPlMXtDfGedYHfG1lLnosnRa52p8YKeX3XurCKz41/z3ujKebCfHf+YJ8Q/lPtPGO6bRp/n18ct4bb7EgxI/Zo8NvTtH4x7mwEW9K3H051HLnA0dXWSIpmjJZ2b3XuslH2r/wok2Uiz70+I38rvvFcKGrspRdL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198jesPh539jvkdtfpHrz4r7c6ho8t2RtbGVP9xc1U7s21n8dLU1G2NwwUtTD97QVYSCWsiQr5tXv3Xuju/zIP5WdR/ML7I+MXZNJ8yfkz8UMv8AGGp7Pq9r1fxvzWF2tuKrru2Nv47aG5s9QbqqqKoye3N0xbNp6vF0lfGKg01JkqpY41M0pk917pP9F/ynv5d38v598/Lbe9BufurtfYO26/sPenzH+bW/6/5C9y7M2t1ria3cdVuDFb13vTti+v4drYyiqqt63BY/GVbRgiWaRI4lj917ph/knY/cvb/SXcn8yTtDatdtbtr+Zt3Ll+/qXD57G0VFuPZvxj2XT/6KPh11tVVWPApctiMN0ntin3BS1aC1ZUbqqqo+qoYD3Xunze2n5R/zmeotl0FYavrv+V38ddxd6dgxUW4IzRTfKP5s0uc6l6O2/ntqPFepyGwvjzsPfmZjrNR+0G7qLTZprj3Xuo3bf/OWX84L49dLQO+R6m/lo9P5X5j9uUolwGa21k/lF8kaLd/R3xQ2ruHA1qTZDF7m666qxfYu8aGtRfJTT1+MliKMwf37r3UneMi/I/8AnX9P7QpY0yOxv5anxG3t3bunIYzPxvFjPkt84MvUdPdUbb3JgI2lK5PA/Hbq7fmRgaQRSRU26YHXUk4t7r3Uz+XQa75CfJb+Yd89txUcr0O7u+K34QfG2tqDhsjQx/Gb4O5fcWx87nNn5rHQrUTYPsz5Ybi7Hyk+t38qUtGut44INPuvdI3+YzV1Pyb+bP8ALh/l6bOy1ZTzYHuXb38yz5Ny42roZIMP8d/iBuOGTq3au68FWoGymJ7v+UGX2/RUpjYmFNt10xVvCAfde6WnyOgHyr/mf/Ef4vmm/ifVXwj2nU/zFe+IZsWlZhq7uLN1G7OkPg9s2py9NkIp8dl8Rm13/v37OWJlNTtPEVBBBQ+/de6t59+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3X//W3+Pfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+69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+bv83zdm18wfkD8890b8+X/VWx9wYvC7j3PQ4ztKDbHQX8s3oOpr9roJt1YQ7Co9gRxR2M0NVuStVYg7Mje691cz8E/jJj/hn8Ofjb8XqKpoMjV9MdSbR2lunPYyOqiot29hrj0yXZu+Y462SWrSTffYmQymZkEjF/LXNf8Ap7917oin8qqCbvztz+Yd/MZy5hyNH8lflDuH4/fHfL0u4F3Hg5fiR8GqzL9B7My21FliE+2KHsfu7Hb+3JW0aMsdTJXQVBW5U+/de6ef5SKUPcy/N3+YK0GJqpvnF8wexD1xuPGPVMct8YfiY/8Aspnx9Lx1IUQ0+cp+rc5umIRgxStul5kZllDH3Xurg/fuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691//X3+Pfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3XvfuvdE/wD5gHyqxHwh+FPyb+V2YSjqD0j1Duzd23sbkBUGhz2+zRHE9cbXq2pVaaKn3V2Bk8ZjWkFhEKrWSApI917qln+R78q/5Xvxc+E3UnVGT/mHfEPcHyi7nmr/AJE/KTcG4+/+usLvPsH5Ld3TQ7p32M1NuXcGKnze4NrmppduRCNEnqKbDRyvCJZJSfde6u53/wDOv4P9X4imzPaHzE+K3X2DySqtFkt8/IHqXa+NyQmVtEdFU53dtFT1xmVTpWMuXsbA+/de6q/+Qncn/Cbn53YFMf8AI3vf+Vt2vDtppKfHZnefeHRmzt8YKDUlRU0+2N6R7v2n2BjsRVylDOmOrkpKmRVEgdlW3uvdV+5/Af8ACOujij21LmfgViqnz00tHn+v+wd+4bcmKrYaqOro8hh+0OuNx0m49vZCjqtLxVdLlaeanKgrIujj3Xugk39u3+R5tiirMpgP+FIP8y3r7r+mWOJOp+nP5jPbPY+Jp8XCf29v7dwEvV/bPbK0DQgwiLH133Dq2kOW0ke690G1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6K7PbmqFihkqs8mH3hQ0MhlHkhhoo4TxEB7917qHiiflZ/OXzmbSMVvVX8qv4+PsihnqcbmKWKq+ZvzbxuH3HumfC5YMMBm26n+KG1cVSVI9dRRydkyxft3k1+691z6Wl/2af+bl8nO73E1f1b/Ls6i278I+payOXB5jbOT+RnfMO1PkB8udwYusgV8nid0bD2FjusNqVEOr9qSbJxOdTPGnuvdZdtrN8kP503Ym5Xalr+uf5aHxKwXUmIp8ht2qWSl+U3zmy2H7R7AyW39xyIaGoqtm/GnqjZ1NUxxsJqeHe7L+iZ7+6905/wAseoHeHZX8wT54ljPg/kp8psn0v0pkKTcC5zA5f43/AAXpa/457Q3Fg0jLRUFHvXu7H9j7hjCELNTZiCQCzBm917pOfKuVe+P5uf8ALX+ONHkKDIYL4wdd/JD+Yn3BtWvpJp4ErIsBTfFH4xZVJRA9LFmP769ubxyNAHdH/wB+9USIG8Rt7r3T38iqWl+VH80H4ofF7KYeozHVPwq6/m/mN9sioxkFXtyu7yzWf3H0d8JdvV2SVzPS5TbWQoext7RUjaAcjtrEVfq8K+/de6t09+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvdf/R3+Pfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvda+X8rrdG5+wcJ/Og+fGEWGnqO+Pmv39hOkp2qvJt7cHWfwz6xw3x+6v31DWVlGssX96c5snItVxuksFMKZUXUFa/uvdG5/kt0W09mfye/5e8u3n8WCp/h51LuvJyz0i45Uz2c2bS7s31K8UaHVGN25LIN9xYtUr+8blzf3Xug9/wCE+OIrsT/Jx+Dk2SiqIq/dOwt8djVS1MMsErzdp9x9j9ktOFmJaSGp/vX5I5BZJo3WRQqs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PJY/ID4vfHGqf4xfGrFy0eQEa0+PzG2uscjvGnESBJZN4zTanMpPv3XurbPfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3X/9Lf49+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3XvfuvdQco88WMyMtK0KVMdDVvTvUSmGnWdKeRoWnmAJihWQAswBKrc+/de6oc/4T55HBba/kKfEncmcqHjwtL1X3/vTdlfuKnnCStXd4d1bp3hlMmlSlZLV0VXW1VXUNKUkFTA/kCkOF9+690vv5cW6pejP+E/vxo7H3vRvS0nXP8tqg7WyFP5oy8m1cX0vkN/42oWWRxHGa/awgmAYgR+SxtY2917oyn8njbjbV/lR/wAuDEuNMknwm+NWblQrKjRTbn6k2ruaaGRJv3Emhly5RxwA6mwAsPfuvdWP+/de697917r3v3Xuve/de6pO/l8o3bv8zv8AnPfJ6iqMVktk4Hs/4v8AwV2NWU5kbKUO4vi50q+9+8qOsYVtTTLC3YXfsFKqokZBxnqAkMg9+690/fDOoxlJ89P54/yAnkrJ8Ziu5Pi71JUaYoBSrQ/Hz4R9bb4y0VHOFSolrY8z3LkFmSS6IBGUPqb37r3U7+QRtzJ4H+UT8Mcjm3lkzfZW0N+965l5YDTA5L5B9w9id4VQp4CFCUMb9gaKcgBXgVGH6rn3Xuu/5aH2fY/yo/nGfJWklq/BvX56Yj434uGSIjHy4r4XfHLp7qLL5HF1Jb/KVk7Pr9zUdSAoEVXQSJdiDb3XuqE+29l/8Jvt4drd09adddj/ADz+UHaG4e598b3318Sfh7kvmx29sTuDsio3/Ubq39tbA4TD7bX45bnwOf3VFJHVz/3hp8WIfUK+FUWZPde6tc7+6a/mU/ze+s8x8dO4ultl/wAsz4Mb7zGBPaVNursbFd6fN3ubYW1t37c3lhtpYfbHWMtN0p8fMFvSPCilzgrtxbpy1NH+waWWGWpgb3XuhM/4Ud9g4/rX+TF8yqVaY1GU7B2xsDpnZ2BoRElXl9wdm9o7I2jR43FUmuI1M1HjK2pqzDEGcwUr6VIFvfuvdWnfFbqqp6K+MHxx6RrGDVnTvQ3UHVlW4WnUPVdfdfbe2nUPppJJqUa5sQx/bd4+fSxFj7917ou3f/8AKk/lufKTeOU7F79+FHx47H7CzskMuf39lOusLj97bhmp40ggqNw7swMOJz+dqIaeJIlkq6iZxEipfQqqPde6KTi/+E6H8nzbWZqtw7G+Le5+s81Ws7T13Vvym+X/AFsNLyJM0MNFsvvvC42lp/NEjiOKFEVkWwFvfuvdOsn8lTZm25qSfpH+Yj/Nm6CjxrLJjsFs/wCce8ewdmRNGB4YqnZnf+B7hwdZRpzeMxrqDG54XT7r3WFunP55fx6mLdV/Lr4ifzANmLVz1Em1/mD0xmfjF3Fj8LT0832eEwPb/wAYkznXW48zLKI1asy+x6NZR/nHRtUze691EqP5k/8AMQ6mXIVnyZ/kk/JZdu45ljj3L8LfkB0B8yJsxZYzJVY/YEmW6S7JgiN3/bkxhcEBQXvq9+6901Zz+fn/ACvoca2yPlXke8vizW7vo58Hmur/AJn/AA1+RXWoqaPKJNQ1uE3PLl+rc911LR1kBkjnimyclPJGWDEqGt7r3VTvY8v/AAmN3NvDI7o+NP8AMnyH8u3sTeVXFmMtuX4B/JTsX40bZymSpfNPR1Ob2LSYHJ9J4toJJOUTD4+R1URlgLD37r3Vr/8AJx6O+Fnx3/2aHNfHP+ZNgf5he6vkj2pguz+xOy9zd2dPdw9t0+SxO1YcBjsPvPeHX+UmymckggMssK10FKKNJTHDBGPI0nuvdPn8p7O4XtP5NfzpO+8DSpLjt0/zHn6To9wqXnTPRfFz44dI9U5AUOQLeCvxWN3RFkkhMQMccjyoHfTZfde6SfxtXHd6fz//AOY13Ii1U3+yYfDD4lfCHCZFPJHh6qs7tz+7/lb2BRUjQtLRZTJYSrgwsNXIxSoo3cQFdJv7917p1/4UfVVc/wDJ5+UO1sdVtj6rsvcfxs6qauEfkWkoOxflF0ztbNSudQWMfwTIVKhiGXWwBBv7917q76ho6fHUVHj6SJIKShpaejpYYkWOOGnpYkghijjQKiJHGgAAAAAsPfuvdU6/yR6Cjqfj78sOyaOeKYd3fzRf5kfak3hhVIYnq/lPvvZ1PHDVo8iZOE0GzIXSdWKhWEYJEfv3Xugo+HnnrP5/P85OpSogrKXDfHn+XLiKn7eBlbE1WR6+7AytLja6ZmIerqoUlql02UwyIPqhJ917oWvnPJkuwf5on8mXpAUNLl9nbf3j80Pl5vejeBKiXGZDor4+U3VHV2cmLavtaem3t8lNUTkXaqij0kFffuvdIn4k1Mnaf88r+bR2NNQasd8eehPgf8Uds52JpI6aqn3JtjsH5Eb7xbRsXWrrcXkt6YwSyDxrErIgDMXYe690LtbPLn/57G3KSN6WWn6q/lMbxrK2FhKKujqe+/mDsimw88JEXgeCvg+OWQR7vrQwLZbOx9+690hfnVUVW9f5sP8AJR6hhoo8phtu7m+dHye3jCyl/wCFw9V/GxOr9i5OXQNcN9797QtCzERtJTlTdtIPuvdCB/MKo8d2X8tf5Q/QGQWq+1yfzL338nsm9G8YlTH/ABK+Mvb+5MEKhJCdWOk7V37tcTEAsDpAIJ9+690tf5yG78xs7+V3822240a7l3z0buHpPbJkmFPfc3yEqsd0Tt1IZ2v4auTNdiwLCwDFZipCsbKfde6K/wDzue8Nmfy/v5OPbPXOyMaTkOxOqMH8BvjvtmoylPRyzbg7c2XWdS4APmq+Sno6eXZnXdNk80Zqh44pDidLsgfUPde6qs6V/lefyZvit8eOieqflF/NRyvWvcO3uttsJ2vg8V/NXg6c2bld+ZSgjyG8aXa3X9H2Rgsfitm0ucmqqPGrRUsDyY+FHneWoMkze691d58f+mP5c/8AKE+G3ffyW6MmqU+P+Z29W/KLtTuKDsXPd+7o7bx2M2fSHCZzDb+zu4twVW86fMYmCNcFTUtcMdNV5F5IdLVcsr+691rsZv8AnD/zvPlZ2F8Qvkp0n1Ns34N/y4fkP83/AI4/GHqmfsHAbE3z3b8gsX3H2HNgZ84+O3pR5iufCS7TxVfkZqnB0GFoqSmgb7LKZJYJqse691fx8GMIn/Dr/wDPL3c0Mj1Fbv3+Xpsj7+WoqnP2O0/hZtzdFNh6emlY01PR0FX2TU1QaIDyTZCXVyvv3Xuhc/lh4JsVsT5k9hVcdNSUnbP8yH50b8patK5qyKrwu1e5Mp0xjsrLUzJHJEJ8b1IjGJiy0ygRIfGiAe6905fyj8PmIvgd1R2BuehWj3b8hd092/Kjc0zRU0dZkqv5O94did44etyL00kyT1Ue0t846mRmdnWnp40NtFh7r3QCfy2+zMPB0b/MV/mD77ymOyWy+6Pml8xO5sPvPGNFUS5H43fE5YPi71pUx1Uq02vHJsP4yy5CjjZ/Eq17OraZSx917pYfyLti7n2x/LC+N3YPYdRjsn2r8p6XfPzV7U3Hj6RqP+828Pl/2Bub5Aw5KtjeqrGetoNqb8xeNL67vHQISqm6j3XugX6MxVH37/woF+c3ck8+QkovgX8JvjL8Odu0U2Ok/u9Uby+S+c3L8o99ZzF5GeKSCfcu3tsY3BY6qamlRo6XKCGZCbH37r3S9+S80e4P54X8rTA4ypZMn158TP5jm/8AdFOY/Gj7Z3jP8X9j4ELOrg1LvuGglYxMCsYhDDlrj3XugR+BPaeU2dgv+FBHyfx4OdyGxf5hvyw/gcFeogoMjL8Xfi901t+mx2iEIn21LmNtzY2WUDW/2p1FmBPv3XuinfGDrgdTf8JLO58nnctVZjc3dH8uv5o/ILem4K6OiatzW8PkTsbtffwqKpsaixySCHc9HSh3vKEiXyaSpRfde6qp/wCFKnWnylyv8uX+TDiOseyt4RdTdi9edK/Hbefx6wG5q+g25vvurcPU2wM71HlcwkdTQYzebRjbeVpKc5UeLHzxxTwhWqJmT3XujO03xC/kE/yKPii/xe/mBZranb3y6+WvUEe0e7stjtmV3cHcmPxu9sXWYjK5HqPB4rEVVd0Z1xtjPy1D4HLxjGZzMV2OiqllrKuihio/de6zUHbW6/mF/KT/AJA38u7elNkcn2l8w+/eiMB3F1RkabIJurdn8vj4TdkbwyO8O3dxUtfTNUYnb+5Nl9P7QzNJLkNH8S+6k+3epMExHuvdXTYqgg+Vn8/DeeWy9dSZDZP8pv4f7KxGz9uOh+7w3yd/mAybryO5t8xVcVQgZKf429a02IFJLE5j/izTB18iqfde6TfdUT/I/wD4UKfEbqHOU08+wfgJ8Ee3PmbRRN45sNk+7PkJ2FB8cdrQ5egkZo6iv2nsnC5DKYud0L0lVIzxFWJPv3Xum/5qaPkT/PS/lT/GUVlTU7b+K3T3yS/mF9mbcp4p56arrqmLH9CdBZ3KMqCDHf3d7BnyktNMzMZHkeEqvkVj7r3QzfzbX/077l+B/wDLcpWo6mg+b3yfxm5+98NksVlavHZn4d/DqjpPkV31gqjLYqeF8C2/d14TZe0dct4ayn3LPTN6ZSR7r3XH+ahDJ3z3j/LM/l+j719r/I35VS/Ijvei/g1Jndtbh+OnwGw2P76zux96UlbS1FNHt/f/AHvVddYp2YqX87RgEMxX3Xusv8zaGfv/AOS/8sf4EU61rbb7W+SOQ+YPexjo6DMYGu6I+A9Hguz6XY28sLXq8NZguzfkNurYOPPkVovFBUXVyAPfuvdPX8xCqn78+U38uj4D4Za6vxW8u8pPm98kqbG1GAq6LHfHP4OzYffGzsZvrBZVmqqjbHZfy93F1vjYvFG/3C0NYmlo452i917pafzi+xN07W+C++eqOtt10eze4/mTvrqb4KdPZ6qGRMuK3j8uOwcF05mdyY3+ET0uVTJ7B623Fn9yRSU8iTQfwYyqy6Lj3Xuu/n9mYvg9/Ks7Q2L8acVktuZ7aHRWxviF8Tdu7dq66fO4fsXtFtqfFv43Y3AVBeoy1bkNv7v3lhZFkBkqNFK0rN6WYe690ej4/wDTW1/jp0T0z0BsgN/c/pLqvYHU+2XeCOnmnwfX21cVtTG1VTDCWjWrq6XFLLNYteV2JJJJPuvdC77917r3v3Xuve/de697917r3v3Xuve/de697917r3v3Xuve/de697917r3v3Xuve/de697917r3v3Xuve/de697917r3v3Xuve/de6//9Pf49+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3VQk385zoRu0u8+vtv8Axu+fHYm1Pjr3Tuf4+9pd79PfEve/dfTOF7U2LDRT7/2+tb1HV717EMexkyMP8SqZduQwJ5F8TShlJ917pTdl/O34v/Lj+X58+t/fGTvDF7qj6n+OPyHxW/VbG7u69391RuOj6b3pk6X+/HX/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bNqpFjcEFfde6m/LRKT5IfzN/wCXz8TWjxeY2d8asT2L/Mz7vwmTx+UZEy+x6er+Pnw7ihyVNGMea+bt/sXc26aSmmkANRsBZ9LNCgPuvdW+e/de697917r3v3Xuve/de697917r3v3Xuve/de697917r3v3Xuve/de697917r3v3Xuve/de697917r3v3Xuve/de697917r3v3Xuve/de6//9Tf49+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3VP38m6nhi6/+fs6QRR1Fb/N/wD5m1RXTItnrKiH5M7ox8M8zklpHhx9DBApP6YoUUcKPfuvdET+TmGl3pF/wql3tHWRYXCUHwp63+PSbjRMfLRzZPqz4Adpd0blppp4SJJJKWD5LU9FVLKfNCPSpBVQvuvdGg7wpK/ef/CbXsQ12DfbmVyX8l3KZ2p2zSioibC5Sj+Fv8fbb0Ub+Sp00NbS/a+N7swXSx5J9+6901fzUOyIcl/wnk+Q3YZhqKJd+fAnZZp6SsaNq2KftPamycLRUE5pjDFLXPU7oSEiMaXlNlUghT7r3VzG8d9dddC9T5vsDszdG2OtOsOrNmSZrdu6c/X02G2rtHbG2sYrVlbWVtQ0cNLj6Glp9KD9TWVEUsVU+691TB2p/wAKVf5SfXlXmsZs7vDevyOy22MDU7r3RR/GfpvsjtbH7a2pQQVVVldy5vd9NgcVsKiw2FoqOSetlOWP2sK65Aq8+/de6uc6U7c2b3/031N3v11Pkarr7unrXY3bGxqrL42pw2VqNn9ibYxe7ttT5LEVgWqxlfNhsvC01PINcMhKnke/de6E337r3QBfK3eW6Ouvi58kuwdj4jL5/euxOgu4t5bPwWAxlXm87m90bY683Fm9v4jC4bHxT1+Xy+Sy1DDDTUsCPNUTOsaKWYD37r3Wtx/Ly/nQfAD4Z/y4fix8Xq2h+RMHyb6W+L2xMLuP434z4bfKgb0zHdS7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uFU00JAgxlNK4ASIke690P3xA+OO2fiD8WPj38Xtn1C1+B6G6h2H1hBmPtIaCbcldtTb1DjM1u2upKcCCHKbvzcNTk6sIApqquQj6+/de6Mb7917r3v3Xuve/de697917r3v3Xuve/de697917r3v3Xuve/de697917r3v3Xuve/de697917r3v3Xuve/de697917r3v3Xuve/de697917r/1t/j37r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3XvfuvdVN/yYqiLNfEPsDe9PRU1HT9jfO7+ZBvaAxVtTkKysSu+dXf2Maty1Y6x4+oyMsuJZdVCkdG0CRlVDmT37r3RD9h77/uh/KQ/nifLijqqDLYjunu3+bd2919DNTxnHz4nr+h3V8XdlQ1cUck8VRTbgr+hIquRhw6VxJ/JPuvdCh8k+u5esv8AhM3uLrlqypFf1b/Ke2BjYa9oo/uP451x8ftp1VJVSwSII7HMYJGeMrbTdffuvdDn/Mimh3T3r/JX2tuqlNTtLcP8xbE75y7wtJFffHXHxC+TO9eso2SBlkali3vBDWlTeMPRIX4Hv3Xulb/N2yEjdcfCXZkCSTVPZH81T+XPtxKeCSOKplo9sfI3bHbWelp3f1q2O211tW1b6PX4ad/xf37r3SH/AJzc1dufBfy4ehqKKkrqP5A/zX/hjt7eWHr4Ip6LLdc9SZ3dHyV3lS1S1AMDQvB0pAnjNzKzhNJBa3uvdXOe/de697917r3v3XuqjvlX/NRyvTXy4oPgf8bPhp3r81/lK3StL8gNzbX663P1R1l17sPrWv3FXbYx9ZvHtHtbd+CxGIy9ZkqH9ulanKyLVUyxyvLN4l917oFZe1P+FCnyBjQbD+KfwJ/l8ber70ddV/I7vnePyz7ewlNeYNnMBgugtv7Z6qqsnInjMVFX5OWnhOvySS8D37r3TzUfDb+eRk6arSX+dR0xtmorl8Svt7+V71llDhVIA+6x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8NSKsnLTV9DkpWF9PjJBX3XulbQfy1u7cXRZjHUP83r+Z3LS7jKNmp8znfhjm8tTyanaZtpZWu+Ghn2aswkYBKQaIwF0AFR7917psj/krfDfK/Z5vszd3zR7n7To46tYu8+xvnz8w07ZiesNM0jY3KbD7l2PtjblLE9KniosViaDHwqCiU4jJQ+690TL5U/En+QR8XsfmNxfOjvKqqdx4WnnqKn/AGYv+Yh8s+zO4ZKQ0zTtjNtbBn+QWb7DzLPTMzrRYjETzzK59D3Hv3XuirdK7u+EXXpye6/gB/wm4+UPem2aqokTG/IbtPoHrvZWV35S1cNK612w96fL/eeZ73zGwqmjjiWKSWnoaXyQ+NacCNW9+690fTbvzG/nKZ+jo9mdEfyNdg9BbLghWg2nur5A/O7o7bm2Nu03mC6sl030ls/du6sfQUzu7mCknDOvqS5IB917p/b4h/zsvkRJDkPkZ/M+6h+Im2a8yUm4elv5enxqx2dqZcRdnp5MT8mvkxX7g7Dwe4/0iepodu08LMhMUcaMU9+690YH46/yivil8cO4Nh/J3Pbz+TXyX+SHU2291YPZXyD+Ynyc7T733rtHHbywUu3981+CoNx52i642tW7lwM01NWT47B0QWmmljiEUTsnv3XugN7T7G6+/mBfzRfjB8dOtNy7W7S6R/l2UeW+c3yUz21qjCb22XS/JfOYvPdPfDHqKv3Rt/cUn8A37tmDcO9ewpqGaCUr/AMS7AF7D3Xurwffuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691//9ff49+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691gqqqmoqaorayohpaSkgmqqqqqJEhp6amp42lnqJ5pCscUMMSFmZiAqgk8e/de6qH/kK4yvxf8or4aZjN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DZDK1MxgpaGtzXbq7IzNMk02lQ9FiMlIxkUJE5Jt7r3RNsJ/P9/nt/MOnrM18A/5LMtBsSuy1VgsBvfuWn7J3Th5KnwFopn3TX13x42Q01H42epK1E1JTPJHFJJqKmX3XulVgPip/wAK2/m5VxVPyA+Z3T/8uvr2sOur2p1YNlVG/cdFK5lR8Mem8buvM1TxxTaDFXdhUjKIwGBe7H3XukNnf+Ej3yW7zyFVW/Lf+dN373PTV1RVVFdQZPYO+d2T1clTMWlkbJ9ifIvcdLCaiKaUMv2DqpewuoIPuvdbGv8AKn/lO/Hj+Ud0hvDpnoXcG/8AfMvYu+27D35v/s6p23VbqzmXjweM29i8RTDa+3dt47H7WwNDjWejpGjnmjqK2qkad/MFT3XurQ/fuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691//9Df49+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+69025lKCTEZWPKyUkOMkxtcmSlrxTtQxUDUsq1klatXelakSnLGQS/tlAdXF/fuvdVLfyDKjNVP8m/+XrJn6Opoa5fj5gqeCGrM5lfC0uYzdLtqsQ1BMn22R27DS1ENv2xDKuiyaffuvdW9+/de6r//AJnvxY7T+ZXw2330d0duvYOyO4ajfnQnZnW+6O0KHNZDYeM3T0b351p3TRR7kptuU1Xm2x+Vj2E9E5pone1TyNNyPde6LLi/h3/Mb7979+Kfbvzf79+GGM2h8R+3sj3ns/r74mdAdxYncu8955XqnsLqh8NubtPuHvLc8mH2nRYnsWrllhx+DDZN4oxMsWiNo/de6c+3ZoO6/wCdv8P+smpMq2J+EXwy+Qvy5yuRpZolww7J+TG6MH8V+qcZk1UvM1fB1zgOyZ4oiEXROJCSQg9+690yVWZqM3/w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RyUiPCwIkC2Pv3Xugyp/+FAmA7qT7j4Cfy3/AOYv84ttzrN/Cu3dp9GT9R9A5uRYZJIIsd2j2hV42p8jlB5BPiISiOpUOxCe/de6Uu3Ny/8ACg75cwNVDZnw1/lN9b5qmq/tqjebZT5xfKvBx1Pjlw+QpNu4PMbD+PsMqU4P3FPk5nqIpHCvTqyMvv3XulRS/wAqX5r7rTR3T/PN+f8AuE1CVCZFukdnfGz45+XzxMl8b/d7q7dj4cxvIxUozso06ChUN7917qr75C7L/wCE6fxa7Lreofm//MZ+V3b3yC2hlcJt3eWQ7b+c/wA5Oz+ycZlquKCp+y3vVdA5rGbW2vM9PNG9fG1Lj1oF0hlpzYH3XurI+k/5G38ibuDbWzvkT1h8ZeufkNtjsHH43d21u1d292d5fIHF7zx2pRSVcuS7K7Z3pR5ingkpjTT0lSjLC8T000SskkY917qi/wCVfyw/kudP/Lbvf4mfHX/hPVQfNjdnxs3NHtzuzdfRnx+2LW7Z2xXUqxR7teioNq7N3zl0p9pZ15sRM2SpsPTvlKKphRxHGksnuvdHZ/l7/wAwf/hNr8x+19mfFLq/4IdE9Dd177fMY/D9Wd2/Bjo/ar5LeuHoWly+y5t0YPCbv29Pu2Wlx9QtPHX1cElYaM06/wCUvBTSe6902fzKf5Xvwc7N/mafyjPhD118Pfiz0T1N2Fub5AfJ75AZ7qLofrXrnefZu2fjTtTb2R210vUZ/Ze3sBlJNib0y245qbP0bT2lpqiKpiKVFFFq917rbw9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691//S3+Pfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Qbbs7l6h2HsbdPZ29+0+u9odb7Gjlm3pv7cu9NuYTZu044JYaeVtybmyWSpsNhdFR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YyPVvWeyM7vzsKt+UHwK6aydJtXbu0sdX5vOZ7Gbk6urKHclZI1BT+NMaMdWzTyqqU4eaRYz7r3Qr/Hb+YL8gPjj/Ip27/MU/mXTYjI94Yjo7cvc2bw9HhsRsCo3hJvvd2Yf41bFqsLhMbRYjbe69+YTce1sZNHFRRGjqq7/ACiPyxzsfde6qy/l/fy4tj/G3+Uh84f5nHz6+OnSXyI+Z/ya6i+Rvz33rgvkF1Zt7sDH7QxEWwd79udf9dSYzeMGbqsFU7rrJ5c5n1pvscgKjMR46pLS4mCUe690eL4Cbs68/k1f8Jvuoe/d4ViZFdo/FSH5P1eOzNXVQDdPbnyVC9k7B6xhj8hXGnIby7Iw+1oxTLHGug1L3dppm917pZf8Jsfhdun42fAWP5C91QxZD5R/zCt4Vfy97r3VW08f9563D9iCozvVW389XhY6iaSn21najcM1JLHG+OzG6MjAV1KzN7r3QI97dSddfMP/AIUs/GLbe0uv9iUlB/LW+Nmf+T/yM7M2ztrFY7eG5e6+6J6TbXR3VXY+6sdQR5PJ1e1cBRYjd+Dpq2aS1DUV/j0q76vde6FHq2ozPzS/4UW94do4+orT0f8Ayn/izifjniKyjrZP4TuH5PfJ0/3x3zJBrjEFYm2+vEqcNl6WO8lJksVQySMBJGre691sZe/de697917r3v3Xuve/de697917r3v3Xuve/de697917r3v3Xuve/de697917r3v3Xuve/de697917r3v3Xuve/de697917r3v3Xuve/de6/9Pf49+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691GrKykx1JVZDIVVNQ0FDTT1lbW1k8VNSUdJTRNNU1VVUzMkNPTU8KM7u7BUUEkgD37r3VWvYf8AOL+HeF3Rl+uugf8ATD89u1tvz0kGf65+AvVOc+S8u2mq5kp2O8Oz9uS47oPYklDPIqVMOc3djainZgHjBvb3XuknL83f5nG+shFF01/Jv3nt7btfrSi3h8tPmf8AHPpJqIP5BDWZfYnTx+T+8oo4bI0kHiSViSqt/bHuvdR2xP8APu31kJ4qveX8qX457arpIzBJt7Z3yq+T2+8DSTMvkX73cG4/jfs/LZKhickE49KeaVAPQjah7r3TRN/KP3d3+hb+ZF8+vk981sNUR5KhyXRezKnH/DH4l5vDV1THUw4rdPSnx5rsdu7sGGiKGMDdO8s9HNATHLG6ltXuvdEl+Y/8o7/hNJsqmx+0vkKPjF8Q63b32eVyG3sV8rk+PGd3bi8eWycGO3Xs+p7Lxku9/MKu9LPLQT5iJZtFFUxeUq/uvdG36/8A5vfw22/sTrzqr4EfHH5w/NrrXrfAYDqrbNV8O/ir2PufqvZO29i4KkwO3cPJ3f3pWdPdVZmiocDjII6eoo9yZNqlApDyMWPv3XulhXfKr+ad8l65Nt/FT4E0vw42rNTJUZP5D/zJd1bQq8jjgWWKpxGy/ir8ZuzN9bu3PuEpN5YKvObt25iofH61qWvB7917ogvySrH66izmH/mc/wDClzFbH2DUrFVZLo34jbP+Pnwx7Qq5MXOEyOKotx7W3D3x8pctt951FPX0+Hno6iVJHR5I9aLH7r3VMGB+Sfx4+Lm//wCYb398ANvfNPbH8tDc/wDKN7t2pJ2h8j9v/InM9C/If5vVe+sPs3pDPdb7s77q8jl3q8xS9sUGOi+7fHzSwTZBYcaqEzTe690cT+Yr1xv7a38oX+SR/JK27UQbR7n+eGe+LXVHaVHjKFqaTa2xOv8AGbM7E7x3BX4WBkqKldodm7jw+RyE8qj7taCrkdPI5Ce691ub9e7D2t1ZsHY/WOxsVDgtk9c7P21sPZ2Epv8AgPh9rbQwtFt/b+Kg/wCbOPxOPhhX/aUHv3Xulf7917r3v3Xuve/de6R3Yk0tN1/vqop6+lxU8GztzTQ5OucR0WOliwlc8dfWSNJEqUtG6iSQllARSbj6+/de6qh/4T6TSz/yZP5fbzY+uxrr0gIRTZBCk8kVPvLddPBkIwVS9DloIlqqU29VNNGbm9z7r3VDvTvb3XXbvxH6j682Tv3rzNdg/P3/AIUw5TtPs7YW0N3bdz2/Md19g/mlvXvPIbizm08fla3PbaxybK+MuNemqa2n8H8Pko5QWiqIS/uvdWI/MHvLvnoj+ffsfsjZfwp+WHy42lhv5Ulf11sLF9D7M2+21sR2l2X8r/7wbwzW6+y9/bo2jsPauNp9mdbY2km1VcteJ6mEGmMMgmX3XujNVffX86f5X56mwnQXxJ6x/ludeYOmkrtxdvfN/cW2e/8AsLe+XChKfaHXvRvx+3+uP2/jKd3WWrzebz5WojZo6anSSImX3XumXJfyzf5hXytzVJkP5gX80rsXb/X+IEMmJ+Pv8tbb2U+H20q/KwOzNmN/dx1+499dyb7oKxXT/cM89FR0k9NHPDIHaQH3XugG+fnxs6H+Dfwl/l0/y2ekMbm8jsP5B/zVvh9142H3ruuXdO99z4au+TE3yq7d3fvDOT+LPZqjWt2S8VZXRU7ij+8o4WCRlCPde6On/O9q6Cf4j9R7Jq6qopqvtL+YL/Lk2BhhSpO09Rkqr5ndN7ieKJqe08UkeK23VTIysja4gFa5APuvdA3/AMKXVp8j/KD702jV1lFj6XsDtn4jbMqa3IVNVR0lLT5D5Y9MV9RUT1tNBUpRwQQYxnlllRo0hVyA0mhT7r3Qif8AChzwyfyfPlzR1EVTPDl5/jzgJIqOTx1TLuH5UdIYM+FgkjM6/wAQvpVS7gaV9RHv3Xupv/ChbfLde/yYvn1mo4p55s11LhuuKeGmkeOeaq7f7J2N1PSRJoZWk8lTvVAYxfyqSljqsfde6tw2Ntah2NsrZ+ycWix4zZ+1tv7WxyLDBTqlDt/E0mJpEWCmC00CrT0igJGAi/ReAPfuvdU9fyhc7PvfuT+dFvyoqxWPJ/Nw7d6yWRkQTJD018f/AI37HpqZnRV1Q0dNTpBGDyBGSSSST7r3Tvv3L0W9P5/Xxu2JX445D/QZ/Ks+TfceGq5tUtPt/cHdHyd+PfViVtKPGUosnlNu9fZOmDFg1RTeUKLRN7917pL7O6765+a/84j5bb87R2Vt/sbrr+Xr8f8Apb4mda7X7B27trfWx07x+Qn/ADkv3x2Nt3E7goMlBg934br2Pr3bhrYUWpMJroC4Qsh917q1LuT5F/HT4zbag3H393h030LtRIhFRZbtjsXZvWuGlSDRDHS46o3Xl8PTVUgJWOOGDU7MVRVJIB917qt7/h+n+Wll5a+n6y7M7p75loK+oxxqOgfh/wDLnt3AZCoo5Wjq3we9dn9JV+xNwUkCRtL9xRZSogkiXVG7gi/uvdN9P/PR+J2djqKXrzov+Yl2tulI5Go9i7A/l5/Kqs3TlJUBZaekGe6629gKdpI0kbyVdfTQIkTtJIgF/fuvdel+af8ANt7NrGpukP5PtH1ptnNI8e2uyPmX82OoevKrEiUCOmzG8ulei9vd97zpaOnkfXNQx5OOuZI3VQuqNm917or3zi+Ov8wai+Efyz+SHzT/AJnO/tpw9U/HDt7t1Pjp/Lu2ftj4r9Xw7k2B15ntwYTZS9+b3x/anyc3diN05jHxUlS5zOCWq+5WJaWIKxm917q434H7d7D2V8GvhxtbuPL57Ndr7W+Kvx/wnaeb3Zkq7L7kyXYOI6m2nR72yG4svlpqjJ5LMVG44Kl6moqpZKiaUs8rs5Zj7r3VYn8gXDZbf/8AKrqu6sPuKXanY3zW73+bnyRyu9IMVR5ObCb47R+QXaG3MFu6DDV2nHZOTG4ba2Kq1p5WannMYQsY2v7917ooXxp/4TKby6B6zpes4P5zf8zHa+Cm3Llt37hwnxk7Ji+Nu0ctuTP1TVWbzseAhruyKuPP5VhH9zXVNbWS1DRguLBET3XujWUv8hXJYwPDiP50f89aipayKljykdT88KLKVNQ1IjGObH11f1LLNh5ZZ21S+HiRSUI02t7r3U2f+QfhZUjii/m9fz2qWExJDWwxfzFstJHk0R2kvWCs6yqijM+m/g8IsgAABbV7r3Vonwt+HHTvwL+Pm2Pjf0e+8arY+2cvu7cs+d7E3RPvLfW59z763NlN37s3Pu3c1RT0ZymZy+by0skkiwwxhdKqgA5917qm3pr5Ew/F3+Rv8vP5jGAx+Q2v2j8kdwfMz5k7fGbM2XrMp3H8ju493bM+KuOjg8tU9VjpMNN17gcbBEzq1BT06R8Ee/de6sV2PQ7A/lF/yodvQbkWiqdrfBj4dU9fuxsRBT4z+++7eteu/wCJ7qqqCnaaOnG4O0+wYamVFaQebI5Tl7uW9+690Uj4sU26P5YX8jffPyI7YpxV/I9fj/3v8+PkRV5qhpcTnd4/KruzD7j7yzuE3YtGn2z7hoN157HbREgBTw4yBblV1e/de6WfxxFB/Ku/kJ7K3Zkqd6TcHxu+BOc703bQ5bJ/cVOa743JsDM9176xpyOTB+4yG8+9d3V0FP5gS89aitcn37r3VUW//jRm/jr/AMJlvi/8HUy+W218hP5gm7fiZ09kK7O07ruqs7s+cvyH2d2x2vhN2rVyLXV+V2r11lNwYutkkZ5vtMMS7aUZx7r3Vo/84DEYzvPO/wAuX+WFQU2Kh2v80Plht7cXcG2KrEVE23st8Rvg9h4Pkn3Ds8nGT0rYL+8+4NsbPwNJNb7dTkvERd0B917opW4e55tifzK/5638xnetUDiP5ZHwF6t+L3S2DnqqKhx+f/vH1fP8zd/UEwq5FpxuPN9nnBYnHSG71YrVgPCRKfde6ydW9HN8W9x/8Jg/hNl8BUY3sDYeJ+R3cfZ2Lab76lxG+NmfBPsKLuivr4vBE7S1XenyKvS1T6TFNLpOp5Lj3Xumz5Lx0fdP/Cqj+XrsaKA5Kk+J/wACu5+9M9HMYaqgoct2RN2n1xjStMFkalyNDPk8PV+STQbyU5TlVJ917o+PW+Kg3r/Pz+VW/KGWtZOjv5XnxM6UzMSShsdHmO3Pkd8k+26bzxo9krWw204TDrXXoMhBCkX917oAf5xw/lBbl7i6a64+bvxO7b+VnysyPXWa3z1ftz4l9V90bw+UGA6j2fuKVJ83V7p+Pud2dv3Cdcw7syValHFW5QY4Vr1zxxoWqHPuvdJv4dfyrf5MPy96R2z318dtpfKOnwNTmM7gKhc78x/nx192b1r2LsjMTYPdmyt6bQyvf9DW7P7A2HuGgelqqaSBkSSJZYXmgeKaT3Xui/8AV21v5NPffaNX0l8av55fzs2V2JR7ubYWM612P/NY7/wH9491LUz0cOE67ou68vnMf2Y0r07U9NLgpcrDMNPikZ2Rj7r3VjMP8qj5HdaUNfU/Gv8AnL/zJ9mboqYpUppPkhn+ifmpsimkdCFeXanc3TsO4JEMhJcQZ+mfTxE8JAYe690Tv5Jr/Nb+B/ZX8vWvzf8ANO3N8uW+Tn8wL4+/FzffTOb+EXxb622xkusd+Hdm5O0934nKdeYKDfu2n2PsXZ9ZV+YZecILNKzBRb3XujBfyZ4KncfyI/nhdqZBKOTIZr+a/wBm9T/ewyJJVS4ro/qjq3CYOiqNCsqw47HbiUIPIWEkkqsqEG/uvdAr/NGpov5gv80b+X//AClp6Q7l+P8AsDGZr+Yj88NuwVQbFbi6964q67aXQHWm9KZXWly21N3dqSeLN4SpEjVFLksfWqkZp4Zj7r3V2vaXyg+HnxNxuIwXdPyE+NvxsxNPSU9NgMH2Z2t1l1DRR0NilJT4XE7nzu34hS2QiNKePTYHSOPfuvdOvx5+V/xo+WuB3Rur4x97dW99bZ2XumfZW6Nw9Vbywu9MLiNzwY+hyrYufJ4Sqq6KRpMbkoZopY3eCaN7xu1mt7r3Vdf8tul2vnfmX/O173gSkq8rmvnJ1x0hmd/1DmjmqsB8bPh50LRUWyqmmIgx1PjetNxb9zqR1QUS1DV8zzO2lW9+690Xr+QTQP3yf5iX80TKQVM0n8wz5o75qOoszW0tRTVOS+KPxrnyHT3QIaOrPkinpFgzVNNpVUc0yH6BVT3XuhU/ms4mn+X3yN+AX8rTxVOd697s7LzPy2+aG3qCfH1GPqfiL8SGxWfxWyex8a9THloNkd5fI/PbSwkU1MivNLjqhVljEch9+690U/8AnFUA+fX8zH+WD/KOipY811Tjt01/8wn5mYxmkqMbWdP9ONmcD1zsrc9PR1Mczbe7H3JDl8JVxSj01OVxtQmkxiRfde6NZ/woV7W3Ltn+XhlPjZ1m9KO6P5hncXUfwD6ipqicRU/8Z+Qu5UxG6p66GMic4kdc4zMUski2SGarhLnSdLe691Xb/N82Pjfl18wf5VH8gfqepp6Xpnb6bU+TXy6xtPLVQjF/Gf4/YxtsdfbEqa/HtI1LPu/D7fztLHTShjDlajBVbqItLn3XutpLtHsbYPx/6f7C7a3xV0u1usOluud09gbsrKanhhpMBsfr3bdduDNS0lHGYIEixuDxMnihTQtkCLbj37r3Wvd/Ji3Aenv5efzO/nKfJ3GQbe7A+cW+O9vnt2Kk7MMptf499d0W54eiurKbJVDO+T2/t7ZOErq7bn6pDR7jiisZCV9+690O/wDwnI6t3FgP5buA+SPZEwyPd3z+7f7g+bfceaZZGlyO4e4t4VqbbMVRUE1DUDbDwOLqkiNo4Z6uYJcEu/uvdXy+/de697917r3v3Xuve/de697917r3v3Xuve/de697917r3v3Xuve/de697917r3v3Xuve/de697917r3v3Xuve/de697917r3v3Xuve/de6//1N/j37r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuv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917qv75Wf8Jnf5ZvzN+UXb3y07woe+cp2J3TU7eyO6cJgu23wey6DM4Hb+O22+XwNDDt6bcFJPmMdiac1EE+SqaOJ4/8lhp0Oj37r3Qw/BP+QF/Lj/l0d4Y75FfGzZHZeN7Xxe3d1bVo89u/tfdG6qRcJvClx1HlaSTBzyUuFmMcNA3gdoC6NUSFixWExe691dT7917r3v3Xuve/de697917r3v3Xuve/de697917r3v3Xuve/de697917r3v3Xuve/de697917r3v3Xuve/de697917r3v3Xuve/de697917r3v3Xuv/9bf49+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3QQd/8AevWXxi6S7T+Qncu46banV/TuyM/v7eubqHh8kGG2/QS1slHjKaaaA5TP5iZEo8bQxt9xkMhUQ00KtNKin3XutOT+URn/AOTlj/jn3f8AOD+ZXuj+WUO+fnf8sO/vlvh+vO9q749dmdrdK9Zbx3ZJJtTrWjwu8Y9y79ongrqKtzMdJSQIRDl6ZHhSpV19+691b1tr+fT/AC0cJQxdcfBrqP5PfLmg2+81JDsn4A/CTszc+2cROhhVqegmrdtdZbDEUjygGalq3pVKnXItvfuvdClH8z/5wHckdW3Qv8pTafSuArnkg23vz5yfMTZuzMtGQXjXI7i6O6I2X2/uqhoY2Ks0TZ2Gqk0uETSY5X917pkf4w/z4u5ZKLJ9ofzPfi18Qo1l05LYvwz+FdD3DR1dCzK0kEPZHyx3Zl8xS15ileMVMWDjVTGkiwqWZF917qVL/JZzu9cjS5jvX+bR/N47WmaF6fObU298rcR0J1fuGlkaQy0ddsfonrfYtQlNMr6XC5IuQAAwHHv3XujhfGb+Vr/L++IWRfcvRnxd61w3YVRWSZLIdw7xoq/tfvDKZOeZaqqyGR7o7Ur95dnTzVVYgmdBlVgEgBVFCqB7r3R/ffuvde9+690xbp3RtvY+2Nx703jncTtfaO0MDl90bq3Nnq+mxeD27tvb+PqMtnM7msnW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ytydhbhpsTgE6b3vQVWWocjjMliOt8rjcpHV0gpa2WT+MRo9JNQvWyU/uvdKjEfzKP52e7qOLIbU/wCE9G46GjbVrfsL+ZV8atiV+pQmmNMFmNiJmVLB765IkT0kcn6e691HPaH82bvfD12z8/8AyD/hx1AqU6LQZn5N/O/pXtzr9ah6ufI/8ef0t8ft4Z6ugp8lI1Qys1CWml1qdRZh7r3Qt0Wyf+FDm+RVUW6u8v5THx5xk8Jioq/qLpX5Rd67nxSy08ihw/Z3YfWm2ayqoZHXQWoBDIUDNHpJjPuvdZKX+V/81+06VqP5i/zpPmP2Fh1rlrl2z8RdgdK/AbDSUyTwTnCZTc3WG3959tZDDSIkkc2jc9LUyxvbyqAyt7r3Vcnw0w/x8+EX/ChCs+KPxF7xzu/ulfkr/L1y28u4tj5v5Hbj+QuQoflT1j29l6yi3XuvNbs3bvDOYreA6lpKiJaGoqI5Ep6+eYRLFJGF917rbP8Afuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691/9ff49+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3QX909K9UfIvqze3SPeWwdudn9T9jYZ8DvTYu7KFchg87jTUQVsCzxao5qasx+RpIaujqoHiqqKsgiqKeSOeKORfde6JF0L/Ju/lZ/GZ/uenfgl8c8JlFN4dxbn2DQ9n7upQZDKUod49pvvTdNBE0hBZIKyNW0qCCEW3uvdWRUNBQ4ujp8fjKKkx1BSRiGloaGmhpKOmiW+mKnpqdI4YYxfhVUD37r3Uv37r3Xvfuvde9+691737r3XvfuvdAFlPld8XMH3Fh/jvmvkj0LiO/twtowPR+T7f6+oO3s1IaZq1YsV1vVbhi3jkJno0aZUio3ZokZwCqsR7r3VSf8AwpA7Q3Vtj+WhuDofrvIz43tD5194dGfCDr+akkb7mat7v3rTtuzG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nbndw5NVkaR0ppMltfpenop6ini0o7+CGN3uy+k2X3Xuoldu/wD4Ugb0+3l2j0x/J+6NpQFirqftbtn5ZdxZpmL/ALlZjo+tdm7Jw4VYj6IZqm5ccvY2HuvdKOp+NP8APM7RaIb8/mc/FT42UZmR66k+KnwTG+8rNTIAj0mO3F8m+3N8UeLepUa2nkxFY0bMQigaWX3XusGQ/lG/IDe0aVvaP86z+arkNxGl+2qKvqHffx66F25IHU+eSDaezPj9V0tNK0jEpJ53mjWwDmwPv3XukPP/AMJ3fh3vjGR4X5KfIr+Y78xcLKsH8YwfyW+dPc258HuCeNnkmqMri9l5DYVOXqpX1MIfCqlRoC83917o6/xa/lJ/y3vhVu3BdgfGL4h9T9WdhbaxGVweE7Do6LMbj3/QYzOUhoMxAm9t5Zfce6JJMnQM0E0r1bTPBI8ZbQ7q3uvdWK+/de697917r3v3Xuve/de697917r3v3Xuve/de697917r3v3Xuve/de697917r3v3Xuve/de697917r3v3Xuve/de697917r3v3Xuve/de646116L+sKH0/nSSQD/tx7917r//0N/j37r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+690AXyq75wXxa+M3yB+SW5khnwnRPTfY/bFbRTzeAZX+4m0sruOmwkTghzV5yrx8dHAiXeSadVUFiB7917rSerf5dPWe1f5FPTPcPbmyOvdyfzP/5q/wAt/iVvfanyY3FtrCzd87d7Z+Ynyj667B2vjetuzMlTLvXr/LUXSVPWVtdDj62kUZGbJPKGR3Hv3Xurtf5pNQnd/wDN8/kV/EeH7Gvxm2e2u/fm52DQ1lOlYuKT4+9cCq6izEsSF5qf7zd0eVpqaV1WIVgjIYlCB7r3Rj/ipTr8gf5vf8x/5OVdFQ1e3Pip1t0D/Lb6b3LisvUz01TkjiU+WPyopcniJAaeDNUm9+ztl4iSZNJtt/xkHTqPuvdA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16gS8GW2H/Lqz27MnJIwN1lo98fLGHFwpHpGlgshOo3HAv7r3Uqk+CP8zOqZ23L/ADwe9JQfsmjg2b8JfgjtWnikjUjIkNl+od518kdUWPgVqg/b8azMRc+6911P/Lz+YtJPPWZT+dr83oFyMinJA9XfBjHU7xiRTImHhk+MrUeBc6rA08dluBpI49+690HO+v5X/Re06HPdnfLL+ap/Mx3919gsRkMpuil7b/mATdF9TUWBxVJPkMpU5fFfHDbnx1w8dHR0cUks08knmWMEGTQFUe690UX/AIT2dbZHtrffy2/mLbG3j8i9rfDPtvd2c6F+DHx87W77787ew2R6f6vz2Nx+6/k1uVe9N/b8yj757V3vtl4qOCOSD+7XhzFBG1RBURyD3XutoX37r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvdf/0d/j37r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691r/f8KQsrU7n+CXVfxMochk8bV/P35xfET4ezVWCgmqM7Bhd6dn0u/c/Ni0hsPIcd1u0MgkIimhmaF7rKQfde6XXyhxeL7t/m2/yxPhdgKfHY7rP4b9U9u/zI+xNlyYuSLBVEm1McPiZ8TaPbc9G8KY/LbN3z2JuHKxwv+z9ritIR7+j3XugK+G+Xp/lF/PC/mpfNjJU/wBzsD4I9Qddfy4Onsk0CTU1Xm8VWZXuf5JOsjMYqTP7R7Fp2x+qNhI2Pyaq5XUye/de6Nh/IS2zUU38rz4+9t7kAr+1/lhVdifL7vTeE1FT0WV7B7c+RHYG4t/Z3duZFNFBFNP/AAaux2NpGCgJi8dSxC6xg+/de6An+VNHV9+fzHf52HzQ3FWVWYm298qNvfy8usvvWp56bZWy/iFtCgffW3tttpaqx9Bubfu9o8pkIVcQzV6+Ur5d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37r3Xvfuvde9+691737r3Xvfuvdf/9Lf49+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvda/X8wuir+5/wCdZ/JL6Fb7GbZnVcfy/wDmPvjH10lSDV5br/rrB7O6kr8fDE3gmyOB3vmZJl8gGmOR3Dekxye690sNibxwe5P5zf8AMV+UbzVK9ZfBb+Xz0P8AFbeecigqGxFdv7Obq7M+YPYeMxeRaKPHZLLbG2FktvLkoY5nNDLkoo30SPKi+691Tr8XNz9ofH7/AISfd+/IXH0lW/yG+c+Y7s3VnsxVPU4/N5HsP5v/ACapPitg+wZMxQSRVzZk7N3HisvRV11dGSA2KoAfde62j995rr7+W5/L33Rmtu4yar6y+DPxEyMu18HU1EjVmU2p8duopIdtYKWqLPLJX5eh2nT0vkJLNNLcm5v7917op/8AIm6M3Z01/LT6N3R2hNDX94fKmp3d81u9s7HAaSoz3ZXypz9V2w1Vk6QxxCkzOK2Zm8Ni6uJRpjnx7BeAPfuvdXAe/de646VLByq61VlV7DUFYqWUN9QrFASPzYf09+691Rd8vtxYztf+cz8Aer6zMVGN2H8BfjV8pv5jPfhyGInqtpvFvnCH4wdCa8xDG8dJufAZCt3pnI6cnymkxxkVGHI917pr/kEbY3Dv3o35RfzB944ufDZj+Zr8we3flBsfB5Okjptx7Y+PVJkR150JtfcTxvPHUVtPtjbNRkYXileBqPKQstmZ7+690pv5H+Sm7e2L88/m1U1tFksJ80f5jPyW371bmqOnajp6zoLpauwfxl6mM1qipoqurSi6brpp6qBzFNJOeboffuvdQf8AhP74d/fEPvb5bwiSan+eHz7+aPyrwmRq46mDJV2zc53DlesNj/d0tYonx9LT7X6tplo6cftpRmN1/wA4Sfde6vP9+691wlTyRSRh3jMkbp5EIDprUrrQkEB1vcXB59+691rLfEj/AISrfy7+g69c333ne2/m7kcfu7Obu21tnvbcbY/pzbuRzUoebIjp7Z8mM23uPO1iM4r58xJkKKtYhhRQlFt7r3Vi3y8/mdfGD+XZvzpn4o0XSHyD7d7n7J2NktydM/GL4Y/H+XsTddXsXa01dQ1lVhdvY6t2ntLC4TDjE1TyxiriWjpKWSeVI4F1n3Xui7N8jv51vzGrhRfGb4g9X/y4OnpyRP3b8/csvZvfuSoHRgZ9i/FzprcUmH2ruCmqJIvRu3PvRyQpNZdfiv7r3XHHfyPqfvzN4jdn81r5pd8/zMq/b1THXbe6o3LjsL8avihhsnCUkps6Pjl0fXY/F57cNJICiVOVy1dFJB+3NBJyx917ozGX7M/k/fyitoZaikz3wq+EOMajeqyu2dqUfXGxOwN2rRQlmlfZmzqM9m9jZYR48KNFHka2VolUamCj37r3Rb4P5p3zA+WsMMH8sH+XF2jvnZmUkEVB8tPnRXVPxF+N70VTTrPQbu2RszJUWb+QPc+1ZmcRs+MweLKusgDnR6vde6wN0n/wop7Spqii3383/wCW98WkyGmkfKfGb4u9rd25nBUlREq1GTwx+RW9MZiK7MUDFjAlZStSysAzqoOge690IHTv8jP4g4jd1P3P8xazfX8yv5KNTzw1fcXzdykXa+CxEdVMlRNiuuei6+N+levNuU08MbUdNT4eoqqLQPHVcm/uvdXGYXB4XbWJx+B25iMXgMFiaaOixWFwuPpMVicZRwi0VJj8dQxQUdHTRDhY40VFH0Hv3XunT37r3Xvfuvde9+691737r3Xvfuvde9+690S7+Yp8i5vid8Hvk333jIJa3d2y+q85QdX4eCgqsnPuburfTU3XnR2z6egokkqqqo3l3BuzCYpEjUsXrBx7917qsTP/ACu7I/lS9LfA3+WF8a/h52P/ADBfmHtb4cbPyeV2F1jvLbvV+xsFsbp/H7N6w3l2rvTsbeNDlU25hd19kV80eLiOOlWWUmKaankenWf3XukpgPnv/wAKGt35JaCk/kX9W9f0tZIfDnuwP5gfTlVisTDqur5Sl23HNnqwhBpIpqPXqOrQACPfuvdCtij/AMKP+3JJjlm/lUfDzbbwxPTinoPkL8le1Iq6FYneGVRnNjdZriaxiys4aWpjAsoPDn3Xulc/Sf8AP5x1KcvQfO/+XjuPOUEHno9m7h+F/aeG2fn62mT9nHZ3dGB76n3TisdkpFH3FRRUzTwhiYo+Avv3XujP/wArr5kb4+bP8v7pX5dd07a2H1vu7flD2hNu/G7Fy2Uq+vaKHrTtbsDrpty4Kv3JI+Wo8Bn8ZslcskVZLLLSRVXjeVyhY+691Up/LS/lw/DH+ZD033Z/Mj+Zvxc657o7A/mGfIfu3uXYD9rbMqU3V1j8Y6HcTdR/HzYeKmaviFBPJ1v1xTbhTNUEVDX1f8eVmkIiiK+690GX8kb4xbQ6d/mwfzd8b8Yty9rdRfB74r5fqv437A+Mc3ZW/t+9V5ztfL7ah3H2jv6pPYWf3LW0eZ2Lntr1UWNjhmeeOk3LIjTJEixS+691m6w/nkfzb/mpJl97fy+P5LNd2F8dq7cWbxfWPencnyAwnXG3ewtv4XNZXb53Zjm3XjdgYSupKjIYadZosRksvFRTI1O1RJIpJ917o33wP/nTdi/Ij+V98tv5ifffxhoev3+Ju6+7sLXbF6z7FotxY3tLC9IbO23ubcee2jn9z0+JosdEMplq3GLqqK6GaTGvJBJK0ggX3XuixbT/AOFU3UXZ3XVV2D09/LE/mldoY3E7SzW8NwZrbHQm2Mr13gcNt/HyZLL5nIdibf37uCgg2xjqSCSWfIyUsccMK6mQE6R7r3VgHYn87z499Yfyv+jP5qu6OsO2l6R7mznW+IqdmUMG2ansLZlPvbeGR2hm8rWUsmbp8Rm6bbE+DrZ4kpqlZMlEsIUQ+ZjF7r3Qd/Fr/hSP/K++W/dXWnRXXW+e19s7p7hzw2d1pn+z+otxbJ2Bu3fcwl/huw6DedRJWYmn3XnJYTBQQVJhjq6to6WORqqaGGT3Xui2/JHdf8175n/zPPmj0L/Li+f20fihsb4C9V/Eyg3jsPsTo/YfY20eyO5O/wDbnYXaHjfcGV2PujcWMxFLsmhx0GRnRqrwzFIoaUOssg917pH91/y5v+FBnzi6uyvxa+afzQ/l5UPxn7J3BsOTtys6U6r7Kq+1qrbWxN/7a39TU21UzmydnYKHI5DK7VpXcvWUwSxUPoLK3uvdPXQlU3yl/wCFUPzF7GZzmNmfy9/gt158fNu1ySBKbE9i9r5LA72rYIoHiilkkSn3fvKimcav3ae2sqEHv3XujzdQfZdl/wA/j5o70pHqTJ8ZP5cXxH+PFfGYA1IuW7v7k7u78qXSp1fszSYXA4wFLXkC3Nggv7r3VXGMrP8ATt/wsWzxonmytJ8Mv5fyY/JyBDUUu3KzdG1cbU+LyT2joXnHyaS5huWedlP1kt7r3Vgf/Cd1oN7fEb5N/J2kR/4f81f5lPzo+UOJqGrIa6OqxG4+2X67x70s0IC/aww9Z+FBYA+MsoCMo9+690CnwM+RNN8fP5Cnyd/mQyUqbf3t3TlP5jnz5dc3Tx4Zdxdj9od39z5HpmFqelhnWik3pjsdtOipkAkCvUxqPRYD3Xurjf5dXx2f4l/A/wCInxxq8ZR4nP8AUfx86u2tvinoYxHT1PZce1MdXdo5kqJai9TuHsStylfO3kfVNUudRvf37r3RKPgHPP35/Mi/m2/LSrrKGqwXW3ZnTn8tvrDHmKKTL7fx/wAX+v4+2+4Z6itjklRqHdna3yNdoYU0GNcYBKDJwnuvdJf+Q1T0m4elfnT3xTVUeQT5NfzWvnp2/SZGBvNSVGCpOz6fq3bcWNrVAhrsXS4XreJYZYvQxLf29RPuvdEX/lx9Xbs/mk7d+aPzJ+ZfzL+auO60i+c/yH6p+PvXXVfyu7Q+KvRW1/jv1bm8HhtlVku1enM7sBK3NPkKutxtVX5Cvq5JhRI0jGsaonl917oVux/jj/Jo2nMaLPfzmO8enosY8k2Z26v88bsjFJkponjEZy2O3v39nMkKmmF4o1pjBIfIVszlSPde6jfD75cfyPfhNlu51/l0bc+Snyi7O7gy+ByfeGe+MXUHzf8AnJvbs7M7QXccmJzG4O3M3h997OytRjJtz5KRxSZ6MeStd3jsQV917o7lB/M7+SvcFI2O+Lv8oz555jc8hgRct8wMX1l8IOrcQtVIFSuzef7B3tu7s+rpqWENLLDhtm5aqHpj8Ydm0e691ln6g/nh9tRvW7q+Z/wT+HapUPNQbV6A+J3YnykrxSSvdKHP9kd8dxdU4/J1dMij/KKHaONRy7L4vSsh917pIN8E/wCcZk6mkXN/z26zHYuCAUtTB1//ACzPipt3K5OIOxeqrMtvHcnZUNPlJY5Cplo6WlgXTGyQIQ5k917p8m/k957cVdU53sX+bH/OC3buLIDyV8u2vlxgeltrRVTRqsr4LY3SPU2wNu4Wj8il44PHNovYswsPfuvdKAfyU/iluTGnDd49vfPv5QYaVoXyGB+QX8wj5cbr2vmWppUlp1zez9u9rbQ2jlqVDDGr089C9NOqASxyXfV7r3Si7S6n/k8fyqupm+QnYHx4+H/xV662zkNt7SfszA/GzaP95HzGZqEoMBj2yGxOvc52HuPLVs0GtpSKqfTE88zhUeQe691Un3n/AMLFf5UnVqNQdRYP5E/IutiaWnpJ9kdaUewNprHTo6wvPku2M7svcNNTTsiCPw4adlQksq2Cn3Xurvv5ZX8x7o7+aX8V9vfKLoymzuBx8udymxewNg7pWlO5etezNvUWKyGf2flarHyS43Kwrjc7Q5CgrqdglZja+nleOnnaWmh917qpDrjrWh/mi/z6u4/khvvAy7l+Kn8nXDUvxo6HxuZMdfs7cnzozc8G7e39+UuIq46uhkz3UNJWU+PqVKpJBksbtzIxMstOAPde62dPfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691/9Pf49+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvda9Gwq3B9vf8KD/AJq/IbP5mjous/5aP8vLp/465jJV8lRSYbBdh/IHP7h+Se6Nyx1zutDVTbe6txL0mUZS0dLHUQrIqyqD7917qnPcXd/aFD/JY3VW9Y0Gc2r8l/8AhST/ADNO66fq3bG5pP4lneuOsfl72XN140uScmSOt21Q/G7rrG46GopXhSij3PSVMOgRMR7r3Vw/yv6W23s3tb+Q1/KJ2DSZyfojbu+6vurf2Tp6immyVV1r/LF6h2zubq/Db/olh+3rMH2d3nuHa0uUnZUFRW0RVbmR7e690tP+FBO9N9by+K/Vv8vTpSRh3v8AzP8AvfZfxY21VQzaZdndTU9XD2B8hezq+lMMn8Q2ttTrjbr0GXjQrMlFmmmj1NFpPuvdXl7W21hdl7Z25s7bdDHjNu7TwWI21gMbDfw4/C4LH0+LxVDFfnx0lDSxxr/gvv3Xun33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/H3+XJ0503kMv/Ln+MS/Iv5l/JD5NZPddPsbrmn3D1pmO3NndbdSdd7Qp1zPY3aG5etcFWZLGVdXOm3hXU0lLWBREfN7r3V13w07E7L7f+IXxY7Z7nxeMwfb/aHx06U7E7SwuFpJKDEYnsLevW22tybxxuNoJquvkoKOi3BkqiOOA1E/hVQnlk062917rXQ/mo7t/mJ/Mr+b71N/KW+LHzMzvwX6Xqvhq3yn7I7T6rweVyHZ+blO/wDd+yq+jqM5t3PbU3Hj6OF8XjqWgoafM4Ok1VVRUVU9Y7UVLH7r3Q2/yDese1viH8gf5sX8uzsv5H9ifKaD4r9w/Fzfu3u2eyKnKR5jLH5RfHqn7IzkMO383unfGSwKUtdiEimtlqmnralJKhUilknB917p9/4Ur9N7d+Rfx6/l3/HvemRy2P2L3z/N/wDhL0vvr+B1yUGWqNodnQ9qbPzy4yd4Z1GSpqHLNPTllZIpYhKVbx29+690aT5Ofyxv5UfSHwq72zFV/Lr+INbsfo/oLtLsSOhm6X2RQ7hmi656wzWWeqn7Kp8XD2JFnqvH4JUmzJyv8VaT99qgzjye/de6p4/4TenF/Aj/AITy96fNnM0M0c+am+VPymkps7W1EmNzdN01tyr6/wBsY6ixsf2bUkOdyXUrUyJGxqKyWoDLKVeFI/de6uN/kJdF5npf+V78d9yb4qqvMdxfKOjzvzO7z3Vk6P7HO7v7P+UGTk7QqcxuGApG38boto5fEYuZmVWb+HKSq/pHuvdXHe/de697917r3v3Xuve/de697917r3v3Xuve/de697917r3v3Xuve/de697917r3v3Xuve/de697917r3v3Xuve/de697917r3v3Xuve/de697917r//1N/j37r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3XvfuvdNOezmJ2xg81uXPV0WMwW3sTkc5mslUa/Bj8TiaOavyNdN41d/FSUdO8jaQTZTYH37r3WkPtztLsLrv/hOZ8s/lbjcJl8n8ov53vyn7hg29hcpUStmKLI/Mrt7I/HrZ21afLsBKuLwPR22qvIYEU8aQQy1cSQpFG2pfde6On2n1TgN3fzhP5Jf8sHrahiy3Wn8pz4p5D5S9p56UxTz09JtbY+2+jOh8e0ksjVcWbot47QwuQq0di9RT52Kc6zCffuvdCHtj54/Duj/AJxH8wr5d/Jn5LdO9JddfBnpXrj+XN01T797SwOKqt57zze4K7vz5T5/bvXVdVNuTL7vwW8cdgtrr/BqSqqaqlws6lDodV917pVfCPtrA/zdv5rm7f5iHWGSbdXwR/l+9Q534y/EDd+S2vuPb47P+SnfOL2zuL5I9t7Wod3YvA7kwVNs7r6Kj2fVRVdDF99DV01RTtpM6n3Xutk737r3XvfuvdB13B2rsrorqfs3uzsnKfwTr3qHYG8Ozd85jQJWxm0ti7fyG5tw1scOtPPNT4nGSskYIMjgKOSPfuvdaeHS/VO+exdi/wAnnA9k0NZg+6/5qv8AN97V/ndd2dY0lflsltvbXWPWuw813Jtfa82SnooJ49l7V2a3WMKUOUKmTN1MdLpkKqo917q4z+dnGvZ0n8sf4kUtFR5+p+S/80D42VO8NqVDmaTK9HfHkbl+QPcde2JHkiy2MxmN2LQR1S1EUtJClWskg1LHf3Xupv8AMfRe7P5jv8l74lVOETcG0sb353j8+uxnp5YTUbTf4b9O1uN6SzOSgLpUDGZPuvunHLCRdGqqJSQTGLe691d37917r3v3Xuve/de697917qgj+br8T/5KXbvbPUffn80Xfm2qXenU+1RtfYvWNd29ufFZff2Aqd0DcVNiaPo/rern7R7PqHzdVIq02Fop5qmKdopUlQRhPde6XPWPyL+RNTs7C9O/yrf5U69Q9F4LHVGN2j2/8x6qm+DHRGNFDHTx43KbV+PG2tmb6+U288VnMfChiqchtParVDESSVFrNJ7r3Sp3P0f/ADON17dr93fLr+aF0b8SeqcVjJ5uwMd8K/jttvr+XGYN1EdVUyfJb5gb47wO1WgMix/xKn2vjZFP7kZgdlCe691Wztl/5BGa3nPkajBfLT+bV29tHI1OMi3vv7qj+YD/ADNMVuLPYhHlNNtPN5nY+/fipVPTxu2iowi0uOihPMqRKNPuvdHE3J8vvl31p1oJOjPht8K/5VPxlxU1I20+2f5mnemwelcLLjaiCE1KY34qfG6rq6fa2QIYMlLn9+7arVjgYT0sLlF9+690zfy0/mx8te8vmv2R1xuTv/ZPz0+JOT6KbeNJ8pfj78Td2dEfHTpv5GYHfiYfJdBbB7Oz26d64jvXbmc2HW/xNM1R7gzskVZTLAxp7yr7917oWf56FJUdl9IfD34mUmNl3APmR/Mh+G/T+6NuQQxVYrer9k9gv8h+0svk6F2DVG3ds7S6Wlra4jhVRAf1AH3Xurt/fuvde9+691737r3Xvfuvde9+691737r3XvfuvdU0/wAwnE0/dv8AMF/k7/GmtxUeV27tbvXvb5970nSoRJ9vx/ETpis2X1hXyxFGPgre4fkhhrElQwpJALkXX3XuiFfDnZXU/wAxf5NO9+tuxvk3tb4idjfzTOzflF8ne4Mxjsv1/huyMxsL5EfLPsOqztDgNt7/AMhTmpw2+ulNvU+y4sq9PVRRY3UabX4YlX3XujKYH+Rr1Z2Ti1yXaH80D+a38laEkw441/znyOB2LhpadfDKu3Nt9Q7a2jg6CbTpWQO05AVV9IFvfuvdKLGfyHtg4MQUe3/5nH86rb23KSIQ0OzsJ/Mc7Gx22aCFUCRxUdLBt8V0EcTDUqiosG/BHHv3Xum/cX8mLr3ZGGiy24P5wH86PY9DTTx0z7m3B/M03NQ0cjTLOKagqG3Ztmp25+gt4lECyDTdTcE+/de6rj+ZXxG/lh9b/wCiLGd4/wDCgD5R0dBtbu/pntncvT3yf+f8vyq2X2pt3qbfGI3xXbczPTVbmoMliavPVmJiNJno43psXWaZRSVFlh9+691Yn8zP+FAf8tvrL4efIbtDoX5tfHnszufB9Ob4q+muv9qb+xeW3duPtGswdZjev6CPbELfxxadN2VdJLWFoAaeijllYBUJ9+690XXeOyNk/wAu7/hKPvfr/L5TG5Gg/wCG193bYyOWw1XJkMRlu2fmvt3JYyWbDZCJJ2yeLyfcnyA0Uk4VVqIHRrRK3o917pY/zdcDunZH8or4p/y19sVtdF3Z8z9w/C/+XlteZqWgyOTxkOjZ1R21u3L0tCtPjo8Pgeveu8ouRq4kWlpTVow8alWX3XujcfzYccp6v/l9fFLbGPpJ8B39/Mh+EfVmZwcwDBupuid0Vnym3jCtLEI6eamj238blppA6GALOLqSVU+690C38+Wni+Q+3fgl/LCoDLW5D+Yh8zuusN2ThKSuOPyL/FT4z1FN8gfkfuPHTXMb1u26DbWEMUcqtG71Fx61QH3Xuhx7sGL7S/nWfAjquIVNLB8SPhp8vvlxVUaAw4WXPdvbh6n+J/WxghgRVGRxO1srvtEVj4lp6t/Tq0H37r3VE+H+bvYvVPxw/ma/zMOh67ET/Lf+bZ/Mh2z8Kv5bUX2uI3RT7y2l0dlKf4z9K72oaLNUlZi6ygxFBjt35J0npKzEDJ09HDOJBWaT7r3R6F6u/wCFZGwIKfLUnyW/lXd6tgamihG19wbK7G2pV75olEbVNblqrA9X7CosTWSNdZIqSvoY9Opo2B0g+69027d6b/mjdN9z9ufzcP5r/ZXwzi298SP5fPydx3U/V/xTHYtPUbS3HuiXb2/8smWquwtvwRVtQMPsVsbDLFmchLU1lRTRRXAkkl917oeP+EuvTOX6i/k0fG/J7hlml3D3dn+1u9soZ5TUTGDe+/8ANY/bVTLUuBLUTZTZu3cbWSM5ZxJUspY29+691K/k/wC99r9TfEn+aV8vNwVlW2y95fzNf5oPyqzEmQJp5KHZ2xt6VO2ng+5ZZYfFR7Z6hX1oHjjIKC+gj37r3VBf8uzJy9Yf8Jlv5yHzy7OnpYd9/PPOfK+ryuWlWooaGpPZ1HH8d9tUNEgJjkmk7e7CzxgZAEeWsjhb/Nn37r3V638w3qqTrj+SB8UPhtPTVlbWbvzn8p34bSYzIKaTM5ZP9Onxr2pm8LJQIpllyWXwm1qumqKdBqCSykfo9+690bf5N498p/OH/lSyUzY9ZNtfHT+Z1nMh93PHDWNjMhSfDbb8cWKhnsKyofJV0TzCG88UERJtEz3917pb/wA5vtlumv5Wnzf3HSY3I5ncO7+ity9F7GxGIpvvMlkuyvkrNRfHjrOkpaW6+bXv7s/HGS50rCHZrKpPv3XuiLfzg+ust8d/5Ci/CzYeegr+xN1defDL+Xx1TJHO+JXeu6d0b46f6Yehpks86QZfZ2OylTNAAzGkjlUi1/fuvdX97M2phth7P2psfbtJFQbf2ZtrBbUwVDTosUFFhtu4ulxGMpIYkASOKmoqNEVQAAFAHv3XutWH549g/wAxn5qfzyto/wAs34s/MDfPw0+OvTfxWxHyP7v371FhcVVb2q5stl6rHEVdfkkopslXZbJZ/b+Kx+NatXH0lPLVZGSCrkhMI917r2yPk18oc7/wn4/m47p+RXeNd8jOwuncx/MW+MWx+1KjbOF603pWdebBp8h0ttrL7ofZH2+Lrd3UtdUV2YWtplilME1PTSSTSwPVze690n/+EhX8vTbnx3+BtX809z4enm7o+Z+RrKrE5KspKSTIbQ6G6+3Dm9ubP27i6iWkavxn9+dy0WQ3BkjBUinydG2G8sQkoEb37r3Rxf8AhNEppPgz39gqXEx4zbu2P5ifzPwOz54IJKSmzG2qbfuPqqbI0lG/po6aDIVlTQrEhKp9na+q/v3XuoHx76p278ov5mv/AApM6u3tjJW6w7T6r+B/xV3KtDMaLIZrH5z4gdoUu+3jqU0T0lZBi+0I4KeYcgKrKfSPfuvdHd/kh9wZ/vP+U18D997rZn3PRdC4DrLcU001RUVtVnOjshlek8rW5Werd6iXN11d17JNXlif8seW3FvfuvdEv+DtM/cP/CgP+cn3Zk6SXR8cOmPhh8RNg1tVNA00WD3rs2fuXsGip6XStXS0U29Nv09QpP7UwcOrMbrH7r3Q2/DytoMl/O5/nPf3fekhpsB0x/K+2/vyKKld56/fcvXHyB3Hh6ievYQpBU47YebokkgVZ/JDUU7l006D7r3UP+aHHR9t/O7+SD8V6iilqo8r8z+zvmlkayPG1NdT4Wh+D/x83nmsPV5Kop3RcZBkd89uYijp5JSEesmj/VoKH3Xug2/4U/fIHM9Bfyb/AJKJt7EVOSy3eFbsj49JVwyyxw4LFdlZ6P8AvTk61IV8tRDV7SwtfjoowyKaqvhLakDRv7r3RQ/5l/U2e+J3/Ccn4xfy9tpY6mxHb/yEpPg78EsTjhHV5iKfuftfcu1NzdoeFIV+4qJc5kttbjkUInDVFo0BCKPde62j+tdi4nq7rnYHWeAkqZcF11srauxcLLWSeWskxO0cFQbfxslVKSTJUvR49C7fliT7917pa+/de697917r3v3Xuve/de697917r3v3Xuve/de697917r3v3Xugz7B7p6c6lq9r0HanbPWfWddvfJS4fZdF2Dvva2zKvd+XgSOSfFbXptx5XGzZ/JQxyozwUgmlVWBK2I9+690JEM0NRDFUU8sc8E8aTQTwussM0Mqh45YpELJJHIjAqwJBBuPfuvdZPfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+6910DcA2Iv+Da4/wBexI9+691//9Xf49+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3VQv88vvnd/S/8uvtTZvVUcdT3t8vNwbI+DPQdFJU1VB9x2h8rc2nV8VXBkqJXqcbkdubMyeZy9HMqtatx8SkWa4917oDfmx/I6h+T3w1+A3w86e+XfYvxYwPwGznVe4tlbo2psjG7ul3huPqbZVJtLau98ti13TsyqxXYeErI6rKY/KQZCSKnrMnWNLTTvJFJB7r3Qs/y3v5R03wR+Qnyl+VHZvyy7V+ZvfvyiwPVm1s92f3Ft7FYbdW39vdb46qo58RBWYfMZCmydDnnjxixx+Gmjx9HhaOniVtMkj+690PXVn8o3+Wp072Z2L3Nsz4ZdHVPa3aXYu4+1t1dg772lB2nuyLe27Ks5HcOQ2nm+zpd3V2wcfkclJJUHH4N8dj0mmkZIV1n37r3ViVNTU1HBFS0dPBS0tOixQU1NFHBBDGosscUMSrHGij6AAAe/de6Kz8h/nV8MPiU0EHyZ+U/QnRuRq6cVdBgeyu0dobY3Tk6VtRFTidp5DKxbly0HpPqpqSVffuvdEB/wCH6vg92Ixwfw0wvyT/AJg/YkmQTFw7E+Inxy7P3LTUc8siQfxHc3anY+D606S2nt2hllRqysrNyK1NAwkEUmpFf3Xuiv8AzE2h/Oj/AJo/xl7d+J7/AAv+MnwF6r7vwuL2vuvf/e3y4yfdXbFLsuTN4zNZP+72xvjx1zUbWoNz1NNjVp5aPIZ+ahCSyRPLKrEj3Xuha+F+26fuf+cV80+34guR2F/L1+LXxz/lqdSZfEF49j1++tx0y/IT5KT4nDNUVlFiN4bSr5NqYCtaAxyw0kSUrl1XUfde6fNq0MHya/4UC9s7kzGUo9x7Q/lgfCLrjYux9smEVcHX/wAivnNmtw7v3rvaKqcwyYrd+X+P3XmOxMsMazRy4fIRuzRs2lvde6UfxNCfJ/8Am/fzCPll6ajZPw66962/lh9PV2PyklZispu5WxPyc+WGQr6BtVLQbmwu9N37S28xiYv4MOyyaSdI917pZfzIvnP8s+iO+Ph78PfhB0f032l8ivmBR98bhwO5fkRv3P7I6i2RtjoLb208zuaTIU21KSTc+6cvVRbziqft6GeOaGloZAIpTOrwe6913/Kr/mG92fMHcPzB+Ovyq6i2D1V8r/gj2ptrrDumbprcuV3R0jvhd9Y7cGa2hurrip3IW3XiKeeh25UpU4/IyVM8IEMrSrJPJSUnuvdVP9mfzy/5otJ8NOy/5n/XnwT+LG2vgr1zvzcW24dudvfIPdbfJ7dOD2n3zL8fMvkWwO0tvpsfaObXfFJPBNj6qepnpzE70y5GLwSVXuvdHR7xi3f81v5tOx/ilur5JfLvo743VP8ALA2d8xNodWfHXtHLfHqq7B3lkvkXnet+yYO2ewuv46XsqWDEbWz+1aZcPR5migVqiWSN9X3Hk917pK/F3tD4i9e1XYFd/Jf/AJV26vk3uDHZ7N7Xzvy/rKrafTnVPY2fxu4129vjG1fzk+S2c3R8gO7KfbWbiqI6uoweI3jQtNSziCSRr6vde6n/ACT+WPyu68rsRgfnh89fh/8Ay2cZu6poodqdA/CPC7r+Ynzt7ZxuVAxk2O2PX9ndbNW0NTVZEtBBU7a6b3DNTySIVr4ZQrD3Xuij474j5jsfcsfa3Vf8o/ePYOXoMJNlaP5rfz+/mZvDN4qLL0f3Y/vdnfh1Ubq7/wBz4uOKOUVdFTVG3eu2omlAWLGSQ6I/de6e873Z8VOyd8LsL59/zp95fIxoDT47/ZQf5W2w+5uo/i1iYs3izj6nq3cu5vhvS9y/IDtGKll/Yo8fluxqF2iiCzYsMzqPde6VGxet/gJ0BujbsnxV/ka7tzPZPYG6J9hdX75+em4uoehare+fTzVdRQdf1fzs7g358rqyU4+jepmjwmwqmrNNovEwcKPde6sy+LPzL+U0vze3F8Avl70H0B1jvFvijT/LnqLcXxk7Z3r2ZsOh6txnamN6VyvWe+B2D1X1LlaPf2Dz+RpqmnqcVQPhqnHsyr4pItLe690GPySnHZf89/8Aln9bpVSVEXxw+Inzi+U2QxENnjpazsebrD42bb3DkYtZCiGmz2Yo6SUqCjVUyKT5GA917q7r37r3Xvfuvde9+691737r3Xvfuvde9+691737r3Wtv8rO08jt757/AM3L5YbOzYpc7/LV/kjUnXm2aXKSGpwVJ3D3rV96fKOevWjp9amqbB9J7JhqI2aOq8U0dlMdRGx917oEf5VH8tr4yfIbcfyczXyr6U6k+U+2fjn178Bv5d/TLd2bB2p2B/o2g+K/wR6PyPe+D2dS5zF19Ltmvqu+u2s2uWq8eyTPl6SohMimnZR7r3R0/wDhOl1r1Vtj+X9unuHpbadDsLrb5afMj5jfIvY+xsTQVmLwuzuv6zvPdHUnVu38DQVrF6fAUvVvUmFkotAWN6aZGUHVqPuvdUjfAbrD+b5/Oz3N82e8N6/zXO9/h98ZNufKTtbo7YvW/RWFoqbL1kG2q6GurtvbSzuGy2w6vZ+1tl7W3Bi8fBk/JksllavzvUMJopZZ/de6sTn/AOEyH8tPbGQxXavzg+Tny++VlNtuZKquq/mD8q46TYE08SJo+9rcPi9jbhpKdYoNJi/j+l4hpfUtx7917pTd3fC//hNd/LZ6YwPzi7B+Lvx0m6irt87e2ftTfeOxO7fk9tvMbvy9VlpcbBt3bNduDsnbuVehO3q6aZ4KWQU6UMt+Ywvv3XuidxfzDf8AhHh3JmYE3P1T8RdsZeujixNNNuT+X/vbY1JJSh3qYqqXMba6MhwOPjM07qaqoqIJeLM3jC+/de6sx/nbQ7UyPw1+CPQHVlLtqHrL5H/zGP5cPQW1MNtCKki2RP1o/Z2K7BwOOwNLhI2wi7OocB1pTTUyRoaJKKnQxrZU9+691m+VVZT9+/z8/wCWN0Ri5JK+l+F/xq+Wfzi7TxUkUcmHVe2aHDfGbpqqmmKSA7gwu6ZcnWQQao5I45EnsVI9+690OPzTqq7MfzVv5LWyIAPsMZmf5g/d+U8hVonj2D8W6PqSijWC+o1S5D5FRSxy2KxrE4PqdD7917oGN8SN2R/wpO6J2nk0lyWE+M/8o7tfunbelDJR7Y7C7y+TeC6fyU7zK5jpspnthbYljEbASPTw6gCvI917pHfNDuCs6b+Yf813vnby0cO5fjT/ACJNk5/AZKnaUZSHdWR7H+b++Nv0TVaBXx0b5TZVE4Ebqzllka/jTT7r3RUOnv5MfcXevxO/kLdz9OfLLbfxz3r8EPjRtXsrAbQ3X8d6PuzYuV7N702Xs3sLc24q3AJ2Z1gxydPnCKaeSSV5pCPu4ZKepDGT3XurL5f5dPzC3bt7MVfyo/nTfMzLwxRZjI5D/ZXOvPjF8MdpYbEMJKueClnw3VfaXZVJRYmkiGipm3XNWokZYzks9/de616u6Pkf3Pi/+El3cncnb/bfdXbO8Pmd2duDanStR8g93Sb77TwfTu+/kpT7H2RszObuXG42bcdXP0p1xkM2Klk0VNRlHZBHCyU8XuvdbfHxg69xPxA+DXQfWOZSmw+L+Nnxc622puN5PtqSGmHVfVuIodyV9bJCWpkllqMLUT1EoLBpGdyWuSfde61yescruHpv/hIF2Bu3dM1ZDuXsz4Y/J/fdfV0gMNTJVfMHtrtPc+PmV3lMv2slL3LANZcyGm55bj37r3RWsjs2jwf/AAmN/k//AB6rqI1+3flH8t/hV1/unGyUpaDJYPuP5T7o7xyNFV0EU1q+lq6iiRdBP711YhWPp917q/j+aZjcR2d8l/5L/wAfqxj/ABHcn8yem+REELVLQ01TjPh/8YPkL27OlRGpH3JptzPh6mFWuoqIIzbVpI917pX/ACcyGRxf837+VKlFVxw0e4+gP5mu381SmKCaatpqXF/ELceP0eaGSWkgpa/D6pJoWjYs0cbFle3v3XukT/N3iyHZu+P5VvxRwGTxi5Hvf+Zn0n2FvTbOTjjni3T0f8Pdrb8+VXZ1I0Da2aBMr1pgInOgoWqURiusH37r3QO/za8vS9v/AMwb+Rr8Laelly0+c+aO6fm5uelgqBBBh8H8KerNw7q23kM1IqGRKPI7k3a/2sbHw1dRQNCwLmP37r3WwB7917qhX4aY5dz/AM/L+dHvDIymSu6r6J/ltdW7cSOCCOOn2/2H1j2F2LmYamXSKiaoOdwKSI3I8blWPoQD3XuqzNrYWei/4TqfzpcYj09VFS/IX+ah9rlo0WnfOUeI7z3NHJlqmkOg0M85x8iLCVQqkaenkX917rZQ/lz9RY/oT4C/DDp3HUsNGnX3xh6R2/Xx088lTFNnoOvMBNuWvWolVHmbJ7hnqqlm0oC0psqiyj3XuqwP+E1WO/hH8v8A7NxXkkmXG/O75n0CTSoY5Jlou262l8rozMVdzCSRc2Nx7917pc/y4deC/myfz79kZBfJmE7f+CnZceQendJqza3ZPxUWDb8C1LuwqKTEVez6+kRRbxyRSH6OAPde6VP/AAnmjnpP5S/x5w1ZF4a7bfY3zB21kELhj/EMH80/kLj6xytlki8lRCzBHAcAi9/qfde6Cz+XN/FcL/Oy/wCFA+18jS00dLW5r+Wvv7E1x9FbkKPcnxj3Vj3VU87h6HHz4MwhtKkTayeGUe/de6FD+XTFQ5j+Zj/Pa31S0UcEuS+SfxA2FPV1KiHN1P8Aox+FXWOMaCpgBNsJBW5eeXHSf7uSokb37r3TVvucZT/hRb8ecTlaj/Idq/yjfkBunalNpNl3PuH5VdR7czkgYX5m21RD62H7X15t7917or3/AArQelf+URuDGGKOfNZv5JfHbFbVgn1mkm3BJu6pq0irEQgyUsmKpKsMtje/0vYj3Xuhx/mEUOQ+RP8AMw/kt/DTIxUWWo+r+xOzf5kfelNgPKlJtWX4ubB/uh0NuOGCr11y4HOd6djS0EHkkBCRnXrcAe/de6vy9+691737r3Xvfuvde9+691737r3Xvfuvde9+690STN/zIvgptj5R7j+F26PlD1Ttf5L7Q2TTdg7n613PnW24+E29WxYKrooK/dmbpqHY0W6qzFblosjFgRkznXxU4rxSfZhpx7r3RxsJncJubFUWd25mcVuDCZKLz47M4TIUmVxVfBqZPNRZCgmnpKqLWhGpHYXBHv3Xuu85nMNtnC5jcm48tjcDt7b2LyGcz2dzFbTY3EYXDYmkmr8plsrkaySGkoMbjqGneaeeV1jiiRmYhQT7917rWQ6O/l89O/z1avsX+Yz/ADHusM9vPpzt6HI9e/y5uhsjuTfXXDdR/DvBZ6Ws2t3nmotmZnamZi7m+Smaik3HO89RXxUe33x8EFRPSSpDT+690Vvpvqrsf+Ux/O3+Iv8ALg/l7fIPuTuL4x/IXrDeXbXyT+KPfO4ansbY3xc60wwyUeO7H6+3lSQ09ZsfK5uba9RBQ0k8EX3FV9lTVs1YMnRPS+691uT+/de697917r3v3Xuve/de697917r3v3Xuve/de697917r3v3Xuv/W3+Pfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9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s8VSVFb/AArcGzf5X/ZFVQSyrLQU+7cx0h3R17l8jSIYo3pXym2urMJFJGGkRnojICrOw9+690h5ZK7df/ClajigoY5cF09/JfrpMjlI5ZddLujtr5l0a43G1KpD4tUm39h1E0aO/KsXUek2917oq/8Awp7nhyGxP5UWyZ5VqIN3/wA3D4wxVuBqK40eOzmOpMbvaiqYskFZmalhmzUSmTxSLD5tXDaQ3uvdGX+J0UXf/wDPl/mZ/Iinx19v/Ef41fGP+X/tXckzNKmbz+7KzMfJrtugxAOhqKLameyeLoq1JE/dqNEkTshb37r3V9nv3Xuve/de697917r3v3Xuve/de697917ohf8AMQ/mK/Hv+Wt0RVdz95ZSsyOZzdZLtfpzp/asZyXZvefZU8GrDbA6/wADBHUVVTV1lVLCtXXPH9njYpVedtTxRy+691R78N/5E/xi+QnTu9vn7/Ol6Ixe8vmd8oN671+UHclDv/sXszrvafxp2FkvNU7H6fON292LtjFYvA9b9bYyklyX8dWWtxcjyY+qlaPHI3v3Xug8/kXfHvcm4Pmp3p8vf5fON3F8Qf5LNTkd0dadedBZ/cvY2/sZ82OwNpx57bGS+T+x8B2nm83W9Q7WXcgp/tq+glhlrqbERYx6cOuQSk917qxz+YZuLcn8wX5ObZ/k89PbnzGF6oh23iO5v5q3ZOzquppcpsr455RhU9YfFHG7ixzxNt/sX5b5OjkGRhFXR5Gj2HS1VYkVbSVctO/uvdHs+cfzH6A/lbfDnP8Ad29cRQ4rZPWuEwPXXTPTmzKakw+R7A3xNjmwvVXR3WOCoKOaOnq8oMasMUdLSSw4nEUlRWPEKWjlK+691X5/Jd/l7d1dU5vu/wDmW/PSrjzP8xj58xYzP9jYNKSWlxfxv6f1Y+v2T8ddtQ1klTk6WbC4nE4aLNQzTypSHCY7HI0zY2XIZD3Xur9Pfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3X//19/j37r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xv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INfX/FX+WJhty46p/u9ujdG36wVvdny3xWGya0sctfXZ6VaTbuReldhDULFMIcptyF4vde6Hn5+773t/My+TU/8AJ9+OefzWD6L2bHtPen82fv3a1XLRf3T6hzTPl9sfCrZWcpRHMna/yKo6EnOzQTxLhtr+VZFr1kyONT3Xuj2fOX5L7N/lh/CfE13TfVWKz+6aGbqr4p/Cv42baWlwuP393RveSh646D6c29SmuxcVJt+g+3SorI4Z45ocDiqpoSZURW917qV8Afijj/gJ8Yc7X94djYLd3fPYGU3b8lPnH8ldxV9Hh8Zvvufc1PJuLsbdlbmslBg8bt7q7rnE0y4bAQmnxtBjNtYiB2p4JGqWb3XuqpfihsDeX86P5z7f/me95bZzGF/l3/FDLV2L/lddNbux1bjG7q7Fx+WaPO/Ove21czS09VDRS1mOi/uVDVwxzRCmo6hIqWbHzz5f3Xutm/37r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3X//0N/j37r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3VRP8APZ7pyPTn8rT5U4zamPqdwdpfIfZ1P8Q+mdm4uZY9xb07P+VGRpulMNhNrRmanapz9Dit3V2VjjVw/ixsjC5Wx917olXyr6e23TRfyZf5Em0Kylyu3Ypeoe4Pkqpo8ZkMXkvin/Lx27trcjYje+DfTUrF8iu/dv4Cip6vxNFLPRZAy+r6+690s/gLt6L56/zTPml/NF3HTfddX/GOuz/8tL4PwOxqMbX47q/M1GS+TXeuMk/fxuTG9Oxs5UYbBZjHuglwgrKOcO0KsPde6F7vRqr5L/zxPiL0Fkpa2HrD4D/FXsD58ZzHpJRz4Xe3e/du58z8YOk8fmsfURtVxVPVuz6HeGdoqmBkCVeRiDa/onuvdOvf9U/yD/nZ/B/oB5c3/cv4S/F/vD5+71oFpI6vZuf7Q7azCfEz490Wakkhkjpty7Swdd2FmcaAyTKR5V4UH37r3V0vv3XuqKI5Zsl/wpjqopqmeaj2p/I1onx1E0h+0oclvL551wzVZFC3Aq66g2jQRtIv1SEKb8W917qrf4bbso+uv+Erfzt7GpcnT7bn3XtT+Z7U0e6aWlnpjm87vLs7t/rnb1fTRM9RNTVeUrZaPG0zcGBkjJIKF/fuvdGZ772g+2vkB/wlb+JWPwNNhaja82899SYOdmjl25jPih8ItuxVmOM1M08KfZJnzEF8pWaohjQFwSffuvdHP/mIdlbX2b/M8/ktYrsve22Nj9WUGe/mD9x5jJb2z2P2xtWPenWnxaotm7Qr6/NZmelw8FXiMJ3HnZoEnljOnySq37JB917pj/kGbnx+4Og/m5jttSU+d682p/NY+euL6q7Pxci1u2e6+t9y9lUHZm3O1Nn56mp48Puna+X/AL/TUNPk8bLV42rbGu1NUSxgEe691rr9y9zbF238ZP5Z3VHcva20+rsF23/woi+YHyW70yvYO4cftfZGC6z+LPzA7hzfZ2Jk3NLKn32Fnqt04t6WokSJp81UxQKAFjLe691c38s/57XfuE+Pu5/mf8FfgpvHuD4O9I5zZe4u3flB8iJMx0PjO4+rcluzamDz5+IHVOeixvam+qaXHbrEy72zmPxmAxstBUomPyxRlT3Xuh+/nYb+2rvf4j/CHcewZE3pvDtD+Yn/AC6N3fGrbdLWwQJ2TuWTuXa+/aCkkpZVnFdhZutqXKVtSTHJDSxxrUS2SMn37r3Sb/l/5Sgof5sH/CiD5CZaphHUmI3r8FdhL2ZUyIcJR5joH4j5Cr7o2lHWykSUrdb1W4aR8lFZYo5KpWBY3I917oyX8jnbu5R/Lq6y7p3ziEwu/vmT2F3z85N3UkdXHWRuflv3TvjunZM/kiRESZurt04FZkGrROri/wCB7r3QXfyJzTb66j+dfyjxVZDl9o/MP+aT81+6+s9w0jwVGNz/AFVt/euK6L2TkcRXQFkr8XPB0/UOswJVpXk0+m3v3Xurxffuvde9+691737r3Xvfuvde9+690Xzvb5afFr4vUdFX/JL5H9GdCU2UhknxDdw9rbH65mzMcTOjnCUu7M5iqrMuJI2XTSpKxZSALj37r3VCH8wP+Zl8QP5ifxF7++J/x066/mR/KfYfceAi6+zXfvwK+Fm+O0dh4LI0W8MJWVuFp+yezoevOsK6krWw81NkKr+Ifw1ccKvTXRTLG3v3Xuic/wAvvfuP/mOdob+6K6//AJ8v81XZ/wAiOs8LlK7sLoXs7q348dQ9g4fH7f3BBhNwS484PZnYGxMnU7V3DVU9LkmxeYrplE6EMaZw/v3Xuriugf5Tvdexfmb0n8sPk3/MT7Z+bON+MOx+6NvfG7YPbvTXV21NydY7r75w+2Np9g73rO0uu5MHU70nyOyNvyYxKWvw5aBKpninjHlSb3Xuqr+uu7P5m3WP80z+ZH35gP5OnyI+T3bnZHY2G+N/x77L3r2xsb47/H3YXw06bnrotnw7D7G3/tjNQZCl7Y3RHNvHcEdDUT09RWSUiIkFUsiS+691Y7B85v55+Lpmr85/Iq2RuCFamKF8Xsz+Z/8AH+n3AlOysZq2CDcvX1FhK6OI2HjNfTynnSre/de64SfzBv52dXKIsN/wn1yEUbeONqzc/wDNL+IuHjglkcq0jU2L21uGpmpYI7MxQa2PpC359+6909QfND+eWqqar+SV1FMajXMiU/8ANG6mpmoIyitHRVpk6QqlqaxWJUyQEwsR+BYn3XupuP8Ak7/Ph7AhlxmC/lX/ABI+P+Umi00u5+8v5hY7L2zQzizeWuwPSHRNRuGthIbTohmjbUpOqxHv3XusSdXf8KGe1IKnD76+V38sH4m0NREwg3V8bvjl3z8i96Y+RggAjpPkL2HsXZlYY9TkPJj1U6VvH6jp917rPR/y/wD+bpW1NJSbx/n0dg122KlpBuSk2T/Lu+HGxN11VPIsqNS7W3fLRboXagClCs0lBkalHViJQGUJ7r3U/I/FP+bF1RidxUuE/nMdc1XVtJC2Upt//J/4I9Wbu7R2NTQJSxyY7I712B250P13uDCzS+WZq7J4NKuAusWqRbMnuvdVp9u/K/un405PJ7R7d/4VYfCem3Q0EMlfiaz+Xp8fN47v2q9ZQyVdO0G3ep/kBNUUCT07JPTw5alqJSjRsXlWVA/uvdFVy/8AMa2XRrRVGU/4VYdt9r9kSo1RgsD8bP5XXWmdxk0LpA6Q1nXGzuld/QS/byTtqbK5ONrFYmbyL6vde6S+V/mj5R8TRVPSf89f+Z32fk4cxmars7Gbd/kw9Qdg1cP8Pq448lQ4RN09D9fY7rg4BYJFrIlrsrTxMrWgj5Rvde6Qw/ni9gdSVtHX/HP+e51r8o1/j+Cw1b1N/Mb/AJbPbfR22MVXZCrnky9Hl/kp0D1pg5sDWSmmqEihytHFSUippWpZEYx+691eNsPoj/hQL8psRiuy+yf5mXxH+EW2dxUVPuLaGw/hZ8Xto/KbGZbbeYgaswNVle0PkHlamjqfNjaiCoWpwrV1DWqweJ1Rhb3XuhA/2QH+dvB5YaT/AIUCeWkdVSKTMfyp/ibXZamULpLRVuO3thaCSa5uGmo5RcC4bnV7r3T3N/L7/m+rh4hQfz9exo91rK0k2UyX8uX4TZDa0yM8zCIbTp8JjMhCuho1OnL/ANliunUuj3XupH/Dc38zfsannwvyE/njd4T7Wmp6Sgkx3xN+JXxy+Km5aimipzS5HIv2DWQ907uoM/lUZpPLQz0lLSTENDTjSPfuvdOkP8hn4S7ixlHj++9//Oj5Yz0rLJPlPkf8/Pljuupyc6oo8+Sx20u0tjbcmZpVMjKlDHGzMQVKen37r3WZf5JX8kDpJqDO7l+Fvxbwq19SMTQZHuasqN20uUyE3+VJRJL2/urP0uUybR0xKKfJOIlKr6Lj37r3Qt70+L/8lz43bbyVR2F8df5ZHSO1/wC7c2Wy0m7+ofi5sHG1W1aTTk58hXfxjbuMTI4lHohUNI/kRpIw9ywB9+69111p/N8/k/1eyI6fr35+fCbamyNg4/H7ax23ajufrPrCj27hMPTQ4vD4nbuztyZTa9VFgaCkp46aiSgozSLGiRw8BV9+690e3pjvvo/5HbKp+yPj93D1j3f1/VVVRQwb06n31tnsHbDZCjYJW4183tXJ5XHw5OhkOmemeRZ4H9Lqrce/de6rx+AOKgy3ze/nQdqUORo6nH7j+Y/RHWP2CU9RT5PHZfpf4H/GPF5k161ECCSmq6jc6mleOSSORFZhpLEe/de6q/62E5/k2f8AChySkjM9VQ/Kj+ejkYYVBfVPi872Vk40kQEMYiaYFwCCUva319+691swdOZ2bdHUXVe5qhIo6jcXXGx87PHBFJDBHNl9sYvISpDDMzzRRI9QQqsSyjgm/v3Xuqk/5ZJp9n/Pr+eX02kypUYf5m9I94tjhUO3jpPkT8TerM9FlFpW0rGmSrtqVUZlVP3JKV0LMYePde6Tv8vJKmu/nFfz/M/VJJ/x+/8ALf2hRyVLhKxMftj4h1eRjpBRBz4calZuqeopprD7gVTm502X3XulVMayj/4UVUL5BquixWc/ku1lHtc1FEkeNz+YwPzfp6veVPjcm8YNTlNtY3M4aSppUclIMlFKy2Ib37r3QYfy2pq7ZP8AON/n4dOtiYcfgqvf3wY7+2/UwPDGlfU9ufHfJQbsqvt7+djLnds3kkF1NQJbhbqX917p0/lt7kaq/m9/z/8AaW3xFU9eYftX4CbjosjTQD7Zezdx/FKTD9r4k18haarqqCv2fQGaIEx000jgKusavde6w/yidWC+cX89/YtZR1JyuP8A5gW1t/y5mtqfu6qsxHaPR21MxgcQJtEYWgwdJjGNLFp/Ygqlj1Np1H3XutVvrT+YZ1P3R/OE/nMfOb5F/IPavQG+Oi/iR8pPj78Dtldg7jXaOQqc1tzGbg6u2VR7SqMmY4jvVabB1mSqMDA711Tnt2zyUqyLTyAe691uR/yHNjbd68/k7/y8sDteiagxuQ+N2z981UDIkZk3F2fLkOyt3VtkihBXI7r3ZW1CtYlllBLMSWPuvdW2+/de697917r3v3XuoOTyeNwuPrMtmMhQ4nFY+nkqq/J5Orp6DH0NLEuqWprKyqkipqaniUXZ3ZVUfU+/de6JB8k/5nX8vz4ibHpOw/kJ8t+lti7ZyUvhw4pN1wb43Jn3Ecssh23sjr2Pde9tyRwJCfK9BjqhIiVDlSyg+691rxfOj5e/L7+edTbM+AX8t3of5R9HfDnundi4f5Y/zBu6OmN1dV7BzHSlBS0+Wzu0uqYtyLjM3nsTuWk1xVtLKcVks5MkGJkjgxVbX1D+691b78xO1No/ygv5dHWPRHw42HR5Lt/I03X/AMM/gD0wtNR1lfv7v3e1O2A2dl9zLHBjcfllxEy128d35SveihyclLVNU1UdVXI7+690M/wZ+J/U38qr4UZPGb431SZXO4LD74+SPzS+TW65qmXLdr9vV+Lqt7979473zdYkuZq6BHoqk0n3TT1VJhaKnileaZJJZPde6I3/AC++ve3f5lfe2zv5vvyyxNbtHprC4nckX8rT4m5amKR9bdW7wYUifMTtiF556XK99917RjX+CRwmXHYHbVYslPJVS1FNU03uvdA5/Mg352H/ADX/AJoYb+TN8cK+spPjT09meuO2f5t3duBydVQU1B1/JkjntpfDzAZ3HzxOm8+0YsX58mtMXmgKxAt4cZnKNvde62Uttba27szbmA2ftHBYja+09qYTFba2xtnb+OpMPgdu7dwVDBi8LgsJiaCKChxeIxGNpYqemp4Y0hghjVEUKoHv3Xunv37r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3X//R3+Pfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3XvfuvdUJfOeSL5Pfzkv5Vfw+pRR5/Z3xfxvcv8y3vrAuv3f8HyeyMKenfidnpl/do6CvoO3d15Kqh88fnZItcDRkFj7r3Sb+Vn8mv5Id2fzD+2vnl1d/NG7V+JWG7I+P2yei63bXWvVu1sjvfamy9n1WPzNftnbfae59zlNr7KzG7sWdxVCUmOgq3ydbOGmEQBf3XujC/Hnt/wDlnfye/ht098VN4/Oj447d290Js+uxJr949p9Y4Hf+9MvkNwZbc+7dxRdb4DO1m4spnc7ujcFXWVFNQUlbVF5WZzI2uQ+690gf5Qku4fk5vP5lfzad/Jk8JivmZ2DS9XfGHaW4aGrwlVsL4T/EvN736+6zy+Vw+coqLObW3R3Dvit3LuzN0VQ81On3VJJTuIXCj3XulR/KV+5+Rm9Pmx/NHrRXQ7b+dfbe2tofGvHVlTkGSn+G/wAR8dnupOmt2ph8xjsfkdrV/cu9a/eG856Ih0NJm6KQMb2X3Xurovfuvda6Ha+/H6z/AJ9vyqzs9BBkszQf8J+h2dtPMiSHGZLb2H63+VnZIy+2KGTVJSVlPuDP5OnrpayqUSU8lNFEoMSkn3Xuq4K55Os/+EaewMLtGUYFOxelep9jZfKV9N44MXQfJT5lbb2z2FmqpEVP8lloux8jJHIb+QSoxJ1X9+691al3jt7Cb6/n8/yueocDPURyfCD4EfMX5I1dHFcSx7Z7rqdgfFDa4y1XKCtbS1FViKsxxpaRaim8jek+/de6uR7t+Nnx5+Su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0NnZzpjFbexn3rNIlHHM8aMSo9BKn3XujjfHjc//AAnV+KdNj8/8cu0f5RnVFXQRNS0fYG1O5Pimu8nifRA8NR2dWburd5ZEO0QBE+SlJYG/JN/de6Mpvj+cn/Ke68xbZfcX8xr4Z1NMiO5p9ofITrXsTMMsaliY9v8AX24Nz52XVpIXTTHW3C3PHv3Xuq/v5c1dvD+ad82Ny/zfOyev85tH4sdP7K3B0D/Ko2fv2mlpdw5HBbpramj+RHy/qdsVYk/uvuDtuPGUu3MRUxPHLNtuKakmib7eKsq/de6evmtvbcn81z5Obp/lLdB7nyWE+K3Uke3twfzV/kJs+tlhmmx0+SiyW2PgV1luWgkBh7I7N/hpn3xVQOseD2/FNQzSyVTVuJm917o1n80z5xYT+WR8Otv43o7ZWI3B8iO0sntH4r/Av48bfoaUf3s7l3RTUu0OuMRitq0ph17H67genqquFPtqWRIaXGCop58hSsfde6EX+Vr8BcZ/L5+L+N69z2dPYvyK7S3Fme8Pl53jX1M+U3B3T8kexqhs72LuuvzVbT0tfX4bH5SqbH4nyxQO1BTJUTx/e1NXLL7r3VkHv3Xuve/de697917r3v3Xuve/de697917r3v3Xuve/de697917r3v3Xuve/de6//S3+Pfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3XvfuvdVK/K7+SX8BvmP3/kvk52vtDtTB9x7l25g9o7/3L1L3r2t1KnZe2ts0lPQ7dxG+KDZG58VS5GLD0tFTpHLTilqHSlgWWSRYYwvuvdBnR/8ACdr+UkkuP/j3x23zv3GY0iaDbHZXyl+WHYOzJa/VrkyNfszdnduU2xlKmaRVcpU0stOskaSJGsiKw917o8HTX8tv+Xx8eMvhdydH/CP4qdX7t26B/Bd8bQ6F6yxW/qBlvaWLfsW2zvF6gaj+49c0nP19+690B386DufeXSv8tX5O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b+TT/Kd66hWHbf8ALn+HEpRoXjq919A9ddgZKGSnAEUlPlt+4LcuTp5Ba5ZJlZm5Yk8+/de6XU38q7+WDU1UlbUfy4fgZUVkpvLVzfED49y1UpsFvJO/XjSudItyTx7917ouXaO2f5DvwnpK3cHaOwP5WPxymCpLJDX9b/F3ZG6srJRvUeKDE7bx23qbde46+naOYpBRUtTOuiQqnpYj3XuiUd5/zQ+zfmV1nsb4r/yLOmu4M9U9vS0HWEHzuznxy7R6a+G3xO6ipKCPF7h33s3dHYGztkUe7N47UwUbQbbxOKo2pklp/LTiqkipaGs917q3z4ffFXoD+WT8QcH07tLN0mC666m27uTsDtzuPsLKUWPy29t0y01Runtrvbt7duSqFhbLZyop6ivr6yrqDT43HwxUsTR0VHBHH7r3VQ3wG2RuX+a18+cr/OW7awmYxfxP6NxW6ekf5UHWW7qKroqrN4OqlbC9t/M7LberBTnFV/ZWSpaqh26tVTpWHGeMzxK+KxlbU+691sqe/de697917r3v3Xuve/de697917r3v3Xuve/de697917r3v3Xuve/de697917r3v3Xuv/09/j37r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3VZ3ff8AN9+APQm6J+sH7yoe9e/jW5HDYz4yfFDC5j5QfInLblxlNJVVO2G6u6YpN25fa+XEMRN8+2IpUJUSTJqW/uvdFRzfyv8A52Hyg8lP8Qf5e/Vfwx6/yklMmI7o/mS9pR1fYrYeraNqzLJ8W/j3V7rzm1tw42i1ino83uB4pKxkEyCFX1e691XT8/vi/wDzHvir8f8Aenz3+Sv8/fOYzvT4+YLNdvdJ9LYjZnXfxl+LXYfYWxcNUbgo+iK3YlLu+lbvOr7Ex9FU4GgpK+lkrshPko0eB9bh/de62bPiL8idt/Lj4ufH35PbRpmx+A756h2F2jSYiSVZ6jb9Ru/blBlsptmsmQCOWv2xlaifH1DLdDPTOVJW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Z3ftyilM7zimoeputsv1V0jR4tS2kUabZFKbamRpGd2917o/XQXwm+HnxXjZfjb8XegujKiUSCqyfV/U+ydm53IeVDFI2U3DhMLSZzKyNCfHqqaiVvGAl9IAHuvdGanngpo2mqZoqeFbapZ5EijW5sNTyFVFz/j7917opPZX8wH4IdNK57a+aXxS61kRpI/tt8fITqbbFdLNEHaSnpqDMbspK2qqlCN+1FG8hsbL7917oodf/O3+Emfhysfxsovkz858zh5ooKzFfCf4p96974oNLMkCsO0MfszD9IxxIzXd5d0Rqii7EArf3XupFb/MU+Xm7cbFXdFfya/nPutlutcveXYfwy+MiU7tYQClpd4fJLcm4shGTq8rJjl8YW4D3W/uvdNH+zAfzt990gg2j/Lj+GXRNdIGKZTvn+YHujsOjiDsVi+7wXR/xYrJ0eIDVIsWRmVgbK97+/de6gt0D/O77hx1PL2X/MJ+I3xCqoKlfJg/hx8OMl3PXVtEzB5Fq+xvlv2Rm8clXEAY1aDZkKtcOQpGlvde6h138kbovt2lnj+bnya+dPzzTJOKrL7S70+T++NkdMS1pRQ/8L6K+OUnSnWmPxwlBZaeeirGdW8c0k0aoq+690Zvon+VB/LU+M+Vx24ekPg78atj7qxDM+J3nH1XtnP75xju6uz4/fG6aPObto3LIOY6xTwPx7917qwX37r3Wsz8rd+7r/nRfNzc38r3pzI5bHfy6fixmcFm/wCZv3ntHKyUf+mzsbF1kWX2z8F9hbqw9YHpsa2Tpo5d8VFHImQgehqqQy0ElFEmY917rZM23tzb2ztvYHaO0sHiNsbV2thcXtzbO2tv46jw+B29t7B0MGMwuDwmIx8NPQYvEYnG0sdPTU0EaQwQxqiKqqAPde6evfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3X/9Tf49+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3RHf5g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fcTYVYvSG+1Fyvv3Xup8/wDJp637TWsrvmd8wfn18z81k4qaWooN7fJ7efQnVuDzEUSRT5PZHTnxCb4/7J2/9wFICVceUkRWI8rE39+690zp/IF/lxVeKqMJurBfKPfuHrI3pKzF7v8Ann816vHVmKeAQ/wWqx+L76xFFPilIL+NoyxYkFillHuvdWS/GX4sfHv4bdR4Ton4xdU7X6d6o29V5LI4/aW14qx4pcrmKj7rKZnMZbLVeSz+4s5XyBVlrchVVVW0UUcZk8cUar7r3Q/+/de697917r3v3Xuve/de697917r3v3Xuve/de697917r3v3Xuve/de697917r3v3Xuve/de6/9Xf49+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3VB388nFE7/wD5KG566Tzbfwv8634hYfIY2WnmqKQ5ndWF7No9pZqfSJKeCbFZ6ijhp5HS61Faml0JOr3XugX+SHxHoPk//OlxPS38x7svsLuX4kdg/H9e8PgB8YINxUewfi/nOwui85gMb8h9h95bBweWo893p2vsubd+B3jgpq8S42o29X19LVpJTUBpW917qxD5o/MbbX8tvbXxM6B+N3xKPc3ZvyK7Kq+kvjX8XOncpsLonadJQbW2plN57syq5zKYuDYWw9n7OxNNG8yCnjQfdawFijmkT3Xukjk9s/zWvkpi/wCI9q9p9H/yvelpsSMhu3bnR9djvk98sKbDxRuNxUNZ8guz9rbY+OnUE745ZZRX4vZe8Zcd6ZIa8SL5I/de6rUxW3v5JKb1zO3ug/ipvv8AngfLLCz0GG3t2DU4Ss+euZO6aWjkXG5Htv5dfJncLfFbq6OasYCop6TcWPWh+tNirRJEPde6P/tDpj+a12PiKXb+08t8Mv5SfSkqU2QouvPj11tjflh8hqCZ5kjyNFkd17swXVvxd2RlKukiB10O0N6wwMAoqKgepPde6VVJ/JQ+H+8K6DPfLPdPyZ/mBbopMt/GKHI/NP5D7+7L2hi52CGS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fN9Q9X/JD5WdmYiBizRJBJ2nur4+dfVFaiBUd5sTNDqJYIQoV/de6cqv+V13f2XFQP8AJH+bj/Mg7IlpJh93held3dH/AAz2dl6JZhMtDkKb409LbL3+yNykkke5kkliJRiR7917qLR/yB/5R4y8m5N0/D/B9r7qqqsZDJbs717Q7w743LmMgztLUVmWzHcHZm9aqtatndpJo2PgkY8x2AA917oVsF/Jg/lLbdqDU4/+XD8NKiRtF1zvx+653TT+g6hak3NgcvSrc/WyDUODce/de6NNsn4efEfrTHpieufiz8ctgYuOMRR43ZPSHWe1cekSkMsSUeC2xQU6xqwBChbAj37r3Q5YPbO3Ns0qUO29v4Tb9FH5BHR4PFUGJpY/NJ5pdFPQQU8S+WX1NYepuTz7917p79+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3X//1t/j37r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3XvfuvdUof8KCo6vEfyzt9dr0NHV1dR8eO+fiD8g5psdRy1uSw+G6v+UnUuY3XuKhWmRquA7d2jJX1s8sRR46SCY6tOoH3XuhH/nG4LLYn4b1nzP6qoxX94/y9Nx4b5t9OZnHZQ41K3AdZ0lUnfmysplKSaGSu2B238Zc1u3A5ekEvhnhrYqgK09LTlfde6BT+Z7lNuYT5cfyJ/lQ+XTIdeY351Z3pCjr8UWqqfIZT5n/ABq7H2N1ZmYp4g0Yw9bufE0VOZTZW+/jAN3UH3XugR3x8Jes/kx/OS796a/mBb47e+TvUmX+P3T3y7+Efxu31vjd2O+Lm0MVtveGY6n+RGAz/VO26nAbE7K3dsTf6bTykBzMeQjfD7vgiqaeaSnNQ/uvdbDuz9m7Q682vgdj7A2rtvY2ytrYymwu2Nn7PweL2ztfbmHokEVHicDt/C0tFicRjKSMaYoK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n3XurCv5a3xJ+H/wp+K+4sf8Oe1Nw94dP9ob2353rnO59zdy0nfc/Ze9svS0e395bqTfm32XbOUM9Rs0RVf8MiiSSvhneXVUvK5917oGf+E+GDl2/wDyZfgFRzPreu6drtyKBo0Qw7v3/vPdlPSxBOFgo4M0sUakllRAGJYEn3Xurk/fuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691//19/j37r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3XvfuvdAX8oOkcX8l/jX8gvjpm6hKPE98dKdpdO5CudZGGPpuydkZvZ8mRXxETLJjxmPMjIRIrxgqQwB9+690QT+T52diPmv/ACcviDl+xsZNuOh3l8aZPj92rj9yLDVNu7J9SNuL41dpS5TxvNBW0u7c1sDIzMwOmaGq1WAaw917qvHHbD7F+RH/AAmKG2K/K5XFd8fGL47bqm673Lio6Q7vwfdH8sbtfcMPVldQ1E0Fd9ruis3B8aaGjrJLeaX7uoR2/df37r3Rsvkx3Nh94YD+Sv8AzR9r4bIQYTJdz9LbY3hXQ5ZqHD7Z+O/8zvqOk6urU3YZDClTg8X3zuPq6vZpnSOnqsVFK4IQ2917q7bO53CbXwmY3NubM4rbu3Nu4vIZzcG4M7kKTEYTB4TE0ktflcxmMrkJqegxmLxlDTyTVFRPIkMMSM7sFBI917rX+7//AOFHPxG27Xbr2P8ABrq3vj+Z523tLEV2YzmD+I2xNwbh6r2pR42krshV5DfXd7YSv25i8DDQ0DSNX4aj3BCoZQRfVp917q3b4VfJ/A/NL4m/H75Wba23XbOw3fPWO2uxKfaWSydHmq7bFRmqQNktv1GXx8VPS5R8Pk45qcVCw07TCMM0MLlok917rTz/AJeP8qvo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737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691/9Df49+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3XvfuvdUr/AMjZ066+O/yP+G1di5sFuH4MfPT5g9JTUFXFSUdRl9k7/wC4c/8AJjqnfNFj6aeR6fbu8evu9KKShd0i1CCRAto7n3Xull/LUij2pvz+aJ8Nt0y4/LRdMfPLtLsHA4dKBo6A9LfOraW2PlrgKKd5kjbJCPfHa278XM1mRWx7RKzBLD3Xuiofy8+gq75gf8J+I/hT2JlaZt7YTrv5TfDD+J5MOa7rvfvx07w7Z6g6W3FW01OIqnG7g63qevts5ykQqJIZaSB7Hi/uvdC52f39lPmR/wAJ1e9u/M/UU53v2x/Kl7/ynZiY/ES42nxvb2M+N2+cD3DhKTBeV56BcF2fhcvQrSli8Xg0HkW9+690Yz+UP15tHG/yjfgBtSl2ttnEYfeHwd+O+T3Rjdv4vH4ygzuS3z0ltKt3PmMtHi4aaOvz245sjJNkqqTVUVNXJI8js5LH3Xuivf8ACbmfIYH+VH1R0buR4Dv74qdxfKT4z9kU8Dx/5FvHrj5FdkVElJLSgLUUEqYHP0DeKdVmKuJCLOpPuvdBV/JG27ltqbI/nA/CRZaejpeg/wCZL8sts9XY8x1AOD6o7wxGK331zFVVMwVakSy5msqCwAYeQ3JXQx917qkLY/8ANE+BFB/wmoxX8vreXcr7l+Ym6/ib3j0lgvjts3Yu9OxewaDtfbu7OyBs+i3DT7QxNTg9r4qmyWFoa6Kurq+JRjDHWRx1K/tv7r3WxL3X0j/Lc+Q/8vf4GfIX+a3jOvKbr3pHpTqHtLE5Tv8A3xuDrzBY3em+OlNsLmdu7lw1VnduVO9sznZoIgu262CtrMhkqOKFaSWUtDJ7r3QF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pPP5BXks0dGkiBQiKw917rF/NT7I68peyf8AhQJ2BuTdGJpaDqX+UF8QPihWF8iD/Dt9fJrsX5c1WzKCrbGVkU1I/wDeLdWIMtPN/lbpVoUUxuA/uvdM/wAh+3PjZ84cL/Mx+S/WHZec7M+NPxz/AJM22/jbt/ubC7P31tbrTcfyGz/aXbPbWaxfXu5tw7fwMm/8rhMx1L12at8RPWY+jkyMNNPL5ZXVfde6stp63KVP/ChzrKPOQRU2U/4Y77CraunhjhUU2UrPnB00ucgeZPJJPElRTQrCvkKR6XIuZCR7r3QLfzydt9W7G+TH8ln5XdnbG2Zvnbu0vnwfiPvPE76wuC3Jtabr75qda7h2blsluLbe4KKsxuXpdm5jZNFlqWaVXfGzwtJCuuVj7917q9THdB9FYfHHEYjpbqbFYllkRsXjuudn0OOZZl0SqaKmw0VMVlThhpsw4Pv3XuiH9s/ySv5TXd+8m7A7G+A/x1yO7ZpZaiuyu39mDYKZiqnBE1buDG9f1e18TuLIS3u1RXQVExbnVcA+/de6U3yz6b6Y+MH8p35i9QdN9f7Z6w6X61+EXyvi27sLa6S4PbmCxFR1H2RuHNR00kP3FVSHI5LI1dVUVP7k71E8kzFnYk+6909/yk4ZKf8AlXfy2IpkMci/Az4jsUOkkCToTYMik6SR6kcH+vPPPv3XurCPfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691//9Hf49+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3XvfuvdUb7upqr4Pfzp9mdjUraOhP5wfXtJ1B2N5VP2+zfnB8TNj5DL9MbknyuQya02NxfdXx3iyu24sZQ0nkq83tunnmlJdEPuvdCR11laTrD+eh8m+vE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9a/Dr499WfGTp591v1j09t1trbMG9905Pee5YMMclX5SKkrtw5d3q6mnopci8NJCojp6KjSKmp44qeGKNfde6MD7917r3v3Xuve/de697917r3v3Xuve/de697917r3v3Xuve/de697917r3v3Xuve/de697917r3v3Xuve/de697917r3v3Xuve/de697917r3v3Xuve/de697917r3v3Xuve/de697917r3v3Xuve/de697917r3v3Xuv/0t/j37r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Qcbl7j6i2ZvXZ/W28O1OuNqdi9hGZdg7B3LvjbGC3rvhqdilQNn7WymUpc5uUwOpD/ZQT6SLG3v3XuhH9+691Sv/ADzaXG7V+O3xY+Tm4Mj/AAjZ3wm/mS/Bj5P9hZUQVEpxnW2K7houpt/5OWSkWSqp6DE7W7cqaysdEkAo6eUOvjLEe6901/zVd80Pxo+W38nX5dfxapxj1PzVy3wI3pRnI0+JwOe6v+cnV+4Yqt91VkyEPRbJ7Q6S2rn6VWZI1noW1Mqu5PuvdBd2/wDIr467U/4UA/Aqr2R3P1VuzfvyN+HHy5+IvZG3No7+2puPO7WqOtd0dZ/JHqCm3zicRm62s22+fr6LdlLhHrIIGqav7mmhZ3lMfv3Xuge6778+dHVv8wz+bh1l8WPgVv3vjefa/wAmukd3be7j7hz1J0D8VOvNsUXxB6R66G6d1dr5dM1uXtL7DObbVotr7LwFflnx9PLJLVweWMx+690NPxP69xH8kjrn5tfJL+ZN81+octVfMH5L5H5L5ePZ+zdzbMwNB2dvbDUMO8NhdNdZ1Gf3zv8A7FydXmGipMdS4ymq8tU4rHUstRFrEvi917p7r8H/ADE/5sCwSZHK9rfyqf5f1fUpVUmKwlXHgf5j3yh20VPibcVaI6jHfC3rvNx1KsKCI5Te9QKVkqfs6as8ae690efpn4kfy6P5W/VW5d79e9bdEfGDZG28S1d2R3rvKrw2N3TkaPzN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YY2GHdXfvXG4u5MRtZaiqxFT8wvlV8iu+dl7Mo1QeYYjCd89ybr2ZhYIqdAjz/aiYxDS8hXj37r3SR6u+ef/AAn/APglS7k626F+Q38vPoWmim/iG78J0Ll+sYP4vkKSlRTVbjr+rabISboztJTosBNTPVVkRRYDZlEY917qsbsrKf8ACeX5C9z97fJ7b3SPy4+efyU+QeTw+68fS9B/HL547r3eNx7J2tiNqYvNfG3d1JsnrTq7rfceIpNr09Wu4YdzY6ox9RAJlyNPBEix+690bXo/s3+Yv8Jvil8jPk7/ADFd8bWqfg/1x092VvLZfQ/yHzmJ7T/mB4PC0eDioeuOvO0/kV1nQbC6Q3buzsfcVScctHU4fPZWNspj6WozM1ZHVtJ7r3RQvg58L85hevv+E43wz+Te08X2hj9h9C/Oz5fdu9K9vYOhzuw8S2Uw+0JOrZtxbA3BjqrBZ3tDo3P/ACrx+FxSV1PM+HE+UqIytTHBIvuvdGfyfVXVW1f+FM3xh2P0F1f1r1KvVn8q7uDtbtwdc7Q2xsym3Vtfenc79X7OwOUx+3cbi4Kip27uNaeshZhJKsFQAAsYv7917rZd9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvdf/T3+Pfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3XvfuvdaeHxr/lndT/OfLfz89lfI7B4DP/zGMT88+6cL0t8lN4VGVy/avx564zmwdk9m/AjdvV+fSvTNdZbV21WzNXU9PgZcfNV46lfGzyS0kMMUfuvdbHf8uX5Rz/NP4L/Fz5PZNMdBuntfqPbeT7FoMRTT0eLwvbeDjl2n3Bt2goqqWeqo6XbXaOAy9AkMrvJEKbSzFgT7917ozvZfW+xe4+u989Td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7r3RNs38g/5Tu267+AVP/CiT+aN3RNE8077R6W+Qm5+4srlBMqBaaLK/Fz4p5LeSRLo9DU+TgWP1szqodh7r3Skru3/5A3Y743B76qv5lvyS7RGPp0pNqdjbe/nVdhdp7npI4ZK+GqOBrqCj25XxSU8r1BdI4oQklzZWUe/de6a9nxfyhtiVNLV9b/8ACbr+Yf2RNDWLkMVk9zfyxcvupK2oDyTfdx5L5Nb+x6ItPK7FDWPEL28QYaffuvdWL7O+XXzzz2Lw+z/gR/JRy/RHVu18Zeer+avZ3TXw6xVMtHUJo2P17010bF3znJpcnTSM8OTqP4bi6N4yrpIXX37r3SV7k+Z/84jE4yCp3P0r/Kn/AJa+ARZVruy/mz86Nwd04nLwxahVz7KwHW2wejaT72kjkR9OVysMEYuzl+Im917ogPyXmyXy42FtvZf80r+eb/KqoPhljt/bH7Q7K6U+KlHtHE5f5D4vr/cuF3phet8pu7e3fG7dzJtityWPhnaLCY2urqh4YSEkbS8fuvdWKZL5I7Z/mJfNf+Xjv34W9U947k6++Nvanb2/ez/nFurpjsPqjo6m6X3p8fOythbs6K2BWdu43rzKdy5HuDsSr2hNNPhcdksbh2wNLkhM7wx6fde6TPWsEfYP/Cnf5Kbxw9OKnHfHr+Ud1J0hvKvpYwsWK3r2v8il7k25i8nLBqR6/J7NppKiETlZjBD6FMaA+/de62Evfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3X//U3+Pfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3XvfuvdUf9K0sXx1/nw/Nnae4qOrosd/Mc+J3xp+Q/VW4ZY1psBl96fDWLcnQfcOw6GeRoxX71odo762rm54YldlxTpI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oUrKxoti/JL5sfIrt+sMkwaqjraTYPQ3UOR6Y29h2qnRXx0FfOgaMlbLoI917oz9H/Jq7i3Nizhct8Yf+E9HR9DTLTz0VTsn+VTWfIDLS1kJaGQVU/YHaPUmOWOppLapmpKipDenWRdj7r3Qm7N/lO/KfZTS0XXO9v5P/wAcYaaWA0+6/j5/Jp29id259BSolVJmaPcPyoq9t4iaoqrkimhqB4+AQTdfde6EXcfxA/mWbEwGQzW6f54m0ukNiYePzPU7I/l2fEfrfa+IhWMPUT5bJdrbo7OxsarHT+llalVE16tfoMfuvdBdtfJYTczUNB2F/wAKaf751GPgeWto+n83/Ky6lkrXCTIKupNB07vnMQxI80TFPufESlrAPx7r3SRy8n8uKfceKpux/wDhR53PnNwQSxY2u2/B/NO+L3UsGYya1ErTpXYHpPA9ZTY2aomqWi8VM1KI10IlmRCPde6TO6urf+Ez+fgrN19r/NP46d1TYuJ4KzK9t/zdez+6qtGqNVZ9vTYXcXy03JTHI1BoWeOOkohUSeM6AdPHuvdB9118tv8AhJx8c58quy9x/CIZKiqaN5t1Z7qXe/d2eklr8lBjY6fbnYu99h9hZnJUtLVvFJVU+LyMsNDThKmoSKBVlHuvdZ8H/PJ/kj9b79yu7+mfiB2PmsZF3JiOjurfk18e/gJj6rYXePceYwGCz3+j/p3sTC4XA5/Odg01VnGpf4RPBR5KseH7mjiqaSenqJfde6sAn/mk/KveOMqMt0X/ACWP5iW7aJGMdHL3ZW/Gb4w1Ncy2LTDb/YveNdvKipXRgUNRi4pTyGjRgQPde6Ej+VN8Ou3PjnsPvjvb5Wf3cqfmx85u8txfIv5HrtnKf3kwnXdNUxjB9QfHbau7JAanP7H6H6+p4sfQs0lTFBW1dclNUVFL4Zn917q1f37r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691//1d/j37r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691Vz3t/Of/lrdAbvHWme+Te2uzO3HNdEnTvxtwG8Pk92fDXY50Sqxeb2p0Ht/sGq2dkUeVQI842MB1rz6lv7r3QLJ/Mq+f8A2vRUWW+Lf8lL5RZjbuTq44qTcvzF7w6B+FZpsdL5YlzWQ6+zWd7V7cpYhOgcUkmAiq2pyGdYpCsR917p7odpfz8t/TSVO5O6f5W/xwxdUGqaTDbC6S+SnyP3Nh1Yq8GMym596dsdJbezVQqMVnqKbD0casto0ces+690y7K77+dHwf8AkZ0B09/MN7n6X+SfQ3y/3RW9SdT/ACe646Xl+OuV6i+Uk1JHlOvOi+0tmydj772/nNr984qiyFLtDMUEkdcu5qA46si019C6+6902/ztIx0vt34OfzEsfJBgqn4BfNvqLdPa2+hipc1kNufEL5DV6fHX5UUNNjKW9dWUWS2tvrGV1SIEkkh/hMdRp0wMy+690qPmR8fPnNj/AOYL8e/mD/L/ANpdAZ/Pbu+LnbfxQ+R+5vknu7dWP612ZsXHdi7D7p6L3ZQbS6+mh3zvLcNHuaTd9BFDQN4XXMKtTLSREVcPuvdBD8ivjzm9i7DzPev83D+cz2z1z11Q1tVVUuwfi9uvG/y7ug6GGeh80+xcdLs3N7y+UXdObnEEiUdJLvmqrK8OY4sc0jIF917osfxe+Ou8M3UZHIfygvghsv8Al/8AXu+5MpNn/wCaf89dn7k7N+YfYuHz7VcWZ3F0V0Z25ltxd9bkp9wOKLKYvIdo7h25t2rpZpJEwdQpjD+690n+8+s/5NnxT7YwuN+Zu+/kH/OS/mF46nzNVtTo3sOv3b86O7KjM5iVMlksBsn4jbOhpvjX0bh6yuSIYyDL4PB09HTpEorXOqWX3Xumr5Y/L75kdZ9QY7cvzI+Uvxy/kY/GvceLWi6y+K3xz2ph/kz/ADIt+7UrmloG2ntyqjjh656y3NkVljip67aG2Msu2Kuc/d11O6CeL3Xuljg9nfF359f8Jeu2Or/hnsPtTZHR+H+NPcuG6l2P3tNiaztCm338Yt857fWKO78jiMrnMFNlNz9n9cx1onpJxTwCtCpFTeL7eL3XuhI+ZHe9P3N/Kq/lYfzRK3MPhcb8d/kH/Ln+a3aswoXmqk2TvGsxXRPyBxkjY4Smho9vYHvjMV1bMivAlPiXZh4wSPde6MrloK/YX/CiTZmRpJajFbY+Rf8AKP3pg83QQrS0mK3b2F8e/lZtbMbdzVZpgSbK7k2xsjtzI0iuztJHQVaKRoRbe690AnxY+Muwu7uhf5wn8krsrIRUO0unPkT2YvWmSweLmFV190l85qMfMv477rxq1OSilzu7enu3N7Z0wSyyJTVFZtqFXJXyxp7r3Vlv8sD5N7/+U3xC2fubuqhoMV8j+pd29kfGT5RYzFVVNWYuL5F/G/e2Z6k7TzOLkocXh6CDEb4ze2P7w0VNBAI6Gjy8VNqcwl2917qwf37r3Xvfuvde9+691737r3XvfuvdUQ/8KRfkNi+h/wCU93lt6r3fjdiZX5Q7g2B8SsJurNU+SqcJhKLuncEdH2Vlc0mJoq+uGLxPSmH3PVy+OMu4g0IGkZEb3Xui2/zMP5p38sbaX8o/5JdCfHP5z/Hveu8M/wDEDcfx76O6/wCne1Nsdj9jZir3HsFOrdo7bpNsbPyGb3Djp6mjr44KmWohgaigMkrshjLD3Xurkenehavrf+W91h8Y90bfx6ZHY/wm2d0dufbGHkaPGNk9v9GY/Yufw+Pnp5Wk+1mraWaKORXZyrBtRJv7917osX8grc8+7v5N38vbK1Nb9/JSfH3CbYWfwpBog2Tmc5sylotEfpb+G0uASn1/qk8WtvUx9+690Av/AAn+ip+yuovnD8zMjVHNbv8AmX/MY+Uu/Z9wuYZV/wBHPXO8G6l6o2liaqNVkn2xtDA7UnSh8paRfupRqK6ffuvdKr+WBh8Pu7+YP/PE72yeLpq3f9V8xuq+gU3c1Kizwde9KfGjquDb2zsa8oaehpcfX5+eorViKRVtTJHM4ZlUj3XuhD/nQfLP5D/GPpn4t7L+KG5MRsjv75kfOz44fD3ZXYOb2VjOxsf11R9pZPPZbc29anY+YdKDcVLj8JtKSlmicqUhrWkSSCRUni917pP1Xws/nPZC6zfzvdj4hSnjD7X/AJWXSFLONRPkm17p703lAahVt4z4vGpvrSS9h7r3XDN/y1f5gu84IoN6/wA835hPoDKz9dfHz4ddSOweyv8Au7M6ipqi/jX0lnco3qHJPv3Xuq2/lD8M/lp/Ky3L8ev5hWT/AJu/zu+QPQnT/wApejcP8v8ArH5Cdoz1/XUHxs7e7Bw/U+8d6R7Xw08G3Ml/crLbyx1TU0TYmQrQmatglpZaJWb3Xurmf5vXxU3f8s/g72Jgeo5jj/kf0hndn/Kn4qZyCggyOQw/yN+OuZj7F66hxUNQyxRVu8GxlVtwzG/ggzUj2bTpPuvdFs+Re19mfz6f5GGZquu6ulwlZ8rPjrt7tDYNPDk5qmh2d3317kKDeFNsDN5OCFWqaHbHc+x59sZmZYJCIoqmSONnVB7917oa/wCR3hPjVjv5VfwuznxV67wvWnXG++ltpby3Dg8WJarIVfblXiqXDdwZLdm4qykoslvLdUfYWDr6KoytQimoioolgSKkjp4Yvde6tf8Afuvda1PyS+N3xu2p/wAKE/jluLuzpHpHvjb/APMv+HncHWtHgO2Ordo9k5Lr3u34XU+29+DfuIl3bic1RYjCb36Y3AmDmjSnjmlqsWjfclB4D7r3TR098Rvjb1N/wpPmpfjN0L1f0Ftjqf8AlXZPsXsem6f29SdfYTdnaPdfyKm2hhafLbM2vTYraxWi2RtioqvMkA8szxF1Z4Ynj917o1m3c1WbY/4UddobJwZ+32/2z/Jp6u7P37SUcDLDWb26p+Zm/wDYGys1m5ljWJ6+TaW/8hR0V2aQwUk4ICot/de6Cv8A4VN5rJ4b+SF8t0x+FpMxT5nL9A4XMTVdLJVJg8ZVfITrGcZqEJZYKuHJUtNBFK/pR6gH9Wke/de6uy+O2PrcT8fui8Xk5TUZLG9OdY4/ITmXzGato9k4Snq5TNqfzGSeNjqudV73Pv3XutM/5R9Wd+9j9X/8KlOkfiL1fuXu/d3b3zE+KW38Hs7rpaTI7toshnNodf7476y9dDJU0EmUxEeKoqigioqQT1aVcsiMjoHYe691dh1j/NK7S612J150PL/Jy/mzw9qbO2Bs/ZeD2/SdJ9S5jqfJVW3tsQ4uDy/I/Hd1f6JMHhqdcXGJ6rJ1GPqR5QIaOZw0Y917qoij+APyR21ujsDK9M/ysf5vnx42T2Nujc3YlRP0T/PO6D6v3Jh+x965SbMZ/cGI6jo+4ajZlGlVX1bFqyuzFfVkqBJSGMax7r3Qg4n4wQ4/CVG3/k//AC//APhSr8jc9SRBM1Fvv+ZDtHuHAfb1kz1FLTYncPUnzw6mwW44jSyR+dIMcDTupjku6M7e691gn+GtZkAcL8NP5T/85jrPN+aOu3Zi+6/5uu5/iD1RLh5aCZEr6LeeA+U3yq3Huzd9RXQxRnGwYWKKKNjJNUwqqxv7r3TjuP8Ak2dl7n1dib9/k1/GTujKRYVPu9o9zfzw/nz2v3PmGpadSMTRb33t0+3VmLrql7RoVEFIEjCSSlQHPuvdZqH+V5sPMSodk/8ACWnojarPiJKjck3yJ/mD9V7do3ykSwRVOC2LH09/szNRWmeSFhTZCugwEZUeQovlYe/de6HXrv4m736ir9vbqxv/AAlm+AEFSktRTwP1z8qvilv3s7aU8BkEOXkqO3/jh1nt801ekhUT0G4ZchEl1eIqxVfde6Phtmq/mkYOkxe/Npfyw/5a+waWhaI47pwfMDdOM7bxEEtO5nk/0jbQ+FVZ1bjK9WlMT01J91ANTlauRQC/uvdClH2X/OQ7KpqaHbnxW+DHxYkjrKWPJ5vuX5O9qfJutajkINXUYTYfUHS3TFBWvTJcItXuuhMrW/QDce691nHX/wDOfxnlFN8o/wCXBuoZKFfI2b+GXyL20dr1OgxM+ITDfNHLjcdIOJfFVmlkZ/T5VXn37r3UHIfHH+bZvg0D7m/madE9QwwoFr6H47fy/wDESV1Y4kjJmi3D8hPkJ3dRUwaJWGgYdtLMDqIGk+6910fhD/MEnkeGq/nP/JEY6RYw4x3xM/l/UGZBLn7kRZV/jhWUsKPEAIitH5InLMXcFVT3Xupk/wAAflZW5B6PIfzgvnXJsarp5afJbfx/XvwVwu6plnhkjmbHdkYv4kU+4MJJ5XDxyU0azQ2sjjgj3XusFP8AygvjzlEqx2r3z/ML72lrIqxHftD+Yf8ALuCkp56xtf3uNwHWva3Xe18RVUj3NP8AaUMEcBPoUcW917qHs/8AkZ/ynto56XdFT8LeuOzs/UeQ1WS+RGc7D+UEtZNK/kkq6yH5Gbz7SpaqvdyxM7xtMNbAMAzA+690Ok/8rb+WTUqqVP8ALo+CNQiOJESf4ifH6VUkUMqyKsnXzBXCsQCObE+/de6rK/n09E/HfoH+Tb8s8d0v8auhtj5bcGE6u6h2Jj9kdO9d7WpsJle4+7Otur4qvDw4PbdIuInx9JumWaOWlRZonjVo7OFI917oiH83rrX4+bA+Vny32VtvpHpTaWJ2F/wmv/mHdk4eDbXUnW2Ekx+/N89o9ZdS7W3LTzYnbVDW0edxdBh3o8bVrIslDTzVMVL40qKpJvde6GLfnVOzOvT/AMJUvjpu6kxH2/WcWS7OyOAqFo0rDl/i9/L9r+xMtvSKppaSNZpNr72p6fJVAjC/eVssRIZyGHuvdUh/ADZWRzHxl/4TSYHM4aqqabvn+bd8ovlTLRQ1NVLS1tV0tu2SkxW4qrHF2Snkw8m2pZ4SQfHTwvJcCZ7+6919Gv37r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvdf/1t/j37r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3RUvnd3luf4x/Cb5d/I3ZFFicjvToj40939u7PoM/TVFZgazdXXvW25N1bdp85SUdXj6uqw0uYxcIqo4p4ZHg1hXViGHuvdUj/Dj+V11d8x/hn0b8wP5onyZ+V/y33V8kujuuvkf2XsntX5OdjdTfFvYVF2dsbBb/i2dt3o/qDcnWPXmA2NtXHZONKmnrVqKSsnWeWaNYJRTR+690Ybq3+Yl/K++PdNn+iP5Xvxxz/yfyu28pQY7dHX/wDK8+MlDujrbGZqrptOPyW/+/cPR7C+NFPNUX/ymvr941FcCzSSq7N6vde6ELNdwfz2u3qJsv0p8OfgT8RsdHUTRU2G+anyS7K7t7HylKJ5BTZCt2z8S9kt19tdpacKXpk3lmHjYj9wlmWP3Xukrlf5anyJ7ao5u5f5gX81/wCXe19301HPWZvYXwV7jrPgt8Rut8I0Ic4LF0WIjynam8ocRVzSs24d07plrqxWQPBTxIkK+691UVht3w9gfyh/57nxMn+UGS722R/Le7R7L3x8TPlhVdlrv/cdVt3YWM278wvj1sWs7eqslW1G8+0Ope3tqNtioycVSBJMaeipIYooYoffuvdbMOb2rtP+ZN/L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2/hIJa9aeKogf7hI0mSrpvde641vxe/nS5LGy4E/zYPjZt+OpRo33vt3+WdQS72oFeN/38Xjty/K7PbH+8SSwjaqx1TCv63ikt42917pkzHwO/m0Uy0VRsb+etvynyNpP4xH2f8Ay8fhrvzAVruihZMZi9l4nqDLYVopS7Kv8SqY7FVZWC8+690Cu8P5R3eXyYw+Y6x+Zn87z5l90jeOGrdvdidXdD4/49/E3r3fnW+U1Uu6tl5zq/rzZ+58rU7f3JgJnx1dJNkqh56SaVJWkWV1PuvdXtdadcbH6d662H1L1ntyh2f1z1hs7bXX+wtqYw1DY7bWztnYaj2/trBUT1c1TVyU2Kw+PhgRpZJJWVLu7MSx917pbe/de6pi/muyYzc/f38mTqOsn+3q9x/zRNndrQOVZlkpegfjp8hd7NT2Vl9VRnKzHICbgXvbj37r3VFnyn21je2fkX/woIjaCLM/6fvn9/wn7+H/AF7T5Clp50zm8NhdmdA12+dlUekOBCkNTPUVKSvHHJFApc6gAPde6Nf/ADqt80lF8sPm1j8zVxU2F6//AOEz3zunp55S5FHuv5F967K6w25TqgIVpNxSbFko1POk2J/s+/de6Rf8ufZWKn/nL/CjrWnoo46D4Qf8Jy/jntIVdFJEaKt3/vfdexIarKQxrDqEOS2pumoZ2crPNUBpGuGN/de629ffuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691//9Df49+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+690V75v9c7g7h+Fvy96k2nj48turtL4vd/dc7ZxUvl8WS3Bvfqjdm2cNj5PArT+OsyOTjjOgF7NwL+/de6oPwKQfIX/AITJfDbvPof+D7k7H+FHxq+J3yo6pkyUVfXRP3L/AC16vaub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7r3v3Xuve/de697917r3v3Xuve/de697917r3v3Xuve/de6//9Hf49+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3XvfuvdMe5tz7a2Vt/M7t3luHB7S2rt3H1OX3Bubc2WoMDt/BYqijM1Zk8zmcrUUuOxmPpIlLSzTyJHGouxA9+691TyP5qvZPyjyEm3P5VvxG3t8r8QlfPj6/wCWndVdmvi/8HcRHTzV1BV5HanZe6tqZjsrv6SgytEIng2RtfI0UsMyVCZHwkM3uvdPVP0j/O67YoFquyfnZ8LviVWxSs0O2vil8Qt199PJC8xdIsr2R8ne1cXTV8lPCPGXpdm40TE6tMWnS3uvdITt74X/AMwuDrneeR7e/nz776s6wxW3snk9577wfxM+I/Sk21sLj6Y1kuer+1ZoRPszGYqanWWqq4amhP2gljM8YfyJ7r3Tb13/ADLO6Pidt3EUn8ybbuM7M6HraGCu63/mufDvaGQ7F+JvZezmMq4/c3f+wNgV++94fGDdE9H9s9fko0zHXlTUzTyUuWo6eEQj3Xurptg9g7D7W2btzsbq/e20ux+vt4YyHNbT31sTceH3ds/c+HqSwp8rt7cuArMhhszjpihCzU80kbEGx4Pv3Xulf7917r3v3Xuve/de697917r3v3XuqH/5MVFiusW/mYfy4d042ip6z4l/ObuHK7f2QqifBQfFf5nSVnyA6DkpabxQ0tLRZzFbkz1NUUMSGGCejlAZixA917qt74+Y3+Unj+oNv/Cf+dDlvjhB8gv5RfYfdvxv6ZT5h782917keyPi/WZXE5joLt/ZPXdZubCbe7I2xvrolNr0kEH2eYq4K/CSSeKCaT1e691aP0X/ADYv5RHWux8LsT4p4nsPC9bJGK3bW2fjV/LV+a0PX1XRzwKyZzbcfWvxVi2jl8bX00SPHX0TzRVURWRJJEIb37r3Thvv+ep8aevsbmt55n4xfzKB0xgqGGtqe/674D98bM6hqHqKiWkho6PKdlYLY+6Zah6yFoS7YhKZJbK0qsQD7r3RCu1v+FKG067H5bK9LYL4ndObSpYaCLGbt+bfy5wP+lvOZivmp4Icdtz4P/B3a/y9+SWRSo+9ikgf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Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvdf/0t/j37r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691r4fzdtpUvyz+ev8n/+XfuulO5eh+ze1u+vlh8nNiuZarA7r2R8Suv8Lnestqdj4IaaLcfXO+Oy92rRVVDW+SinqIYi8TvHGV917oee4aDtL5lfJPeHw3+MPenZnw/6A+EPXe1m7Q7d+OlFhNuZmu+VG9MBj830P8dtv/x3Z2S2bkOseiephSbu3xt2jIgyg3NtnFVBhpP4hTze690ab+WL8nN8fMf4FfGf5Hdl4SgwfYfYewpo97jDI8W3Nw7p2ZuTO7Azm/tnwSQwSUuxuy8jtWTcWChYM0OIylMheQr5G917oMP5pHxf71+TvXvx7p+mNudU9sY/pP5ObA777L+NHde9tz9b9afJXbfX+G3T/dzYG6d57Z2tvuOnpNsdh5TEbqpqDK4PKYPIZLA0orYWSNVb3Xuo38qv4c9qfDzqbu7bvZuG6h6zxHc3yH3t3lsD4vdC57dm8+lfi5tjfOC2vTZXq3Ye7d74Pa2SylHmN1Yiv3DkaWgw2G27j8tmauHFUUVJpL+690gOyvgD2P8AFHcW9/kp/KnyVH1tu/K5M787X+AWbyVNi/h18q8jSQKNxUu0cLWMuM+JHyA3tjKWKCi3rtkUuAqspT08m48RkIpKmqT3Xujz/E75c9TfMPrmr311q+4MBn9q52r2N3B092FiTtXuToXtTDRxf3l6p7g2RNPUVO2N44CaQcpJUY3J0jRV2Nqq3H1FNVS+690aD37r3XvfuvdBH3R390d8cdq4/fXyA7f616T2Xldz4XZeO3b2pvXbuw9uVu7NxPOuE29T5rc2QxuOkyuRWkmkSESavDBLKbRxSOvuvdChj8hQZagocriq6jyeLydHTZDG5LH1MNbQZCgrYUqaOuoaymeSnq6Orp5FkiljZkkRgykgg+/de6pH+avxW+fmyfn3sn59fy2MB8bt3737F+MeT+IfyI2B8k95772N14uPxHYlF2T093rUUvXOOqMnvDO7Eq6nLYiuu0mUXC1SUtFGwkeSl917pqof5f381zufdWN3/wDKH+aX1x1vVw0UdL/o++G3wV6EpW2zJT1c9RT1O0O//k3i+6+0KKaFK2cRNFj6J6d5WdSSz6vde6Lp8l/jD8Jvg0aTMfLn+c//ADd8pvffkky7H6ok/mHds/6WeycvlqifH4zH9UfH74xbb2PuXcM8+ZkWlpVxeE/h8VSY452VCQfde6Jt3D1r8Ac/2f8ABTdXx6+FW6P5t++/nRsrfVT8dPkV/Ml+bfcG9ugdqSbAxmVyW7epsqfkA3d89N23hjgauau2XVbVoMoJsfV06Sirx9ZT03uvdCB/L0+SvzXwnyq231b0F/Lj+FPZXx52R3Pmvjv8uO3/AIefDTM/ADanxt7H2zuZdkdrR7I3h3d3VmKzvei6nyz1NRlqDFbWpKzIUNMI4mhqqhYV917rbF3rvfZfW21M7vvsXd+19g7H2tj5crubeW9c/idq7U27i4ComyWd3FnaugxGIx8JcBpqiaONbi559+691VLkv55fwMyyZun6An+S3zNzuFra/Hrg/ht8P/kt31SZyqxvnFZ/djsPb3WdN09uGkjNM9qmm3I9KyjWJNF29+690Cn8kHZneu38r/Ms3D2L8We5vjN0F8lfnBu35dfHva3yNpdpYPtquh+Qm1sRUduYLdHXW2917vGxaDAbp2rTzU1BUTLpXKyRAM8M1vde6Fn+SXFW9XfH35B/CPIQV0cP8vP5pfIT4t7FrMzkzks7n+javL4rv34/Z3JuyRGJoeoO7cTiEUIqWxB0lh62917pY/zfcBl9jfH3Z/zu6+x1VUdufy3uycN8qsY+KjxcOU3H0Pio32v8xOr67J12OyFVDtbfHxlze4aqang8ZfNYbFVN9dHER7r3RcPl5mcN8bf5wn8sP5vYapw6dS/NXrfsr+Wt3D2AuXSXb9Vlt3ik+QnwzXFw07SUGRzG9ux9vZnFUmQU6jSVgiEhjZFPuvdCv8EEh+H3yM76/lSb3xtDN1xlW7Z+Z3wby0eCei2tn/jN3T2vkc13X8ecjDPQNiKrefxq7z7CrIRAtbWS1+x9z4OdoacQzxj3XuqR8Vmsx8T/AI9dMbzyWNzy/wDQPb/OT7D+OO8d5ZmLJb37Bx38rHv6gqsBJv7JYfEUGQ3LUYPFfH35BbTMcdJSzLJRbJWYIfD54vde6PR0t2nsPsjuLsLvL+SZ/KL69y+8+48jns5vf+ZJ8qtmZb4fdK5nJ70K7hy+X2TFn+vsx8p+3cDunJzrUZWm25t7BYqqrG801U8y3PuvdGm3z8avlRvnaGS7Q/mu/wAznDfHLqLFSUUuX6b+C27pfhh0FjaainqTNF2P8rOyMvV/JTeFLuTGLprqegz+yqAAOqU5W5PuvdBH8dvlN8AeiMXlNs/yc/5b/cXyqy+Xp8piK/t7419E03XnVG8d0QVvmgpe2Pnl8nMj1zjezo8nkJI6moz1Jmt8yLA61DGWyj37r3U/v/rPtndvXeS7g/nUfzFdofCr475AVPj+IHxJ7gfoTrnIYZ46k1WxO4flTuCHC/IP5DbhzmEro6LI4TZo2djampVo6WmrI5wG917ov38mXNfwL5+/MRPgp8ZO6dmfycfkfs3rztzqXfu7eo8r8funNo/JHZW1sB1/vPIfHvYG/wAbb3runrLvTa+Mpqyvy/8ACIJY85h0p/t4aaMSv7r3Vyvy8/mj/A34I756n6z+UnyL2Z1j2B3RuDEYLZez6gZPO5+GmzeROIod4bvx23KDLVGwuvDlFaBs/mRQ4kSRygTnwTmL3XujI98/Gz4/fKPZ9F1/8jul+s+8NlY3cGJ3Xjds9obNwe88RjdyYSbzY3N4+kzlHWJQ5GBWeFpYtDTUs0tPJrgmljf3Xuht9+691rF/MP5GfzyKv+b9u/4T/APc/wAVKjpyu+MfVPyVOW+RuwKuHCdMbS3BuLcXU+bSp3Fs7LHe2983uHsHYuSraKnWiqAsc4gKQwUz1MnuvdG+wnR38/qnpY67MfPf+XxVZVEUtgG+FnZdXt+ST9tmjfN0fe23Mz49WpdS06krzYE+n3XunmlT/hQjtWqhern/AJP3dOGpZ4/NTRw/MboLdGVo7yeUJkvJ3xt6gyHC6T9mYbMbgabv7r3Un/Z2/wCa31/XuvcH8myt3jtXHMBld5fEz5x9GdsZOqgBbXW4HrHuLb3x23PXWVbCmFU87ErxYsY/de69R/zsukKKgjqeyvhx/NQ6VrWc08uH7I/lzfI+eohr0Mglx8eY662v2BtLKSxrEzCWhyVVSyxjXFLIpB9+6903yf8AChf+ULjcimF3f8rq7rHOm6zYPt749fKHqXJ000esVUE0XYnS224WaglidJ3jeSGNo2u9hf37r3Tj2F/P2/lT7W6+3purYXy86o703xgMLlJNk9I9RZ5t1dtdw74SHwbT6x6z2pR0clfn93b93HPS4vG6E+1+4qlklljgSWVPde6Ml/LF+PHZHxx+IGycL3suHf5K9t7q7M+TPyfqsLR0FJSH5AfJDf8AuHt/sLAJLjcjlqLJ03XVXuqLatFVxVM0VRjcFTNGRHoVfde6IP8ACGki+U386D+Z/wDLzctWtfS/DvCdXfy2vj/ioZHNNt7CwYqh7t+QuayEAlloajcOd7Ry1NTU1VGsdTBjYHppLg2HuvdMXUUFTuP/AIU5fLrcNBHTS4rrb+VL0n11uGcTsaql3DvXvOh37g6TwXChKnCY+okfg6QkZuNZHv3Xuhg2BFL2F/woT+RW5paypmoPjd/K16J6lx2MllmkoqDNd/8AyJ7C7R3BlqKDU1LS12VxPWeKp6iSyzTRUcS3KJ7917pJfzipPkV8ju4Pgp/LT+KnyJ7S+K+9fkjvTtDvTvjvrpvLTYneXXPxi+N+0qUZzHrWYrO7e3NRVHZnZ/Ym3sZjHoqmJJKylYVRajWohm917om3yf8A5dX8i7+XjiupeyP5nO/PkZ8u+xd87gn2P1HuD5fdo/JP5adi9hbupoKCtrsBtjqnrimqdsVpqJ5qZG+4wH2iS1kUDzAzqr+690ktm73/AOEhGbrsrj5dh/BTr7PLJ/Ecxtvvf4/7z6Sz+MneKlpmpkwXefX+zamhQBFKU9HGKdzrmjVgzyH3XuseI6z/AOE2k2YkpPip/NB/2Rt92ZEZDM7e+In8z3f/AMbdl7kyMhiiT73Z2Z7In2HhJpQioIaCjx2trtpMjMx917qxDFfyYNq53G4vc+w/5uf86dMZlIKPM4HcGA/mO5/fODyGMqAlZQVGOj3lszfG18viqmIo0bmCdJorAsyMwb3Xusnav8nTurs7rHfPSlb/ADiv5kWS6o7I2PuDrzeu2Owp/i1vzI7h2rvDE1m393YbI7tpvjntLcr0OcwNfNTER1EU8SyMRKSbe/de6uH6j6u2d0f1R1j0t13j3xHX/UHXuy+rtjYp5fO+M2dsDbeN2ntnHvPpTzPRYXEwRl9I1Fb2Hv3XuqTP+FE87b0+HvRHxe2tM8/cvy6+dvxD6g6cxFHLE1d/eDFdtYXsnO7qraXxVVRBtLZ+2dlVE+TyJhalx3mgaoZVdQ3uvdX6+/de6pk+JMU3af8AOI/msd0roO3ukut/hb8Kts1kFbFUxZXO4fY+7vkp2c0kMcd6QYKv7zw2PVS5c1UNWGUBUJ917pK/yp56Xuf5k/zp/mFGuQWHePzg258N9tLXLK9I20/gX0/tnrqqyW3KlwtPPgs72PvjcU5anBiaqSQF3dTp917qb/LfeXuP+Yz/ADp/lWmRGT2vS/IHob4KbBgqKelkm24Phx0tTZDtijx2RU/c/YZrtju+vknhCrGs9GqkvJG2j3Xug++WHYXV2e/n5/y6tkdkdibV2JTfE34S/MH5TYr+9O7sVtLGZLdffu5ev/i3t6kqJM5kKHH5jINt6DcD0NMmqqQJUSKNAe3uvdITt7ujqr5K/wDCiP8Al19Zdfb/ANldkR/Ef4bfMbvnONtHcuH3NjNrbr7pbbPStLSVVdgclXUkG7o8BipGkoZwtTS4+uSYqEqUY+691sae/de6p8+a38iz+Xj/ADCvkfifk78sNgb/AOxt7Ynrrb/WCbco+196bL2LW7Z2xnc9uHE/e4zZWRwGcNbFX7jqtZiyMUMisC0Rcaz7r3RdO6Ph1/wmn+HtXievu/umf5a3Um548dTnHbN7Oh62qOzKvFim88OVqcHuCtynYWVpGph5HyFRHKrKdTym9/fuvdHI6L+ZH8mPoHqGjp/jr8oP5bvSHSgqJ6qDHdXdw/HDrHZn8UaN5KyWrxOB3Bg6T+8MqxM1R54vvpHBMl2v7917oF+9/kp/IK/mD02zNp/If5Pfy8PkJQ9Xblbe+zdt9h/Ijql6DFZ6SmNBU5CHEZDe+LpM/S1FGPFU008dXRyxkCaIgj37r3Qj7W/mX/ySvjFtaj676y+Zv8u3qXZeHihFBsbpftjovGbaxieOKniSl211fk5MZSOsKINKwqwjAJGke/de6R//AA/t/KTr8iItu/JXN9h10EklLTVnVfxh+WPblJK5E148dnetuiN1YqqimWJrPDUNE62OrSQT7r3TDuT+ft8I6EGj2D1t88u7d1VbPFtjYnVvwB+VTbu3tVrCjJQbVpOwOtdgYyqrJquRaVVqaulHnYXIjIk9+691N+Nnxj75+YvyS2t/MS/mHda0PV8fVdHkaL4CfBrK5HE7vn+NdBnJaf8AvB8jO+8tj1qcBuD5X9hUmOplx1BQSSY3r7C6KZWqM29RU0nuvdXUe/de697917rUn703HvLaH8wP/hRZ33tbIYd6Drj+Vtt7Yux658gKz7Hu7C/Ho7kwmG/h1VUQJBkp8nu2hgdIHjWU1EUbN5JGHv3Xumv4v9SYyo/mW/yRem9pxUdBs74Cfy/vkz2ZkZ5J8vVNlt99w1W8fi1nMPRAUtPFRZrF5XpmrnrVqQtMqRvDE0jJEx917pP9R4fH9ydyfDisqhT5Da3yq/4UtfzC/mLsrcjAV9Jmdt/C3on5IdV9e1+Koi7PDSZL/QlSaZZBqp6ml86hFKr7917o+n/CdZMlujp7+Yv3rmqiqqMr8hf5tvzU7F01cLQzUOMpcvtDamPxYu7o8dBLgZ1QJ6YlPjH6PfuvdbDHv3Xuve/de697917r3v3Xuve/de697917r3v3Xuve/de697917r3v3Xuve/de697917r3v3Xuve/de697917r3v3Xuve/de697917r3v3Xuve/de697917r3v3Xuve/de697917r3v3Xuve/de697917r3v3Xuve/de697917r3v3Xuve/de6/9Pf49+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3XvfuvdUg9pJHVf8KF/iYlZOyR4j+Vx8o8piIG5WfKVnyD6ZxtbFAt1/fOLZnb9V1iHH59+690A/8sDqneHzg/k2dabq2H8kt4fHDe/zW7q+RXyF+WPanTG3dpZDsjeM/bvffcGP7r6rwO4t8YnL/wCjfdmM2+1LtPGbsx1KuZ26m26OahVWiA9+691f71j1rsfpnrbr7qDrLb9NtPrjqvZG1eudgbWopqyppNt7K2TgqHbW18FTVORqazIVMGJwmMggWSomlncR6pHdyWPuvdLn37r3SF7Qyu/sF1r2Fm+qtpYnf3aGH2RurKdc7Fz+412dg96b6x+CrqvaW1Mzu1qDKrtfF7hz0VPSVGRNNUCiimaYxuE0n3XuqEfiR8rv50P8wDr2m7N6tyP8rj44bOx+7t8dZds7b3btz5Z91fI/ojuXrjLvgt+dKdldUVuS6G2vtbsPZGepzBXpPmKqGqoqiCupFamqKaWT3Xujb/HT+X18mdmfM2T5tfIv5h7D39vur6wrOrdzbE+OPxcofjRsvtrDyES7drvkBXZbt7uncXb2U6umULs+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6/617Y2pRUlYyUdJT5XM4JadXjAeaU6ORFGT7r3R+/iJX4/ZHz92bvfL5nJYGh6C+Gvx5617ZzG68viopNwZbtfpv5vfPnsPCJSUAghphsR9+4GadnvGtNTxuT6gT7r3RZf5dG49t9Wx/wAnbL9gzUcWI+H/APJY/mBfzN92VD66Smp4fk32h1TV/czGdZKPGS4/a2Y3EkFcA0hgmq1IWOUhvde6ta/4TR7Py+2P5MfxLzO5aNKfdfaNV3h3BuSrDTNNmqnsbv3s3PYXNVXmZrT120Zsb+my+NVPLEk+691fB7917r3v3Xuve/de697917r3v3Xuve/de697917r3v3Xuve/de697917r3v3Xuve/de697917r3v3Xuve/de697917r3v3Xuve/de697917r3v3Xuve/de697917r3v3Xuve/de697917r3v3Xuve/de697917r3v3Xuve/de697917r3v3Xuv/U3+Pfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Wuj85/lH8Zvhp/PG+FncHyq7U2/0rsLdv8vz5JdT7X33vM5SPacnYWZ7+6Mr8Vhq7J46grKPbKNhEyE1Rksm9PjIIVXzTRHST7r3U7I/Cz5x/HTsPvrsz+Tl2z8a9x/FX57Yrc/YmS6v7a33n6LZ3xo+R/ZGIlp2+Wnxc3RsfZnZu3t09f7mqauLPZnZ09OtHU19LGuOmWkmjhofde6vM6M2h2L1/wBM9W7H7e7Rm7t7T2lsLa23uw+4Kja+K2TN2ZvHE4ekotw72k2jg5JsRtttx5OGSq+zp3kjp/JoDNbUfde6Ln82Pnh1v8I8d0/Rbl2B233F2j8ieyIuoehOmOlds4vN727K7Cmx02WbFxZXdef2fsLamKxuMgeqrchmcxQwU9JHJKvl8bqPde6KlJ2p/O+7ymhqOs/iz8KvgvtH+I1dJUVny17m3l8o+46rECESUebo+r/jBFs7qzBVc7TKhpZ+xMkYXhdm8isq+/de6Ijj/lZ8X/5LHZvy/wDkP/MI/mC9Qdk9/fNXPbC3zlvin8TOnMrt/Cbf3t1FtmTrKvzmyeqouzO3d00O8eysbBj4s1nd05bBUmSr8Uyv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PjJ1jNmqrYPRfW+1utNr1+5KumrtxZTG7XxcGPGYz9XRUeOoZ83mZ4nqqtqempqfzzP4ooo9KL7r3Q9e/de697917r3v3Xuve/de697917r3v3Xuve/de697917r3v3Xuve/de697917r3v3Xuve/de697917r3v3Xuve/de697917r3v3Xuve/de697917r3v3Xuve/de697917r3v3Xuve/de697917r3v3Xuve/de697917r3v3Xuve/de697917r/9Xf49+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvdahn8/342di/zPPl10D8cfh3h9l7t+QH8uDpvtT5mds1u+du4jeHXcFdv47Om+O3xezuOrkrsFlOwPkRuLqapqGwWfFHjk2zCa+c1FPKIm917ofPhN8DOqO/fi51P85f5QPyr7+/loZjvTasu9M90PsvNRd5/Dnb/bU2SloO3Nj7x+Knc1NW7doMnsvsPD5TB+bbdXtlKVIpJKKNYngC+690bTaP8ANQ7P+JuawfTn84PpGr+NOZmzOO2nt7539ZUGV3h/Lx7dq8pVfw7buWzHY4NXnPi1ujclYsiPgN+RUlPT/by1QyP2bxsvuvdHF+bXwG6N/mMbQ6Wqd59ldz9f5fpve9D3V0N3R8aO1I9ib12bvCoxBpcVvXa2e/he6drZYyYmrvTS1WPrYfFMxj9Er6/de6Khlf5TvyRhxWWwez/50f8AMppsVuDD5PBZyl7Ll+LXbTVWOztHPi8zFR1GV+O2EqcTNPial0ppoHWooqi1RDIsirb3Xuiu9Tfycfln8CqSgy3wh7P/AJeve+W2ht3B7Y2JS/Nf+X/sHZnb2Jw+1qaX+EfefLv4p1+wOwN15+R0WJ8huHbuXq5JJ5queeacnX7r3Vuf8uL5mYn+YJ8J+gflzi9rVWxantna2SO69jVkk002y+xNk7oz3XfZe1o56qClrKrH4Pf+08lBRzzwwT1NEkUzxRs5Rfde6O57917r3v3Xuk3vHZ+1Ow9o7q2BvvbmF3jsffO285s/eW0dyY2kzO3d07U3NjKrC7i25n8RXxT0OVwucxFbNTVVNMjxTwSsjqVYj37r3VUvwh3nuL4b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Hn4VTBKv43/CLZG2P5gPykxhaSfF9jd2Zvce5dmfCrp7Pfw7KY+rpqLZe4ds5vsitoK6OsxmVkxGIWWBvGCPde6ux9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691//W3+Pfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+690XT5b/ACf6x+F/xs7i+UXcNbNSbA6b2bXbpylLRGn/AIxuPKNLT4ramyNtRVU1PTVe7d/7tyNDhMRBJJGlRk8hBGXUMWHuvdFL/lNfGLsvoP405Hsn5JUdMPmb8xOxN1fK75bVyz1lbUYjsftGpFZtjqOkqMjU19RjtudA9ZQYbZ9FjKaokxVFNiqmSiAiqCW917ohncH8pf51Y75X95UXwV+blJ8JvgD8zc5je6flBtnr/G1eQ+QGzu/w82O7Ry3xiqa7CPgurW+QOKhx9Zmc9Bloq2gy1NJLDSPEkNPL7r3QM/ynP5fHxpxH8wf+Z5vjqDFboyfxo6VTZv8AL5zOF3r27v3uHFfK/vvH7Rxvany/7Y+UOB7Hy+4MRvfsPAbj7CxO1aSIRRYSnp6asMVBDK50e690cPN/yYa74/8AbO2u5f5UPyb3L/L3qDVbjqe3OhanCbm+QHxL7lgq6Z6/blBV9Dbz7JxOC6vON3DGIXqtpy4qelxFXVRY4UM7LP7917ow21v5gHZnR+9to9R/zJujcd8bcvvnPYbY/W3yj6x3RX9n/CrtrfmYajpMVtObfdfhcDvn47b33Rkah48Vh9/Yyix1fLGaagzmRqjHFJ7r3Vp/v3XuqOt8fGT5c/y7+5+7Pkt/Lv2dtr5E/HHv3e9V3H8jv5d+bzUPXu78N2tlKHwdh94fDvs2tNZtmj3b2A1JS5DObG3BSw43LV1NM2PyFJNV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697917r3v3Xuve/de697917r3v3Xuve/de697917r3v3Xuve/de697917r3v3Xuve/de697917r3v3Xuve/de697917r3v3Xuve/de697917r3v3Xuve/de697917r3v3Xuve/de697917r3v3Xuve/de6//19/j37r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3XvfuvdUa/zf5pe3u/P5QHwkw9fNDlO8P5hW1fkZvbFSU6VWD3H0R8Dtn5vvjsnb+5IXilQ4/Lbrm2tFCJAI5Kkol9RUe/de6vK9+691737r3VBON/k4fKboDcHZ2X+Av8AN7+SXxuw/cXbvYneW/tj9zdE/Hr5dbPr+xu1M++5d7ZvGQbw29sDO4ybM5Vg8kpr5qtwp1zszOze690vsJ/Lw/mpTrT1XYP8+bu/NZenmkZJdgfBn4W9b4M08iRgwvgarZu+PuZFkQlZKipm0qbBb3Y+690xdlfyivlT8l9pbh6l+YX8435d9xdEbzxWRwW+esOtOlPiL8cZt6YHJQmCr27uPd3X/Tlbk63b2RgAirKYRL9xCzqrxM+tfde6oKxfyl/nI/y0Pn3sj+VtkflZtreHww2bu7obobYfy67v+O1J3FuLZW2vmBLuZfjBk+wabF9kdfbtzuU29u/r3MbIiq6rOxYKlgoKiapj8SY+KH3XutmGf4ufzd6mmjoj/Nm6SoYx6pcri/5ZO2o9wOzlzIsc2V+WOY29FFGH/avjHZdK62ksxf3XuhR+G/8ALvxHxX7b7t+Sm8vkD3J8kfk38lMRsfEd3dob+puuOv8Aa244OuceuI2f/AOmultkdfddYGbDYlBTxVtVTZTM+JpEauaOR0PuvdWMe/de697917r3v3XuqxP5lvRvY1dtLYfzY+MuMeu+X/wUn3T2r11tqlqamhX5DdP1mFYfIH4gbjelw24vu8X3rsvGKcDI1DPJid94rBZGJ4BTzM3uvdF62H8qvnV/M823t3NfDfrzdf8AL7+Je6qZa+r+YHyW2ds3cPyZ39iYKytoMlhvjh8Wpc5uHb2xppshjHhTefYUtVQmjnSqxuAyStHMvuvdDj1z/J8+JGE3fQdl/ISs7j+f3auDqGn2nv8A+f3Y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W1Rna6PB1OPpHWETRxDGeaWuyNTVyzR+691K/lSbib5QfK7+a38+3qKyt2tvb5NYH4TdBvVtT1+JHR/wd21Pt2v3ZsLLpEJJNqdqd1djboysqI5jappxcExg+/de6PV/Mb+Wn+yR/DLvD5C4vES7q7C2/tun2t0jsKjxtbnMn2R3/wBj5Sh2B0fsDGbfxerM5yTc3Zm48bDUwUSSVEdB9xOF0xMR7r3Xf8uT4o03wW+DPxw+MdVkRks/1f1xTT9m7jlylVlIdx9wbxrsj2F3bu2PKZIislx24+1t05mvp/MS0NLPHGSQl/fuvdVKfy/+1Ny9K/yevm//ADb85jlqO9flbj/mX/Mjq8fvGanq5KDDYDAbxg+LvUcuYWdZ63aO2uout9t0mPoxIqUz5CeGAEvrk917qyr+UH0mnx9/lj/CLrqeHLRbjn+PuxOyexHz1bUZLN1fbndmP/0zdw1+VyFWWq6usr+0N/ZaZmlLSAOFJNvfuvdWPe/de697917rXo/4Us7er+0Pgn0h8aYd7ZbZeG+Xn8wb4a/GbdyYCmoqzPbn21v7sGryc+CwlLXKYqjKY7KbZpM3DGCBK+ICPeJpAfde6qn/AJzH8p3+X58Ff5fWwPiL8Ifi5sFflr8+Pkb0J8WurOxd6U1R2d3jW1dRvfF703Zueh39vOXLZLZGJkg21T0OZkwgxWNjgyqK0CRaTH7r3W5P051Vs/ovqXrLpbr3FUeD2L1PsLafXW0cRj6WOio6DbuzcFQ4DE08NNESkQWioEvySWJJJJJPuvdCR7917r3v3Xuve/de697917r3v3Xuve/de697917r3v3Xuve/de697917r3v3Xuve/de697917r3v3Xuve/de697917r3v3Xuve/de697917r3v3Xuve/de697917r3v3Xuve/de697917r3v3Xuve/de697917r3v3Xuve/de697917r3v3Xuve/de697917r3v3Xuve/de697917r3v3Xuve/de697917r3v3Xuv//Q3+Pfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691RpiPP3d/woc3jXS1kMu0/gn/LR23tmjwmQiY1cHcXy+7nq9x5DdW3SWlg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v3Xuve/de697917r3v3Xuve/de697917r3v3Xuve/de697917r3v3Xuve/de697917r3v3Xuve/de697917r3v3Xuve/de697917r3v3Xuve/de697917r3v3Xuve/de697917r3v3Xuve/de697917r3v3Xuve/de697917r3v3Xuve/de697917r3v3Xuve/de697917r3v3Xuve/de697917r3v3Xuv/R3+Pfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691r7dm7hxPxU/4UU9M7/wB8ZNtndV/zE/5fuR+Ne1cvVmWDbe6vlz0L3RFvzbOCzOUmlTGY7OZTp7cj43CxSlZa/ITJS0wkmn0H3Xutgn37r3VBHya+J3zP+F/zP7O/mV/y48DQ/IPbXyFxW0Ifnd8Cd0bnh2xl+2azrbAzYDandPxy37nHqsXtntnbu2ESjkwNQsVBl4VlCCeqqKdKb3XurIfg78+eg/n71tmt9dN1O7Nt7p2Hnm2Z3T0V2xtyfYPfPQXYMCzGq2J3B1xXzz5DbGbRqaYQyo9Rj63wS/bVEphmEfuvdHLyGQoMTQV2VytdR4zF4yjqchkslkKmGioMfQUUL1NZXV1ZUvHT0lHSU8bSSyyMqRopZiACffuvdUwb0+RPYn80TOt0B8G85vbY3wzXM1dD8n/5i235cltGl35tbCV0lBnPj98Cc5JFR5Xfe7+wa6CWgzXbGLP92NpYWKqbCVeSzdTRS0HuvdB//PL2T1l8Z/5DXyv6d6f2Ngtidebf6i606Q6x6/2tSJj8Vil3z271x1ztvFY2mBeWonbI7kSaaWRpKiplMk8zvI8kh917q83a2Fj23tnbu3YTeHAYLEYWI8m8eKx9PQobszMbrAPqSf8AH37r3T77917r3v3Xuve/de697917r3v3Xuve/de697917r3v3Xuve/de697917r3v3Xuve/de697917os/yz+JPTHzT6iqOnO7cXnpMRS7l23v8A2RvHZO5ctsbs/qXtTZFacpsLtzqXf+Anps7sXsjY+WP3GOyNK/AaSCeOelnngl917ohbfB7+ahtesNJ1t/Op3JkNoU60keKxnyE+BHxs7d3bSQ0a6RT1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wjl917q7H37r3VIvwymrO0/5z384Ltt6XybX6X2H8FfiBsncFJWxVePy+WxXXG9e+e2sY6BDJSZDau4e18XRyxK2lZDJqBY+n3Xunj+ZLVn5K/Lb+XX/AC48DWVLUO5+46T58fJ+KhfC5Gko/jT8KM5hN0bM2jvPbmTBnq9v93/KPMbOxcM0VxHDh68kEoB7917quv8Am1/zTviF8c/5w/8ALz6x+RnZu4qTr34k7B7y+SW+9lbK2Tl+zv4l8he29iL1F8bsPndt7docpkKXdm1tjbh3VnMc3jjejGYoqhiq1MDj3Xujo0H8/jqndFIMr1h/Lf8A5yPcO35IhJTbn63/AJfe88jt6saZzHRQ0uSzu6tvRvJkXKeIsFjCyBnZFWRk917p3pf5tXzC7Hiki6A/kbfzGM/k430+D5HZD49/EjGMGOhCMx2B2ln0a8t76YmCp6ibe/de6Ru7Plv/AMKGdw0Ii63/AJRXxY6zyddHUNTV3aXz42t2fj8G6IXgjzWN2Jt3r+qybSGyD7OqClhcsim4917pH/yV/gH8z/iDvf59fPX+aD2R1Pl/kd8za3rjeO8Rs3KR5HH9TbK6lxG+J6/GZzcS4jGbexWPocXnKKjioMTUV+NosZt+lJrJ2H7XuvdCl/wnmxtdu34Tdn/LvN43JUWf/mA/M75V/MCWoz6zR7hqtr707OyGy+vlrqednGOx8Wytg0b4+kgY0kVHMkkIAlN/de6ve9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvdf/0t/j37r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3SL7D7I686i2ZuDsbtbfez+s+vtp0EuV3Rvnf25cNs/aG3cZALzV+c3HuCsx+IxdHH+ZJ5kQE/X37r3Wr5/M87p7t/nKfFveXU/8sL4d7v7v2d17u/bXcHVX8wbsDetB8ddlbX716Q3DS7p23l/h3h984aLsDvLceWpKLJ7dh3NRw4bakL5KWNcpPG5kX3Xur1f5ePzj64/mB/GDY3fGyX/AIJuwwPtHu/qjKo+O3v0d3jtcnEdldVb82zXGPO7bzW3NyUs4po66GCWsxr09YieGojJ917o8Xv3XuqTv5o/x42h09Lkf5o3RvcSfE75j9QbaxOz5d60Gxcn2fs/5fbayOWocNsz4n919F7ey2CzHdWQ7I3XWUGE2lNiZ4d3YvMVNE2OndqenhT3XukcP5Y/dv8AMa65bc384Dt7saOi7B+1zkX8vP429jy9a/Gfo/GriPscLtXfG/NjR03Z/wAi+zMbLNPkctl67Px7ajylW1JQY6aioaWrn917pZYH+Ur3r0BhYKH4T/zZfnZ1FHi4sbjdubB+SdZ1j83+i9ubXxFJT0ON2hg9i9sbPwPYWAwFDQ0cNNTpjd50LUtPHohKXJPuvdVo/PGf+Zx2L8rP5bX8tb5ab6+CvbvVnyV+XWwO6Mzmfj5tDtzrTuDN9R/DTKL3r2JjO1ept/7+7G2jRbL3RTbfpBT5LHZSSP8AidIaU05IV5fde623vfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Qcds9PdUd87DzvVvdnW+yO2euNz0/wBruDY/Ye2MPu7a+ViF/G1Xhc5SVtC89O51wy6BLDIA8bK4BHuvdU913/CfX4ObLqa7P/Dzefy1/l673ra1Mi26Ph18ou1NmY+eoQAtRZLrvfmZ7F6wrsBXvGn3dCuHhSdVIVo2Yv7917pK5j+VX/M5WqiXZ38/v5UYfE0lK8FHS7r+Mfx03rkw7sxMtfmIYdsLlCEEYBlpzKpDEONdh7r3Tef5d388jbcX2Wyv+FAL5XGceGHsf+Wn8aNwZimZ2lknkO44ty/eVwMrDxpNHpjQ6QQFAPuvdJV/jT/wpQ6J05zrn+ZJ8LfnH4TTVlXsX5RfFSn+PUFUxlEddicRnvjwktaUFMokhmqquDVKSG0KBq917qP/ALO1/wAKL+uZqrIdh/yavjz3Tt7FU0LVy9C/NjZG0MzknZofuKzA0O/q3c+UqUp01/5GceZ3JGh2Ckt7r3WWD/hRDtrqTITYP55fy3f5inwpyMcMJh3LnOjsh291Nkqv9yGqocP2PsNYf4w61yCKCSmxskMwcMzRXCn3XunFf+FI3xr+0Wvk+B382yCiqTM+Iqpvg5l/ts/RRqjwZLD1Ee+5IJ6GtjkVomkaJ9LAuqX9+690pqX/AIUl/wAuuhxNPX9jbZ+aPTGTlSN6na/aHwv72oM7jhKIyn3sm2Ns7r2+dRkABhr5gT9CQQT7r3TFP/wqC/lNZr76i6c3v8hvkfuemhgFHsjpD4pd75ndWZytV5lpdvY2k3js3ZGOTM1UkBSNaqqpoHbgS8MV917pl2h/NR+WOAx255Ojf+E8Pzc21i89lK7fFRS5P/Ql0ZUbp3Fm4KX7zcO68K7yVce6spTUkC1kjx1+QvEqS6igA917rXbrf5cnx3o+1s/8i/kv/wAJ1v5vmWfsDeGV3r/oa63+S+B+S3XeSzefqXzWQzu6YtnLsrvLB5LJ5WeRqqnyWXqY7SMHZv8AND3Xurs/5e/83DJ4X5hdHfyxdqfyM+5/5fu0+xMBuTc21ajKR4fr+nwPWezcNkqmo7O3F1+OpNn0FfihkaOKhyVcueralcpWrEZKqslWKX3XujA/zjvll84M58lfh7/K4/lg7/xnV3yt+Qa5vvjufufI4PB7joehPjBsGtlw67lzeN3Htvc2Kixu992U9bCkqw/dVFRhExkXryqEe690vPh38nf5g3Sf8wrFfyu/nLvXqD5d1u4/ijn/AJV7B+W/UeyR07vqi2vtzsLHdcVmH786XoKmt2bhkym46uSnxmWwT09LJIKeExVE0tUaH3Xuo3/CkI5vcn8uGj6JwddkqCb5WfLP4jfGnIPicjU4quq8N2J3VtyryuKWsphdafL0u3jSzo7LFLBK6PqVjG/uvdWR9E/y6/gh8Zdq0+zOifiJ8fOucHCkazNiOr9q1Wdy0kUUcKVe492ZjHZLde6Mj4YUU1WSraqoYKAXNh7917qtr+RxneqOt/gL8pfk0y7P6w6R7E+dX8xz5NzZTF0dJgdhbV6swPe2+dvHLUENDElJQbR2ps7rARQiNFjp6GhVFULGB7917rj/ACY8cmH+NHyo/m1/JSrTr3df8xXsTePzL3jlt8T0dAepvh513h8vifjDtTcOWp5ZMfLtvYPQmLbOQ1ur00GZtIS0bE+690PX8ozZe4N/bF7w/mN9nYesxnav8y7smj7023QZmGkps/sX4d7YxB2j8IOqsnTYjLZPAw1eH6SEe5sgaYRzSZ3d+RNTqmB0+691Z/2h2NtTp7rTsTtzfmThwuxurdi7t7G3nmKh0jp8TtTZGAyG5txZOeSRkjSGgw+MmlYsQoVCSQPfuvdVafyNOus9i/gVtr5I9hY+lou6f5hfYvY38wjuKShrauux7Zv5Q5w7y6/xeINcWnoMLtbpBNrYqCkXTDCaNyirrI9+690Vn+W/8kOie8PmH/MZ/mIdtdy9W7Pfevd6/Aj4l0HYPZXX2FrKb4yfESRqfN57YgyWUx+XGB70793jndwT0s4aXyUtKQioEZ/de6u9w3Rnx0re06z5MYDqXp2u7o3TgMPhqzvjF7L2fWdi5zbOKo5KfCY89j02Ol3BWYilx1UY4UWrMRgKqLoqAe69065rvzorbdTLRbi7p6mwFZC0yzUma7G2fiqmJqaR4qhZYK7MwSxtBKjK4IGlgQbEe/de6am+THxwSmNY/wAgekUo1i8zVTdrbEWmWEDUZTOc8IhFp51Xtb37r3RYt6/za/5XnXeel2vvL+YT8N8JuGmmSnrcPJ8ierauuxk8lisOXgx+5qtsRLoYMVqvEVRgxspBPuvdVU/zYP5iHWnzE2P1V/K2/ly98bB7574/mLbkxPVnY2//AI97t2p2/gPjx8OsrXLTfIzt/d2c2llcxtugeXYIq8ZDj6iogrKigqq2aBkqYaNaj3XuthbpnqTY3QXUPV3RvWWLbCdc9O9e7O6w2LiHnaqmx+0ti7fx+2dv0tTVyAS1tXFi8bEJp3/cml1OxLMT7917oS/fuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3X/9Pf49+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691rnf8KaPhtur5F/Aag+QvVtHkc53L8AOwsP8AKjaOz/38xtne20NqVNBN2pg9ybGrBXbX3QuK2rQDOQmsoKqdY8PPRw2hyFXHP7r3VyPww+VHT/zV+MPTXyX6Ly2IyPX3aGyMFm6TGYrI4/IS7JzLY+nTcXXGeGN00+P3R1/mRNisjS6IzBVUrAKF03917oj3y0/lf12W7U3R83P5enZknw8+f1TQ0tbuDPY9Kmr+Ofy2bbpaqxPXXzE6ip9eL3bhc1E1Rjl3Zi4qbdmCFca6GaslpKWnX3Xug+69/nufFTbOOPWXzpot4fCL5t7WGOwu/PiDvnZu997733HuuveTH4ep+OOT6+2zuTG/IzZfYmappINrVm23q6vJyFITTxzOiye690NnQnSHcfyx7h2l83/mvs3L9Z4vrrK5XLfB74T5vI0NZ/oCx+UxlbgR8jPkfT4StyO3d1fMnfG2snVQUmPiqq/C9WYGufF46SfM1OZytT7r3Vq3v3XuqzvmD/M366+NnZOH+M/UfVXZ/wAy/mzu3Ancm2fin8f6TG1e4sDtybRFQ777y7BztTR7B6A6yqa6op4f4xuCqSaX7hJKWkqow7J7r3SE/l1fBXsvrffHaPzw+cFZtvfX8xP5OQfYbxrMDkJ9wbF+MHR1JkjkNg/EjoatrUVcbsbaEEcFTn6ylRW3HuPy1dTNXNHFWze691bZ7917r3v3Xuve/de697917r3v3Xuve/de697917r3v3Xuve/de697917r3v3Xuve/de697917r3v3Xuve/de697917r3v3Xuve/de697917r3v3Xuve/de697917r3v3Xuve/de697917r3v3Xuve/de697917r3v3Xuve/de697917r3v3Xuve/de697917r3v3Xuve/de6iUtBQ0RqGoqKkpGq55Kmqalp4ac1NRK7SS1FQYkQzTyO5Zna7Ekknn37r3Uv37r3SV31vjaHWWyd4dkdg7ixOz9hdfbW3Bvbe27M9Vx0GD2vtLauJq87uPcOZrpSIqPFYXD0E1TUSt6Y4o2Y8D37r3VMH8pLAbj+WG+O8v5x3buHyeL3D8v4V6w+GuzNx089Pluk/5e/XO4agddY9KGsphPg9w/JHeOOm7B3FHBV19BVioxMtNKsaeNfde6gfyhMVT/IjvT+ZN/Mx3PSUeQ3L358r97/F/ovNRSR5XHYj4j/DLIN1HskbLyNRA1Ri6Ts7sPF5zPZ+GimNDXZKKmkId6dGX3Xunb+W9VR/Kf57/wAz7+YLUBm2xgO0sL/LS+O8VVjjDUJ1l8PWq8v3LvTF52nrqrGbl2t2n8i+w8s+OmhVPDTYBEa7l/fuvdQ/51EU+7N9/wAnDqiktNLu/wDnE/F7e+RolLmWq230htHtfs/Lt447u1PR1eHo5ZSQUCpZrBrj3XujkfzWPlLW/DD+XZ8uPkXgqqSk3vsrqDO4jquSCimyc79zdiy0nWnTUUWMpkkqMj5O0N34nXCgu8eq5UXYe691Ud81+i8p8Zv5Q/wA/k19U1dXtztT5m7m+N/wN3Dl9ktjf41gdn5anh7H+cndEeJkeWmyuAOztvbnfN6DIAu49V2LC/uvdG8/mPYDGdqZz4RfycuncbFt3YPyHyNPur5J4TaEtXRU3XX8uH4lptTIb72PWf3a3Bh9ybLwXf8Au+bavWGNq9MlHV0GVytKyuqShfde6uzo6Okx9JS0FBS09DQ0NPBR0VFRwRU1JR0lNEsNNS0tNCqQ09PTwoqIiKFRQAAAPfuvdUy/z5t7blf4GVnxW61yFRQ90/zFO4+pPgT1TJDQVOSpaabvjcqRdp5fcMdHIlRj9q4XofAbqnra1v2KciIS+mTn3XurfNlbO2715s3aXX+0MbDhtpbG2xgdnbXxFMLU+K27tnFUmFwmNgH4hocbRRRKP9So9+690QDGfyc/5U2My+6s838u74eZvMb0zeW3FuGu3j0H13vuafL5ytnyOTqMeN64LPx4GKasqHZIMeKWnhB0xoigAe690Ged/kL/AMnTcWSbK5D+Xn8cqeqd4nMWC2rV7XxoMVRJUoFw22cniMOiGSQhlWAK8YEbAoqqPde6XOP/AJLX8pPGU60tN/Lj+HMsa6bNkOhuv8vUHSiRjVV5XC1tW/pQXu5u1yeSSfde6wTfyUv5R88zzv8Ay5fiAryNqZYekNk00IP9Ep6fFxU8a/4KoH+Hv3Xuh02j/Lo/l+7B2/PtXZfwd+Iu2duVaaK7D4f45dQ0dDkRfUWykUW0AMnIx5L1HkY/k+/de6VvQvwn+HvxZz+790/Gr4vdB9B7i39FTU28cx0/1Rsnryuz9FRTtVUmNrptq4bFk4mmq3MyUi6aZZiZAms6vfuvdGe9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3XvfuvddA3JGki1vUbWa/8ASxJ4/NwPfuvdf//U3+Pfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691q49v/AB2+SP8AJb+b25vmP/L++NvZnyE/lyfJ+irsp80vg58fYodxb16l7wjqJZovkV8cOpqiegAjzlAlPBWYTEOaQoKunnSlokwb4f3Xuq/vkt/O4/nN/I/bnzJxnxs+Me1P5bWy/jx8QdwfMoZ35T7Y3rWfKveXQNPuHO7NxO4tg7dzG3/7g7Y3Luio29laimjrsNWUtJJjHSHJyERzy+691dd/LY/lD/Enr3MfHr+Y/nsr3v8AIT5h77+PG2c7mO7Pk/2rlu290HMdtba21uzKZ7G0GaibE7TzeBpq2rxOKOLSnWhxNfU058zyGb37r3V8Pv3XuqLf5rvy6+b22/kb8KP5dv8AL/pNobT7i+bC9q5XsP5GbwwVHu1/jX0j1kdnQbz7O2btHJ53Dbezu8sNjtz1VZRxZZamkqKmigooqeaorVkpvde6sK+FXwb6W+C/XGZ2Z1ed07u3nv8A3BNvvvHvjtLOzb17x+QPZtcrfxXsTtvflaiV24M3VSSyeCnRYcfj45GjpYIVZ9fuvdHI9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvdaj3/AApv+d22tibp+F/8ujs3J9gdUfF75S9m7D3z86u+8RtrdzYWj+K+3OyMdj851Vtrce2cPlK+qze6qvFVVZuGPGn+JYzG0ePSSGppMxLC3uvdGt7t/wCFBf8ALB2j8E/kPuL4LfJTqrf/AGj0p07Bsn4/dEbb29ubZu6snv8Az6Y3q7pPA9f9U7027sncm89p7c3dmsUchHgKSsjx2Hp5JH8aIPfuvdCFn8iv8jX+QntHaOJpUHd/TPxv2/1f17tzbNGN11O9vnB3i0sNLSbZwsZFTuqmzXyO39WZaeCBZZ3xMdRKEfQQfde6NH/L+p/ix/L5+MfxV/l6bh+RHx829391x1Ntmi3p1tXd0bGp+wd2du7nLbp7g3Zjto5rcw3jkYd5dt7jy9fG3gk/4FqikgKPfuvdFZ3nXUvy/wD+FBfUuxaItk+vf5SPxN3n23u+ro5ah6Og+VPzbgx+x9k7O3PQ6BQSVOM+POFqdwYuaRnlhlrJDEqkO/v3XugX/nc/Ijpfdfze/lB/y6uyuzNqbD21vv5U4v5n995Hc26MVtnB43q/4wYHd+5usNob4rc7X4zEQ7X7s7NxVXRQmSYOavb9o7SmIP7r3SiofkN8fvlj/Ot3p8g6Lt3qfeHxa/k6fy/t0biznbOM3dic7szYHfvy5yWQye/94Y/d+HrK/bNRgds/GLqCso8vVRVDGjnqJ6eSzwyKnuvdEr+BP86f+X5vb5C/LT569kdrb77N+S/ye3KnSvxo+KvTPRHc3d3dPUXwo+OW48xg+ttuNgNjdcZpNn7o713tuDJ9g7ipKnNHFvU5eghhl8tK0a+691aJXfzYPmfvnG0+X+Nn8jj+YDvXH1B1K/yP3L8fPh7XvT6lRZ029vzsXdu6KfyEkrFV0NJMEsXRDdV917oIOh6j5y/OL+a50N3P8xfgL2T8Kem/gt8Ze6NydUYvc/aWxe29vbw+Uff2c211hl8zFvfrLIPs/cUO3+j6PLU+PpWgerxstXU1DtEtXCJPde62Kvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691/9Xf49+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3XvfuvdamP8ANupEpfnx/MlQosVBuv8A4SofMeuyUYbTFX5nYHeO5ht+qnpkb/KqvHLvKRI5mAMCyAAkMQvuvdX7fy06/IZX+XJ8AMplpGmymS+E/wAVa/JTPIZnlyFZ0VsOorJHlMkplZ6iRiW1tqJvc/X37r3R2PfuvdUe55H7K/4UUdf0EWKqKrBfFv8AlOb13dkdyUE8b0eL7E+SHycwu09vbSzwjiZ4Kur2D1Vl8jTwSupkRllQWRi3uvdXhe/de697917r3v3Xuve/de697917r3v3Xuve/de697917r3v3Xuve/de697917r3v3Xuve/de697917r3v3Xuve/de697917r3v3Xuve/de697917r3v3Xuve/de697917r3v3Xuve/de697917r3v3Xuve/de697917r3v3Xuve/de697917r3v3Xuve/de697917r3v3Xuve/de697917r3v3Xuve/de6xywxToYp4o5o2tqjlRZEaxuLo4Kmx9+690V75BfCb4qfKjL9Obh786R2Z2HuP4/8AaO1O5Ontx10Fbitw7H3/ALMyUGXwlfj85t6txGUrMG2RpYZa7C1ctRhMo0EJrKSfwxaPde6Kl/M5/lQdW/zUIvjrt/uvu/5Adc9c9Bdh5js2br/pbdOC2pjuxN11OKo8dtjObhyeT25ncli8/sMQ1SYnIULRVFLS5jIxoVlqI6in917pHbT/AJBH8n3afX9b143wS6Z3hS5b7qbO707JpM32L23m8nkbPlM1V9wbvzOW7KpMpkqrVO70WTpY4ppGMKRA6R7r3RhfgF/LW+NX8tnbPcW0/jdDv5sZ3Z2rU9rbnquy94zdg7jx9SNvYbbGC2Zit3ZWii3VW7H2hiMMExcOXrMrkIXqah5KyZpSR7r3Tx8oP5Z3wH+ae9ttdkfKf4q9R92792jhKbbOB3dvLAvNn6bbVFlK7N0W26rI0FVQ1GW2/RZbKVdRDRVhnpYpKyoKIPPLr917oUejvhp8SfjNt3ee0fjz8aejOlNr9jCnXsHb/WXV+ztnYnfCUlDWY2li3dQ4TEUdPuOGnx+SqYUSsWZFjqZVAtI+r3XuhZ6+6s6x6lw7bd6q652H1nt95RM+C6+2ht/ZmHeYBgJWxm3MdjaJpQGIDFL8n37r3S89+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691//W3+Pfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Wnp/OPx/zlzX8zX5H4T4p/CDfPyY252l/IP7m+L+9d0y75x3UeyNo4nt7ubeVRn937Z3pu3D1m0t89g7MRKDwbMpKqlzeYhqZZFtDTiVPde6sn/kJfPfqXvj+Vd8IYN17i656n3rsbpzbPx/otkZ/t3ris3Ju2l+O2Kp+nF35j9u0mdi3HhKLdz7Ilq1x2RoaStpjrKJNRtS1tV7r3Tr8j/59Xxm+Inza7G+KHyC607j291t1t1l1d2Nub5Z7E2pmO3eodmRdpipGEo+18Z17hsxunrfG1U1MYKLIPDXJXThh4oYwkr+690Qb5NZX+TN2R8j9yfPXoD+ezF8LPlV3ztnYuNzG8ejfl51VujrrddPsPbVPtnaEXc/x43tBujFTYbGYejp0kw+TbBUyVtMZ/HFWS1kk/uvdYqH+aH8uepsvtzrvBfzoP8AhOp8v6ODVHJ2F3Z2LuT429g7rp1VxFPnsr0F2Z210dtzLVJhYmKmxkEauVVY28qBfde6m1H/AAqU6a6G3qmzPl5s7467kwFNDSDJd1fy8/mp1X8wtk09TXVcVFTNP1/nMX0z2c1LHNJrqP4NT7ikpYB5XXSGCe691c18B/5uHwG/mYT70xnxC7wg35urr2jpcpu/Y2e2pu7YO9cVg62oio6bcUO3t6YXCVWa26a6eOnlraD7qnpqiWOKdo5JYlf3XurJvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvdf/X3+Pfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3WOWKKeKSCeOOaGaN4poZUWSKWKRSkkckbgo8boSCCCCDY+/de6rgy/8AJ0/lSZ3J5nMZT+XR8M6nI58yPk6hPjz1lS+WWZg81TTQ0m3YKfHVcr+ppqZYpWYklrk3917pWfFL+V78B/g7urem9Pij8a9mdL7j7E24Npb1rNt5Pd9bTbh24uUGZTE1uJ3DuTM4cU0WQGpDHTo6JeNSIyU9+690JeJ+CHwewG4dybuwXw0+KeF3XvFqxt37nxPx46ix24d1NkWd8g25M1R7PhyWcaueRjMaqWXyliWvc+/de6k434O/CrDbZyuysR8P/i5itm52Cppc3tLG/H/qeh2zmKWsjaKrpsrgaXaUWKyEFVE7LIk0Tq6khgQffuvdCVjuhOi8PszA9cYjpbqbF9ebVSGPbGw8d1zs+h2ZtxKeN4adMDtemw8WDw6QQyMiCngjCqSBYH37r3T9tXq3rHYldV5TZHXOxNm5OvpI6CuyO1dobf29XVtDFMaiKiq6vEY+jqKmkjqCXWN2ZA51AX59+690u/fuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvdf/0N/j37r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+6910QSCAdJIIDWBsbcGx4NvfuvdeFwACbkAXNrXP5NhwL+/de6//9Hf49+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3X//S3+Pfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691//09/j37r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvdf/9Tf49+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3X//V3+Pfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691//1t/j37r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvdf/9ff49+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+6910L2GogtYXIFgTbkgXNgT7917r/9Df49+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3Xvfuvde9+691737r3XvfuvdcH+n+x/4g+/de65+/de6//Z" alt="cover"></div>
        <div class="body"><strong>GRID </strong> is grooves, research, ideas, data<br>
        <strong>GRID </strong>is the anti-dystopian&#39;s favorite rag<br><strong>GRID </strong>helps navigate a complex modern existence<br><strong>GRID </strong> shares everyday experiences, like great music, to build optimism about the good in the world, and grace in our daily lives</div>
        </div>
        </div>

    <div class="cell rotated">
      <div class="panel">
        <h3>10 Triumphant Songs</h3>
        <div class="body">Music lets us feel what we might otherwise repress. An oppressive world still delivers emphatic music. These 10 triumphant songs get us through our days with their deep emotion and explosive grooves. Some, like Galaxy Band, smack you over the head instantly. Others, like Isaac Hayes&#39;s masterful cover, burn slow for minutes (and minutes) before the horns announce themselves <br><br><br><br> <div class="body" style="text-align:center;">
  🪩  🪩  🪩 <strong>HANDS RAISED</strong> 🪩  🪩  🪩 <br><br>
</div> 
        <ol>
        <li>Kano—Another Life</li>
        <li>Galaxy Band—Gosh</li>
        <li>Solange—Losing You</li>
        <li>John David—On The Mountain ⛰</li>
        <li>Bob Dylan—No Time To Think</li>
        <li>Josette Martial—Let&#39;s Be Winners</li>
        <li>The Ray and and John—Day By Day</li>
        <li>Jerry Garcia Band—Rubin and Cherise</li>
        <li>Phish—What&#39;s Going Through Your Mind</li>
        <li>Isaac Hayes—By The Time I Get To Phoenix</li>
      </ol></div>
      </div>
    </div>

    <!-- Bottom row (upright): [Page 4] [Page 5] [Page 6] [Page 7] -->
    <div class="cell">
      <div class="panel">
        <h3>How Many Times Does Trey Say &quot;Mind&quot;?</h3>
        <div class="body"><br><img role="img" aria-label="agnes" src="data:image/jpeg;base64,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AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAB/8QAFAEBAAAAAAAAAAAAAAAAAAAAAP/aAAgBAhAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/xAAUAQEAAAAAAAAAAAAAAAAAAAAA/9oACAEDEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP/EADkQAAEEAgAFAQYEBgICAwEBAAUCAwQGAQcAECAwQDYRExQVUIAIEjdwFhchMTM1NGAkMhgiI7BB/9oACAEBAAEIAP8A+7o9OhR84bkSD4OM3hx+MfBym8uMsusvNpcb+9q37oEiHMxQxrZVwMLf97IlSZK8Lf5DbAbFOtOQKbu74p9iDY0qSpOM4+9fc18eh+2uDevUWyH48qLXCv3rFyLQsXOIOkyEgmQlzpPOp0c5apGEwg2kanBSwueb0xTyCM5iW+hHqo9/5nGubX/E9XhyXfvV3WU+Bp/w6Oes6Hm1lVLmQB8EdGRFhciI+GTgvwpuxKO/TzOGE63t2atYm5LrbiHW0LR96m/5r2MAIPNhh2Q82y1VQjFfADxrHRtGvZOU0ihHGnbTk1W/gJH3qb0WvN0aRnlq4TgpdhTauq1iMhbIXHY08TfhXke0j71NyT8S73PRjloAf/vCOere4rEaywSCKDAyQuQGPj71NrfqDYeenxqYFIhude+Rnv6+Ono1X+oNe+9SXMiQmFyJmxZ8MjdTkuHwlKlKxjFWHtDa2GiN9W04Hx1DMpxpaHHlXmNl7709+jcuBQxDHKsD8E7EIg567lDkTakdjMaJhvuWyTKR96dyCfPasYG45adGZn3ocvPWRxj5UR4/D3/sbF96mcYzjOM3gQ2GtpqC1xoCCzmYen56yOMfKiPGgPZgIbV96u+xOWigsmnjRhTMW3rhdFotIurj0TiEWTHlxmJMfla5yhtYMzk6QjR2qVl5H3qbgFJI0mY6nirE8i7GInY5EiEUZAlT5d7uEi2m3ZudQbEUNkoBF+WzZjEKinVu6thsRKKG9z96kqM1KiSI7pWC4PJTIbnFJJfM6iDk8tx3dwmSWChctRbByZjICT+N4T8xqaiPxWIkeFWwseP96u5xGB90feRxocnh6uT4GVe38ufYT+O+Yzvj+UWVIhyGpMag3iHbRX58bumsvn60Lyyy0wy2y3ymTIkGI/LlHN516F+dsZN3pbXX/wA8X+eF44hb1tzL6VyQm+RL2EILiTQg1G+IG/eZvQGuZWoxJHGjSmIlsdhq42xX1hrjOXjlCgy58tiJEoNMi1QK01xKnrN7tYy3yNGxwUe+QIXi9ErYRy4vpB2AuAmYljKLeRluG4cR95dkDNnABUYtxtba1IXVy2Q1gFkeG3EONIWnaVOzZa5lUbOMpznGcY41HQEBobJ2dYS7QQESKO6YZmzb5iZz3FbsmDyxUfrq1il1s1EJxoU6NPhRpkb7y9thflF4J/l41yc+eU4VJXxuekfKiWTsPTlD+ZykWKfxvc5mICgiGtAQGlSz0/PFqMIB1wqTUtalqypXNlp151tpkXqC7kWPfcG9NXEWw6+0806y6409xouxpmBZQZ/7y97g1SwY8s1xoKwYQ6VAr4Lihpkc+Onxo0eKw1HjcbRsOTtvnLToyF7invyVcbvILjUrDCOdWqRi1EPgxtN16EqcdCmeV91qKtMN5+MRHTRk1+FN1zY1V62jpWfvLMDmygkhAdnQ5EGZJiSKabwBtAgopC23G0LRy2BYWa7V58vKlZVnOc63grH0avsL4/EFMYVNrsHHIOKlmCcQdEqNXiVgKwPY6NvUto4GWTiY4o5v59VBBBf3hSJEaM046/8AxrT+IJ8ARfyzC9uM46t00x+GSdsbHGm7ugoJSCmcKUlKc5zty5MWEy3Fg69qDtqPtRlIQlOMJTxuiW+/fZrLvLQor35soTX0qThWM4zZh2RlhLQc6DnLWENQs/eBaLkDq8XLpCybns5Ra0Dpc6bNfU/L49uccV69WevOM5g0fbAiyKahTuibCiz4j8SXftOzQ/vJ4Jl+VCkoeYCb0sUGMlifbdr2SxMvQ0VGhnLVIxiJW64LrYtqAP5XadghbT8pHLUInA2jD1K6t3D1xbst/Ohn2GrRPac+7+9XGNUQ2ZizBkibIPz5/ShakKwpOptlPk1rCHOmya5qlhXl2ZP/AA/Z/Oj4EJo6vwnWHyMSLGhx2o8blJkMxY78h59WFPu5TyEwEjRA4e31fiBHoRNATuNK/qCN+7/+39c7KtGbJaZT7fQlKl59iVoWjPsXwhakLStGuLr/ABYBQ672rvNaH1E++9yoQ9wjcwEdHX+IP/BWeNCssLtJB1f3fbELfKqaZkY6KFrIlasomPAKZWq800kcYrQA4hSSd70y5BYfJV/jWdozXLRFeXjOM4xnHZ3FOzDok5OOWkoLEu8tLc6/xBKZxDruM6AhMZePTs/d9vedhirwoeeer9cv2GY0Unxo0eLHajx+e3tcNvxXrGJ418byap4mZns7+mPMgw8VHL8PzGcP2B/PX+IP/BWeNEMMIqc19P3fb/nPYeBQOdcCST5uALjjBkMTAij4XQpOFYzjOxAjYS3lYjGgTDOGjQhXZ36w8sOEeTy0TEfj1OY+517/AJzmSwWBxrKI/CogBl77vt6zn3raxFVy0CJ9r5kqvq38NwicGIo0zPVDvkFvHZ3l6Gb56ugogUQKhHK93+FTvlmHQpkcbGsEB/Pc01cm9TWsi4SRwqAPR9323SGJ15I+zlqOAuFRhv5+rdQ7EymLf4q0huLZgT7n9/647G0sJzQD/t5V+FHhAhMWPwTJRRkCVOl2U/NsRmWTl0W9EagS960ENDjQ9gjA4dcbbbW66Eck2LZsGTj7v9juNu3c6tvlV4LUCuBojHVf4r8ilnmmeIkiPKhxpEfsXSAxPqJ9h7lSJUiXUAL7/G7rgmTKRW4vKi3olUCXvWwpkcbGsEB+xDWA1OLScaPE4mW9U1f3f20UkPYiQ5HA9lD8+Iy4ww3HYaYb6jf+mLcqb6Mq/ZIRETh82Et1GG3XEctLT2X6OwzglOaHDZs18jNdnz5cx3nqmnSquBezO30cyhkYFb0GMyyJLks/d/sv10e5UyCwQtQSI91rQh1C0OEkIQRmoRTfRlX7VvhMwLSdiMcaAnNZGHYGLjBfmVQ7FY56g14t99mxFVKQlOc5vBvJ20lZ2NYDvl9GBtZ+7/Zfro9y1FBYmXwVh7rUpKE5UonlKiU7Kab6Mq/a3ZAXFvT72eNCTnmrOQiYzjGcZxnatJVWTan43GtqQ/azKMuRYkeJHaYY2nZGgVQmYwKgqIE4UPDTeGmWWsfd/u5CUXhzGONUkMQb2HV0e3GM4xnmbx7QZfPKm+jKv2t7gcygEAsjjXRLI27AX8cWSvQbEHlDpuKDYc2t2tIq9cg1sPFHQ+NyWNBm2uRmNOi8zrtCdz94G/WWkGwziOK/LfhHBclnGcZxjOOHXWmWnHXb/saYYszEsRr3YcK3QctO8rtNfgVE9KY4p6coqVbQrsnxDZsISGOzoUiBMkw5LLzrLrbrQgiyVFQCLPHwkX4v4vlsKyprFZmTUZVlWc5zoIV7uKXKL+8DfcJ1YQTLTyrE9mfXAshnjdVzcgRkAIfA8hNGTWJsPX2woVtg4ae43AQXBo81COEZ9qce3kUMCxEVUkib3wJYQtsPjf5zgbv9n8iMEa/saoHltNRee7aSn1NB40eeROqbozPPa9w/iI/mMxjGc59mNcglgaeNiOfeBtMV8zo5VCeWpJ7syhjMucXKbJnWk2/I5DiM0ZNYmQte3dm3h8ur3/PThkEOxTI7sm215prle9hjKhHbSqxWgzZJy5RLnjOU5xnFI2wbr77DBAbPiEx8WdF4cbbdbW25s/V7oBx0sJplrl1U6wRYBHBh0awRHcbN2TBCwJokdnOc541TU82CzMuv/eDPipmDpkRRCE8PnS4b/GgprSwxmGvjYYd0PcDDC+enqOsEOUZmbfJYn3oglOmoC5d7gup4v90ZqQbL6SRKaUnSJs3q03d8CCPyWbycbbdbW25fdNTIr0kjXBZ6xVyQ58A9sy9PsuNLccW6tbjlZrJSzFG4ECqViBVg7Q2H94W4QmBV1mLRxoQgtmzz4eON31Nc8SydY5afoOCsnB4iXItDBc+e9MlPTJcmW/oAb7XzhFfGzrI6ftc1XRWambs0vMcaI0XWojftJnNGViTFxgVb9fn6q6r4pKlIVhSdeWdFlqsKYvnZ6JWrNhCiE7QDC1pzAEaFGsu/nKCgosNGxGHfeHu8BghV2ybfGvJ7Y+6gX3OJEdmQw8w9fqour2KVCTRKTNtpXDSIUOLBisRIu8jiIdZYFp41GGQMpcFfDjiW21rWYkNSi5KS1yptNKWwniLEAABleGMjh3KVFjTIz0aTs7WzlXk4mjtL2NYq2IgL+8qXFYmRZMWQeDygZicMkx5D0aQzIYFz45EXBnM8bGpOLcESw1UavBq4ePAjcbXPNmrlNWyBEumTEAa3DisxIkeMzNxj5bNzzaacecQ03RKtHrFejQ09EqLGmRno0m0hnqtap0BAAsyaCjCbf3lb0q352YlhY40xYPmVPRDXz2GfUAqZKY1nOc5znOjK04+TknneJ2fYPmKzy1IJwSuw/K+rfgnEY+MJI0WYdl1qbAX95REfEJQJMGXbK7Krh2aNfqNqIVUy0SiU+5B7XAXKg8ZzjGM5zuC4MHjbUKDAgyiExiJEqwFivAYAtni+ei7Nz0BAR7TpHr3kNXJp7MpGjCXwtudi5+8vY9IatYXP5H2HozzjD4ssQEzGpcGtb2jZirRYrltw5YUKiw+NP6+fFIyeK8r56Ls3PTUHMOhw156thwY8ykWJp6mT0jrUElq+8y96yE2ll+UzYqNZq7I91O/rjPA0IXKPtMQaBp9sU7HKned89F2bnSokeJT660x1EokaaNnxJDD7jDzTzcJ1b0GG6v7zcgAOM59sdiPGaS0x0Xz0XZuSMYytOMxo7EWOxGY6nv8AC/yps16fVAMp/wC9O+ei7NypaMLuFbSrre/wv8tf+ha196l89F2blp1h92/ilo5ocbX+fCecpaERH1L41/6FrX3qWCA0RAFYLnGi5UZi6uoe5XG1QqqGeIyans80FPSZ0wWTHlYDE6DyvTjTdMsineNf+ha196k3GPls3PKml/ktpCkM8PPssMuPPbBuz9uNe/xxT7kVqhNEuJXLGKsYxogP43VOZiUSUyvgKyywGGNM/emtCVoWhRthqOZJsM4znGcZxWS2DVdDkONykJUCkPfDc6dcSlTKJlw6+dHWERHJwN/k/wCgAYjgZ/rYH3q3eBkdbjsXPGkC+JlRXCXueA9Mor62udLqM22GEQWBY2IKHxoMXbJpRa7Ecco+z6NDixozzm8qa0+tGIO5aPLQtTo8qMKM5eH/AHo7agLhXorlfGhi/uD08auVGYlxn4r9lATa6ali5nAgQQNEGIECm1OBVgzEKOcKMCA5Ai7KkvSpL0h7oFFyQiWiWP15e2LgJWtf3lWGwjK6LdnzrJuCzk5mVDoe0LxFkIe4pu64BBTcM+lSVpwpPG+R6GLNBl44pBl0JahM5vjdNN+ah0HoyELWtKEayoaamNW+/wAbzsC4QaGIZ6GAByQyh5hSVJz7Fa2srldtUJ/7ypEhiKw7IkXq4ybWael55622ZJrMnEIjGkx5cdqRH3JWnTVW+Lj8YznGeKaXZMVcRNbcbQ62ttym6ni1+xzyT/LZNmdsVqnP9Aoe8TJwoDMKIzChRojO7QTL9N+NabWttaVoCy0TA4ySj7yN7l1xK3AHI5afoIE2JnFS83V9IXDlJjPMrYedaXpy7vjSrQGY42h1CkL2LUHqtYno+ONBncuwCgZzntK0Zr1Xke56NMhmydzaed4vMJubTrCwvjXecfwHWvvJ/EH/AIKzz16LyLpYKJnjbIhIu7k8IjvuR32nmxkpUwWPlKs9aE2cU5AnnQRIATfHkNan0ALeNlO4z7ee07X/ABHaH/c9GhxGGABEmrhft92vGJcV+HKfjP67zj+A6195O+WGc1GC9yFw8TycCFltPu20I5b9DZWyHMo41ktKqHX88rtSRltGe4kWSqmqzNxFJ6t2jGkw2Ax1KkqThWNpbIjA4j4cdwDqdgPv4ZG3LWJGpBoxCXyqIn5NWQw7PK/D3B9zsEdzXecfwHWvvJ3JDYlUIi6vjUw5U69Cs45bPE/NKOZQnjSLjeaPhCeRyviD8LMQnddQmQGVyhsaXZ3HvhIwTWlzsL6Xl13S1bFLbfnsstMNoba2sIwTopb2cUYOg1bQo93+39MctzwERLzKcTWoTECuh4jP3kW+B8fVD8XloOA29YSc1XJ9liQ08y8VgOjSc+A7pUTiDT0yV9GI8dLinUcyMJoiPmwnpcV6JKfjPgLCVr07M0b/ADgv3H84L9x/OC/cTjhO1H4D5Zlltllplv7yTw3Ik0THcCrAbDOJWN/mpsDgfuC9Q1uLV/PO8cGy8k0VlkpNLgIHVIFFT2dqCPlN3Kox0anHpnXoThX3lbsF5hXRcrpAwXSJoZCaSlKU4Sns77Bp9go010aCEL+JMF1feVvQHiXWopRPRpYRmfc2ZKu1aQTVgr88WoiPlDZ0iFK5RIkmbJajRqDV/wCF63FgL+8olAYIjpsJ8sMkiSUwfJ56RArHVd8g903bagWtodjxi227mQmKeZD7cug6Wl56k7QBWhaIvO7a7DWxpTyzevLcFWr4kJqO4lHUYdp2uwVUQlbP3mbmoLs1GLCNzjKc5xnjXFFk2kwjL6EJQnCU9G375KAsshx2c5VnOc8YxlWfZhDi214WjU2zHS2WABf70j+saedeXJkwNNUeFKRIyxHYjsoaY6dw/qGa56g13hTbNkJXqtrrdknQOGH3ozzb7FBsubNVoE9f3s7j/UY7y1VQ1WQpifMQhDbaUI29UWTdcdnscaAkY+APsZ+9ncf6jHeI0d2S+yw1UgTVdr8AY1w60080407cAmQNmKDMaB/3xn/tM0oMHMqenH95hIuUoERN4WtBZEuTWrGMsglkjB+23cf6jHeKqiMuyBsSee83Yi7m0hjQH+8N/wDZn32I7SnHju2KgJ94jBzd9lm/nQOmEJ093DszhCFrWlKaWE+RVYSNX9sxElAGRVypxfeoCK77sd/8go/AbetelL/IRgkYJCOiTC5bmhvsX8i44A/3ojo2QQXPvNhdXoD/AHpv/scqdDhtOOyi24aUMd90k1vY7Jx+QWVsh0wv85Ho1aFwYugxCvtmecaZaU45frvNtZVzOedQt5Wqk0TIYE5BPiIhOHxvv1hA4iSXIkqPJb/nxduP58Xfj+fF24ccU44tavw9/k+AsGVf9emlBsBDq5hLa1GgYTxP3/ESlv4Avt67FGsM8TCM+c5l2X16JAfCB5hlf2zbYLYF0YrhPKu1kvZJ/wAEMXpC6obWvhaFIWpC9G2V2EdfDL4/EIx/Wtvp6dKQ1x6Slxf/AE+YRgQkoVMVs+iNLWlbFsqz7DbzeLNW+IxIdLTjMb87fH52+HzoSMr8r+LNW+J9/po9xCJM/blGiNIWibvWrNMZVEnb/wAZYxiDN3hb3nsLizdgXKcy8y/JlypS8LkdoYPkEiESDGBimQweANa8uTIjxWVOyCOyaWOy+h6fvasssozDn7+kZWj4CfvS1v8AuvhP52Xvj+dl74/nZe+Ebru6VoyvG/jnEffwlbqEPQNvUaWha1wzQacpSIn9/wCuPs93+SylgCMTy0BAW2JOz88bZB5EXSf7ApJ0UWgEGo8lEmLHeb3nDkP01h5vobbU44htNbEoCARgxP8A0692lNVrsglgubKmZS5RHm2++3/6fGzOPjZnC3Frz7V+Fo+q4nFnzsnySJcWLYckTjW867F/+gwvuW4kWfdMzjBUi7lyb223XW8+1sRsW4iVoywF36j2JQZCXmpnFIRB+zvdZPE68Ps45aihtxaAKynjfwZbooQVRxSZ7s+ngpD11B5P1UuMblxJMOS7Gk89L03BIms5O/6fv8i1+cCNR5OP654o1aRWa1BH+RZb5W620v42y7wNTvayFIEpxKS5Jm+ClSkqwpNf2lbwfsQiq7grpv3Eec2tDiELR9nG6QWBlxcltcgkDI0KLgK4uYn5zVDcDHGqiGJ1DD55XfWoW1IVJ4s+vLNW1LXLUlSc+zNG1gYtC8vPQocWBEYiRf8Ap+/fUojytQ1fB2zokP8AjHrEHr8JyURuG5ihRDkQO4446vK3PGq+wrLWloxEp21K9YmkMSfs33eCxOqbRJHAGE0QOCYT2MezGMY4/v8A0zeROQ9tNQ+NL+gYXNSUqx+XMmuV6TJVIexjGMezH/UN2S5L17ksueTqmrfw/WGlveI4ttCcqVeNxwBWX4AQqXImJrsyf5P9cZ4pu3zgVaYxQEfFHRyJ4z7NSkFkiNnQXpMd6LIfjv6uwxi7iX5OLHXeMWOu8Ysdd43giDLLDi0PV8SPDowTDX/SC10q4SXiKSAWkFYsTPlfb29JYk30spnyKDXcWO0QIC0IShCEI8MmWGiYq5k+/wC0yFhXKgD/ADQFmM12YiUNouyRNpiMR1/ZruGuKDW5+QjppcFcCogojv8A0jZpBc+8nHFaRO/L7XmC529het7L5Oja6iIGkGnfDs9mF1kW5Pn268G7XJwqd58WVIiSGpEfWW1sGV4EnPs03LW1l6v8ax0RWFSJLDCYTKo8GHGV/wBHIScxIEyViQ9l9953Iue8NJQ5zA+czNgRZjHaKuuvE57jvjgRLpkyPGtD4MYdAiwYvhWezi6wLcnT7XaylpKLnTvoKFqQrCk6021iOnAmyNuNvNocb+zJ9ll+O8y5ba+9XT88Y7z1oEcMXIU10svsPoytn/oe1iWR9GKKxy0ed+Oq7o53szZOIkKXLzJe9/Jfd8jQ1eS7JInn/Cs9nGVoU9Om222lbUVXOnfRNebUk1tvA4jBmxJ8RiZE+zLZmvUW2KmXELhyQaa/Cn8RIkmbJajRtcUZmrB05e5PPMx2XHnr9uGWS9+OA1q3G63PalQKlcwVqhIdh/8AQt+EUoGBx6eWmTmRlxZjK7NkfYYrpp57x2GHpDzTLNUDYA1wWLT4M2ZGgxHpkq93mfbiP51/RqTsQzVH220BDY06OYID/syMBQ5phLBIho+oyHG1xq7Sa3W/9dyeeaYZcee2Zsx6wvLGDOQguQCkGJ8CgXfFsGuvr/6DvQkuTbGInMdMVBIQ5iYz6JMWO+jsbL9B2LyNL1tZSzpIueFta/5sRD5eO+kVe2mKyQalwarbgtnHtSoX2bbxKGoICIzD5NtOOrwhuh6bWrKJ9kiRI8SM1Gi/9Bvk/BC4npOOes5+CFEALx2NzOvMUWXlvx9UAPklPi5V4O4r7kbHXXx2c/SgpoiDIsEB9H2OItjPuMfZqUGQSw+TBm3Kmk6mTVFlVmg2SyrTmHTtdAasjC2v+hGyDYwKUnrccW64txznpKe1Jo7LGOxvYhliqRImPGoIDJ+0jYSkIShOEp8C92xiqgnpapkyTNkuyZP0uDOlwJbEuJrrasWyPJGlPsxsVoC1uHiSTp2zK9Z//wAMcigUUYifDkmmWWWm2mv+h7rLtwaYqJ06BnMLBGYPZ3/NYxEAwceNouvKhhZhh7wHXmmGnHXb/cX7YdXJx9NbcW0tDjesNrqkrSGsGM4zj24+y6+XwdUh3tyZOFTkxcsi06tpaXG6Jud/87A6xxpUaZHakxv+i7ssKClobgMdH4fpbKJtiiZ7G/8AKclAOPGEDXipWAOYEjYokbCHxOTj7LPs95M2HS4TLrq8bj19/wD7B2rQ5r3uUQC4oi027C7O67niFCRX4H0/GeNabXyERgWciyo8yO1IjfZZfL5AqI/25LFp5ie/OncqxVylnKNwIFXrcKshY4uJ/wBEutkarNcnEsvPOvvOPO9GiZTDF1eQ52N5euc+NomvKfLzDrvD77Edpbr9u3ipp5+HXiZwuWdy4Q5xpUmI8h6NU90mx7/ujgE+KPjG5w3qsRqOCCTij5ktMMlJZGX9R17s2dU8riSBRUeYHMT4P2V7qoxZya7ZI3KpUoza5a2YNSqguri0Qof1lxbTeMe8QtDmPzI7LjjbSFLXtK65sprLEXp1I80xsEGt3sbamPyb6YS74mMcUOttVurwYWONwXz51PyFg9dNuROpk8SowE2POiIhSF070tGHpkavR/qdOvZupyfbDrllFWMYzOH/AGVKSlacpVtDVaxjrhgHStVG7JlMmUDBjQI1geO5LdbaRlxxu+0tb6GERpEaQjLjX1S92tFWr0ggkxZDZyT8QRGWc+JU3mDWt8S0LwyeCWIKejYkDepxxDTalr2ds9ZlbwcR1Ub1nWOzsWaxOux+Qz4mq66s3bof5+Nn2JYCoTXWezpK15HG1hZPRYjUYEFnlHyM+SSnypsn6oAsBSvkmCA+l7BCWxhKGPsuPG4IEVKJzbdfTtnlPZe4r9pOV6Wh8dSLS1aq+wQx9T3wV9/YII5HMeSnjZKJMKo7zRhDEOwibKAMNYUPxnGcclrQjHtWc2fUArTvtt2yrBaP/wAXeuKtbchlaOxZvUhzxdIgEDq24Uc43/MexgBCx2R058fPiTGIMtM2BElp574sa1SYFfZ+rDiM0ZNYmw9bbQYsjXwBP7Ld/wA99oeBgdGkheYVPVKV9T2CSQSuJuSjpbddaV+ZuFebbBXHUxK2pepTDjDk6wnCPu/jOzjOcZ4rjrj9dCPO9UnP5Yz+UuuuPOuOu+GCFOmDA8a1BiNQocWK1xvZ17NvjMq7WrJrEuiBvycpkyNBhyJck4WlGS04lK+roWtCsKRqzaeJyWQRz7LN6BMy63DKI1TUYFnMT2SFj0aahrW6Gm1k9Ak/Dy66LbDARY1P1KS8lhh95U+TiTOlyMeHrSW9KogF1/qOzmxoMtOX4miK9l4hOOu8t/xWEFQcjHa0ojKKMz+flu8/kfWmhSPrOM5TnGcai2M8YRgEW+ysoNikxsyBK1fSpFUglmpXDrLTqMoc+p2qfgbWzUzoo+uC9pfYfVtzXUAQOhlw/f0yQXLo0VC+q74x/A9m8WhgEV2rDYPPd4hc2pNTG+1QIr8SlAGH+W4TfzS5ymkfWhhCSMIRJ8YTPYJDYU5n7KLntgLXlZixAu+hTzmEFRJ4KYbW4N+rbD9iKPYsr5Ro7smQ0w0GhIGCR8FmXEjTor8aTdqw7WLDLGq72hSHva4Ug56tsSnYlANLZ8PWVewftsBl3nPhMkIMyG+fBzgJaWNmditBZJ05AGsMMNR2GWGuDhJsSGIEXJMhyTJffc+t0H0TWvso2ltP+j4IFyDSicYlGUMhtPsworL/ANV3N6AIcwP+8E89q05Vjr/vI+fbjPe0BPThZ2B17g/Tox4miwKoICaUe6Nr6/xYYGS0POMpznGevTNJeFRFHp3LdZdcCn4jI+twYcifMjxI4Ua0LEwIDf2TbY2W6wuTXhHPSVdxPsqyb/1bc3oAhzgSfhJ0STxHe9/GjO45bbpqa6exKi93QsthmzEWF9W+HnWafCQjwhkB4kRhwmRQ5gWMhj2OnYmpoRhp8iEIjZwyY7Em9CEqWrCU681E8+5ELH0pShOEp5b7JYesI4en63pCoLflrscni47Xs0azmIwrVl3etAR5E77I5jCpMOSw3ZQZQEYlQSXCUqVnGMUrTU8l+SYdHDoQ2GxDh8e3H1XfTjqKyLSnnTSCidTBzHOVzq0S0V+SPekR3o0h5h/uabkMsXwf73q336RGeHpGvIIWJ4m91ma2COM4QTM6FGu+/cFT9GXBh78kZWkr4n+8DQEv3ntI17XlVrqveQui/kMkbmfkK+tUSkzbaV9yiFDjQIrUWJbTOANaLFOM541lYsgbdAdX/f8Arj7I7/QIFsge3ELU92lS1xlUvV4OtJRId5TZsaDFfly7Js4+TsbJKHQ76Pto32p+p79noWXDwE89FlMSaq/Bzz3fVflxpoyx3NeutM3WvuO9W/5zCAYWD4eo68oLUI63fAKzWh4ufOdWtS1ZUr6yGETTROKNhVKsQqwGjwI3G+zaWoAoM3y1bZl2GoxXX/snceQy0665sbY0q1SsxInAcwQDEGJ8AdJXLGwJDn1LaZb5pdyy089GGsQrO+OXzvtdzYqtPgIcbW2tSF9sL/uBnX+IP+9X8KqAnrBYRotppptlpttrwNqTHYdCOONeU0088v8AI0N1/cCXw+Y/8nL5x/Jy+cS9SXqKwt9REAbGLy3O8n+uc8ako6QQpJKZy20byWuk/CeWhzuIdimCl/ZPuK//ABb666L5a+rTtis0GPwlKUJwlP1E4TYDhyBF2TJflSH5L/MOSeElYBFmLKjTIsaVG57cr/ya3ylo7aVKSrCkjVKyLH5z0/iD/vV/C0ICyuWWNueDvuUwisC4ufIrev7RY05XBr2jQ8JbD5ceBBi0NIgdDrLTza23T2rKYYy4tVq03Yg2HZEB1pxpakOeNqKkYPFckpnKyFkiAZQmp11bzrji+QEq8HMjiLMd9mTHYkM/ZNsunP1exPI5JSpSsYxqin5rIH30n6lvWw5iBIYVrp0ef+Y1h0WvnusCmfUsEUdyhvvP0uvuu9P4g/71fwqBX0V+qDYfRua6SRDUESM/jq48fx1ceP46uPH8dXHj+Orjx/HVx4/jq48RdhXONIbfRWd3nIszODY+fCJQWZsPn+IN5rK62x44kMTMy0RR1Q0uKHoaknGWmmGm2Wezbtd16zM59/aqabq0vDJDxAomWZLQRkQEFggRMQZD5bwOfBVlgcjo1Cd+bUuIyv7I/wC39cltx1IYVxB4GlR5aGzMhWKvjbCKfHz7HXCdcJuwCGmqTgqR+ezfqSlJQlSlX0+qwWonNx064tGa1aIklaVYVjGcciEFifAlwX5cV6JLkRn+3qWc9MoYrL3T+IGc0osCgY8CgA8nLaJh5xjGMezHLOcYx7c3o28ctRSY52dK3RY8imvyue/PVQvxqVQC9uecyxXKwHrkBuIP7hIYOKRFxZ+xNdzKnNy8x4elaZmFCcPzue6i/wAfcVxkdGkLEodZHBa/sj2jtF5b0oGD4pd0J1ImmVGqNwE2oWmXDvVNiW0LmIsAFhBBkQZD+pbltjgQI0NideobV89q6Ij/AD3CJwNvM9SO3osi6/Un42enffrCB4Oh68hESedd520pgVWTE7txJT8OSxJYGykTBsKVjluRa1X8tjPia11q/ZX0z58SFFhMIYi96dBhkYT8OXsXXU2pTcvM+DS667ZLFBHJYZaYZbZa5EJrECDLmPkpzxGfMmvdESU/EksSWK6ZYNBIBJj7Idx3x0cjAAdzp0ezvGoy69AxORCZRO+pGC0EMMlEZtmsM2xmZZOX10S1P1ewxJqYsqNLisSY/Lf41WUACSO3oCe2ocdgdW+/WEDwEIUtSUJpodIOsC4GOe9CmIlUjQE9vUZZJCjj055bj/UEt4mttbP2Z9M+fGix4kdqPH8AyHhGRksdNudVl1U4+Of8DSlX+WA3DD/PcJvIumSWkdWi7amPJlV6V9kGcZ/Ln2XoKVDWUiyS5UrXhi2O4daAVsNXYXwgz6l/b+udq7BRY5aBw3s6f2IiAv5CY5btgIk0fL+e3oCYwgwahq6d9+sIHga1B4NXEWwvo3sWxJs8Ment/h+I5zEPD88tpz0T74ecR4VAosu3ElI4hQ48KIxEj+FsWltWsCtDTja21qQvvUyuu2SxwRyWGGmGWWWue+TDUk+OFo6o0l+JJYksU+zwrQAikWPsgu9OhW0N8I6Yo1lEllDHabpN7K0S7HDhRIMZEaJxMmRIER+ZMCbsGTbM7DlsPsyWW32Pp+09o+3MgCD7dE3HJFtMDTkK+02ZHS+jc93ElY0MKO7ejX22rqvC+nffrCB4Ggw3uoZY0vouRf51ajRHHb0kQbiXdplfK9es7J4QURMNFIQ2JV65BrYeKPi+Jueq/J7H8yY72jK8iIDlGXeec4xjOc2Qu6aPEyTvXrK6LrB1CX2nW3m0ut/WiecYGT+KZt4yEW1GJgLEKsYxmeN/ePKU5zjOeTzrbLanHNp7ERZH0jRvGsNlSK7IaFkMZwrGM4+mf2/rnYm38RnJgkAtSlqypXk6pWhF/AZX0779YQPAp4T5FWBI3PO4Ffk9VMkePb7c9ynE8irSEm89vMtM38xhHg6epqAwVJaR4u0AKjNMIoR3QomUZLQRsWDEjwIcaJH57NNpDU0s4ns6l2ZiJiLXS31on/q5/KnXAnVCiJcUOVhmBUMjD/eXdV4Wha6xD5UatOWSyQYHDTTbLTTTf0uTJjxWVvSNhbdfn5mCAfl1H1XXereU5mVeMMo72sgfzq5imVdG9CmYlXhwE90FPWSBiJzvG4/1BLeDq6r/AMRWiOl3GMYx7MeK62h1tbbloF4EWEqPx3NE15MgpNNv9G+zf/3FBGuylSkKwpOutusOsxRVhxnGce3H1gn/AKufzoF/n1GfwMJwC0CNOg/vJZoJKAfJxSXCUqWrCU6spSa0ERIlfS7Rbw1XhLkTrnsQ3anFNO+Yy86w8280jPtQnp3D+oZrv6AE/kZNl19G9C2JVojwEd3Uk3EugiMq43My8i/kVr7+McapquAFXYcf8fdsJ5i7OvK7muwuQtPFRF9GxC+S9xMycdugbekisRRZweRgkIbMqF9XmtqdgzGW32HGH3WXeWs9kvVaSmDOjSY8qO1Ij/vHt+iNGBazEHjTNEckS0WIh9KUtKE5Uq67nhwPzQwBEnPJylyp3nVeU9LrACS/0bh/UM136GF+R1MTBzzUpKEqUqzkclLEWnZ7ugCClhjUDPG/PVQvwNb11Vgto6NnyN/eoxPcogBVgtI2BwlKUpwnHO3lPlFYMTkrUpasqV3K7azdclYkDatuwGR/IwXYfYfbS4z9WN/7kp0ao2G6BntiyKVJWlKk/vGf1A9KvaEwocONCisRY30mz20JWYnvyN02abs61sI+ga0nrn0OvvOdG4f1DNd6kiXDFqEQ0YxjGPZjneSeBVRNy+/ogkmPZp0Fzj8QcJhEqvTEd/RVeRFBSzbvkfiBeayWCM47ehQeFPlDTvRvg3lgMPEo74S0ngT6HhwLfU9r3TZgHtamGFoax/f+uPqZv/clOnTmxG2cJrpb7DHHENoytd43JDge/gASROeVmPTJ30HShDMmiss9O4f1DNd7QYn3pQoUV0b4K4Yrw8cnvauIZgXoGvHG/R7C68HnZ7yEKWrCUgBTIcINGs+Rv/1GI7mtg6BFMDs46NvmWyt3m4a8LWm1ZIl9I0224262hxv6kb/3JTpaccacQ4jV1+RZhWIcz7CrNdK/WWkKI3PZhyzqWxj6HoKeyuuF4OOjcP6hmu9qUSgbRx+eneBb4y2ohJ7wqY7BJwZbTD7L7DLzW44zL1AKrX3tXifmt2EIV5O4ZqJV6IYb7VZFfOLAJHZQhKE4QjmaIJGByRDMiQ9KkPSHvD1DsRY6SgEW+pG/90U6qzYZtcNRCkQcRhkx8OdF+weVKjQ47smTd90MMYXCrk2dLnSXJMr6J+H6Ywl6xw89G4f1DNd0XBeIkoUJmJGYixmIzfNSsJTlWbUVyYsZYh4FJn4I1IDKzaoL0+tHIUfvaCHIUSMEV+Q882wy884cIuFDBCc52tFCcSrRLIL6N3m/gKo2OR4mPbjPGprxixhsxJn1AipaB05aHHFuLUtfVoiyrfhTQD/7xDrnXCBuWGjfQ7lsYFV2FoXab0fs77uZf0bQq2k2silfRuH9QzXd0qIVPujUrPReCvyeom52PA0lOQ/S/ccKT+ZKscGIKRxYjBT3dHQUxqc7Jx5GzTeQlNIvI7eixOIlVlT19G8Dnx1oZHo8UAbmAS0MnErx8dYBMchB+n3Ka7AqZ2Wz10Y4sHaRU3GM4zjGcfvBtPaGY+ZAIJFlyYclqTG1Ts1RxKApb6AWMDA0Vcohc90TSSFwwTji3FqWv6Ppr9QhPTuH9QzXd0KL9xXipFXRvsuuKDEi0eBoCcv2noOeNrjMjr0XTju6xhsRKKD915G+zfvSAwMjt1ETgPWQ8DokSGY7Dz7xie8SKz5r3hRYsiZIajRrJri0V2OxIlctY3t6qlkNPsvMvstPNfTt0zWo9HeZV2NXHcGqYNW7+7+1NgLrURuAPccW64txzjXI6YQuQZuL52c+zi4bgCBULYFnLKbPv++J/SdevOtXauZa6Nw/qGa7tOFfJqsEHZ6N4z0Sbr8NjwNLEsQ7swyvjf0BpsyIno7teix4dfEx2PHdcQ02txdqOLP2AkUV2qsLyXsYmBhKUoThOOe2yyxVJn5a8PUlDaDCmzE9SUrxnCtpaugIgPHAfLTuw0oSiul/p2/560oBDuzoQ5lkiTDL/d+wkiRQ1PmEuWl6gsMHcLzPNslyAVlpCyVx2kfsS1MsfSxEl+IVgSGOjcP6hmu5SQ6DVrDD3MYxjGMY5/2/rmzE8lrCWn+DSJ6x1tBSk8b1gZfqMaSnuR2FyH2mUQGFsQIbK/H3JYkCak7CR29KifjriiUro30aw8UGiEeFqKnIPnczpfLOMZx7M7c14sJMdNwOELUhaVp1bf1WmAqFP+m7hKYn3qehPKwVQmBYFPyemkmEBLWGIuY9mce39392Uz4OY1YIPGrqeuyWJlbyUpQnCU+XLmRIUdyRJum60ZaVDrcybLnPrflfTGnFNOtuYFyszBQ+UvnuH9QzXc0KNw/YSM9XReyXyynnZXhYzlOcZwImMThUCWxfRuSdNOxUdwP/ALcb5Gc4xjOc7ItGbLaJclvt6AgN4inCGealJSnKs3UsgxajM9HgjR8onPiwotZr0SvBYgyLznQYZCI/El3+lS6oZda5CicsURiz4lKuIy2isSmPpch9qMw8+8SnOkSM2c7xWg7po8MGt2aqwbBXJAhZgRPDEZI+f01UlkrVwc5X7vEhsInAkQptgpRQbbXALFQrMSsAow5jy7ftcBXsOsRbPcz1mlZeIfT6QRUSp4CQrnuH9QzXc0gM+EqDkvPRvmepiuDoWPC1XPfm0EIt1xtt1pxpw3BWPMEYa+2H/wBuN8jcl3wMgZAwukNSbSbShyAR1NeR7OHlOtOsuLbd6NRwFQqIN/Pz2EXcC00vNb8LSNOywwqySuk4DGnhbw+faKuUrBRyBP4qFuJ1UoibDr5+CfDxCcL6VtItgXRjSsctFBsy7NKKK42vQE2OB8yG5x06Xnol0KIwn933xo56dGnr75e3VsNj/wA+XvGpRvicMfz/AInH8/4nEPfghb6EShu3KRNQ3nMSdCmspdidFhtIStxPiSd22yXPLcijlKyrOc58ata6tFkR76Gf0pZBcVyVFzjOM+RqUgzLoQrDXPcP6hmu2hClqwlNYHYGVwPBx0b1Je/tEWD4egyKFgjEDluMT8vusp5PbD/7cb491uI+qClyHyRKaUmvzZvOLFky322I9D07HgZRPPtoQ2hCEcX3Wwu0RH32bBXydeJOjyHKBEXMmxYqIMNuDCixGue/jOENiAiPBpdbdstigjUw4ceDEjxI/VcqpBtQSTCfNBSIQi/An8UO+EKiQ/MkQXgFx8edB+k7+Lr+JDBk8tPBMiqXFdc4sJqKCCzykmZKdmS5Ep3o0P6Om/vdbNi1+stPodsm27UbbWwha1rV+ZXTALlBq/zwgW8LLCcRgnA3hT5KnPiZe6KSwwtxk9vh1aHGg08jPIyFSJvjQBk8k/iPCpelENYRNsrLLLLSGm+N0UxIsi0ch+Po2Yw7T3oyOe4f1DNdulD0ErYDiOdN5noI247KR4WgyK2bCWgct+icLhByyO2H/wBuN8a67CDVNhCXbBYCdiJvECHOsVA1aJao42m0ANU2FYj9F0pgu2C8xpVmqZqsTMRiXGoQuSl1grz0bOL4LXcy8jwdK1X5WAWYkdi+0eDbBLmMkRs4ZLciTuNa7IkVWViHMiyo0yMzJi/SL+b+e24vNTxXg75w2OFsRo7UWMxHZ43racPy4teisMuvvNstWfSbyBUKUFcbW0tSF8tD+jpv7wXy3MVUE9MzqDYcrJJYQt2n32Y7Ljz143PKl+/gAHXXXnFuu91ll591DTNX0gTIMIlGL9q4ANpL74jwcYyrPsxUtKEyTbEswHrwUGxhgZzPB45oLPHPyY7kaQ8w542gHG/lZ5vPPaC0rvh7Ke1osXmTan5vSfnNDgJSc6pSlqypXhatnMwb8Ade42cHwUo5ZCe2H/243w/7f1ycuFdAMOrn23d776HYlekSH5T7j7/LGM5zjGKJqIiYWzOMihA4RDbiQOoyBEnIWYhO96zLVZb0tvQQnKIJkurnZyuA1dLkuM5znOc58Ck1t2y2OCOw002w02012dj63iWqKqVEmwpUCU9El8a22TJq0jEOZElxpsVmTG+jbBP4AVMlL4znOc5znjRALL5ieYXxYTMYEFnE5BGfIIz5U2RpSuoJ2VZB/jeOYOLi21G5aYgoiUOI6n93pktiHGelSb5cZFsNLl5QtSFYUnWt2TagOMvdgiRhjIT8yZfdkkrPLeYjd5KVLVhKdaa1YrbCCBHh1pDzTjS7UDWAsJIWrwNUa6jDIDJop1bBcYdulgWx42gMe0qf6Noqxm+n/Z2tCj8sV0pOz0bhLfLqTMbT4Yie6OKjp7eM4zjGcPMMvsuMunRuRRomOz2oshcaSw+iC9mRBhyFd4mWGioy5M83vcew6+yJf3ta3WFoQU2PcSmPY+6446vK3OYwSRLSkxYFE1HBCe7nGOzJjRpUd6PIDBh4McwPgc97HfhgcES14Olqt8sArLP9vY+t4tpiZlRJ0CYPkuxpfGttkyatJ+DlxZcWZGZkxfou9z/viEAI3y12AwAqY2IrjeVrS/LigIvGsq8sBUIDDvF5L/ObaanY4xjKs4xisC8B68HG5/d7dd2967mswuWp5BVm7DcQevOcYxnOdpbEXY5GRUHv6oGYI3oQlfPfVdz7Rx1nv60rzNht0CK/jGMY9mOnZWyI1aiOwIi1qWrKleNo51abt+THO8+tLP29dwFj6QAjr6N/kFYQCHJ8SkzWJ1Qrz7PG8AzkG5KndwZnHycVjvFY86SLnswLy1aY5x9iwdVJ1watS0PprFUEVqA1Fg9/cRbBG7zW0eBVwL9gOwBjMeO3GjMR2uc+fDHQ3pky07bOED7EsTQdkQLc04w51XvX4u2RFKUaCkQhF8eQ415suZUnFxpIYyPMDmCED6HNmR4EORLkWQy4dOkSjnGtK6s9bR7KuFYzlOfZsCjHq1OXKnavruD1vgNvcXQsgRVTU3Oc5znOc8auArNXIbjP7vWIs2FBEiapcuRMlPypHDLLr7rbTWsaKisCcSJXXuS44Eh/k0fwNPSXmdgCEI53ID/EFZJDcONqbcW2vva0sLNet0CU/jOM49uObrjTTanHNh7g+GdkCq868685lx3x9VSX2L4D91zvPrSz9oXBeIk4EFlCEoThCOjdE/Eu8vs48TSk5cmjobe43mIxLqsaejt0OS9JpgB57vWiqiLINcjTrXUitXJKiTeceNIlPIYj0PTOP6T7Ky0yy3hprvmSTIoSQIOy5TsuXIku+BoavYyoiee6NpXiSfNSIDHEKbLgSmZUTVWwl2OEseR6r1RhtuG4Q5ZawXrU/wCCI8Ua+k6jOytusWcZZRTM+B9C3bZViwDItjloyvIhgpRh7lKixZTKmJNVpQiq5JZH8b7Ne6gigyOWlK8sZWXZ737vTIkaZEkRJGwNdz6pNy4yyy6+6201rPWjQBlomT63HEoQta7dYXrHYJ5NfgBCKhZgaRSw+zIYaeZ57ZruAdvl5Z7+prgiw19EV/lNnQ4EZyVLv+1J1hzJHD/Jps50fagclrnefWln7WpxqZ99C4X02gjgpYzM5Hifh9now6dH54sIz5sAKj+HWXGXXGne1qkjmbQxGfAuNQGWsSqHKPBJoEtLGTOWmCceDc2GnvB3UayOqOYiPAQhTi0oRVASa/XRorHO/n81ypkp7XMdPlDp0aZFptrhWcLGnMdVrqwu0ClwZt2pBOokPcv8Vy0Ga1MzJGUu9hrXDZ919AUpKU5UrYdnzZrPMmI4rwh02cGi24UKPAhx4cfp2YbwauRR9HFQB5P2MYN4YZaYYbZa/d99hiTHdYfqWrQNYIvz2uxtgzgPRiOU+FqM06UpEHDnPdVeQTqnzBvv1axzK0biFIokrBLjYs+FaLQLrIxydOvV8JW4h+dflQJWYU6JLTHdy4wy7zvPrSz9r8P0NhZI9NV0G56hoQqQR4ukiCot0Qxz2sDwHuc/CO1oyeqRUX42fA2fQ02gR8VEUlSFZSrgKSeEloBBqJKYlxI0prwN5FvjLY1BR4GowSDF0hZc6N9m85eEhEdGvLm9UjiH1tOtvNoca6iokYYhLhkb/rElWpL8qHwPITBs1iZDoW34Rv3I83/f+uPO2vZkgqpKaRy0XVfYiTY5XTYyzYYCUJOPPOvvOPO8aJri2mZ59/8Aerf5L/QDUeFoAm6gkZHZ5vsMyGHWHzwl4KaJDHe/r7Zj9Tiz4j56xmLBMzKJeYAntTwgqa1yvPrSz9rRw9cWnPSV9G35rMWhlEL8WlzmR9sBy3uW+gmHgw0sjtfh+nLUyfg58HdVNyLMZOReWozCClKgI8CTIaix35Dxwo8YMECLvgaGCfChZ5d3mtxDbalruxz59aCpFPTpe/8AswitEut1pt5tbbmwtNqY9hCsqSpCspVjOU5xnGvduTAuYowwNJjykFiZB8xa0oTla9nWvFlsz7jHA6BJJTosKMCFNBw44a1073NqjBIAlHEeO9KfaYYrQdAQALFp/erfnqkX4eoZrUK+CVO9G+q/lohAOo+m68lMP0ivKY5Xn1pZ+1Qx2BlPCROnf0/3QQNAx4rTrjLrbrYyRmSMHv54s4hBqvExuXG1NuLbV2dGzUsXTLC/BtVeYsVeIDXZcR+HKfiv8aDMJaKlhS+/twr8soxLCfAZZdfdbaarYlAYCMGo57ENfJqcWldaFqQrCk6w2iwUYihTHYvephti/PMGFRBEPNdhz+KzbjdZl+/HVDZVes7GEI8vcFo+S1vMJnloyr4emSbDJ6tvl8EryRSjjTtfUWt8eUv94rFaglbiLkkQx0SdgImDevea3c3XCV+Frv1zWum815B+rEoGFoWhakL+maadbXQRyE8rz60s/ZHxFTZ8OIlhv3TDKFdG/prqzIaF4+qSCJtFEZxy2sCUHuc/CezrwhgfdgD+fC3pVcQisY9H4phb5NaQs/Pf3ycxJNjw7fgazC4MXIWyro36WV7QolPWlSkKwpOvtxrSr5fZm3G3m0ON9dnqQO0QkRiV21wZqb3tVwhSkKwpNJ3RNH/khnxRcWZhImDvIeeaYZceeulmfsx+ZPXwFESzJWENiV0LGBBIIyP0kJzA8fNnPypL8uS/If40mDwOqapy/wB4brdBtSG5ffPnyR8k+QIVy0GK3NRKH0q/hbbHWljq356pF+Hrhh5+8V9LXTtWvJBW+alr6C9UjUeupPv9rQfpQrzvPrSz9nXcNmddQLD3TtyYxLvpfLPjaGmvPVmfGXy3mCXOrUQm12WXnWHm3mh8xidAiTGPBvwBuwVUlCxyoBhwzTQkx7uuOtMtOOu2svg1YyxHHgaCGe2SZKK6Nmlvml1Lu47OsdnOgnECSzbjbraHG+uRHYlMuMP3zTC3HpBGtvsPx3VtP8A7EYAy25Q6nbmElMe4NNONuowtvxt1XbMRjFchctGVRSESrFK6t0F0QKW9E5RYz0qSxHZDj0Cw40e3+8Fns4utC3J04+fJWEm+QIcq5BPzSaGwYdJJAuG2T6fxBQmEy69OT4WjoCpFzxJ6t4AczaywSb89ppx1xLbdA04ljOZ9m3ejCKM0hHa/D4tef4lazyvPrSz9nRUJ1+3PSsdNrnoJWU1NR42gp6GjxaDnkRgsER82DIJD5Q2fLgyuzqMvknRR2FeDnGM49mdgg8g7cWh440Ac9rBYIvu7ZPoCVCW3jwdOjEwKPBczzPEEjAZSepxxbi1LX2tR7EWMlNgyvZt9AAWpjOZNuoR6qv8A/l8qnseyVf8AI1Gqeza3Y2WG8+JZ7DDroWWSlGS0swUmkZfFXAyLCdgDGYcSPBiR4kfq36SwsmHG441AJQSu0Jbn7w75YNJMQXXuVNoZm2vr+FrVVDVqGmPA6t8QcPVOBLx4WjQfwVclE3ekhBYnj5cJ8yMeEFZ457zYMGWQlsxImvdcQqvCw/L42qhKtfHlZ7Wg3302sgwnlefWln7OgILXuT0/pnSfhIEyVxJd99Ied8fUM16LfBSUc96V7EI9FMNdnQBb2PHBK/C3+FaQoOXRxrUwoTdA73e2taP4gtD6GvAQhTi0IQAgpHgxULHPdZLEKkrYx3NRXxR+AsYR7MuHFlxno0q8aUad/PNrc2DLgyXY0rjGcpzjOKtuWxB/YxPrtur1jZw4O8La9ycPnXIbHLT1PyDC5JyuvZ5Bc+8nFq40IHWxAKl1/vCdBDD4x8eQuNCMVcrmIqkaamTF/FWKCPhD4yY0Pr2lBemUA82x4NXAyLCegC2YcSNCix4kbq3wCTFNDy7XmNNOPOIbb1bQUVwdidP5bHhvTaOfYY7WmJ70S+wWkcrz60s/Z0iwhqkfnz0Xqc8Ppx6Uz44ScgcZGTlpV+ZOFY5bIruT9QIx2+zrAw4JuwdzHhbOEfNKSXbxw2tTbiFoqphButiiOO3ta5fw6ByxEznwaiOQTs4WEvo3/PQomCHY7lWPSK8egFGYcyPOixpcftWenALNFyzPuGpT9fWt+IpKkKylXEaVJiPIfj03dkyEhEQ+EsQU9Gw+N7+270gKKWKhZzy1pTF2g4jLyEJSnCU9UySiLEkyVTH/AIiVIf5a6FZE00PGz+8TjTTicYX2bVGemVg/Ej+DqCkYCivm8zr2DXUWGpkoePM05r/3qk2Mpzs3pixdvXM9Y+8V19HK8+tLP2deRnolIAMvdG4pb0SiTcNeRWZzxCthJj/LOMZxnGdjV7IC2kYyOw2tTbiFprBjBoAKJY8GQw1JjPsOl4Do0pOhO8aFN4eFEw6+0cODQI58gQs9kI2Us8RneDpOE7JvDD6OjahJBG+HHGu7o2xLnA5gh/uXPUoOxfmmRLRSz1Yk+6Ich5KeNkokwqjvPGEMw7EMLii0RMkf3LVZoFYDukZpgtOMkpRGdxChyZ0uPEjUiqx6sBjwU9ezC/yull3scCYLpEnChtxWGosZiO3+9jn+Nfg6h178c7g6X7EuXEiMOPyrc2IRZiyRHlazoi7UV/PLYYZjMtMM8yEFqdAmwnXE4S4tPars9oafDz3uV59aWfsNoU4tCEh2XY4cZHd6N+POoAB20eRpgg3MocJro3lW1zwEUqx2dFnMTK7LFueFuAamBeiOUcasN4D3MatfZnToY6G9Ml7Dur1rMrdR4WgIHtJHSPQ66ywyt50jMfnkJkx/u6cK5gXaG1nuyYsaWw6xIuOlBs1DsoAarpoFIywS5CDhULKRJHVHemFZYh2GHNhzmEPxOy882y2txzY93dtZf2tctJ0n25/iab2N9HErlDAzXGpx7c69h0ufva5/jXyBQ2ZxoVDetGjxEzGXglgqJ+uve7JdvXuoX52YZY622hpCUI67ptEHWkLYZsdvPWOQp0h5VWrk2yGoo2NXwMCvCo42D0vf5ne0jOMKxniFLZnQokxji8+tLP2BEZ+UVgMMdO/5D+JYGL5P4fZ7yhx+ErnKjx5kaQxIsIWUCNzxknsaqOYDXOBlfhb/ABOc4ClkcNuLbWlaKUfRYKuLIZ6zh8WAguzSF02AYtUl1K/D0FAS0CMz8c9gzlD6TYH8d6rSX4lkCvsd8gNHEoi4s646QZWhyVXCwQqGfQwS5AbQcr76XxtU3lAl+5jH4c6FPjIkw+vc19w9ldagcqHUH7Wdah4jx2YsdqOx1nTg4EMkEJ5wtKMlppKTxoCCpRQ5Pz+8m2b9kBCwKga+uDFrAtv567NLfg1k7NY4p7Tr1rAJa4nD4RGK7Fm2jRkV7874AvVz4VxSCHXXKTYrI7jEClakFV51E2d2NibeWlyUJr+c5VnOc+VGjvyn2mGKDS2akGxHz1W+OzFtZ+Oz2qJPZn0yvvNcWuUxNs52VH69esuvXauYb6d5vvKuTTCvI0PObYt8mOvo3rVcPwotijdhKspzjOKaaQdrAohjwdkhFm6UWjMctL3BsQXcDzOq6bOCVhtxhqz2cpZybk+f4mmYDMWgwnkc93PusUfKUd6NIdjSGJDUV1T0SK4vwC4QSai5jkbZop1GHJNfKgjAd3LRDkCs5yvyMPDKvvEfKwhg/DmwpzCJEXo2jsSNX4T4qCpSlqypXEOJImymIsekVGHVQrENHXZLgCrUbL8+7XclbSPvn+WhIbLNYJTcfvHb7RCq4WRPfMl5ponLIzdd29dVsDMlUeQzIYafY6twT8QKGSRnjU/6hV7ocaZdQpLpjUdKI4WvBTQPsxJWOm6MtbDCnGP5OXviBpC3ycLzIH6CX+VGSIbU9NFLwvhhhiO0hpjsbguT9eFMQIHmacofwMdFin9d5QrFysnt7WmSGZdCiNcS5LMOHJlvuZxlxecdemc+zYYnq27PdmXwrhfka2nPQrzX3GugsOYKDJw94sLlCSUwfK7GhrEhicQBP+FsSr5rNnlw0cJUpCsKTrTbDEthAmwtuIcbwtHI5bq8AaU6RuO5ihZPwwZ1xx1xbjni6viPQ6DX2X+f4gX2sRwEbvxo7smQzHaiIU1EjNq8KeOgEYy4821aNiPYck185WDoBz8pPkDs5wA/h4bXN8QloQ0bH2WvEmcvQ3HmWkZW7e9uChcR6GEkyX5T7siRy0zRlDmMniPQtaG0ZWslba0M/LmYU3lV4uPZBN7qtM/K0wpUuVMeU/J56qjLYoIJD37xOutNNrWvY1zXazi1t8tGGSM2vzoknq3+X9qwYhHGmh65l8gLT4l/OrO2spL8zVFD/iIn8fNxjGMYxjr3Fj2bEN9vQEp9Ys9GVe56B9MsMlXY0IhpVrIqX03ieshbzslfkQnlR5kZ5Md9l+Oy+z0b2qn5FxbFH7AAzKBGYBSMNIxCY6HOi+DtWm/xMBy9FWhaF5SvkBvloAfkRB/nfeuDO0bmXa9y88+8+4tx3x6b6Mq/RvqSw7ZoDKO9W23HLAGQ34suFEltJal2LR4Cetx4XYte2ivPKxK5JUrH9ny5WQ3lp/nqyg5sZH44hjGMY5HbrWgGM4Imd9DGMKSHJbouczEhDJCzWAk687MznOf79QCI9AABYT/7xbxs+YAdgKxyr1eJ2ImyPH18ANrotgbA6XHG2mluOW4+/YbCRJvcaJZdVb5LuPDLrcbDE3ULWpalLV5VbATrEXijIVfCwgAiIMh9jcP6hmu3XLUarb77wsxtqxma/JDTex+H6C0uYfn56FqShGVqOSGZRopJZ8mjEfmNPAyekyHjGQ88fJLDJQklMHyexoq04cYlVyV4W2taPOuybGIUlSVZSrqjRZMpxDUeJq28S46H2zlFtQFpDpHw6o06xVK6w9z3RlOb5M9ne1NAdmXsR7vx1JSpOUqteqa0fS8+xaqQeqzyEkeipVYjZyzMKKGDwAo2OPgcWgJIOB34Meza4t4V5a5C0LQrKV822nXFflbhV48Qw5mJA1pdZ7a1tSI78Z92O/wNgukSMGA1+8ex9esW2Al+NNhSoEp6JLr1eJ2Im1AH02mjamMxFi9W6LliAOQDh8vw+IczMsGceHaJHwtZNSPM1DTlgQeZ8vs72iMMXVpxvxPw+YWmPZF9Mj/iyvL0vNXJo7KF9O8qb7cJs8TsADEkGYgk444hGJj4c6L4OcYzji66kD2J1+fFP65tgNbnv3WnWXFtu8MRpElz3bAXXNvNYwuKD0PFaWhwwLABRDWG4HDjbbiFIc2xrtFdkoJjfCR/6J6NjZzm82Lv6EE4cJlSi/Jnjx5GKuLOvmoJ4X2zQvKBAlEZjESJR6bBqIn4VrnnGM49mStRrRbDvxk7UVGlM4aRA07R4XvMLj60o0WQh9qMDDQncuRkIQj/ANTFrrgRGVEL0QEk7WVnieKPHfk3GuNs/vJd9dBLYhbyqbTRtUGJjRuq53EbVBmZUkuUmFyUqfL5aJgusVSZJX4OVJT/AFzwdQhwEYSvytQU5B47mfL7W+/WA7xdDeiJ3Td8rRTrGpPlfh9nM+7OwOohBikYEqDKsQSSBNTxcnsaOuSfZmtSvEdFjFrUtcWkVGFIRJjNQIDK/eM9NgEMmgRMY46y6w64074KP/RPRa57hGymZbne0yL+ApbL6vLv2nIZPLs+vvjp0aauE9qzXyq1EcnkevOcYxnOTNxrINbaCJrfI9nC0Bzuz7ga/Ohx11x5aluctTfqCC/eyx2kNXIS5JG4W8layqpkvkhC3FpQih19Veqw4e74O4L046ciDBgEvENBoBKMc/0xfyosZ6XJYjsVCtxK0BiDmO1vv1gO8XRbTzNJfyvo2bPzAop13y9FTnWLc/FT1buqmJ4hByN2BRKUKIxJ8Wrn41jAQCrPmbcCYFXWetHgo/8ARPQZ/wBwT70KI9Nlx4rAyEmAOgwk+YSrgMiQhT5XUXvNUCez405vmKljKQtg2XbTyHWn1uLcV+ZfTpOC1KvDTq/3qt9ph1YM+RfsNhJ2Im8QIc9PUP5nMQen+Dsm3t1ivurQpSlqypWhrMt+LNrr77TbzTjLhBtDU6W2jyNIVbE4w8bk9vffrAd4uol+zXITHTuL9PCnl65mohXYE851PsMPsOMPX6srrVlmQsdjT9ySBOKHy/M3sE+KAQSyPBR/6J6DP+4J97UIX5rdoK1fQ71cbWs8WGu5znP9c9jQ/rSR+8xAwLGJbUQiyo0xhEiNz3iaxOtDI5vkNEEislMaBUdIxoT7Ew+2022jCUeDuE46TukyPyoJRYq4A5SeCf8Asp3kRoz8qQzHYqVeZrlfhDG+3v6MpNjESfF1Ev2a5CY6d9e1NSG+WOlfBz4cvhh3D0dl3r2ZUGrNXXvd5xnGc4z2NQXf5+I+WzPLsApsuEJjnJDDsd95l3wK3OkT62DlyOZn/cE+9oAX+SEbLZ+hmNa00xNXMlSdM0V1h1Df8gK7xN0A3l9Sos7QBNtj88Sy0d+tocTO6NEespWf3lvF4HVId712wWQxYpnxZOo3k5VZSVw6lfQNqYx8JwpX5EKVk4RyVMkp/KoAF2OwjxSa5WBFbgYhDvBQfEZOZC8ZzxYZjE4+YmMcUxlp+3V5p3gn/sp3kaQq3x5h84/3PxBIexPry8+Jr6EzApFcZZ6N/PMIrYiPny6VOdm1IDJd69xUzIUz80h9ivHZtfLxCcOt2CDYg0MlE8vZ4ZAe6lWG/Apvoyr9Bn/cE+9rAWkbRQSPo5uzBK/HU+St26C5Bb8YLIffkvOPv9H4ev8Al2P95LJYYNcDSyko2aInCL5Cfygz5o6W1Lha+KWYnXWJRzZRZsPSTbyuWu7M3WrREnPtuIdQlaPA2be8VQWhqJqYvnGwYr80lNZHjp057lquGxMvoJt7gn/sp3jtNuOuIbbolaRWa1CH93f/APsa/wCzxKb6Mq/T+IP+9X8zSc5h+kNMI67CEhHw00ZLMiJwUnKHTexq++O1csiNJaeaeabda8rfwZeFhyqPA1tPVPoVdeXzM/7gn3RUFREnAgpabS0y00j6ITKjxMRyXPtG9M4ytivTyE0jJckzOr8Pn+ezfvJv9JL3oPOeUWLIlyGo8egaijic5nnv7f0xv2UwiuCYmeertoLCLaEGG3EOoStHelyWYUORMfttllWY7KJv6z9dgONjT/l9FsT/AD0pAdlXqM+ngn/sp3j6driy9ramL7u/n/bZBMfHiU30ZV+n8Qns/PWE+Z+H6e7mIfhZ7G4qRkyNwZg9nTuxF/nbrhbytoBcmKSUbR4GoH2ndfBkI5mf9uS7un4C5l7HLT9EKLnNCyDsE3ZDZ5/L5Jttx1eEIHUq0k8R1RR+jrXIQhcuBoQQ1l3E7aYTXYOEmGJ5/h8/z2b95DQUabGvjyFrqhSrlHIM6r0w9Z5Puh9L14GqjOct8t8mGpJwWMR0UDZ5GrO5YlBjI0yPYIQO7uqw/LKwkezxrlrL13r6MbpnIh0OWxnloKE8s8Ym4JPrjDZ8hDzq3nnHV+NqIB8nqLDyu7vv1gO8Wm+jKv0789YwPM0RNcZtM6J2VJSpOU52vR1VszmVF7CVKSrGcar2MwagMiJ/kyGGZMd1h4tAdGlJ8F3v6G9ETujYTbbd2sKEdzQQn2vmSq/omcYzjOMxtRUaNJfezBrYEelnEPGMYx7MTJsSDHXIl3zcT87DkCvOuuPOLcc5/h8/z2b95SgQMXYbaJRYsWIyhmPyOlowUMQJyChGUUIy58rp1XdHK4dbjvYz7e7ucv8AMLo+wjjWfrsBxv6fhoGHgY5fh9jSEQrHKyc/0xfx6eCdP2McNQ22hptLaO7vv1gO8Wm+jKv0779YQPM1lOZg3yvvPdm0V+DYwkwXJNCJgYpMHS+xDlvwpceVH19sCBboOG3fJ3KKwPvExae/+H1efcWVGeeyPXVj7ukoTLFKQ+j6OXmuwBc6a3bLobtc5apAqn2UsprEENouxTG8OELvriq0+svyl8tCvvJts1jH70b0J/CVeLCTxWQnz43DGcCNJ1SLDfanWLRRVjL74WeNnjZCo83kJ9vykZnPbeebYZedcOEXChghOXxpKFmTdUPZ3/P9pIGP56KYdapsla77JkRKWekMeNoUAj8hM473t9+sB3i030ZV+nec1iVdUNNeWGn5Glxs/Ha23QknhuS8HsjCc4VOYmwqBdWLeFw+vyN/i8LgAyqO/oRacWkkhXPZHrqx92mQVjamDhr+jrQlaFIWJo9VDL/PCQlKMexNl2NWK+37ZF2uhG2k8yH+Wh/Wkj96d/rX85Co5BCCxhcfOQw6h9ll1HBEMKKNLan2LQ8F1Dz4PGv7JGsEEXOjsNsMNMo7dxnLHVM5MRy0EHW1GLl170msv3BhhHLVMZ6LQAaH9nyWI1EO++8XGM5zjGKmDQArgwYnvb4caXcoaUeJTfRlX6dx/qMd8zHFbkuyq2CkvdnOMZxxt6gfJZuTQ/s1+wE66TaID6XcxdsF4kxvH2eL+ZUU234Go5TEa/B1Pc9keurH3BzCJE+GyuOw2ww0yj6LnOMY9uSdmrwhD2Z5bdlQge9TELb3OP8AvUDDF4tJh73kv25z0aKeQ3dXcL/ej8QP+8Bc9blclaSGfVzUlKvZ7e5tKazCohpTnCU5VnGMa/AqAVIbCc21LYlX0upnlW4bo2uBoDu7cYxQnedJAIsNlgDXdmazC1MBGIQfB1aDyauotGe/uH9QzXi030ZV+ncf6jHfN1BNYlUEalPaJD4ZMdKgy7nVJdVOPj3uyJMkw0tEsfr/AGBBtsDKF+M62lxpaFF4KhpWfBz3qwQ+WWIRO6NkeurH3NbsOv3gBhH0W5PbYj5kZEWSxXeQ/IZNLcccV+ZfXqb9QQX7078HKdCiZ6OWgy6FwCwlfgbhjPP0MjhnjWldRYLdAjPcXtaHLlYlo4Gw1zyEOEhtP5G0Jzvia8xV4EVHLQo3LtinkON9eih/haGBZYFEjLvf3D+oZrxab6Mq/TuP9Rjvm6DnodrxaB3LzTYttCKhrIj5Q2fKgyuyMJzhU5ibC17tCHafbBmeNuKAuHfCK1d5C1IWhaaiawcrQohz2R66sfc0fDffuuJKPoxQOLLxVxiB7RtfmZW6MOaeuAtSlMvMvMOLbd6dbz0QLwAfX+9GxQ+S1KNMp5auN5DXUW5nwLpBeIVI7GZ405VsBq0me/wQ/wCfL5a9gNkLqAjr4/EHjGAgTnokf7mrTZmd9eih/gttrdWlCKmGbCV4YOT39jz3J94sLrniU30ZV+naktiXfjrjHmaAnrSROwO7tjXqj8PBYdnHajvvRnm32Nc7dQR9o2x4zjOPbjxPxAjP/oDJ+Bq7ZTFYS+NJwbVW57Hvo0y9VCDHy+7diEQlazU2H29AQnckTc76UXrVfNNrSQN6HDSPasSa1TdBGPzqdacZcU27yqHsxbK7+9OcYzjjYNeXXrWRh44xnOM4zjXdpxZ6xDlu99SErTlCw+r5KtjS4klKcJxjGDDrsYOTktOLU4ta18aQYQ5dfzr4/EE4vE0AzjlQhaRVPCRuN9eih/g63CqNXETG8G8+s7P4tN9GVfpvPrSz+bpd9TN8gox3dv68+DeWfEdvXe25YhcMUagToU6I3LieHt0XghR560+AlSk+32d3QUN9sMalK+jrWlKcqV81EpxnKmbZWXnsst/MxvDM2E77UsbohCGao/NzyxnKc4zjH9sfvTviuokCYJ5nlrW3/wALWNp95C0rSlae/wCzHt5KSlacpVf6q7WLHJhZjRn5T7TDGrKI9VoEiRO43gW+MtqISeAMF4iaGQmk4S2nCU769FD/AAdBil4UYKq8AtNfIFJ81/stNOvOIaan64OjKquwT+zTfRlX6bz60s/m0aUxEuACQ/3VoQ4hSF7R189WCK58bt0y/mapLZyzVbkEtMBuRB8IyPbJiCEFb7K2H3WV+bo5paKQvK/ouyb8/TWBeWC25rnP96hifabESdcdmfnVx7c44/OriNOmxFZVHkFCUpv3UjnWZT8utAZD/wC9BccwWEkBz5GC8Pny4T3LTFteMhHhczwtj0du3iWkMU7XIGrIw41yusqTLtp56RxpcRmfc2ZCuN9eih/g6rF5GUcWjPfznCcZzl7/ADPdrSdOgYGYscmxikGQJMcp5lxh5xlzsU30ZV+m8+tLP5sB1DM6I6th5t9hl5rulhI8wPfgT77SZdRLYjr7YktPDzmJ0DXu1R9gYijyXhXwakZbzcVHm6q/T+vfRtk6+fuDEDLJHTd2huKw3Nrh6AltUtSVJVlKuvW092fQ68+7+9O7q9gdZ8EWuWoCj0C8QGkeNuikzYpZ+wxW21uLShGpqbLrQR92dxvr0UP8AQOeKFIMBmHGahw40Vrv2f2/wxYM47VBQ03Sa4lvjaQhQu6lUdnVDq3dfAcudF59aWfzqlPSRq4SUjvWWti7KLcHkLNXptcMyxkrtoWtC8LRrncH9xtmbcQ4hK0eBvSAiNb2ZKfNoEBI+lV+Mn6OpKVf+xKo1gk28iUR0vTJi1rZIaAfx7rEAjp67wUPOIn1mwDnXGpfPSU92TR0NL/encgTBOmvSEcqpJejWYI6z40+BEIwpEKXT9ZhKu/LkJ5blhsSKBPec5IYecbdcR3NRCfmV3HKV4F9npH0ywSc9nGOICUNDoaEcfiBgeyUCIY7Gol+zXITHTefWln87Uc9c2hjML792pQy2jFMSD4EnXyT48h3Nb7WcrqMDC8SZEnRGJUXv7+HLWICz0+bVPSdb+k5zhOM5znfEuIWlNPMb/GqdQh3G9qXjHGNqa+dZx+e9FYBe1lZo/loCY64LOw1/vTKityoclh4yNdFFp8B3jGeA8yPODjpjHk20bkrWTcFtll191tpqnaWnkMfFHtmBBQbWZOMO7mgBPsaNl1+Bth5hnX5rDnZriMrsIZOOW/B63QAiansaiX7NchMdN59aWfztET3XqtPjK8DYNMZtoV1pJAfNGTXoczua42PKqsrESUNKDycNEsf3tsC8TqIW81KfzKxjgLCdHhRcF36QpOFJynJ/U1QM4/OixaZtApK3ocuDMhOqaldGgpCkWMqxn96t3iFwrfiZz1VNfnUIMt7yVJ/MlSeKxr6t1pCFReN2TPhqQtnPc1EJ+WUUcrPgb1xjFIY7Wr21rvgHKeW8/QrPZ0jOfk0fDTnRefWln878P0572noWfB2FryDbYWXWSI6aMmvwpvcod7IVEj+dAcyNNDWJ8DumYKiIYrATnHsznHmN/5EfSbMZQBr5IsuBv8Ad94r4+FvOovMfnlw9hUqc80wzNg1azsZbesOioL2H3wh8HOAFZAudy1DJYj30Sp796t7CviaxBII5aBJKWJOj/N336VG9zGMqzjGBMFscKHwW/A3+86gSBZx2dIY9t4Tz3l6JRjs6G9ETum8+tLP52iJjzdtlRseFsHXkG2wcOMkR00ZNfhzO5RL2RqBH3jYcwPNDIxGB3buMyKtx+H5jf8AkR9Jstdi2MM+NlWLRp2Fl94PPFkhznu5vDUiQzjOGoN3tkFMdEcqVnlyEifO5VYh8ssgab+9d5HNEqcfjL5aOK/B3TERXmb79Kje5QYCyFzAR0eDv99/BULFz2fw++zBc9z2mnGdfWHs6FkMrqpKPjovzD8e7WVD3m6klPx76IS14ex9eRrXBQ7Gkxnosh6O93NbbHk1SXiLLhzIk6IxKi9zdkBEW9Pvp7teo9lsXtyOg6Dn+3OZ/cb/AMiPpc8aPJRnY02xaPAzlLdEndYXAN+da1JynOcZ5tuLbWlaAJBJECKlp/eqxi8hzxYbyqhfIayiCPGM+3zN+ONYrIprPb0mNRLuiZC/B3nPcfuCIuezoDCMCjy+e1P0+sXZ/D5/isvTtplpjYJ5Dfm0qa/CtoF9nxNnayYsbTpQU8y8w64y73NU7ERXJKxhNtxt1tLjfb/EDCRh+vTkdyO3h2Q03kUNiihsMdF4tSEotB5Ce23/AJEfSb7UX7IJS1FzsfY1emTIMsZv6cj24Jj9z0iW7+RyBYq+R9ziGdolUPob+NPaHIsZddD89TT0zaKK9n71bwFZh3HExPLXxP5pSgUjzPxEf5633Pw/QnEMn5+fB2xPzOvRbPa0c0yil5cxyvw9JCln2M9j8PakYbs6encf6jHfOiyXokliSyzn87DWc+JtrWjMlqXZBHd01sLPtYrRHt7yHvP0tqQjuVgfglYhEHPLbTDrN+M5X22/8iPpV810MtrDbmbJUjlal/DkuELWhX5kCrzbBH5MQ07mtTgx+BK56CJJWMMD1fvVvYP8TWYZBHLQRb844yLX5e/5jCyICFjt6OgIj05cnHg3OegjazctHZ1PCYiUMRlvlafS1i7OgF+y1E+ncf6jHfPrxFRGvB5yvEzjCsZxnbuu8BpPzkT3ELUhWFJ1bf2LKNQOl9rZEKPNop9DvcoHras898x3022HIV20Zxhac5jyGZMdiQz9JmwIU+OuNMtejIUn3skAbqx8C+60R6dHl/grauGv96rKMUXrpcfh1txpxba+NVHfk1yHqX5e+84zc4nc1uw1HooFKPAlv4jxZD/E6R8VMlSe1SB2R1QARedjaderp1pr+uM9jQmU/wAUkuncf6jHfP1rPSQogB7xpUWPLiPxn9h0h6omMMo7gguQDEI8+BV7HCsoWKTi9ma372DLRl1tbTi23O3QPW1Z57/gPe7Azu7VPSdb+kOvNMtOOukN1n0WObMHVrdVcItIbJxpUeWwh+M+wxIaW0/atJgyWHJIay1E5WZXuCfOmk8CbSFm8YzhWMZx+9W0QmA9yJIRw06tl1t1utF0Gq+KIJ8rbi0r2CcyntNtrdcQ2gahbQweyvwLbPUNrBubjspSpasJSEbdYCCmHeb3+ZzsaayrGwBfTvaJGYurTjPnaYmMP0KE0jxrTW4dmByhko4GmhCksdM7mtLmurHU5ebcQ62lxHZt8N+FaDbD/boHras895jsP05mVnuVJaF1Ou/k+jyozEyLIiyLxp8mFw9NEqSpCspUHs54I4lY6vb69uWmDgaxAjqMqGkRo8pCehzdjaldBofKh+dQLYL1gNP/AHr30CW9BGGkctEH2nhM4I75Vxdbettjda7VdivyzwlhjwdrT1waGYUjswf+dE6Xv8znY03n2bBE9O+/WEDz9A59lUI+RtmhpsAxZaF3dMXlMyJ/DxDs7dgZhXsnnPboHras89pwETqIZwruaq/T+vfR5RIbDcablf3/AK44u+rQdkQt9m0Uw9V5WWSPEKdMgSG5MSsbtsI32Mlq7sao2JjGEbW1kgRh08H5aLMZlVeVAV+9VpDYOVwsO4WhSFqSrjXFgQAtw2W7j2Zx7fJITGh4+bNdXn2qznt60YedvID3Xg74lSGKtBYR2aHjGbpXMZ6LVEYhWY7Fj9dBznF1rns6N9+sIHn/AIfM/wD0tHk7ho2QZbJaF3BROUJJRCEWq2OFZQkQnG7G+4DbFkHysdvXbC37tXUo5WGHGmAS8d/uaan/ABlDhN5+jbmoxRUt2yxKrtCzVzKGsVPY9csrDCUcToEIhGXGm3jSsiFhc6vPsPR3VNPcYznGeA2xbMKi/BcP5YU+7ljjRhtUK2OjlfvXtuufI7hLUzy1zYlWGoDpj/kbKILHUY6+jt6USv8AjqMtPg7/AJL6c16Njs6jisSr8HQ90Xn1pZ+xQPW1Z6fxCoaw/Wnced+H4gps0bg+SeCwToiYMmGg84IUlDZvc05cUAjah0vsb/isfAgZXc03jGdgCebjTbra2nCbTbJKe0329DzmF1YhDx9GWhK05SrZWpZEOS4UrqVKQrGU1Xb1lCe7Yl1O+ALUz7YfFx18AtTeVSLjQjVUk4RJ6ABV0MaGkmo77Ehhl9n96t2V5ZOqskWOWjrM0OOyRD/kb6npZrouDjt6A9QGPC3k+hy6IQjs6MgNSbmt9fRsWC9Au9hZe6xylInw1J6PxB/3q/n6CUjFvIeVuimZLC0HIXcSpSVYzjW9xZs9dYUvr3iwwqmJdV29L/qGJ6Nkx1x7wfSrt6AlsYRYImfpF61SJsTT8weerxcBOchkmnnWXMONVfdZ8bhLBat3es2RrHwDzLL7eW3rtpNC/ezazOHTh0lcabz1Uc+cUoatf71PsMyGHmHbIFfAnCIp7gfOkDp0SbHrpmIdCwSkfx97FPf2iJAT2/w+xmPyH5efB2ZMYm3o+8z2dAQFrMGp/TuH9QzXYhezE2LnhKsLxjOOe/oDCwYWfnztOfqIF8paErQpC9iVFdVsL0VHc1daM120x1OYzjOPbjq2iyyuhHcr7el/1DE9G7o77d4fdX29CPst2Uk2v6ScACT8JUQlddUGq3+eVE4ZedYcQ61V94lInsYPAbSCsDHvhlnpwGzxfckLfq2wVrC5OOWhjWGCxIQv9698VpDa4B5nloSwqw/OAv8AjKUlCcqVcCqS9nLz09vQUJ9kGXmK8DOfZjOeDU5JIwTnI7P4foz6IFilK6Nw/qGa7ID/AEAbo356SG+fqeUxFv4Nb3lbYq3z+ruvs93VlmdsFSYy/wBVkQ2uuG0r7el/1DE9H4goT+CQOb3NRTmId8FZe8ktZQAVGVES276nD/OiFN3/ACcPYzAm7yt7z/5ov88L5xA3zZWGFIlDN9i15jIIg7zVDaU/A9n2YzxetMwyGX54EkMnipjsOfxDmy4T6H4tN3fJiJxFsdo2MDgVR8sNccU44txfFVMLC2EWRS24h1tC2/3qsgSKfCThb5CDJHzZMORwDLyQpeCSjCyMUqNiT4vi7BL/ACinGZKe5oz0SvwbBOdHAC89rtaG/pTZvTvtOE3KF2a8rC68FzjnuqCzJor76vOo/rKt+XnHt42bVs1u0ymWu5p2z5C2pqG71OttutraclpSmXISntaynOwb0AW3z33BddBCZie3USHy2zhJnkXDaQCt/wD4t2TbdrMuZxGW644r2r6kqUhWFJq2zrRW8ttNUvYgK1M/ka7NppYC0xstELlrY9VlqdXy/Mr8v5ejVVj+d0+HhX717uquRpxBhjloy3rw+9Wpfi77sGMrHAkdzTsBMOiwF48Dak1cKgm1tdrUf6cgsdO+/WEDs6yXnNCr6ejcH6eGPPp8lmLagEh/y9t1bB+rvPsdxp1xl1t1uonkWGuDCeOq5RWIdsPRmO1QPW1Z6NxQEzKJPXntx31x32nkQZC5MCC854hk4LCQnZpC67cMH/zxBvbaedYcQ61rrcCX8ZHWZKkqThSew6wy+0tl696Xy+4+RrkmLJiPLZkdGjbBiDYnhTv713CssWauTxqn2HozzrL3A2fKGz4k6KANRToYeUjeGpeEoyrNuO5sFjJFO7qv9Pq74O+pTCKuMjK7VEYYjUuuIZ6N/jstGgs/s6yUj+AACcc9iw2JlIPoe86N/wAhjzdh1tddtZGJ3dC2HOFkgDvVtSA3BvhxtHaoOcYu1aznneIcabUD7D3c1iQRPooVSPDu13GVMdl9+yWk1ZpuJZPmHqdjNqxgcO0dbJGY6pcHQDSHVZn/AMgK1wQ0BEVhHy4tou0RMOLgmKpYwft+Y9Gn9iZbWmvGO1baJX7Uyr4y36+P1R5XxXOBOkj50aZGEFoxcXCIRP3r3bUljjSDkblpK3YGl3gsvw9vWFIanyGEd3XkJcCj16OvwN/z8rJAh/bGQmRwyBAY6PxB/wB6v2dJZzmiI6LwhSqbY8J86N/yGPN3mA+NAxi6O5UTzwCxjibTbrbrbbrXTu4e5FvL76u1AznE6JnHOTFjy4smNIcxjDi8Y7eiSC36rOhq8K/bRgVn3w+GQITSMt6XM5VDW5+zuYWiv6kqIZDankJSjHsT0vMMvtLaetmlgRTD0kOdAFQE9cElyxnjUF+wZgpCz+1Jjx5TDjEjZuqXxjzpYHz0RYsyhM0I/wDvXZAkQ8Eni3yEGSPmyYcnhtxbTiHEa8tzVorzUtfhbPtObHaJC2u7VPS9f8Hdk19+8yWF9kVBURJwIKUp9icY6fxB/wB6v2dJegm+iR/xZXntL/I42rgdMTOHQpqPLJwI5EfMhPkYLw+dLhvdzVpz5zTBy19O/GncWUUvPajOJaksuKiSGZcSNJa53NCG7fY0I7egp6Wj5SD4KlYTjOc7H2+20j5bWXnXX3Vuu8NtuOuIbboemUI9k+yoQlCcJT2blTRdrF5iyrDXyddJvDyHIUTliSUQhErB+NYQA8mz2loQ4hSF7e14obIesQ3lqw7kLcxrmf3s3hTkNOJssPlr64PVU8zIzHkMSWGZDHgbGtOK1WJT6FKyrOc57tU9L1/wbnNZn2s7KY7NHhyJlwrzTHTv3Cf4UGK7OgP9Mcwrm6jDjLjfBOHmCRmw/Pq/pkF5u8ATsC0pnp7mgjKUSy4ZfT+IP/DWO5Xl4VXQuE89xMLZ2AXVnt6wJYG3gK4vvyJMeMy49I2BtmWb+LFieQQGSOz2IA+ia2G1Npbq+5f6Uxbw+I2J0KTAmSYcnlpm3thTjg2X25cSLMjOxpN+qb9WsMqJnhtam1oWmuFEFwAmen96zAuKXFTR0mxg5QA1OFyeWlLzhac1oh385xjGc523a0nrIpiN3qp6Xr/gEpKoY2dMS85l15xztalQtV/B5x0779IjOzoBacCjyOm0IWiyG0r86r+mQXm7nCon0p6Xnua5MuB7iIfT078gsrroidnt6zX7aDX09G/oTyLEJmdyBMegTokxmJMZmQ40ljunbAKr8Bc8nf8AYE62z/YnlSqIUtc9KG6vVhdXFtQIPe23r353D+bi1JUhWUq4SpSFYUmhHkn6oMm57e5K7gvUly2OWkzGJ1OzDX+9m56ZkuHSag8mnXGHUOta8u8a2BkZd721bT/D1YdS13k49qsY4Bx8RAgmMnv7JmZhUg46ntaJ9aP9W92XF1CCtHY0B/tT/TtL1/YvPq/pkF5pGCyRHzITxGC+Pny4T/bSpSFYUkERSUBCZ+OjejLq6XGWjt6YkPv0SN7zn+IKC6uEAnI7mqyayFDCqX3LhcBdUFqlzLRbjVomIkEuWv8AVc2yIaIz4MGIPiMRYvgbioaA8rBwdy0hZnR59YZfbfZZkMPMOnxaxJskPXx+H6a/8UdhZ/ezOMKxnGdpU5dasLy2eVYsc+tmI5OHXTsKwhohOJ3FKShOVK2Jb3LUfdfR3mv8rfg71mtsVOLEV2tAMsqIH3s9O4P09L9nQMhls2ZaV0bpiMRrzJy151X9MgvO3CGQLu0taO5pUg1KokdhPRtz9Oz3c0E86oCbbVz3cOxJpCpHd0AWxmGcFL7d82cMqmFwmShUgWnPzZ3CEKWrCU6z1NnK8FrI02202hpvwZ8GGQhvw5l0qsqrHZA97iHLkQpceXHrR1k/XxhRrt7qG5h3V5/HGkV4TeWvb+9tzrLVnr00bmbDfhS5EWRy13d36mZQtcObFnxWJkTt7stiB4hAOL32v8rfg7/mPYfBQu3oCChEE4Q6twfp6X7Oj/XCenfMBbNohTM+dV/TILzt/jMLGgimO5oApn2Hxi+jZI5c+h2JlPb0HMbQZMRF89lQG59FPNK7moTeRN2goz2ti7ZaBvOig8mS/KfdkSOIsWRMkNRo2t9U4Bu4KmvE2TSm7UByhpxtba1IXxoayr9s+vP9vf8AFfSZCyc8az9dAf3v3XSffsfxLC56tv7taJphTW3G3W0ON9k6bhAhUojMsR2WfMzScrvtf5W/B3RNalXqVhvtaKgvR6lKfV07bYdeoBnDfY0xLYjXmLh7o/ECw78eBe8+r+mQXnbQHuT6GebR3NIz8RLy2znouno+y9zTc9qHe4GF8zEKLOEEYsjuQJbsKbGlNQpbU2FGlt9ec4xj252Ht9bL0oTXlKUpWc54EiZ5ifHgQdd6zi1ZGZczxt201UIhixRuKuacBWAaTRGksyozEhjtfiC/4Vc5a/lNxLiFfd/e5xtt1tbbmxKS/VDTiEc9YbPdAuIElm3G3W0ON9jct2wUIfIoXgNf5W/Bu89RG2nZWe1pbOMa9h9V3xj+B7N2dX+v670/iEXhQcHjz6v6ZBedJYbfiyGnJDD0d91l7t6/lSIl1rjjHQagIJBig9Xbpk1+DawUhjnnGM4zjNhQho+Ybb7mozCydJgpd6nHG2W1uu7D23MKLliwnIDXS1hn4hDKFQoFRH+QZEQjQyUOmGxMkMWmjpPGlbD8yq3wC+1v+a9kmEg8o7T7zyG2P3vtdWgWYM6OmmgpEGRfHkOdA2kTra40CbCmxSERiXE6tqbBYAQHRg9a1LVlSvASrKVYzgHNenAg8p7vT3244+W+t59195x53ta7ShNFr2E9N3xj+B7N2aIQSOuAKUro3YhGaO4vPnVf0yC8/YcBEC6n46O3FcW3JZWjoc/xr7iVKQrCkhZzBEIMms89ox1MXw7ju6EN5ZLkBCumdOiQIj8yZs7Z7h9axInlW62TshNqBAqFQGVUWmHD8nelV+KHxj8fjT1iyGtzDC+1vSeh+3sxU8a/ix5lxCx5H74bJ1+1boCXY06DLgS34kvnSNhmanIbQisXAFZ4eHh/RediCqtEdQkqVnlyEmfO8Kqel6/39lTm4FGPOOdutQWh9dDw2um74x/A9m7Nc9QhenaMSPJoZvL3nVf0yC8/eMH3FxQ+nuVdftq4DPQvGcoVjiZEfhS5MR/t6lJ5n0QZhfPejDyLmh1XcoBXIm4BZWeibNhjoT02bsTYky1zPcMcqZTCltJYjRafUBlVGIhQ/Klw486HKiSbQCk147PFPturacQ43UD7J+tjiaOTq/dtOL4ot9F3CGrKOnYxHJG6GnuWtPXQH98tj64h2uMqVEnjpw2S5Fm8x5KeNlIlQq3vSfFZwwcH7Yok1K1Zl7RosVhx7i07ydkMPRQMqVImSXZMnw9aS35VDALe7285j8anMsI7UdhyQ+yw3CaWxBiML6T45BIGWgr7EOU7DlxpTMda3Y8daudygII1Q5EX5uMZznitpUiuA0K878QMJ7PyCZjua0lvSqIAdf6Lb6qsPc0AQWoaegdH4goL+HgUzusPux3mnmojmVQoa1cp06IPhvzJmxNiS7XMywxyplMJ2wliNGAABlfGswIHmb1rCHxkU+zxoWw4ygmBc5Oo94y6jhqUSrB91cPXuzIVsQuJJ5nijYgKSIuSHlyH3Xl8aSYw9d0LV++Vxooe2wW0TLbQj9Ve9k3y9ISHHqRhDve3/LYzNAQ0doL/ALkZ1y8f+JL7UbOPgIeOifE+MHzY3EhrLL7zWfMjf8hj6BviI+7WBz6O5qvKc6+AdNt9VWHuaSJ/B3lhjo3qPy/VYczHcjsOyH2WWoaFoiRm1cT58QdCfly9ibFmWyX7hjlTKWTthNMaMArwwAMagDvNKjYxUbNgSSw54WTnQHqWfzXbOLJ5xnGce3HLdNaWLs2STcWXJhyWpMbXW2Wz7qBZjlu058BVmoDfLQEJ7352d++kuNFmR1sSLTo4VN/O+CPVGxAHlNEetttx1eENjqPbSSGVxYGjbhJw58TC0A6pjGZn/wAfYnH/AMfYnBDQExKUfAEtM3aFl/LRMEZEufkIdn8PxBtLh2BnvbnnPSr7OZX2tetNPXUA271S8f8AiS+1SX3XqdXnHeixwHBx8tCc8yN/yGPoG505zQpns7mi8ZVSl9N0Yej26wtvdsGRULMjCGELStOFJ5bZH4m0Qr7e2hC3FpQjWWqpmJQ4+Z4mTY0CJJlydibEmWuZlhjlTKYTthJMaMAADK8MYHj/AD97AERS0Auxxq88gzShmed2qjFqAyYGZ8CYOlvxJiFqQrCk673BiSqIHP8AG4LCoxb5MdHLSQ7EOm5fz++rrLTyFtOltZ0srlxTpPQYxaZCx87QR9ljK4v8kLtxA0TaHlrxMg6AXh//AM8XpKowsoVKGVOtCFZUP65EaLJa90/YtS1A0p55Fk1DawjT8hHXqAgiFeR2F962zW59oOy2u1qyE9MvQTDXVLx/4kvta9kx5VJrq2OjZkF+FeT6HvMrcBBOwCIC+3YrrW600pRKBPhEoMeZD8LYnoOy93RWcYpD/Ttf1+e7utyiSdHBv55WyBHn1Y3He7QCtmbDN+EF0bV4qsIRKk8OutMtKdd2fs5Z91YoVyqVZmWc3FHMAAA2vjWYED6BsoA2appNrPGiDWYx2aKXz23r1oxCePDuVR3JNEhXRpNa1LVlSuEIUtaUprA1AmuCB6fsHzjGcezNw1ZXLE266i0U45V5fuCPTBk5iTIsnA+ewRGwpjPcLzvlokhOwpXtVnPb0r68i9cvH/iS+1p39PxfTu6A5Gu7r6vMo/rKt9t1HvG1o4saJzZ0m3OpewTdTfSmPW7SDs0FUoX4N6hSJlOPsMdzRWcYpD/Ttf1+e7ugzSFwCoZfKRGakRnWXpiENy5CEdikakLn/dzCQQIMBD2IA7jOcYx7c7b2OwTwsAJ5VqtFLIUZgQKfURdWGIhQvoOcYzji9hshbWXhYCk3xJWCQYjS25kWLJa57loCYbrtjG9GuhOS1yCRs/YURHQycF+HM2DqiaBWqaI6dK2JBKr5HL7mz5ioVDOOtdvQ0Vh6xk3l9SkpWnKVHmGYxwtHZ7GjyGZNKzHz0b+hPJMhpvm6nisSr+DQ929yCfl12lvJ4rVlJ1oo0QgUW+jLcPypHgGU4+RFFd3RWcYpD/Ttf1+e7uoDLoy7QG8c76xiNc7A3jqCgSx2ZiIMpWoRIP2SynPbmxG4TEquDuQQPNNlIg+HUakLqotEKF9D3+Hc+JDGUcabOtE6gzDXw860y2px2PKiykZcjSozEuM/Gft1ferlgnjHOehQGG4pI+59hecYzjOM7T1ZmBl84D6NP2JIW3ssvdzfc/DVeGQc9vQESRkmbl467N6jOdnQK/ZVivTv8c8oQDnY8zTEV96/wHWu3v4RhcIMWRyrVjJVoswSgVw/AsIaITid8ynHyIoru6YhPxaNHWvo2v6/Pd2HJciSo8loOTaKiR89rludl1u+TlK6aRqUxYMMzp4OvCAEFMQZz2bfMVUYlmJIkPyn3X3+BImeYnx4EGhUIfUoH0XZgdktSTSF8aTN5gW7EJXG/WJiMBJSNd3d6omffrZeZfaaeZ3+Nxh0ESxyaZcedbaaqIZIKsiRf2G5xjOPZnbeuGA+cnBPNl51h1t5qsHWT9eGlGu3vggl6ywYKO3+Hf8A4Fj7Fm9RnOz+Hn25esqendcB2XRXXkeZoX1aQ7m1BmJ9GLp6NT3dVdMYgy8ZwrGM47xlOPkRRXd1Z+n1d6dr+vz3e0kW+NqGYeeW/wCE+k2GmZ516tGbFMxFG07UYMD7iXPxjGMezHO2WWHWQsklINFphopMIy+IkSTMktRo2ttbxqvFxNm/RVJwpOU5Mjsiy5KBmJKfiSmJLAYkyVEDiDO8Bzb9OZl5403fsjpWK8R/EN/rK/z1JXlmbhEeV9hzzLMhlxl7ZlBk1co5Ijc9AnVuIKgne3ssishdjTme3oSAtmvlJvYs3qM52dAkFNHTEDp2QOWQothZT5n4fWGMyLJJz25sZmbDlxH3U4Q64nHPUFxUfA/AP96wyWIlfLvv9zX0FwdSQEZfRtf1+e72kDWYFtVBVy39AWsIGn45UfT5MwpmcZDhBYSC1CH9EmSxEYdkSNhXR61mcu44QhS1YSnVes1BPcmy30fdYvMG7Pv8tE2L4wDMCO3QfkjUTkRPGM5TnGcWa2zLDBCMyuWk6+sbW3SL32HngI0+KfHELGBm14xLFzOVMO5AWYWR4acbdbQ632SEjMWBMkpkvrkSH3l9vRWcYpD/AGLN6jOdnQucYuUzpJwWiIufBd8zQEDDQg6Q7uwIT0K6WFl3nSbO7V7BGJYiyWJcdiSx3dieg7L3MYznPsxXG3Ga4EZd6Nr+vz3ehTJEGZGlxxJJgmJgT2ON0j8S6HIe4rVSOWaYlgdTdUgq7liW/wD2/pjp3Ne2pa81wdy1NrVmSiNYi/0jfw9rIwHP5assLQK4wXX32GZDDzDpSIuESmRV8wYt4uWgDmYEGMPhRocb7ENsUjNjDYmw+eprEs3UIyX+ztklgfRieO7p2AiHRYC+xZvUZzs6g/UUF05xxYITI86XhM+Xo6G/Hpa3XO5uuAuLe5L6ujR1jzOrkgU93duTXYdFJZa7cZC3JLKEdO1/X57v6NPIm1h4Uvg+EhHxEkXNHCx4uIiJA6tl3RNWBL9w66484t1zjVGvWrHKcJE0IQ0hDaPpG1x6ptEMJTwlWUKwrFLPtWGrjSGNoQHYN6OIc56ICLfNTTC/sS3JSkgi6CkTlpQ/gXa8QV9nfpX/AEgtPc1Z+n1d7Fm9RnOzr6a/Cu1cdZ6dmwmYN7Pss+XqD9Owvd3/AAXUHws3p19Yl161jZme7vWetipxIqe3RGXXbpWsN9O1/X57v6tsOQNwgrV2LGehV4RLJy7NYptjMyicvigUmbayqE4hw4sGKxEifSbDBYngC0Z/loWxIQ4QBPb5gpZso6UjljGc5410A/h+ojomfsSsoOLYAk8ZJIQZA+bKhyOI0h6LIZfZq5pB2viyaextQ0kxdSS0dzXkJ0fSQEdzrs3qM52avMjwLKDmSOnesZtq6NrR5dH/AC4plbxjufiG/vWOrWRvBmmCns9zf8t3DgGFjt6UguSb5EfR07X9fnu/jOU5xnFBsCbBUxs3PUZMDgQ58gRvN4I24j713itgJliMxBkSsVgZWBbcCB9Ls8J+DYS8Z/iqnHwJ8cSa2zeK9aUDmRvLWdcXYLbAZV9im8acllaLJF5aEPpygoBd6zM/AwQSIZkyH5Uh+S/3Kz6YrvYs3qM52W/8iOr8QaF+9ri8eWOisRB8KOx3PxDf3rHVoU7hqcUDu9zc5FE29TEJ7egIKVlTs/q2v6/PeBoiw4YJzgj/AEmzY4KPfIEL1eiNuI+8c4iRZEyVHix9d0dFRD/kd+mbThPxL0bw706RAfLa08TX9ih0SwaDERr0+FJgTZUOTxVj0iunh5Vhp5l9lt5rq3ebxAqaBye7WPb/AAwAxnrs3qM52qqtSqrXsq6N7xH3qlBfR5QKKzLNiYryU4QnCcdz8Q396x1UA1kLbRMvuKVhKcqzYiii50mRz29FjcxqrLmL6dr+vz3gCCTwsnBnsjCEUmNhz43MyaHBBz5AhebyRtxH3rvLUevcC4qDhb6bvGA6xcESV9AIRINF4I2PDiMwocaKx9iu9q6qIahm2uWmrIgrVkD19W6DmCdwdiNdxn/M12bN6jOdrXE52dR68+90bWgLnUMulHlUAfgjcwMbPd3/ADXlHg0HqZdcZdbdbBE0FQgyejtbBLoEUw5Jz3NawMQKMBZx07X9fnvB0ZbmvdPVqXyMmhwMe+QIXm8kbcR945y1Nr1JuVksVxjGMYxj6bv+M/gsFfz0aKrTciXOOv8A2LbCBfPKeWio5assqa/a46nuk8VaDhSJJ2Q+5Ifdec7jP+Zrs2b1Gc7WnJ6ZlDgox0WWA0SrpiGvytOwMzL1AXju7pmvSb7OaX1aimvS6GNy92t/l0JiBg2O3CiOzZkaI1GaSzGYZx07X9fnvBhzJUGUzKi1HdIKZCaQeMbXpYxl7KLleDFultuS+VIqEy1GmYjY8dEGQY8GH9O/EF/rK30NtrcWhCagCZAVscOR9iyk4XjOM34I2EtpaC1whakKwpNDP5sFWGTVdG9z+WoI8GjuwWHpM2Mwx2LN6jOdrQ0yKurTouOh1tDra23C8dEUqQjo8nQ8F120TpuObzrbLTjrkrfIdgr7lirXMBaY2XRvVnOMYznNgI5KHCk/PVoSStdaKsr7WxLCmw2wjMa7etRqSN2CtL6tjz2p94PvteKNGzSs+NBhUiowqoFZitfT99wXHgIqbjnqCtuGLWxMV9jG/g7KJQgu3y0VYUQzMwM/zdcS0044q4WF2x2GeSX3aN60rHYdX7tl1eCMxU4hMmK7P4fnEYi2Nrq2hGfYvZz3vk/h+g5wk7Pzz3qfdhih4djiAQmDpjEyHQbk1bQKJS+nYphkRTTD6+v8O/8Az7H2tk2HAGokH0ZznOe5oUZ74+QIZ6rb6qsPjakoOAsJJgl9Q3xPSxWR0LPPUVaSEqbElf2MbeG4nUUirHIOVlhykMjEFEmCYuCQY5bktHyatfL2O9RvWdY7EvH/AIkvt6B9RGOrecF1i4IlL8nRMF5irz5Kue3TKSt3n4Ry13cV1Q+0+tp5t9lt1vo30c9qxQVvr0LOW1ZCULtbusySJ1kQx3NFQPcVSVKz1W31VYfF1BR0GyCy0/GMYx9R/EC4ziKAYxyo1eTY7QNHLShKE4Qj7GJ8bE2BOiZkNe6fdbxy0TYmpQWcDe4WtKE5Wu+2bNms02envUb1nWOxLx/4kvt6W9ew+r8QMDHvQRHytPw34lEgYe5FSLIsZNIPvvuyHnXnuel7qieL+QS+ch9qMw8+9bDij9hJE+xon1o/2bjYWq5Xp5Jb77sh9553uUaEsdTwUZzpz7MY9vFlfZk2M2+x4dRrMyznYoyMLHRRY+JAi/Ud8y2HrNAjo5aPrCoAqUZk/Y1eIKIFtPR2+VEsWK5aRpJbbiHUIWjdltRCEoBRe/qyExNvwFp/rl4/8SX29aSn415AKa6d6RWF09iQvyaDGfiUwAw/y3YXRBp2YXSELygpaESihTMI2JiEoPLddpwOCtBo/Y0T60f7O4rc6XPrEMdyvwHSRwZCaSlKU4Snpc/xr8Rttbq0IRrGlIrANC5H1LbU/E29FfZxr/W5WySo0yQywzHabZZ+xrdUR9i9Snl89c7VerzKxhSwHJZ8xMJyu/p79QwvYs850fWzc1ntVyZIhHhUljp2Ww8/RD6GfIaaW8622gUytgZAZd5b0LfFWeNARy1lR27YUl4l3CnlKoUXDmcaSuS4BTICVwYKRAomcTmWawzbGalk5fY0HBbdNmJvY2nclVkBhEZSsqznOe5pYViddWX1dTn+Nfiae1/8U6g+V+p7YoJ6KZJH2dc6kyYZQVOsMsx2W2Wfsb3/AOqhfi6e/UML2LvjH8D2bttOuMututjXlvixzjnQXhKniSMNDiMocUjPj12E/PPCojHJ15tlpx1w8RcKGiU9zlq+trrtTjMvW+qxLSCfHv2Cvk68TeHkWJD0Z5t9jX1sZs9djyeNwXzJWbkFA7P4fkKxJsK89RcnEDjZJCZbrPMtBuQSkd3QIz3YkyUz1WKc8Pr5mcx2sY4A6dtxZtDz8/Q9ojMYXFLgy4V9DBPo1vreTaZGJs2LGjRI7MWL9qP4g0IwisL8XT36hhexd8Y/gezdyjTnplNByH+mywGxtiMQG/H1rFkSbwBwxy2YV+VUos9jlrGvKPW6Ahf9v6Y42bQ2bUIW/EzjKc5xmuWwtXUEkQc5znPa0I263Wya19Oc4xjOc7W2C4envCoHe1wNwNo4Bjruno+y9pll151tprWmsGALCCRfkVDCjEXMYjatGkon5nwD9OtbDzjS41Lt0l9thqn6S9w+mXYosWNEjMxo32pfiD/xVrxdPfqGF7G23XWaAYW129Py35NDH5e6dswmYd+NoY8fSUN9+7svt8t+Fms5ECE8tJ1/I2tLJO89x1xAa2uSWe3qOI/EoY1D3TtvZEdTEquCu8EG5KGRo/jGMYxjGOrY8/I+iWJ/taYojUnOLIS+1v8AEH/irXi6UipfvTDuevcH6el+5oJ/GQRZhXTv+C+2eCzM+PoGE9kobm89pl/ml2KrTww1l15prgXCSPGQYWOe/wCawskBgp7dUgIHVsLET0bT2TGCxZIUd39KC8zLo3Jz17c/Ts92aZV5NnPRh7UWKxEjMRmPtb33CYXWhkzPiaC9Xk+xvKXIj0xhpHb0DOaaPFYSun8QI3KhIIh5GgIsloYdl54MT2xgkjPdefdfeced41eNwRvIVvPRsw40cuZOSx2qtAdI2MRDa/t/THPY+1IoaOsaFeedfdcdd7+iBPwwCeSV17wlPxqQlDfWlKlKwlOrqeqsV7HxH2uXwO6ap52Az4mhPWBHsb7x7KkM7mpZzsO+B/ydO5Ysd6gEHXPH0nEfjUdK3ONzE8wKPJbxy0BCUoqbn9F5Pt16rEp+c5znPtz2tMCfj7ky+vkpSUpypWx9usrjOCa54NGFfJ6iGhZ698qRioD0djTNOyWMYNyftd/vj2Zt4b5HZiwzHh6E9YEex+IPKk/wyjHbETkjio+cpCvzJSrptsJ2fVTsVrx9awX4FFr7D3G/yWVkggzno6G6xSnXV897n8vlYIRHb0COwlo4SzwRIwBcF+bO2FticbclDBPg04d8ztIWHxjGMY9mOv8AEH/hrHWHEzTJKIOhV0HEr4WGNi/a9v0JlueLMo8PQnrAj2N/y465tehp7lALfNaaCmZ6HMZW26nBCE5AnzIbni+z254rsV+FXw0SRxtEgghfDzqOVAhNQKTXGGuRCfGHQpU2UaJvFi08g929RD2odEGrRcdjAaqjLbtruJq1TkSSPhaHFe+PziSuxv8AnNLnAYGOrSlOxFhLsMv7X9mgsmqeTZR4ehPWBHsb79YQO7ogvmVWZw1fTsaExBu59hnxR0F8gQhwWOHHENoW44RlPzJ8uS/xFjPy5LEZhpttppttrlus3kdVPg2+2nGM5xjNi21JiiogEA886+4p13w9KBsD6j8Yvsb99VDOqhVRy02GPA4ZZaYZaZb+191lDzDrTlkFqDniY7PhaE9YEexuR91y/lEL7miCeItrlQ19O8YOI1z9+jxdfQXp92rrLPFteYYq1gW9yo0SRLuFeaY57rNZn274FP0BttTjiEJAjcCgowensbkznN/KY6f65zxqyp4rtaj5f+2HY/rmw+HoT1gR7Gz57c+9n3kdykl/ktqDT89P4goL35wMzHi6XgLl3yE8njaf6fH889QR33r+HW1ydcS0y44orNyQJz52foGrBLpS7h8I7Oz5+Z96Ou56NOU7Jk3gu/8AbEdWtZsopfhaE9YEexbJTEy0HpTHcSpSFYUmmmFmKoHnOdG8YDT9QZlZ8XQUN9VjKTscbrfeZozmGuWh/Wcrns4okZRji/oWgAuMIMm19m2zmSFnOTWeYsbLKkI0CHWgEOuhIQ2N9sW3gT4q4zX1eFoT1gR65clmHDkS33FYy45nHd0QS99Wp0Hp2fBYl0M1hzxdAQXUQz07PG+PQ6Of4fWGlzz72eW/Z/uwwSB9C1YJ+VUcQ2vsZzjGM5zN/wCbK6NIVFDUZyySvtj2FTGLYCcjonQZY+W/El+DpMguHemGcdV2msQqgfff72kS/wADcMRVdBVlb4oi0242tpxba/E0XDejU999zjfHodHP8PX9JNn57+kP5sQmLn6BXxLpk0OGtIR+VCU9mxJx/DJvPRSKs9abDHGohw40KKxFi/bJdKCFtcJ7LtnqpisEPgifga4nuQbxXnW+rc05cOiyUJ7wMisWYHz0MupeZaeT0WsfkbZTMLPiapgvQqIGQ7xvj0Ojn+Hr+kmz89x5z/MEtj6DpALifanZ6+zsV55ijn3mOeqKcmu19Ep/7ZjQUaaHPjyF91KSrn55w7vxZDsaQw+0PmNTx0Ka307+JZTgKLx39VGGidHF4R0bagswr4XS14lQiSINVBRJHG7WXnqOvLPL8PX9JNn57Nn5n3k85n6Bo4SiJVnyHa3DOeiUWd7rlqKmLNHEE5P203vTwsqh+cEJiyAma9Dn97T5dBGkxGs9O4S3zC6S2k9/QJv2PGAq+jfjGUWIW+nw2GHZDzTLUPC0Qora+No+gLBz/D1/STZ+d99a2b6A00t1xDaKuMyJrwgdns7u9CucgYaYcKxBsOuAodfERBsT7arHVANmiZjFLnrU/VVreX3dEnsRjE4OvomSMRYkiRknPeJEZc17v6+LtBrkDmvdG/4b6xQOUjw6yw8/YgzbPK5Q2JtTPsP8vw9f0k2fntOA1Avhxprz9dhkGrgJiL7W7vQrnGMcanof8OjcEpv22PNtPMuMvXrTESX78hXZ4+aNluxJnbAFnQxkeSahymZcONJa57kP/KakuIjwMZ4pprBiqBJ3RuWAiZRJjviaxQtV7AezkThonjJ0FTiPyOLTy0NLfRaZ8ZPLc8Z9m+kFr8/QghS55YqrtW+rRLQFcGSKzpNgVYPjCX232mmALTFw0Ruutj9SVl17t6RtWJ4Z4HJ57lsXzW1rhI8HQZfLwkqLXzvUGNNpljaf8PSHrlvoPD8jDZSBnjS09ES9Rmlct/jsoLAyGPP1OGWJpMDDv2+KQlacpXeNLQJTC5taJCyAqWuIQ7NRsT9bsEAo3GeYlMMPscXaytVmtziWXnnn3XHXvB1EaWLusBHQ8wy8w4y84nKVqTnwvw+f0NnM9G0oLMG+HWmuNbT2oF5r77vLeYj4yqMEUecHHPFCsAew0yyw02yz9v1kqgKyw/hyVx1CdBe+lQOzpC6e+Zdrc7jdNp+Zn0iWPChynYkuPJaDE2SomCQZ57BhPwrtY2nvC0BCY9wendG8oTEe6ofa4HzXx8+JNYxn24TnlbRKDNZNDvP0QD+IOzTDn3AZxjOPZm56jB2HMqZCsdVN1uauKT64M2TAmMS40/bcFNDQXjuuuPOuOueHpc0ojTsRl891D8w71Jdz4WgWnkBjbquf4goCcKr05HKlFElKkBl89jA3wlwLMO+brevrr9SgRXfuCIjoJOA9Cm3LSGEIcmVqeOnDZK403y9GncQ7DJGO89+wEINBZ+PC0f6Fz0byhPyaU0+3y0gSXKpHwzvLe9ey8PgHWvM1pVs2OzxmnEpwnGMY+4Sx1OvWRhLRO36aOh1OSBDja21qQvyauYUEsAwmlDmFoQvHL8QUF1UUBOT4Wj/QuejZkDM+iHmsctATloKHIHM4HjGg04dJKjpAslMgSfL1HVsAqw1If+4e2ayqtl/O87aNa2mtZUuT5OvS3zilhZXPfnpcVjw9MRJEejRfe87TCfn1c7Ej8tUz24F7DLc57yp7v52LJE8rVlJ/iY17+T9xVv06COrdmQLLRbLWV5+P8fQJlrMMyGVy/EJjOHKv4esVY/l7Xk9En/BI5gJz482MmMcyQ6KTHTIMq41eXVzska/5AgVNMEoo6DT6xErAKMNY+4tbSHUKQu26ZAlGnnw1ip1irTjaSvi66sWK7bR013luoliZeH2MeFrFWP5e15PRapkiFWTkxjk04tpxDiBUlyUIHSHeexqM1bhGEMyoz0WQ/He8fU9AyAh5LT/uOcQ262tty2aSDz0IeBWCjWeuYSsl4mmLYgqCyJlFSDQoZNIPk57xIjOnveFrFWP5e15PRsOWxCpNiW/zB+nwnTtzXjJOI4dF+NqrV3sywePfci4026hbblq0xXSuVPjLDQLVXlrxN8KpWB+un4BNrc12ivjIQUf4esVY/l7Xk9G5JMZmgkGnOUZnD0lhrMKNiHBiRE9Ox9QqIvrLV11p1l1TTvh6t1Z+TDB499ymU4zj+tl1NUzzi302XUFtCu+2KtKkKzhXgZznP9/D1irH8va8no39P92IBD+dOFfN7QHg567/AKrHWbMgjCJiiImWuIQ8AcMIFJSIkDX2qYldW2SJ/cxZqJV7L/8AefYtFlYqX3wpAURGPZZneMMBlyzqWh0TTd7lMNvcfyQv3BXV93GfnU68w8w6pp7r0w+t6jMYVz32QW6fEj8ctEB/ibHMKq7FkqoKyxMxyVr0/ZAeXX4a0KQrKVd2p6ksZ7DUmTWqkCrMX3A37myIoaUjZjz7Ho0HN9++Hs2vbTWcZcneELFzys+PBg1DSgmAhEk9Hixozfu2OZatgDLWUkrXopaPfSa6RHTBk2RCm9OnrsyBJujJvI4cHABz5EjaDrthPkSrnLVlbdr1RjIf7Vk1lUrC47JkWPSlpFIffgy4cuE+uPK7EWJKmPtsRa9pe1FUMPza/q2pAloebxjGMezH3PZ9meD2u6acw4uSd0IVYwt4OUAGxC/dke9XK4TsZRmAPp9PFVQXiJE67HVgdkgqik75rErVV5ktdOoNg5KRsASt52SIqjeGcWW2nLNMzIJctV0hVjM4mS+7PFiyTaGp5XTFHnP+9aIaAfwz7R5DR90i5b+G/kzsHj+TOweIGkbpJW5iRA0BJUznM+DpOjRFrW8ODihLWWR33SSI8eSytl+w6gqBhbj7J3R9ogYWuATDFRT2WSHartdJ2ImyPH0+oDKoLREidlaErSpCr5peI+3In1ydBlwJb0SXzhTZcCUzLiOOLdWta+VbrZSyE2oA+sV6FXA0QdF+76XChymFsSzmm6cU/O7GM6HscNKljC1YsIf25I9OMZVn2YqOn7EadZfJV2rBa3CRFG9y30CvWlnPxdtoVgqj3/m9IcIVOTEQxtBoUCowPvDUlK05SoprqklE/wD7T9C1x38nwJDQEtGUfAZ0Af4iaCDNPIXJAUGqV5TTo/vzoMMhDkQ5dv0bla8yayZrhsG+4yR4YYefcw2zWtQ2owtC5dYqQSrQVxBn3tvsx328tvTaxW5yfyyEQB7TmHGf/wC/X//EAFQQAAIBAgIHAwYKCAUDAwIEBwECAwQRABIQEyAhMDFRBUBBFCJVYXGzIzJQUlRwgIGxsjNCU2Jyc5GTFSRggqGSwcIGZMND4kRjdLAlNDWElKLj/9oACAEBAAk/AP8A990rIYXIuBI4Un+uO1aRFJCg65OZx2tSMoJW+uTmMSq6NezIQwNj1H22407RqFuHl5QoVbHassMMvOCE5EC4neVgLBnYsQOm/T2jUQGK+QI5sM3qxEiFzYVieYg/jXBBUi4I5EfbYnaKR1vXOoscjckDcCe9NKclJOzWMLeCH7a7KqU0LyEsbC4GGzTVErSOfWx2IMsAa0tSwtGmGmrpluXu2SJsJL2fLYBTESyD2q+IdZSsQEqkB1baJb1sHwFV63Tk/wDv+2s8qyVs4junIqN7K2wki9l02+Z1FhI/hCDilip4EvljjUKoubnTAs0EykOjYZpaOcF6aU/kb95cZzSTrqahQRybDhkYBlZTcEHkQftqhdU4lm0oXkkYKiKLlmY2AGL2gi3kggs7b3bZNpaMeWRDqYQbrokvV9nWT1tF9tVjkFBCVXTGjxwuZ5Fc2Fo9uJkSCqdYlY3OqJuh+9cC61avC/21YsnkkcUHtsM+l/mQBNtIlStpLG3Nnh5s2JdWTVo4b+V5/wBtX9snu105C9W7zFgu3TFmpqrK0vzEcY/bt7tvtqVMUEKWzSSOEQXNhcnE6zQPMoSReTZUC6ASSbADmTiN4xHSR3Rr5lZlzMDfbcJqUWe/8o5sA3ggllTws/21HP8Alqt4CoW4OvW9/wCqaZdWJ6yJM9r2u3AQNLNRSqgJAubYQGKCicSe2Q/bUW7zU5MXnZRrUOdLnpmGmn1sdKrzv0QoPNfgfR3/AAOPosX21N4O44y6uOoJQKuVVWQZwoHqvoY62KGGFV8CsrFj+TgfR3/A4Av5Wn5PtqxPaaFoXf8AUBTeo0GQrXUroFHxA8fnhm2CxR5kjVUF2JbEokimRXjdeTIwuCNMauYaOUhSbA7sJaWerkLn5+T7asaGSjZZwzc1GhWYQVUblVbKWF+WlykECF5GsTZRhWjpkGSngLXCJitC0MgtSyP/APSfwS/gh05jrYTCpXrKbDAI10Zlf1u7fbVvkmiZG62YWxG6NBM6ZXFmGU+OhApNIiFQ2axjGTRMwo6J7T2YWmmH/ZNIQVdJCBBJcLrkXRHcVdZGl+mS74XLGtHEQtyfjLc/bWRUjrYUnX8rE6Aimmqc4s29hJjnY2xm8r8ok8oz/G1uY57/AH6ZWimiYMjqbMrDxGAUracKKqI/8OMMxyefMnJCJXCjCBUjUIijkFUWA0zLFBCpaSRjYKBillrZQXAf4kV1xBR08fzChkwaH+xiGjnjAN0CGPHZslMbNd4fhExXQ1MfiUa5HtHMfbNQ56Cfz+QAim0GMJW0xW7GxJQ3AXRCUpq4+UwtvIJf4+mBpp5mCRxoLlicRjy6dVaslvmu48FPRcJLNFTdopCEcXyJTbn0zCKniH3k+CqPEnBaGiS4gpr7lXq3Vtqskgl3Zsp3OAb5XHiMEQ1sQAqabxHrXqp+2YqkVFOyoXJCrJzRjbo2FKspIYEWIIxYCnqFZyQWsh3NjeHAYew4RfLqMmWHwLL+smBYjmNAcdoVMR1SEFdTG2Ctqand1V2yhnt5i3/eaww5cxQTyzu7XJ1gyaZAaKgcr7ZuTngHfG1nWwOaNvjLhw0M8SyIw33Vhf7ZgAjrbVib7/pic9/94OiXNOiama7BmzxbiToQ+R1b2n/cnwimjppSIIWS+ulHj7E0SEPWTZ5v5UWGOdIooAvqlJbQUBp4GKBuTSHci7urYJZmJJJNySdiNnd2CoiglmYmwAAxQpSoQpUVD5CwbEcVbGnhA13KgXJynEbI6MVdGBDKwNiCDyOie81G+eJfHUv9sxGLUMxR+QtFNoT448sif+iODog1tNMAHTMVvY3G9cRLFDEoWONQAqqBYADQ6NBSnyaAoQwKR4p8j1Na5DlbF0QAaAp8srYonv0W8uxGu5c0kzkiOMdXIwgmr2iCz1T828bKOSjTFHTdqr56VFrCbwyTYp3hnhYq6PzBw6rBK4p6ksQqiKUgFiTyCGzfbMvkqaaSNrGxsy4TLNDIyOvRlNsG0cE41ptmtE4KP9+U4cMrAFWBuCD4jSfhpUMMFmKkvJgkkm5J5k4kD3pRNdek7GYDR+mhgnnf+Cdgq+70pmnqJQiYCs6i88oWxlk67KIK6gQubLvli8V0SF52gCTliCxli8xibfbDnjijjUs7uwVVUcyScf8AqPsz/wDyY8dr0VRIELlIp1dgo8bLjftb6WrcCbqkuh1FXQoBBdt8sI/7poIAAuSeQGJ9bQUQIVvB5TzbC2o4LTVbdYwfiAjkz4AVVAAAFgANDgpSwQRRepCgk0xoyUlMIk6q8+0AVIsQfHEgfUVcqZgMoNmwihYKpJFPiTMtj+T7YNQNYVvHToQZZPYMEdnU5DLZLPKwbq5xVSzzPbNJI5dmsLC5OntKUxJu8mlJkhK3zEZTgCj7Sc2VOccuzAs0EyFJI3FwwOFlquz1iLyo1mmhxLJBPE11dGKOjDoRYg4oYK4Iiqj3MT+1zjLQ0Mi2eCI3Z/U74h1dMrAS1L7kXEOVF3u5+PI55u501GvR66bVyXzAxhrJbSjrLWu9U4f982Qj1FFG2y5aumikT2KNXh1DTULKi+LEOG+2BGJKiVtXTQ9XxOZZ5TdmPIDwAHgBtEqykEEGxBGK7PUsQaOZ+cvWNtqhEVSbkzQnI+O3bJbeZosVctcUVS0VgkRfEKRQxKFRFFlVR4DS4SKGNnkY8lVRck4NwXYg+onS5dKSmihVzuLCNQgJ23u8kEsBToIiGx+xqPdn7YD3paf4Cm/gTZBJPgBc4UqehFtDEMpBBHMEYf8Az9LZKsBLXY8nHDDMoopUsoBN5hkGkoD5bHIc/IrCdYeB+0q/wTCKXioGaNiLlSXA+1/KiyPCYYw+8M0u4jZfybs1HAaQ85eoTHZsSyJv17gPMWIyk5jjsuCoJCrnK2eym4GcWYDBaaBFLvSG5kHrTQ9qaptBUexsG4O8EcKLN5VPFBfoPj6b3paSaZPbuTgIS5kqLPewUAJi+uRYYR0s5Lfa/iJNTV+72Ey9lQScnF/KmXmgxCscMahURRZVUeA2IUWWFS9dF1REAumhiZRFqZCVC+fF5h4VlinqXaT2xjTDuyQIrleB+0q/wTEYEsnaDq79VRF+1+F1RSSfTueolClvmJzZvuGIFhp4Eyoi7IBU7iD44haKnMokgBAAyPv8z1A4yK5ZahOrfqNwkYxx1Mgd+hYaUtHU1rNEeoVQnAC6mKleZet5HKH8mEAcwNL90zmRftf21VNRoYv9+lFsiJBG/wDy23T2DxPDJN1ZTdRhARVxTQN7zhfTotMpbXIZz7ZTfTB5TJVOxaFWswiVfj4nEtPKNx8b+KsPAjYn1kUEMMcYBuEGQMy4culJTxQq7c2EaBAT9r+LJ5OscHtsNOS85kmBHRztwtJJS1COpX9QE2Y4lESR9oUzO7GwVQ4uSeEoNo094NK2ijpIrAkmwtocJDBEzuSQNw8BfxOCNZMwsoFgqKLKoxeWjlIFTTnkw6r0YYnE0EouOoPirDwI0OFRQWZmNgAOZJPIDESM9R2yKh1X4uRH1j/bAkV0acWZTcHzRpLFEo4itzfmt9uMvI9I+RVFybaJRJFNEjo45MrC4I4IYL5FLJu6xLnGmTPK9HEWYgDQfMp2WSpcEEM+m8tHKQKmm8GHVejjE4lp5RuPjfxVh4EYYB5IjBHdSwLTbsRuY6Cmdw45CSTzAG+2AECwSBQELFd4B3Z9F8kk8aNbcbM1jgWSJFRQd+5RYbf0Kb8uj0VS+6XgsUWpgkhZl5gSLluMbwrEf0OiYvJBPKkn7lzcLhwsVPC8jMeQCi/hj9JPK8jbybFje2wbVlc6ySRBiVjUDcmJfjkzzAN9yhsZw1TOkK9CsQ+2B+3X8g0MwjlrIwxXgIHRgVZSLgg+GFAVZ5AoHIANj0VS+6XhRlIoa6dI16IHNtCvrEnSYt4WcWwmeeWhmVE2KZPJkF6OJxcu/hLggAC5J8Bh80bTFIfPzjInmrbEpcyRGfla2uOf7YH7dfyDRyiEky+2NbjgEBQLkncABggg1EpBHIjMceiqX3S8JwRWU0Ey9VCrqfxTRbVT0Jd/bE2BcHcQcIf8PrGZ4eiPzZNCW7OpXVqtybexBiJYoI1CoiCyqo8AMNaprgaaABirDPzfGa888cd1GYgMbE4ObVoq5j42FvtgDnRw6I8+udoPZrRbYIueWx9Dl/KdHoql90vCQ56Gco/qin0IXDVSwlQ2W+v+C0IpDodW5FzHJ4OMQBqxDdn/AFFi560nwXEajIoMsgFjLJ4udEjGn7OTUDoZecjYEuSjR5iyfbBRQ70j52tYtZ9EmrkjqomV7A287BuDyOhwkaKWdmNgFAuScVTw0vZznyJwLMW8XOLQdqwoBPCOT/vx6VUulHJzFx5wtoBDL2XSAgixBES8LKFqIHQFlD5WI3MAfFcJlmgkaORedmU2OJGR0YMjqSGVgbgg4uI6qnjlUEgkBxezesaKeLyjVavXZRrMl75M3O19D2qnGppv5r45k3OEcGRkgQn4jKu8/bBgBWGpYPJ4qHGm+rajiy5h0W2iUiapQPO6sQVTwTRO8M8Lh43U2IOGEPaUC/DQ+Dj56aHRXqXSGx5sraOg01kVPEP1na1/Z1OKB6l/CSXzEx2HQf1fHYZzl7M0Mm4JjtFUne+WCYatjvtsJ0WsX/hX0JaTs2b+qTln2P8A+ToC8cXR38X0RlJ5UM86k8nk+2CsjSQBahFQXuY9IUalnhW3isZ0Pnk8tmW/qRio0ztDPCwZHU7wcIkVdTMEqYl94OinCAkl5y+IjIf8Qp2KgZvNRwzaU8prZbGOlVrHJ4u5xVtL5zGOO51cQPgi7BsRyOJpa3swCxjJDPH0KE4kDxVEYkUgg7iOWhA8bgqysLgg+Bwhfst2u6eNPgF4xdJ4cxUSI2KgSQyD2MreKt0I0VKN2q4CNZc4iR9ERNDQ2mm6MR8RPthOUWogkizDebOtr4QpLBK8bqwsQVNtE5LpUo4i6Iw0ZirztOjEWzLKc2xbyvtCBNWnjFAfPwEtSokAKte+XEiKKOGadvd6Aj1kxy00JP8AVvYuJ3mqJ3zO7cyduUCjrXGqZrnJPpRXR1KsrAEMDzBGIzPSswPkXN4r88nVcVtRRScnTl/VWx/6gqcjqUawVThyzsSzMxJJJ5k4iux3ySH4kSeLNjOVDF5XbnJIwALn7YdhHXItUvtfc2hEKVNGWLHrFoYayhUrKnWJtMCPQwMRAjfryjF9XS08kpy2Jsi3wQ0s8ryOQLAs5ucUwICJBFN/y40boKVmghXoE2KYuEK66UmyRqx5scVM1dIV8GMSYnmopxyZiZUbEWvpOaVUQJTnYZ/mtgkMDcEbiCMG9TF8BVfzU2KT4dQwWaI5HF8dvOkdt4miDtjtaSpUMCI4k1WKKKnj6IoBPtP2xLiTsyW5XrFMQjaFZlNSIrL1mBj0JnjljZHU+KsLHCP5K5z0rm5vG2PMpISpqpvBV6e04hWKCFQscaCwUDDrru0JxdTz1MGgJrK0mpcqT47lwbKoLE+oYN45qqaRDyurMSNK5IUs1RUMLpEuIQkSb2Y73kc83c+JOmFZYZVKyRuLqynwOIZX7Jk8WOdon6NiRFpu001LX5CVbmP7ZcSyRTxNHIrcirixBx+lppihPIMOasPUww5SSJ1eNxzVlNwcZilTTxypmFiFdbjQyJWUzGWmdvEnmjdA2EXOFU1EoG+WXxbRIHgpFWliYDmI+ft88nDBWqZlTN0BwoWOGJY1AAAsotyGOeqf8NKlndgqqOZJwlqhwJKpusp2YUlglQpJG4urKcSm9JOGhdTZshs6G45NgoRU06OwQkhXt5y7+jfbLTeloKrRNefs5zCQXu5i5psTBKhl1NPzvrJNAIiplMUPR3fQbKIJLk/w6VcxUoadiBcApyvtpEq1lKyG3NngbBY+RVAyMW/Um+2XHngqI2R1uRdWwjBUc6lyDZ4/BhgK+7JNE3KSIkErhykkZtLA9s8eg2A5nE4koaAFQ45PK3NsRNLPM4REUXJJxY6lBrHA+PId7No9HT6c4cCKBehDXY7cSXo61Hd/FUcGPAW1ZSOmYtYgp5/2zLivpEd6e3u2xG0csbFXRgQysDYgjFS8E0bAhlNuXXFK4nSwSWmQEPgHs+iPNEcl3DDk7aIMlXKlqNDcPEjc3b1vp9HT6ZA/ldRNOPd7YLKlFJL/AL4RnXEZcR1cfmg2vmNvtmqtL2qQMlR4PbwkGOznKMxEc0YLxv7CNFBPPJJfIEQkG2CstWm9KTmkT+DMdj0dPpGVD2fA9vXKudjtpnhnp5I5FuRdWWxFxg2eN1dD0ZTcYa7vTxsx5XJFz9s7siiY3uSYE3k/diFIo1vlRFCqLnwA2fR0+jxIxGEihRUjQclVRYDb/ZP+Gi2slo4i1h9tT0dPoTMp7TpbjqNYOB+yf8NH0FPtqejp9ERdYEneXoqmJk2HBKnK1jex6bBAURMSSbAADR9BT7ajFFnpJULrvIBXQ9mn7Omii9bgq+m5YnVwRrzeQgkDEjVNNXTZ6yLqfnpidZoZVuhXS6oD2fOoJNgWZSFGj6Cn21Oeqf8ADRNqkhqk1rhc1onOST+qnRIqRxozu7Gyqqi5YnoMI0VHToY6aEt4eLt+82hy8RsJ4GJySJiXPG250O5438VfQjlqyqghQ9GU638E0RokaUsQVVFgBb7aguCCCOoOEyxxVcyIvRVcgDRJG7TUqPKyCy6zk4HsbEmTympjgf8AlsCdh80T2WogY+ZKmHvDLuIYWZWHNTio/bVE0P8ARI30fRofyD7asgcpWSHMB8859EwL0FQUCBeUcnnjH/4Wpimf1qLpsOI41XPPKf1I8RhIYECKAAOQ54J1dFakjBHLVfG0dsprIoY0fIjuLheqjENdKEewdYls2KualK8lliJLf9F8V0FSgNi0ThwDa9jb7aTqfKMky28FZdExCVcGdEtzeHEYeGaNkkU385WFiMAZ4WFmXkyMLqy6IGmqJmsqj/kk+AGI017KrVU3Myy4ZQlLA72ZsoZgPNX/AHHDs8krs7sxLMWY3NydmrlppkI85GIuAb2PUYj1VZS2FTGOR6Mn2y5cqLyUfGkfwVcVL9nUqnzESxf/AHnHbUstr+ZKAyHCJRy5bCpW+qfDAhhcEbwRoYlqml3r01Z0FrLOquqkAsjnKRoX/M9nxHWr4yQf/ZhSzMQFUC5JOHD9oViIZuka8wi6JAHrWLzddUmz2TWSxuLq6QuykeogYBBHgRbG+CciCdeqP9sqVYoYlLO7EBVUDeScGVKNDalgc/ETYd5uypW9rQN89MSpLDKoeORDdWU8iDhSZuzmMwXmWj5NpI8+nRHUNmyvGMpBwoZWBVgeRBw8M8Suf8PSzFol6tpJ1EDmCBeiJsC8lROkai4G9jbF9XBEka352QWxDCslDVo7vYBskh1RUYYqykFSOYIxOJhLSxNrAc2Ykbz9snOvl9QS3QpBppTUnXmCGJ7qgVQGL47AgSZoXERzvucrgWeNmRh61NjiZ3oa1gkA56qdsKHVwVZWFwQfA4F6SctLSt+4TyPrXQ5vA4mi6BH2Hy1dbeCD7+bbIQpQQtU2PiwIRdEGtvQTMicyZIxnTR9EX7ZP7Sr/AATSZc3k4ldXFirzHWFdCsIqm06krYEyc8uCQ8bq6kGxupvhQHnp4pWA5AugawxFcc45F+PE/g6YgMc8Z9qup5Oh8QcSBKeUmCduiSbEmajo7wU/irdX2VZXq6rVgleccPiujnY2wmSaCVo5FPg6GxGPoi/bJjGdO0kVWPOzI+iTIKioiiz2vl1jBb4N8qgX9mhTZC1LL+dNBvanIPtDnQBFUxgmmqQN6N0PVcU+rZhmjdTmR16qcVxFYJRHSzPykQjcHbBBBFwQdxBw5ftKeMo7BrahHH59HZ8spIuXIyoB1LHFdBMZavUFI7+KZxpiEbwUkYlUNmAlYZpP6sTpZWby2SS69JjrBj6Iv2yedJLBLF/GXEf4PoRHSmzzyB+iDSiNJBGKlCx5GA3YjQ4zrWzZhppEnj3lfBkY+KnAevobpyW8yluqriq7RaRAVEKPIWUJutYdMUksEUrEvU1Nxyaxw7doTAKbPuiDYjWONRZUQBVA9QGI0aSlC1KEnlqt7H/o0ZTFJUBnVwSGSMaxl+8LsOSauCGdvd4uI46SLLc3O9b/AGyafXO9BPq48uYtIFJS3rvoJvT0gVeh1p0xrJHIrI6MLhlYWIPqOCpkpaiWFyvxS0bFTbEOSSumMpa/NF3Lswxq5vdgoBN9hM8VRA8Tre11dbc8JllhkaORbg2ZDYjEqxTmNkzFFfc38WO1E/sR47UT+xHjtRP7EeJtfK7wwEhQl0zerAskaKijoFFh9spmYUtVLErMuUsqMQGx2jPT2bPlRzkLcrsvI4/9Qz/9KY7RWquvKdAQuDRf2mwkKTVDBpBEmRMwFr2xIXy0cbZv4xn4UIjjnKzxi/MSbLlRAXn9piF/tl5ytdSxS3PLOg1ZVdnLnnqY0XP8W7NgAKBYAbgAOEnWCY22R5iIsEftb7ZagSUE4DfwS7KIYqGF5mzf9C8NkVp47I7rmCON6tiIxzQuUdSCN40xNLNKwWONRdmY+AxK7TOddP0WV1F1H2y0DRzwvGQb2IYW8MC0tPKyN67bCFZe0ps6jrDGLJtFKztCwKxKbov8bYrzRRclhhxXmsj5NDNgNS19rmJyLN/AdK6ivSIpFOP+M+OypXjDBBLCNYjEi+62KI0UBUMZp8Ra+u88GrcefZvBftm07vMi2rEHii8nwLEcxogcdlwG9TJyv0RcAKqgAACwAGy+Ssq4i8svjFFg3J5nQLk4cqw5FTYjDlqsKRTT89aqeD/bToXhqJXzvNA+RnxBUz5OUc0oZDiFIo0FlRFCqoHQDa6UvuE0gEOrikg/qpdsA6nNngPWJ8SNHLGwZHUkMrA3BBx+nUaif1yx82+210pvcJoiU9l0j2lDH9K9rhMKAoACqBYADCXrez0Mo6tFzcaJbsJYXRC322ulN7hMLeSV1RBe12Y2GLFokvI3WRt7HQgdJFKurC4KkWIOFISCc6q5BJibzkOPoS/n/wBU1sNNEoBZpHCgAm2KZ65jzd7xIuI4JabLZqRFyLhyUfc6MLNG45qfs3dKb3CYkaOLy2HMyrmI87YZDIlBEtRYWIe7Nj6CvvP9TTJFGN7M7BQPaTitNXOusGSAX89MQxUMZuAwGd8VUs7gWDSOXIF72F9ClmYgAAXJJwCskUAMovmtK5zv9meqiggTm7sFF8UM9YA7BnJES4/9ON/fxRT0V2ADg61BiqiqIW5OjBhpSyVENPJF60EYTH02D842FQFKt4Rl6QfBDH0Ffef6jqooY0GZ2dgoUdTieWscM6vqBdVK4oYaMWXz2+FfHaU9RutZ3JW181rbIvHTE1Um8qbQ/ZncBVUszHkAMSFaCB2FLCOng59Z2GzRtYTwN8SVME6mddytzVgbFTo9Ew+8fFs8MqSLfldDcYSg/snCUH9k4Sg/snHNiSfaceE8H+n62GBUjLtncCyjHaoqCyMwECl8dhyObnPr3CYrUpUysrCnTIWDYq5p3IALSOXNh6zwGOesfVovRIvszyBZqsLSp69b8df+jTBrJAMzkmyol7ZmOBRtZeSzYUqykgg+BGH+Ar1LJ6pU0RchUo8oH8BVdqIIairldW8XQWX/AEhVw06McqmRwgJ+/HbkVwSNyuRjtyiyOgZbzBTjtyg/vritgmuL3Rw269r7vWMOn9Rh0/qMdqUsTb9zyqp3HKeZ8CMduUH99cdt0wLLfzG1n5cdpNUktbJChLYpKueX5jKEx2HaW4uZnwlLTJYAoEz47cqTFKfOQNlGKiSZgLBnYsQOm/hrmmqJVjQetjbBLJTQqgPMm3M98qEhRBmYuwUAdTfHbETyRpnyR3ctuuACMUVXUOWsytaPHYqKlvP1z4gpaW172UvmxVU/9rFVT/2sVVP/AGsTUzKGF11OOxqP+rY7FniiYgO4cMRjtB6cqeU0Zx2nSzuFzFUkDEL1sPsfzCzPNUTReyyI2koUnnjgTqDELn8+gERVlqqM/wAzng2ennSQGwPxTi4SWNXVTzswvvwl0gr4pJfYVZNkXZmCges4AHk0Co2Ukgvzci/U/wCj0Dz5lip0bk0r4rJJ5GJN3NwLm9gNiV13eDEYqpv+s4qpv+s4Yk9Sb9zjvBQ7oPXO3eq2GCNACWdgMUk1a113/oUxLDRKVdWMC7yGxXzzuVCku5a4HEkZSRa6kg2x2vM6BUXVynWLZOQAbHZPU56bHa0TSMzAROcjnKLmyt9jwJaigigDK17/AK/4vph1b1DzTy9WYuVDfeqjQiDUTvBL1tKLrotrHpEzZRYbhbCkyyxZoQGC3lTzkviJopomKyRsLMrDwOxAxpaIqabo8/X2J/pB3DKJZ5U8CGIRO9ga+2tqW6zP3itUzgG1PH50hOIPIIvGU2ebFVJPM5JLyMSd5vu7kSCDcEbiMVxqoiwJSovJ/RsHyCrNhZz5jMej4YMrAFWBuCD9jmO0HaMQnHTPyfTJrPJKSGDMBbNq0C30QmR5aRzEgNiZU89P+RoQrqA0H9s6P8t2hlCrUjxA8HXFGZKfwniu6YBBxno6FbHXOhvJ6kxEsUEKBURRYAD/AEh6NHvX70l6Ts6079Gf9RO71SRKqllS4zuR4KuEaipy36a/wz4dmc7yzEknu9WZKcc4JbsmHSireWpkbc59TfY4QGXs+cN69VL5jjQWEdTWwQuV55ZHCnHhpRFRal3QILKEl89QMfSqjSAR0OOx6OSZiCZHhQsSuBYDwH+kXulPBCkQ6KyB+9JasrrTT+DL8xO6kKoFySbAAYVaqrUujzfqRHFS888huzt3t3r6IlRd2+FjxUiaJiVvyZT0IP2NgTHUwSROFNiVdbGxxGUlhdkkQ81ZTYjDQrBBrZJWlICqAhA547aof7647aof7647aof764roqlZYDBIEdWCGPCm0sRle5/Xf/RPakUE2QNqzcmxxVicUrqshAI+OtweI4cIIo29TogBHebam5ln9cceFsoAAHQDulQkECEAuxsLk2GHMHZRIHR5gvi/fqpo2F7pzRri3nLiVaftOx1kHUqOafY2RFp+0Rr4rf0faKNIlJHcr/okIMk+pGXpEMmHtB2hEU3tZc6b14npCfvMRE9Y5SMnwiTukll5RoPjyP4KoxNanR2MNOu5EB+QJWimiYMjqbMrDxGHRK9idRNyWb7GqBpuznMu5d5j5NskAyuqAnkCxthgTDCiEjkSqhf8ARCZjBBJKFJtfIt7YFjI7OR0zG+HKyU8ySKRzupvj4s8KSKbg2Di9t3DkZ3aokLMxuSc3eDZqmdI72JyhjvOEyQQRLGi+pR3OTdySNfjyv4ImHsBdYYV+JEnQfIRKspBBBsQRiqJiAJgrHJJX1Phw8bgMrKbgg+I+xmLrKjIwG7cwscXtE94m+dG29TsQCSGGUTzhuQSPZmSRQzKSpBF1JUj7iP8AQikmfJACGtl1ml7yUE1kBb9R+EhcQQvKVHM5FvbAtrJGe3TMb94iJ1FoKZv32F37m9kG5EHx5X8FXD2AusMKnzIk6L8io9T2dcZPnwYnWWnlUNHIhuGB+xmQnadOhEfSZfmHFM8M8TFSGG4+w6ImlmlYLHGouzMfAYhU9pTreqk5+xBpkVI0Us7sbKqjmScO9PSiXfVqxWSULiqewYNJCWJSQdGGJ1WoCZpqZiNZH/oOZw8szysngyJpciKviaE/x814Uioi0U12JsBdCB3iMvJIyoiKLlmY2AGAoMEK63LchpTvdvvbuUqxQRIWdyQAAMXio4SRTQdPW3VvkeQzdnmS8tK2JxLBKNx8VPirDwI+xnQQ1MY5B1uR47jiWqprTF5FuGDL8wYoVEvjO/ny6ZAkcalndjYKoFyTh2TstG3tyNQ2mcxTxG6sPwOOz5aaWEIHJBySFvGNv9BMhSlpFsBzVn0oGannjlCnkSjZrYcMkkaupU3BzC+48H6N3hf8t2aM/IENKwso7nO/+F0/9JpRzf5JmOVW+EgJOrkU8wRicByvwsBN5EYcwR9jfzKOsleKrk/BNKM7k2CqCScIUs6tFR395iFIoYlCpGgsqgeA/wBBR5L1bpb+V5mxHkyQaj+wTHfgyldZUwo/rXvAYTV3+YlDdymdKyZQah1/Uib5LnMU8RuCORHirdQcL5N2giBngPJupT7G0CyU8ylSrC+FzwPc09QOUi4pCkFwGqJPNQYTyitswaqcWazeAH+g1ZhTUsspC7icgw5Z3JZmJuSTzJ2EINHVSxHoxY638H4KAiqrBdumr7vEXgEgkn9UaYAVQAABuAA7jZqmTzKaK4BZziZpZpWLPIxuzE/Jk7RTxMGjkU2KkYVKavyDIR8Sf7GVSIw1xGg3vIVF7KMP5JWbvgZSLt/Bpo4qmLMCqOL2YYjVI0UKiqLBQOQA/wBCH4WvnSNbNYhUOdjs31sVaszeyVAo/Jwb60vJN3dLPXNkh/lR9xcJGil5GJsFVRck4LCjhulJG1gVT5Ocq6kFWBsQRyIOKi8rvaCrb8j43g/YvKzV8qnUU/8A3bFW88pJtmO5QTeyjwGGKupBVgbEEYYOjvYV3iv8eJklhlUOkiG6sp8Qf9DTZ4OzYjH6tc5u+y3w0sMEqr1SJmVvz8HwpZe7ECWqnjhUnkC7WucJlgpolRB1sOZ9Z0zJHmNhmYC5x27TPqzYpG2d+nIY7Tn/ALD47XEZyFs0qGNf6tiugnR75DG4a+U8KptPUb6zJzWHwT/f8oyO9DzhnsXeDEqSxSqGjkQ3VlPiPsW2mrplPk9P/wCb9FxO008zXZjpjuecsjfEiTxZjh3dEuzu5JLu3M/6FI1ypkp1PjM+5cOXkdizsxuSxNyTsuqvP2fLHD63Do/B+hQ92jBhpEMMP86TRKsca/GdyFUX9ZxCrBWI8rk/FBivnqGLX89yVB5XC8hsTvDIt8roxVhf1jDvXUx/X5SpiYSxPcN4MrDwYbdskERIX5z8lXD5pqiUu3QX8B6h8pI9T2a9zqfGN+qYnWWCYbmH4HoR9ix3qaYRok0fMwKg/JpQLHGAZZ33ImE6NNMR58r9T8tSqhPLMQMOCOoNxwmCKgJJY2AA8TiS/Z9GSkNjukbxk2nRFJmQFurxMo4LXEBSJPUgXu1jM662oI8ZH0Najo5CJXVrrPJwGLwOQJ4CfNkXDFoZ1JUMORBsQdp7pT2lqvXJ8qSZ6Z3Vpqd96uBiUFXFnjJ89G8Vb7FagqRYg7wQcQFqN3vLTJzh9a/uYzUVBdwZXXz2ZfBVxAI4Ix/uZvFmPiTpZVVebMbAY7epGlZwirn5sTiaORQbeYwYX+75VCtNcR06NyeRsV807jlc2VdwG5RjtSohVGLqgclLnqpxRq8TWGvgFiuK6KdSASAfOU2Bsy7bBVAJZmNgAMSlez1NpphzqP8A7Nv0rSe9HBJKGpK/fGAh7rEGpqM6+a/7vLRIEqai1PD7X5kcKS1NX21V+SzrsnzKeMkD5zclX2k4fNNUSs7n1t8qzlJYz9zr4qw8QcPqq6OIPNTP/wA5Oo+xe5WCBRewuWJ3ADFS8VIW8ylRrIq6Kx47MC0V7o/tGAqTAsk8YO5H+VHa1JBmdOS55diqlgmQgh0Yg7sQG6hU8rj/ABdcdpwzkhmyhgDZTYkg6XCjqTbliuWpnCgrFB5+HFNSAkiCIkA3FvOPAcqwdSrKSCCD4Hg+kKn3h7rERUV7n+ymgjVPrpj/ABrZeE5SWCZJEZeYKm+FKiohSXKTcgOt7bD+YiCpn9bvcIh+V52hnhYMjqd4OHSHtNB7EmUfYutqp5ppn9sICj8+wrq9bUF/aqeaPlSZpY/KWSMt4Knm7UjIbWupINsdt1VoMoRGcsll9Rx2w4VrXKKqNjtOpnyXC55GNs3DcvLJQU7u7G5ZmQEk7bWYRsQfXbDFpHYszE3JYm5PdDZ6qdIgx5DMcfo4IkiW/OyC2iQlEoEKD2u3DkLtCjRP6nVtMmSCCJpJG6KoucNeapmaRugvyA9QG4fLDEEciDYjE9qnclNUsf0vRH+xaLvQT2bfyjnwL00NISwHO7mylcTpWwBGbIxCSi2OzZ4XDohLoQoL2tvxe9PTopub2bx+U1JEUbOQOZCi+AQJpncA8wGa/dJS76gpfosblFG2pdaaklkKrzIVT3WMGKmQwQN4619MVpZaaVXbqEPDQi9XKy6QC/aL2f1RxfLRsRyOJg1VEl6eZm3zD7FiZ4qmJo3HQNjfPLVEZ18Yk5EaI1dbg5WAIuDcfKkecQ0cpy3t4W2EaDszORJU9QvMJiERwQIkE8Q973BAPJZ5YVPVQQ+36On/ACd1TJNqhLUg89fILvpTfRVIdrLclG83hrlkWlBK3vYOSw0m8VCi06+1d7fLbZZqeVZEPrXBDJUQpIvO1mF/sUgV1aCt0VrIqt1fHZklLdrCSI6wBcdowVKqSGyOCQQB8rkC9EwGkXkldUQdWY2GIwiU8Cxhb3t1xEJIZoyjqwBBDYZniWzwSNzeNuPF+grA+frrl23KuyxRt60lcI3dIs9NATPUexNgAxzwvGwIuLMLcsRlJYW/6lPJh7RwUu08oDdAg3sThMkcUaoi9FUWA0Gy08DvyJ3gY3vK7O3tY3+XPR8P2KJ+qVVWvu49NRNDUtKixmMnMSSLDdibXTRwokknLOyrYt8rfSKb8+n6bB+caUAraENLF1dfFOPGbusU+f1Icm3+0pvfL3RCr18gEfrii2d3aFJC3mAfpkXAsRzHAQCathUUq+KQvpLB66dYif3ALn5cTPNPIqIvVmNsXCU0CRC5ufNH2J3KOPMrJx7tNiAtB2fFnjPgZnNk+V/pFN+fSubUzJJl5XyNe2Fy6yNXt0zC+kHyLtEvLH0R73dOM1nnoiI/ajBtuQgS9oor9GUIx7mCZJ5kjWwufONr4vqqaFI0vvNlG1CIe0Sxd4uST4p3hniYqysLbxsgknkALnEQFPlEkVH4v/NwAFAsANwAGld1LTFyQ3Myn5cjGogvHS+uTRXCOjgqDFGrIjb4/MbEit2hSvaX1o3J/sSTvC8kTIsqGzISOa4H+YQ3L3uJA3JwdAJJ3ADGekpt9oOUz4gWKCJQqIBuAHyu5CvX2K9QEOw6tJJRxhwvUaVAkAMlM5NskyghTiMpLE7JIjc1ZTYg8WQJrI5UT1uw2/Sq+6fuaExdnoGTprn4HZ0NRZgQWG8feMdqPCTbVxSrdMPSVSBQTIHyYpqb++uO2ohEV3alLtihzz3JE0x1jjZQLaseIAdIfgvls5KSAq1VN0U4hWGCJQkcaCwUDG54KdjFdbgyt5ifdmOiXJTTnUT+x/sShYe0IVOon/8AB8dnakI+RpXYBAbZsAVlfZgZn5D+BdM6xQQqWkkY2CgYqnpoqNz5JEvIL1fqWxaGvhUa+C+/+NPlQteCneV+h1p2GQNRVTWXxKSefsR2gr90vRZ14rBUFYl2J2wRLLWNMvsiQqfz9zRRPXnyl/4G+J3EMYqWnklfLzyoMxtgkkkkkm5JPy1HnnnfKgvYdSTiNc4VTUSgb5ZfFtDgvM5qZfUieYmkk1NG5ppT89kAIb7FDhERSzMeQAGC0PZcLeYnjKfnvonMM8JurD8D1BwAHmpo3YDkC63+U5S8VOwpo/UIuY2GATtGD+rw3fY/TZRLD63jwpVlJDA8wRxPpcP5xt9Kz/4+5EKZ5bM3zUUZmbChY0UKqqLAKBuA7i4RnRIfaJnVGXvcbOx/VUEnd7Mdi1Orm3pK65E+9jigh/vpigh/vpjswOE8I3Dvjs2op2CByHjIsp73CPL6xQwutnhiPJNLkw0dqaP/AGaSAnaMF0/mwfYonYQwM6VzjlI6/qaYs9NE6y1XqiU4ACgWAG4AD5S3pS08kp3gZii3Ci/XEheWZ2eRzzZmNyTsb3pZ45QLkZshvlNvA4kEkU8Syo45Mri4I2LamuHlMfEJBBuCOYOCSTTRFid5JKja6Vn/AMfckNokFLCervvfuTgTS9oiVE6pHGwbvNCRDa4mlORMVbVjjnCgtFjs2ng1YKoVQZgCeuzGjxuLMrgMpHrBxQGlna7Z4PM3tgeX0gu10/SKvrXClXUkMpFiCO7pegom5fPl0/8A4end03ZvO5LjezsWPtJ073pqhJLXKhgpuVJHgcOHimjWSNxyZWFwfsTh2o6stNTuejMboT1XQCSTYAcycJ/nq7JLKOWrFtyH5TK569883URQ7S/C9mP/AFjlJcbCAz9nyq9/HVOcjcVy8j0SZ2ba6Vn/AMfco9XM8QmqepmkFzsVbw1ch10ro1mRMdv1v9w47frf7hx2/W/3Djt+t/uHHb9b/cOO363+4cdv1v8AcOO3KlihuFdsy4tWUz2F1UI8eJ1lgmUFHU3BGw4Mqiqdk6K2Tu9I88zW81BewJtc9BgisqgxOqBOpXEapFGoVEUWCgcgOFCIKvmtTEAHxBaN2YRTrvSQL3VbzVUyxr0F+bH1AYUiCBbAnezEm5Y6XtLXTWYBv1I9l7z0LmB7tdrc1+xLrqkK5SaeIXSPFUk8LoGzKQbXHI9DiEOji6t+sj+DriLK670f9SRPBlOEBpKKUagci86/KZAFrknkAMS54BKY6fwAiTcu05FNN8DU/wAD4IIIuCPEab6qpheJ8psQrrlNsRlJYJGjkRuashsQeJziMkK+yNtpPPgpZZi3qmcKPd9xQtEswlm83MAke/G4DTuAwQQJmiiCm4CRmy8Ilqase8H7k2x6LT3z92tBSxW1k7g29i4plSygPMQNZKR4seLSxTxMCCri/MEXGLz9lzN8FN4p+4/dKcCepAFHfmkPi/8Av2HJSigSK3IK7ec2zIqwdoJ/SVPsSVC6jIEqKlOZbxRNDF4HIE8B5SLh8si2E0DEZ43w6RVKMGgmK3KYjyxQrYC/NjvY/KcuWq7QDBuqwcCS9V2daN+rR/qHYVFirEjqUCfvizE+11PEUAUtY6KfU4D7XomH3j9xjOd31EDfuc32DHeKkkKBjYFiLKvDcpLC6ujDwZTcYkR9fAj5k+Kcw8NLEhUgC+zVL3VGi7Kib752+YmIEiiUAKiKFAtx4FmgmUq6MLgg4DTdmzN8FL4p+4/cgdWzZ52+bEu9sKESNQiqBYAAaXCRU8Lyux8Agvj9JUTPI3M2Lm9tlyksLq6MOYZTcYbMJ4VJ8LNazD7EU7JUSrerceCNyTYSY1cTq2ZPiqCbXf1Yliepy/DNEpVC37oPynKI4YFu3rPgo9pxuaVvNQElY0HJV4DsKdnCVSDk0WJRLFNGskbryKsLg6YVsNbBLJ4ktZ0HEBDpMkxb1OMm16Jh94/cASzEAAcyThLOkCtJ5uUmRt7bDpnrqkXTxyRefxHQy0uaAqvNQmn9nTe5XuitF2XE3sadvmJiJYoYlCoiiyqo8B3FC0M6ZHANiOhwS8Ys8EpUgSIe4papr/idVhXYciWvdaVfY299uVQk51tLm+f4p9iFrEjcedsM8sksrSLOylRKrm+YaRqaFJAstQ3/ACExSLCpCmRubyMotdz8qO3+HUzG7eE78KrIpnIFG78o28UOl7NR1UUntLnV8T9LPSo6eyI7XomH3j9wQPDE+vmBBIyR7Lqy0NKC3VZZuIgyJLFP97grpQoI5xB98AEfc31VFTlTUzfgq4jCQwxrGijwVRbuYUdoUt3pHY/1TClWUkMpFiCOOCI3bNO3zYl3scKFjjRURRyCqLAbBUmgp2aU9Hn25CksLq8bjmrKbg4YCSwSeP5kygFl+xC4hnSQPDPlDFMdnTSyl2WFo0LLKFF7rg5FUgpSo3vMQJDBGLJGgsoGidYaeFS0kjGwAGIFp+zZHCU07fjJiRZIpFDI6m6sp5EH5Qm6pV1S+7TiB56RFypOu+VcduUygkizuEb+jYnE+qmE80yNdOVgnEkCM9BMietrqdr0TD7x+4c5XFNF7F899mbWpNVPqn6xIcif8DiZv85TSwr7zT6RqPz9yTNNUSqi9Fud7H1DCKCiLrZALGWTxc91S1L2jd/Us36/HiInrZSkX8iPYNgOZxmvUVDuFY3Kpeyr9w4Eh8gqyIqgEmydJcOHjcBlZTcEHxHy3u/y035DgvXUQAUXPnx4mzRtudeTo3irfXIASOR6aWCRoCWZjYADxOCR2dTuSX5a99DtJ2ZK4A6wM2DcHeCPk5g0gUpJW+CN4iPBJYm5J5knvRCjWy+6ba9Ew+8fuAs8EC60XDfCv577EhjaGlfVOBciVxkTiziFIqyLWSHksbNlfSgS4gcgdWiU9yT/ADnaCK38EPdkzT0wFREAuZvM4y3mqZVRd17X5sfUBiMJFBEscajkFQWGwbSTp5NF7Zdx4T2h+JRz9C3JG+W/os35DoOaJrCeA8pExIHhqEDixBKk81NvFfrmIsUR6x/+RFpB1ObPUN0iTnhAqRqFVRyAAsB8mTJFEvxnchVF/WcPkoz5j1fJ5OoTvnpOk96u1zpKGGF/aby/g/HQmGB/KZvEBYdl3V66p+5kh4yhHqqKCZlXkDKgew0fs6b3K9xW9JSWnn+7kmNwHdlDI6lWU8iCMEEQVLopAIFuLCStIojp28NY+y53AzzcIkMDcEbiCMSET3EcVV4P/NxvB+Wfos35DpvN2fMw19P/AOaYnEsE63Rh9crs9XHUOJXbm5JuG9jDQCWJsAN5JOEH+I1iK8vWNCARF8mTrrMhaKnuNZNhtRRBgUpk765SSNgyODYqym4Ix0Gz0pfcJx0TeyQRN4i3ntss2WipVDr4Z341QZng1sTfuZHNlOiMqssNO6dGURBO4raqrrTzdQD8Re8IBHUU0TxnqFGTii0rx6+X+OXfsy50E5jjP7kfm8QmWgVSiT2LSxYqUmikUMrobixHywt3kp5UUetltgWeN2Rh0ZTY6by9lSv7Whb564mSaKVQyOpurKfEfXJCor6RbynxnhUaIGEEJ/ySnlI/i/yWwCgXJJsAMFKmfcTU84lxVSTzOSS7sSd5v39y803Z9M8jnmzvGCdnpS+4Tjiz6kSTePnyeedggC1yTyAGABr6qR7A3HPjIAsFUkof1zpY+70ei098/cIw8ELieoB5aqPvPo/iECPPrJSfmR+ccAAAWAHIDYIzxUrmO7ZbsRYYJJJuSeZJ4tWU6xtdo29q4T/D5jzfnEcTLIjbwyEMD/T5X+mTfnOxV27KnJF236hzhgysLgjeCD9ciZOy6n/Mzv4Ref56YjEcMKKkaDkqqLAfJVUAxzBIl3u7Kt7DBNJQ3BWBD+Y/IKBWSnMIC9IHMQ/Ls9KX3CcYc6hHc2zAIhzHG4DYKZxTFEDmwLPu485C1dGcieDvGwbQPhZYp4j60iKle4JaatlaOL+TF3mOzikdy/VWbiJuiUQQEr4tsmxq5jK/8EXcK+SIr+pe6EdCDigWcDIpmiNmxWGmlZiqpOMnyr9Mm/OdmdrOwWikf3X2DXCqBcsxsAMWnqbOj1P6kTdUxUPNNKxZnY/IUdvI6ueAe+/89npS+4TjRgiCFYo36PJslA1VPnZfHJHx48+tmMHs1wKaCddDXGEeyZCx93xwSSQAALkk4sVpqdEzBcuYgb2t1Y959Hj854mXPPGKmQjxacX2ShSjRKUMvIlO51Ly0MhASdiWaDDh0cBlZTcEHxHyn9Mm/OdlirqQVYGxBHI4nv2rSoTN4axPB/sF1dpHF0hQZpGANsE0lBy1CH44vzf5EvrYa7Wv7J0AHu9npS+4TjKVlq2aoluuy6slDAqex33tx5TG8E6OHHNcrc8OHjlRXRhyKsLg4iDGGSCSE+KtrQhPHjZ4oHNTJbwEQuD3qUukCRRepWVeHny1NXGjlRchC3nH7hgBVAAAAsABsIWWkppZit7FtWpa2JC8srs8jnmzMbk90qgKGUWpZH/+i/gnyn9Lm/OdqxeEkMh5OjCzKcOWhqIllU+ph9giZYoY1LPI5AVQPEnFpZOTVZ5KeijE7yzSMWZ2NySTf5Ff4aRKeVV6pGWU7PSl9wnFTPJUTpGq3tcubYGWKGNUReiqLAbG4AXP3YkzrPVSFGta6A2TuEeS9Gi5b3+IMmIxJLNQVCIOrshA48DXihSKJ/C7m7DvJskaM7HoFFzh87T1Ej5uVwTw4bpQ0ps3SWbzBsuBL2lMEP8AKhIdu7S37RogA7EjPKng/wAokqyU8jKRzBC4YszElieZJ2zfyb4aA9Ebmv1x1qPV043r+qxHMKfEr8iSCeuKMYqdOo+f0xVMlMWJSlQkRp8jsLv2a/vE2elL7hOKgMVBA8z3XxIyLsyOkiUzJE6i5EsnmJ3GfPJT1Thl5lFbHiCMOXFNVSwhuRYRsVvxpSTV1bsV6ZPM7y7LNOuoiI6ycSNQ9dVEq/WKIZNlyYuz4Ap/myee3dj8LA+ax5MPFTiYOjgZx4o/ip+ULayKjcrcXHAchBMElAIF0fccG4O8EfXDLaYXSqqR+p1RMStFNEwZJFNmVh4jD3r0Q6mb9uF+QatIIlB3ubXIF7DqcI1JAwZZJm/SuGwxZmNyzG5J+SPmT+6Oz0pfcJxQ4asqwi9CkA5r977PKtneVz1SDuKjVgRT6IBFHOyToByYON7cZTaWDXP63fvPKBDO/tfcvEVFeKmQSBORci7HYfJHEjSO3RVFycOGeoqJJWIFgSxv3OJpZpWCoii7MxxS62J0uzw3cR+p9MxHZlU9qheeQ+DjEivFIodHU3DKwuCPk+Uq9TUxJH67HMeDLeWBTBLvu14/rgdT2jVITfxgTDFncksxNySeZ0O6GOcSu6GxVE3sfkApX1gJBt+iTFa8xBuqk2RfYPkpypNfEhINrhmsRs9KX3CcWMRvDSprVBuBKwzPshgaKjiif1s15fwfuMrKtXC8QA5M/MaL3npXR+g1R4y5Y0pIgq87bu8EBUUsxJsAAMJkFRMSi9EUWUcOPOJ6qMOpNroDdsCwAAA9Q2D59S604Ia1g/dIF/xCrUPF1ihfABB5g7xiAo8JL1NMgJDqzb3TTV9FoXf3XyeVyM0s7dQVAUcFzaeLXxep0+uAk1bykSgjLlKeblt4W0xWqu0EUxDpB36rCO4ukSDM7AYkehovCGJiC/QufkyQpLHURsjDmCG2elL7hOJlMctQC4YEhkjGdlxuA2QwFRVSuqsblVLbh3FAxWsjWzcrSHJocAUtYntfOCnFtmkdUW+4XY2GAuaKnjRrcrqtu8SEVXaZ1KfygQZOIjFKGB5cwNgrnzV2eVNFrpP45O5oTRdnlJD0klvdE07wcIg7PqZBnRBbUO2g2YEEEeBGHQdpUw9hmT5/ydkKUccdOpTSl4a6kSeORQcgLi+S/UbWURxVADluSpIMjNjx+t+ntBU3FZ6pvB/9+iINQULJLU9G8VTAAUCwA3AAd8mSKJFLM7GwAAvgG7Kwerce7GKiSaVySzuxYm/ybzRgw9oOFAknpYpX6KXQNsdKX3CcRt1LShOXjKdkXYUjooDZTebzO5GxHI4cvFNTRujHcSGXECyyeTM8anqm+/F+lQ/nHeDYDmcNekg+Apf5acQtnLpDsGwAuSfAY+JJUMEs2YFU80HuUZeaeRUQAX3k4ByRC7MebO29mOxAs0EyFXRhcEHET+QysTSS9V6H1jRIUmgkV1IJHI8jgiOeIqtTB4ox+TJFSOKNnd2NgqqLknAAkqZ5JnC8g0jFjoBvUVCIxAzZUvdm9gGIgiBB5PbmjoPMxCY6iBsrLtSrLLNRQmVxyMlrP9b8CzQTJZ1bFO7vNNak8NYjcjjeyjPNIebyN3x1rq9GtqV+Iv8AG2Kk5AFCwpdYly9F+UIlS9Gi5Qb/AKPzNjpS+4TiMb1tU7WK+CeZspuqqu5b+SO52uiPCLdIWKDC5kdSrA+IIscRGIwVEiZDzUA8T6VD+cd4lHldWvw/WKLa7KnkidwmtIsgJ6k47MEw6QuJMRsjqbMrAgg7Lgmd5Jx7HOxnEmq1UbDmrynID3NfPnVo6VeieL7UAkhkH+4HwZT4EYj6mKUfElTwZdD3U2WeFj5kqdDi+pnX4jc1ZTYq3yW6rLUoKWO/jrjZx/0afiUFMQv82e6aIFPasH3GaL5m0hU0dRPC3rJfXfg/1wUqNVU6MkUzC7IG55e4dqQREFRkvmbzvUMRVM8iXEZCgI+OwZf7ox2DL/dGOxpoYvF1cPjtA0zvJkCypiqinjN7MjBgbGx5bNUIwbhEG93YC9gMM1HQBmAyGzyqfn4JJJuSeZPd6LJBa4ml8xDiaKtSKHO6ICr95JBpw8L+0HY6UvuE4YJYkAAcyTgsdRSRqc4s1+Z2QQKSlX+sncy5kgqll9QSZdEZWOsRJ1PViLMeJ9Kh/OO7sDUuCKaAc3fE7TTzNmd2O87ETSyyMFRFFySTYYRZ6kOrxQA3RMKFRRZVUWAA0RJT9q80m5Zz0fEOSVN4PNXXwZTpVmaaZEAUXY5jbdj9HBEka+xRbYcXctVTfkTuWYRO2edx+pEu9jhAkMESpGo8FUWG2sYlCk00zc4nxAYp4jYg8iOo6g6Ly0UpGvg/7r0bE4lpplzBvxB6EfJRYIiNVSdGZjkXShWavdqp/Y25NHxKeIuFvbO3JV9rHGUSTyPI+UBVzObmwGz6Ul92n13TievVTkpU55v38TCjpyzeZDuYqeQLYYk9SbnarZ4GsVvG5XcTe2EirobksfiPhKqltyLLe+Jp6h/CNUK47N1ZKi00+KqWeVubyMWPd6SWeVuSIpY4sz+eBRL+LthQkaABVUWAA8BoS1NXuRKgFljm7wfhYKx8/wDv2OlL7hOHmyPVx5svMBTfaDBXq3ADcxk83ueTJU0Ql9ZeB9EIujmCV+J9Kh/OO7N5RWSBtXTIeXrfExeVz9yL4KuxBcJYyysbIgOBrqqQLrqhwL+xdlQk6AmnqPFGxT5M9zG4N0cDodAOqogalyDYgpsuzRQyiCO/SEZDb1Fu5Jaq7S+J1WnXgoEr4EY0sw/IcUzwTx2zxuLEXFxoLSdlzPd15tE3z0xMksEqB45EN1ZT8kteLXGOL+XF5i6DZ6mYJm+avNjhQkUUaoiqLAKosAND+ZBaap9ch5LhSzyMFVRzJODeoho18qpma5eXqmFKspIZSLEEeB0+lJfdp9cBU1Ul0pUIJDPiqd1q3L0sjH4knMrw5FSJFLO7GwUDxOLwwHOj1R+O69UxIzu5uzMSSSep40bPIxsqKCWJ9QGKryKN0DJEgDS4pHFVRETM/N3QfHDdyFycT+RU7qHEQ3zHFFHAnUDzm9p2EVlqImC38G8DgWeJ2Rh61Nj3d1z6+NthpSBMou56IOGWAo6ZvZeTZLKkFNI11+MLLgkkm5J5knufJ5mh++dGiX/ltESvLDH5RGWNsphN2I4n0qH847p2hGpXdqgQzk2zABcRNArbvK3+PiRpJZGLO7G5JPM6Re/IYiem7PN7JylkxSpBEigWUAE2Frk+J26RKiK91B5q3UHHw/Zhlskw5p0D4RbySpTxP4gJ577Eio1PTO0bOLjWckH3t3IHUls87fNiTe2ECIihVUCwAA3AcJVh7UhWyScllHzHxC0U8TFJI3FipGgtL2XK29ebQt89MTJLBKodHQ3DA/I++R01MX8cosDpQ5KWLVRHq8mgjJBGSB85vBcPmmnlZ3J6sb4iLQ9nIHXprmNk0BA6UUYqAi2+FZmfS5JrKmedvc/gn1vyrHDEpZ3Y2AAwrR0yDJTwlr5VwSCCCCDYgjDD/EKSy1KgW9j8GdYoIVJdydww70/Zi+akANjIOr8cEsTYAbyScIsnaci+0QL0XQAyupVgRcEEYbMKaYqjdUO9T3GlvXzqTHFKu6FNsqYzWPYr3f6LF+fYkica5ReMWFwg4bE+VVYQL0EC7M2WSrdIF9YY3fugVnpqmKZQ3ImNgwvg3B3gjCK8ciMjq28MrCxBw+c0tVLDmtbMEYrfhgFonV1B5XU3wAGmhRyByBZb8erigiAJzOwF8dntUAKQkznIM+KWjicrZXVTdcdrzKpRkZYvgwyth2ZjzZiSTsUrzzH9VBew5XOAlTXpLdF5xRcKFZYpVKOji6sp8DiLV08WYqt7m7MWOw9nrJs8gDfqRdyS1RX2KdVhXiBY+1YV8x+Qm/cfEDwzRsVZGFiCNBaXsuY2deZh/fTEySwyoHSRDdWB+RuVMuvlPVn0teWRddN7ZNEoKQWlqbHm55Loh1dVUA1FT7X5A+xdEolR6lhE3WNPMTQLk8hhEU01LGkmTkZLXdvvb633IWMg13RjuZE0o7q7lKlQLjUnmW4BsBvJOPM7Op5rlvGZ17hBrYoC879F1akqx9j7EIsBqKhh/VO4W1EV55V+eseNwG0RL2pOhAXwhVv13wSWJJJPMk93YhHoprjY9K1fvTw3Vi1MJt3ScmQbLKUZpZ36grZF7qxK+QxRn2xDI2gHVdoQI4NrAPEBEy8Two4vyDjVIgqnhcQykXCORuOJ5ZZwbo7E5HXwZNsajs8Pleob8ExAocIBJOQNZIerHuDloqNEgUEWylRdu43vNIM7fNQb2bAtHFGsa+xRYbEyw08KlncmwAGJ3paSje8CfP8AXJhUpe0YrkwXuHTqm2BDXIloJxiAxTxGxB5EeDL1B0I9T2a/OLxR+qYnEsEw81/EHxB6EfIjhIYImeRjyCqLnAsamYuF6LyA0RB6eBxPUX5ZE0GxI3HpiTyuGqldvK15F2PJ+jYh1lLTEzz+xNDlStK6JYgNnkGQW0oWhpH8pmPQRb1+t+3+Wp3dQ3Iv+qv3nEheWd2eRzzZmNydEbPI7BURRcsTyAGIrdqVSfD/ALi8wg4DHyuvT/oh7jIVWYTpJ0ZdUW2FUyvEWguL/CLvGBZlJVh0IPHtqJbwSt8xZMbwdhgiICWZjYADxOHVzkKS1oPusSM7nmzEsT957w5XPKyP61K7HpWr96eFbW1NRHCl+WaRgowAqgAAAWAA2Yiho6aGA+87rY+TVc0UY6JufRGpehqVLP4iKXzOJIXkejTMzcenRpQj6iUjzoiw5jERyMz6ia1llVTa42IWllc2VEBZifUBiK+5HhpFb3uI0jQclQBQL+odwICU0Duelxg3eaRnYkk72N+4xG6HUUze82Z//wCG0kpWNV5SOvNzoneGeJg0ciGzKRiZP8RplFn5NOm2oirIQTBUDmp6N1U4hyOVDI670deqnReajlI19Newb1r0bEm7lJH+vG/irfId1m7TLBm6Qx/H0xETVzlEb/8AJj008c8TLZkdQwOA1qybOb80Qck0NvmczyexNy6Yws3aLh166lfrfiEkU8TJIp8VYWOFefs2Ukwzcyn7j4jZ5HYKiKLlifAYjV+03W6p4QcAhVQEkk2AAxcLI9oU+ZEu5R3FcxpKqKbLe2bVsGtiVZIpUV0dTcMrC4I2IslLV2ni9rfG7hITX9nIkc1/105I+moSGFAWZ2NgABfF4OzC3seZR8/vQBdayJbN0c5Nj0rV+9PChLxwO879EMSkox9j7Uzyxz1szxO3MpmOTuobO6xTqfABbpoNjU0skYa17FhhSsiMVZTuIYGxHDQLqVaD/oPcBllS7QTgb0fAAmgaxK8mBFwRpjQ+VwvEjsLsr9yc62vkEX+zm3cQSzEAAC5JOHzmCG0jDkZGOZzsMBUZRFT/AM2TYkKTQSK6MDbeMOgmCBaiFTvik24vO3mGYDz4n6jHwtLJvgqVFlcaKoxl7CROaOvRhidIq2xMtKT56leZHVfkEgKBck7gAMOTSxnU0v8AKTRmBqqhELKLlVJ85vuGIwkMEaxxqPBVFhtG8UT6iP2RaA2SaYa0gXIjXexwoSOJQqKOQA3D64Iw8cilGVhcEEWOHepmudQZR+hXgn4WttRx7rj4X4/c82eidqQsfEJYrsX13Zj6z2pKQr9wszREh4zydGFmU4k1kFQmdWtY+w4f1RRD48r+Cri8NFESKemB3L626se9qGME0cgU8iUN7YFi8atbpcafStX708K5lhghiT2SksfybKB2paOaYKxsGMaFrd2dQlXBIjfnAGlQIaq1RH/v4aAClrGVW8WD2fuKIvaNIpdT4yIOaYBDA2IO4gjQSHp50fdzIB3jBDJNEsikEEWYX7i6slDTqp6q7727i1koVNaR1MLDLsubIDUzflTZLGhnslWi8yuHDxuoZWU3BB8Rt0kc8DENkYeIO44R6jsrmJRziHR9EzQzwsGR1NiCMFYO0XcqkgFon+QCPKe0FamiX1N8dtKc7wUn/m+1yp6d3UXAJbwAw5aSRi7seZZjcnQm6Uain/F2+uuY3Alnli/oiP3O2peBJ/YyHLsRq8csbI6NvDKwsQcXLUtQ8VyLZlU7mt0YdwgaqgdC9Ol9yTYq2ma7ZFJ81AxvZR30HJPSxOqtzUMNPpWr96eEqWrK13Q+NkATZco9S0MMPrbOH7sCY46yMsBpXz6WXVP/AAScNBq0MUwPre6dyANJXPZ/3JtNtZRE0zj+DuDhI4o2kdmNgFUXJOL5qmd3sxuVUncv3DuKG9bMEj/gh2GCqoLMx3AAYa8ckxEX8tPNTadFQBjROfdcBA8bgqysLgg+BxAXSx11J/3TAIINiDuIIwbEcjgmfs8MQJecsWKhZopVDKQe+kKqgkk8gBiTNR0w1NORyYDm+hM008qog9bHButNAkeawFyvM7R31sxd/wCCDRGXlldURFFyzMbADAANNTqr2JILne5H11+i098/c2KiUSQr7ZEKjZC5J0FNN/GnydIHyUUSMehQWK6fStX708KAwsKVHlQ89Y/ntspcT1byl/5Cf/f3Y5XRgynoQbjEokMtNG5YWsSy6FuZ6dgDe3njeuNzKxU+0HhThBU0joqHk7qQ3cgBrkOrc/qSLvRsRlJYXZJEPNWU2I0O1qmATJ0vD3CUpLWMlMn+83cfegPcULPIwVFHMsxsBgC1PTorEDLdvFtj48kRgjuLgtNu2yQQQQQbEEYnIr7FUnblN0X+PgqlJ2kXzu36kuKZ4Zo2KkMOnQ6KkqpK6yI70kCm9jiZaStvYwTNYn1p3x7VXaN416rH+u2mO6QXipvW525EeGjVKaMr+5vb+jHQl6bs0a9/4+UX1x1IWwusQsXf2DFWs8VyptzU9COBKGCUUQRQhTJ3P6fDsoHmMRkhubWlTeuFKspIIO4gj5NcExS1AcdCZCdPpWr96eCwU1E8cQY8gXbLfDXyIqg9bDZI1MdIZR/HI5U93jK6hGg9pQ6UIhqyKmI/zOFGXBq1it/OGq7mloa7zJ+gnXRKI0iqkErkXCxOcj/8HuDgpRQl5f5s3cReOF9fJvsbRbJW1nqHAbgEhgbgjcQRicFMgENZ7ByfDh42AZWU3BB8RwIL5CTHIhs6E4BqqMrcVCKbL6n0Ehgbgg2IIxnq6YZiKjnKuKxJ4WJGZT4g2PeXCRxqXdmNgqqLknDtqS5WmQk2SJeWhbzVMoRegvzJxbLBEFLfObxbauIqaCSaTKLnLGuY2xIXlmdpJHPNmc3JOhAJu0Zi/Ig6pPNQfXEQ9TICKeDxc4nMk0h+5V8FUYqWSzKXiuckgHg4xeCqiCmWBiL+1dv0Wnvn7nGWK1aM3qVdpW1FX/mIj/H8hQaqjeVEiLbmkz33gcP0k3u00+lav3p4MZePykMQP3AW2nLJFki9jRoAw7vICsFbaNeiuA2mIl+z5/P9UUvCcpJGwZGBsVZTcEYctDPCkkbEWJV1uD3KLPMsRmp+omjFxpJMpg1chLZmZ4Tqyx9bWvxnCRopZ2O4BQLk4d2SoqpGjz8xHfzB3EJ5iJAnVS2zJnjhl1Efsi4Upfs1zZH5mnw4eNwGVlNwQfEcCJJIpFKOjC6sp8DgC7vdqL8SmImjdTZlYEEHRVvCysCVBORwDyYYKUNT4S3OqfDqytyZSCD3dyJZlD1br4RNyi0wkFgYaS/9XfbI1vaE0cSC9iFQ6xm0LmkmkWNByuzmwwSy0tNHEC3MhBb64XsnJEHx5X8FXE5kmkP3Ivgq6UnarUEgwkqVXqTiZJKtYlEzILKXttfpZoZ4W9kJDD8/c3AWkpZXYdc/mbSEyUM12/lyfICFnchVVRcknwGIFdrDU0n/AHfAso7Rh/4RuGxyAUrfn0+lav3p4IGqpqN856F9pCiz1krhTzALd3S5qaQOD/KOm5iqYJIZLGxyyKVNsJkmp5WjkHrU24UrvLSM9LJf9zegHsQjuW8HCERGYyw+AKS+cLaCLowqovvsj8aQrU141EQ9TfH7kEL1bvPsIXFNTSyFQbE5VvhizMSWYm5JPDqwKCXdA7//AEn4UQhrAAEqkHngDEGspmLGOoQEoVDW39DpnE1IGJNNJvXFSlLW5Rmp5Tbf+6e6uLRqRGvz5CPNXD5pqmUu3QX8B6houNfKA7/MQb2bEYSGCJY41HIKgsBthDqIHmJ8QZToBKUiPPyzKWX64nv2YUK03qcfH0gRU0RUSzvyGKZUbIqyzW8+W3ix24LvT16AvzKJKjdzVhJXzeZ64otq+SpheNrWuA4tfBBkpZ3iYjkcht36Fpp5WCoii5JOESftOUAySc1i/cTQoNki94vDciJ+zmd08CUdNPpWr96eC5D3ihtspmEELylRuvkW9sC2d2a3TMb93cKtQJYZPWpQtsBsnaCWl9UsXCdyCkdVGv6gynI/cwA7hoJNDoI5JtTIXNlyS+bxnvSUV4If+7dxF2YgAdScRCIwUsSMg5BgvnbAua2pih52KgfCcWbN2jSLdWPOWHhQpLDKhSSJxcMD1xZHsWajOIWimjYq6MLEEaDYjkcHy+m/fNpcV8bPYExMcrr3NyKGhdkQAm0j+L6VHlfaKKw6pD4LwAo1c+pW3SLzNFxr3EEfsT64oBJDIP8AcreDKfAjELzwSP8A5adFJD4iengABSAGzvinSCFb2RFCjgAM4iSX/ZC4lfuVxr5AHcC+SMb2bEYSCCJYo0HgqCwG2lkroSkvrlg76hd2ICqouST4AYp1Has/PxMSHkmlQX8nz/dEwc8MC1VBPDJ7Aut/FNPpWr96eDFleWrlJbZUF1pHF23iz+Z3gMUpquGVgNxKo4YgY5EaVXXxDXwkgc4+EbJPLqJBfKCsvm9zjZ5IUE8YTrHoNmUhgehGGu08Cl72vnG48SZVr6zzIvFkTxfuQcpNWRK+TmFvsqweCCWd+hExCj3fFuTBKC6/OjO5lw4eGeNZEYeKsLjh0yh9xWZAFlXCNXUIUNrUHnr7VwCGBsQdxBGid4pFN1dGKsD7RhGqY7gCpX46riuimWwJUHz13A2K9wnQ19YpVwOcMLaVYUFKQ9Q/4JgAKAAAOQA21JSCJ5GA5kIL4vaSV33m58430RhJJIRNIAebSb/rjQNYhhcXsQbjhRl5Zuz6lI0HNmZCB3KMeXVqAp1jgaxC8CIvPEhnprc9bH32B7IVagQ+92PRdX7s8NA5atSG3qqPgdPpWr96eDGUlFMCVPRyWGywvPLFE/8AAx7ywMtRQwSSFRYXdATpFwdxBxFkp5X11P8Ay34O4qQw9owd9RTqW3ZbONzdyBKSo0bgGxysLHEZR6ed4ypNyMp0Nvp5BMn8D8OYRwxj72PgqjxJwwzsMkaLyjQclHcrZKWmmkf2MuTZZikUqwAHwMKhG40oL0LBov5T8UigrWLMzqt0kY/PGKY5CAVnS7RtpqpIJlIIdGIO43xAeSoayP8AFxitiqI28Ua9uLcqCEjReckh5KMS6yona7tyG4WAGiMvPPIscaDmzMbAY3zvaSpfrK3AkZJZUEMZTrJojLvPOkYUGxOY4BCQoqICbnKosPrt+afw7jSXpUsaNH5SP8/gzxxRKCWdyAoAFziQPQ+UMYSBZbHmF9QPe0cdm0++V+QdvCPEYjiiRUjRRYKqiwA2CQlRBJFIy81WRSpAx4Ej+h4Slo6WtgmcLzKxuGOn0rV+9PAF2YhQPWcC0kNJDG4vezKoB2XsklY+detl7yWDUc88Dk+JLa38H2EBloDabqY34T3eimugJucj9zhZI6lUnUnk5dfObQbQ1JNNJ/v4UyxQRKWd2NgAMNIlBDupoW/P7W7nLbU0yQZP5xz/APGTYcRxxqXdmNgqqLknDh5aid5JGAsCztcnjF8lWjwlV40EcsTgqyOAwIIthxS1Oe5gc/BNihlgbwLDzW9h01kkEikHzTuNjexGKfxVfKk/FxipjnhbeHjYMDwnCRxgszMbAAeJxdKGmukCX3N1kOlOoof+Vd+C4OpBnmHRm0FgsLPPdesSlh9d3zT+Gi+rqKyCJ7Gxyu4U4m8imt+he7R4oXjHhKPORvYw4i5KT46UZFnk6F8KFRQAqqLAAcArWdoc1hQ+Yv8AG2Kx2QsSkINkQXJAA72CNY15JLXEaeLnCERRA7zzZjzY7Xz2/HheBBwxMVTCkqEixyuuYaPStX708CMvLJURqijmSW2pDqTDJLk7zbVQTwyp7ZgVb8mxGJI5kaN0PJlYWIwLSU8pXoGU71YeojguFhqrwSEkgef3OJuT0sr+Hz00MVZSCrA2IIxKHleEJOALWmTc/AqliRFLBbjO9vBBiQw0Ae8VKO6Sm89WsBT1Qpf/AJz7EQe9KYv7x1XHkKSLWwgMOjMB3ClinjcG4dQRvFsPZy1zSyN5mKKWmkdQ6q4tdTprXisQWS90b2jEGol5a9N8WKhJ4nAKujBhvF+A6FFs1XKnutIYUsdnqpBYFExGEjjUKiqLAADgTCOGIfezeCqPEnDXlqJS5F75R4L7AND+ZFTJAV6mY3+uVyO0KpLmRWsYEwUWsgslTFzIPg3sbgECanoJ5YyRcKUQkaELN/iFO1lFzZXBOimSeB7Z0cXU2OKrUvz1EpumOzp4bEDMVJUki+4jgUTGO9mnfzYxiUV1YE5FRqo+C4tYpLWg+6wSSeZ73G0ksjBURRcljgpJVzHPUTD8gPQbcYSKLtGoREHJVVyAOHcKKKKLeLG8A1Z0Pnhnr6h426qzkg8BCxWvic2F7BWuTtSExxUUeRe8ykGqoXSNOrqyvsxWeC0NV60b4j8EkEG4I8MOhd4FWULyWRNzDuUAlqI1WeH2wm5t6yumQil7QZRD0WfbcVXaBVgkKG4Rv38SXblHGvxIk8FXurktWVM8zj2NqfwTYcpr62FH9aWZuO1pInV0Nr2ZTcY+O8SM3tI7jRRTpawzLcj2HE9xz8llxQTQMHZQXUgEqbGx01zwm+9L3RvaMQeTSctfGCyYqYpom5PGwYGxt4bL5+1J4ypKn9ArYJLE3JO8knRGXllcIigXJJOFQ1LANVTLzkfgVID+EKENK3sGCY6WIkU9OOSDqeraUImnryh9kKfXIyazKRTxE75ZfBcPnnqHzuQLDG+kntFVDohPxx61xIrxSxq8brvDKwuCNuVo5at4oI7eJZs7L96A6P2svum2IlkU+DAEYoWpndwxeFrY7Z8bxJKmJ6WpcEDIrYoIv7y4ampemd75sdshXD+ekSXumKM1ThyVac58RrHGgCqqgAAAW4M2qrq7+scPfUOvnQrTRMvxE+fwFK37TqTYi3Nzw48nklRNBfr+vg2igjeSQ2vZUFzjkWJHA+ZUe6baAAp8kKewLfvKgl6pYTfpN5h2biKqgeJiOYDra4wuWanlZG9duDMQtSBPTL++m5+5qRSynXUv8p9BIYG4I3EHFSkc8e6Gqc2EvqfDBlYXDKbgjTXxIQSBEDmckEDkMK9DT+L3GtfDFnYksxNySfHuwCuYnm/2TuZE2JRrQ8zlOOt3ldUQcrsxsMbmSJFPtA7nSxVETc0dQ2KnVPz8mlN0xQSwAuyI7DzHK9DprnhPigN0b2jFE8L3s08G9cdq0sig5SdYBY2vbEioosCzEAb/AG4nWp7QN01g3pFiVpJZGLO7G7Mx8TpgZKmdStMjfqRfP2WCqASWJsABjtiljJRnVc4JIXEE9WxiLA2yLnxq6GI/M3vid5pGN2d2LE7ERjYpK/tV5GZT9cbBEQEszGwAHicFhQU10pEb/lva2ku0VDMiUzno43ptyHcr1Uqe3zE0OB5LHLOfWLZO6uTEspigHSOM2HfFcUFG6t6pn+ZgWA5DgdKb3CcOUmKKeF0T1uMRlx5G8X3z/BcFd6dmOVPQmRNpAhNZIlh0jOTvMhQxyowYGxFjzw6ukyK6MORVhcHZTc1oarg/pKaUMByDLyZT6mGHzw1ESyxn1MPH19yT/O0F5IesqnmmAVZSQQRYgjT2i4hUk6l/PjxPTf2cdpGGMqVZYBqg2JGd2JLMxJJJ7x6KpfdLsSKXhogHA8CzcdCzGtgsALnc47tTRTLe4V1DBcVDUEhTdHzivigd4gGInhBdCF0kjHaFRIhIJV5GYbvbsU7nsun/AKTSeCae0Y0kCswhU5nOUXx2bJO9ltJN5i4mhpUkPmatBnT2NjtWplaUASAyGzAC3LB27a2loKeGSxuM0aBTb642tNX+fL6oU0w55HN2b9VF8WY4jyxJvZj8Z3PN22nCIilmY7gABvJwf0spEa8wqLuUaEJjSgkzn2uvdHKvHSTMrDmCFNjgksxJJPMk97sJJSSWbkiqLljiMLFCov8AvP8ArOfWeD0pfcJw6nVPMmR7qGBGIqd0nRVkmC2c5SG4LkSRQww/dKxY/k2TYKCSfUMG8U1ZM6G1rq7kjvUWS9GiZb3/AEXmbI+CqImS/QnkcLaanlaNh7ODJvjvNS+z9de5xFs93q4B7xMAgg2IPMHbheV2IUKikkljYDHZDhX5B2CNjsuSOM/rizge0r3SMpLF2bSo6EWKssYGwQbU8H5OOwGoLzN7FHeACCLEHkRiEUNYQxEsQsrObnz1xTjVSEiOdDmRtlCUBBnl8I4/EnEWrp4Fso5kk8yfWdHaUtFI5FpY+dvFT6jileriCkmoivILIMKQRzBFiNiNmPOygk47LqZglgxSNja+Ox5VCtY6wiPEZjlidkkRhYqymxB0ECSqqI4ULcg0jBRf65HEXaVKh1BJ3OvzGxC0U8TFZI2FipGIS8j82PJF8WY4AeZwDPOecjbc5FVVC9RbmsOlDYxQd0jL5KOYZRYE3Xq3fIwK3tEI/rjh5qnCjCvUdnwyS+twzp3UEAvSgN9z7P7GT8O9yhzBUyxKPFU2l3Lkhq1H9Ffgm0lPKH9o8Rhs0NREsin1N3OXySvcXcqPMdsdnPNAhAE0IzqcRsjqbMrAgg+saIXlexOVFLGw9Qx2VIkZDESTfBqcuO0jNZzeKEWVlx2fBAAoW6qMxANxc6EDqwsVYXBGEb/D6hiGTwgfufQbH0xuPGpEEIijfo796pUqIn5o6hhgSVlES5dObw6YWlnmcKiKLkk4fWVEpD1M3z32N4OOyady7KS+QK5K+tcUBgIYHPE5DYpHqs/LWyE5cdiRZkN1zEtjsylgkKZS0cYU2OFAv0FsdpwRt53mZgXuouRYeOARSVLrItwVJdlBf+raIy7DtGncgdI3Dt9co8nr1iyRVA/BxgBp2ANROR50jbZzyvdYIAd8j4kLzTyF2JJNr8gPUNNslTWMY/YgC9yIFzbfoQMpoZ7gi4PmHvaE0fZxR/U83NF4fomH3j919Ky+7j2SQR2bUEEGxHmd7JDloptpM8NTE0ci9VYWxvenlKhvnqd6t7GHBc83lpD+ZO60NM7k3LtGCScdhUcUq3swQHFFBE9rZkjVDY+zay2qad0UsLhXI8xvuO/CFHRirqRYqymxB7l0GwgRpKyUlRyFmtx40D10zylvEoNy98CQVjSF5oSbRPfFNIlSsmrMRU5s97WwintGpVQF8YE4BsBvJOO1IYXfkl8zfeFx2a8z+EsxyLjtAwQNnGqg8wZXxIzuxuWYkknT1n9y/wBdlUiHKxjiB8+UjwUYOWNbrTwA+bEmlSWYgADmScMdYFMsvqeTeR3KoZR2XMJJHXxnXD5kqIVb2Hkyn1g4+hVHuz3pC0srqiKOZZjYYQB1UNO/i8p5tw/RMPvH7qhCz9ozOnrUIi7MYfWQaj2a8iO/e7ZKmjfOf5e3CBPQ7p7c2ibgvknp5VkQ+tcAKZ089Ab5HXc699S0VdarT2ybn7l0Gx9Lm/OeMheSaRURQLksxsMPmFNBHEGta+RbX77QxSVNG+aGS3Lb7UhzWU6pDnezeNlx2c5m5ayfFcYqd+cMIyLythyx6k3O0xBpKSaZPd/XWM5uEiiBALucTZ5H3Ko5Ivgq7CutNSSg06Fd0z9yP+cqg0VMvRvF8ElibkneSTh/0ANTT+pGNnXCh0dSjqeRVhYjAsqTyKo6AN3mO8FDuh6NM3E9Ew+8fuv/ALn377Pz4PfL3ufVR+UhWb1OCu3GjxyKUdGFwykWIOFOoY6ynbrG/Bcij7RKJ6o5uSt30efRT5H/AIJu5dBsfS5vznjC8dCDVvvsbxbk+RO15tTS1joix/Bj4IlPDB4Po2X3ifXNXQUyuSEMjhcxHS+J45opACrowYEEerYYFOz4Ap/jfTSSzysbZUUnFQk7owcUyfE9jnCBVHJVFgO5Sq1PQBYIghuAbAvonEKeVxxys3LVyHI99H0iX8x7xGXlmdURRvLMxsBixaJLyt8+Vt7Hicn7OyD2pK3df/c+/fZ5P2knu372mbUTxyZb2vka9sC2sjV7dLi+2h8tpFaWlPi3VMcxwZr11BGB/HDyVu+XtU0zoLWuCcDK8Tsjjoymx7jJmmqKCnllYC13dATsfS5vznjIl3mSmib9dcgzv8idmjXvcu0bsl2JuScUs8LkWWQSkkY7TrcduFIDyV4rtjtmCaX5jqUx2vQNULypo3LS7Ph2bL+dPrltLVygimpwd7Hq3RcVRmcAhByVF6KMTlqdnVpqZzdJMTaqp3lqVyNYAujeFBP9MZrVNTJIoY3YKzbgdD5BO/nt4qijM5xBlW5Znbe7t1Y9yqlNeINcYudl0EmGorqiWMkWJR3LDQgdH7Rp1ZWFwQXGj6RL+Y94S8FBuh6NO3Fe8JhnCL0cFS3dblXoY5jfrONa3/LbMoE714cJ6kjbvkolkeii1j3BuwHApgnZ9afYsc/ivBPwkD3sTYOPFTgi0qgugYExv4oe+BRHK4nRR4CXuPoql90ux9Lm/OeNkzzxGpcqOevOcX+R62OIWuqE3ZvYuB5HS3ZRNzldcStJK5u7sSWJPU7P7Om/F/rk3rEPNQEBnYmwUYmMs0p3nwUeCjoBpqHgnjN0kQ2YHFMsUrBRE/J5EA+O4xueaA08QDWbPN5mnMYGDRTBej4cMjAMrKbgg9xdD2lVbolbnGnjLh3llrFmQvzJd8X1VLTyTSZRc5Y1LHSCVSV5h/HAhkXR9Il/Me7oWdyFVQLkk8gMAa8jXVLdZnHFmB/y03wV+6+iqX3S7PSs/wDj75fPS1M0b+1jrOAgMcyEK1gSj23OPWMR5KiBsrjgzW7Lqn+HBF8jcg4w4dHUMjKbhlIuCO9i6ZDA/cVCstNqbL0p2MI2Ppc35zxWympqI4QxFwpkYLfACoihVCiwAA+RapIIIxcux64pf/7mbFQ88zkszuSTcm+3+ypfrkv5Dkf+9piaWaVgqIouzMfAYihqaogauDmkWhrTS1+tQdUiQq359iUt2c26GZudPhwyuAVZTcEHxHHa0MEbySNa9lQXOBlD2WKO9xGi8lGPpB/IcRZ81IYbf/qSIb/dm0soWjpZ5n9asuq/F9H0iX8x7ugNN2cNc9+Rfkg4y7k7ODhv45G7r6KpfdLs8wlWfd98VckTwzL7ZbpwYb1tGp1iIBd4eFULqwlqGR/dd7DGWmAqUH8ruMoYwvUo/qYys+x9Lm/OeLltSpLO4boBk+RUV6tKeRoFb4pkA80HFfLO3gGNlHsGELMeSqLk47GqWjmaySFCqYlpqW72ZGYswXHa88/zNUoTAt2sJwHRJC4QDmH2P2VL9ckAlglFiDzB8CD4EYj6tDKPiSp1XFOci73ne6xrgCorGa7VLqLj1JpsxooGeQ9Hn2dZV9nsP0RbejDkUxMJoJRcdQejDwI401qjtB7H+Su9tEjoTVDzkwlzWVEEC9VIOt/BNKjUw0Iif1PK4ZfyYtnhp5HW/K6qSMfGdize1jfu99dXnXuON6Jh94/dfRVL7pdn0VD71++T5Ip6FiU+e8bjggEEWIPIjENuzq0l47LZInPOLgkgg3BHMHExXtOBLIzn9OO9IrxyxtG6nkysLEYAD09RJEwU3AKNbuHpWX3cewoVBWPYDixKQqpBG/8Ay/yLvB3HFA8wk5JI5KJjsymiMItG4jGbAsPViojgiQXZ5GCgYZoqV4iks7Czt/BhizuSzMTcknxOx+ypfrloIqpUYsiyKGsbWxAkUSABUUAAAC2nfHSwlyPnHwXDZpqiVpHPrY7TnyGtZY5ekZPKTjSh46KJIVAHJubaPpH/AGOEuZ6xpc/8hP8A/ppT4GaSCJG6vEGLfnx9CqPdnu9rSSgyE7wETe2FCIgCqo3AADcBxvRMPvH7r6KpfdLs+iYfeP3wMVapMNl6zqYhwkBDoSknPVygea4wmWanlZG3EBrHcw9R4L5JoXV42Hgym4wVh7RhA18HgR89O9JGqVsUdSoT1jK39WXuD+NKQv3PsfTX4qkSVNVK0n+zzR8kU7TvBA8ghXm5UchiVxAXvDSqSUTHZNRIshYK5Qqhy+s4qoaIMhIS2sfFVUVNdPkipsxAAfm7aZSIpOz3Z19aOv10lw9ZUi5HSLRUrA1Q+VXZSwvh5auZ1IEvxMnrUDFUtTCN6RPufFNJBKOaOpB07z5HB+QcQ2SJGdj6lFziQu1RUO+YixIJ3aIc6QUsrliLhGxFYRUzz5/5rZNKELN2lK8Z6qERMPldKVwG/i7vGCQwpoG/5fj+iYfeP3X0VS+6XZ50tBDDL6nJaX8H75HnNJVQzhCbZtW4a3Djdu0aSLkB+mi4U7QzwtdHXASOrgISeJfz95CDVzvTP89s4zp3BwM3Zre8TY+mvxShZKOO5XxJF/kgXDAgj1HHZMCPmDB2GdgR0LYAUDwAsMViTzZbpBAQ7Y8ymiuKaAckXT6Nl94n10k2FIzaJHQwTo5ZfjWB32xfLIiut+dmF9FDDOjLlIdQTiuaF+aQzb0x2dJEJqmOLW79UQzWuHGBZI0VFBN9yiw4iq7x0chCtpDhZbU6dGC4+PS0KJJ7WJk0xlWZZZfakjl1w4XWQiJPW7N3dQrwwLr7G4Mrb3PHIJTsyJX6qdY57r6KpfdLs9Kb3Cd9kLyzdnUzyP4s7Rgk8OBV7PnIEqLu1MrcKYpKhsy+Dr4qww+SdABUU/ijd4KBoYNepIvbUHP3BwofWxr63kQqo2Ppr8S+WSeNGtzszWwLJGiooJvuUWHyMbD147Vp4mQAupcFwGPzRgT10iFbZFyI2KCCmUsCjv57hcdrT2DMVRGKKuboBsuAX7PmCDq11P10/QD+fSXLxw6h2c3LGI5dgA2NxfqOKGOuQQLbrJoFyTYDEeScprZx+/JhiyoY4m9TxIEbSUaSnooY3K8iUUDH0mDSJNTKWMrR81RVvfFTVSvLWpDaXoyO3clJipWNVL7Id6/1buHSl9wndfRVL7pdnpTe4Tvshd6d5oX9TZy/DjDw1CMjAgHcRzGCXj3PBLYgSIeFVvBMtvOQ2uAb2PUYKw9pQqNfB4N++nd7EOpU3FxYjDFjTVEkWYi2bI1r8ePP5PWRPk62bY+mvxIi+SqV2AF7KvyNDSGmWWR0aAZpREnIOHxWVqFnUvC90QMBusuHLE+LG54HWf3L/XTEloJ2R38bSDS5zxTLOl3/AFH7ihcpLC7+pFbQhamhJnn/AIItDh1avmIYG4O/QwVqieOJWPIGRst8byqgf0GLGOprLSf7FvpLAUtLlHRjLj0tF7qXuSWaqlEMP8EXcOlL7hO6+iqX3S7PSm9wnfUOeCrEl/VOnEfVVETayCa18r8rH1HCZJ6eVo5F9am3CnaGeFro64RKbtEC6oOUvrTu7hhVJFOv3jJxzZlIIPQjBu8kC6zkTrF3Np+mvxPiUtLK0nscZPkehinjbnnW+KmSjlbOwT46YplrYgQA0PPlckqcRtG67mRgVYe0HaQsDVCGw6zgxfXTGjSJFro8/g0Pn6SRFUt5LL7Ju4lBJLSSBcxtojtV9pWlPVYR8QaP28n5tDlV8qV7r1ivJo+mN+TTID5VWbl6avHpaL3UvcVLOxAVQLkk4AGogUOQuXM5F2PtJ7gqqUq3hAXpB8EO6+iqX3S7L51Dxxk/vxRqjd9TzJKZJi3Rozl4qKK+lRtYnIzx8ORo5Y2DI6mzKw5EHFRHFPziqjZEf1PjeD3U+LwFe4CQ0Mzh0dOcT47ZpXUQmZvPsVQcywPLHblKVBA8xxI39FxJrIJ6pnjfqp4hXVJAkJ63c/JXZcE182VigzAsLXvivlpTdfMca1AuKDylLKS8B1m9sIyupsysLEHT6UpPer9dUQSB3M1N0MMhuug2tyOJL1cPwNV1zoOf+/uADKQQQd4IOIQezqKcVDEiyuj70TAAAFgByAw+V4aSaRG6MqkjBuzEknqToiDCKjlYN8xtDnV6mZ8mkJnNMsjlBYMZfPx6Wi91L3G+RJRO5HMLFv7j6Vq/enuvoql90uz6Vq/envspRZYZkYXsG83jUgFK4JrI0/Uf54XiPrezx5iTc3hxUR1EMgukim6kd0CZqRknDN3EkXFjbxHGAEU9VEie2IfJBCqoJJJsABjtGlAC3J1qY7ZpDIMl11n7QXXFfTf3kxVRSva5COrFR92Oy4GqpaiGJZ7BXTSbEG4P11ITLSuIJ/5L6Sxo5xqp1/B8MGVgCCDcEHuQBUixB3gg4YvA/wANBJ85HxE0ksjBURRdmY+Axur6uwdQ11RF0OrJQwKnsd97aApknqY0UObLctgAACwA5ADHpaL3UvcR5tkgQle4kGWoqJJXsLDM7XPCjZ3chVVQSWJ5AAYCwJeIJAQS5Eni3C9FUvul2fStX7099kCRx1sRZuMoZWBBBFwQcKD2XWTNqrbtS7XbVcSVpaLPealJ3MG5kdGxIFlsdbTMw1kZHc41cTwOmV+RJG7Fs0bsje1Tbvylc9fKyetbL8jUKVMlY8u52IVVixOlHE7KVEI3rjtapld1yteQgFcMf64OGP8AXFTLExFiUcqSPuxWzypcHK8jMLj27Dl5pezqZ5HPNneMMW+ukkJVQPESLXGcWuMW1lPM8T25EobaZGep7PyhGbxh7mUSvpmvTyMSFsxGcNhPKK3mamQC4NrEJ0GlryeXTL9yNlXQiNFQwvO2f+i6PS0Xupe4q6vOGndW6ydwNgN5Jx89vx4USy1MrulN0iRDlxe1RTuoItfNgWeNijDoVNjwfRVL7pdn0rV+9PfTZEmRmPqDXw2ZJI1dD1VhccaBZoJhZl6dCOhGH1tLMGeml6r0biVDQ1ERurriUQdq/EXwSbucDRRrVO0at8x9479+yl98/wAjVyQS0SzlVZbh2lC4pI6pFTOXifHZdVCHJCF4mF7YBBBsQeYPAsHWm1IC9IGMQ+uq5i7RTOeiumkXSsV4HHd4i9HU21xHNHwpZmICqBcknwGEyVlcyO6fMRPiLo9LRe6l7gAZKmdIlubC7m2L5II0iS5ucqCw7huI7MqvdnhoFvQQsQBzZhcnQgEc7ieOy2W0nBcsQswueizOo2fStX709+Uqr0kdlPMZRl46XU745B8eN+q4U3iY5HK2EieDjiEhgQVYGxBGKr1w1r/kkwwZWAZWU3BB8R3GQt5XRo/syEp36UvekSb75/hfkhQbdRfHY1K+tbM7BArFr3vcYimpSyWRY3x20jfP1yYokqUV7DVPctjsqpiZFzteMkBbXvcbHKlrJoU9htL+L/XUBrKFxOumUxutdAMwNrBmAPd4hLBPGUkQ8iDg+VTySnVPIATFF4KNIJalngli9TlxF+D6Y2KRgF2AuFBNt59p4sRaKjDVL+op8U9xiL/5N4rfz/guGgAFOgAAsFAXRILPE8AT+Dz+D/7n377PpWr96e/KFEDSQi3iEPcEEVTGCaao8UbEBjmjP3OvgynxB4pkn7OH6JhveHE6zQSoHjkQ3DA9wVLQzvG/X4Ud+9GU3u1+STYDeScdlU09JFNKqPC5DOFaytjsGdELAO4lDELiCu++IY7XTz13o0bYjVKV5FWKwsGWNQmb77aSNTDPFIntlBDfXVfJNG0ZtzswscCz007xnx+KdLlop6eN0uLGzDvUKyyTUUoiRvn28zEbPI7BVVRcknkBh3oofCEfpWxSRQRB6YWUdJF4sXMpSxSX/wB7juMgRpdUiA+Jzg2HCXNeug3AXv540uMlPVMjDqZRwf8A3Pv32fStX709+CZKassnscX7iEWui300x/J7GxC0M8LFXRhYgjilpeypm+FTxi/fTFSk8LkgSobi448BllgCToBzQod7fcvffE4cO9LRwwsw5Fo0Ckj5JW4IsQfEYpvIZgpUGnsFPtXAWvhDGwj3ShcU8kLqzKVdSpupsdmayPQ31fgzK6/XWAIq6BHFlsAyeYdLC6I8P+yJyi963XBH9cUokqQBepkGZ9BA8rq4Y/6HPxUZJa1nqpA375shHtRR3H6fDwkLWnZm9gU6fSMP4PweVLWzQxeyyy/i+z6Vq/envxGpAimA/f7kFh7ThX4GbwcfMfEDQzwsVdGG8Hi3lopSBUU55MOq9GGJxLBKLgjmD4gjwI4zhHqqSaFXIuFMiFb99+cPklMwpoSyr85yQqj+px2Gmrtu1L4gq4JbkBAglx27TGRxdVJKchfm2Eoa9EIvlYPkJN+a4rWhfmkEm9MBBUQZM+Rsy+eocaXCq4ljHrZ0IA+usOWo6ux6BJtIPwM6TB/5w/8As776TT3T8QXJ5DDsyUtNFCjNzKxqFF+4yEJLUSs6cLwo5tPhXwk/0bg+lZfdx7PpWr96e/PaKaidpF6mM9zyw9qQr8DN4P8AuPiBoZ4WKujDeDxby0cpAqKc8mHVejDEwlp5lurciD4qehHGgWFErZWijXksUhzp/wAHvnzh8kyzRRSlTmiazebioStgG9EPmTYo5oHsDaRCpsdEzoDzysRe3sx23VrHAVyR6wlAFxOZaidszudMefUVkT5etm+usO16KSRQvMvCNYo05yldSyx+oOg1oY999Jp7p+I6g+WRyEtytD8Ie5SfBCleUJ++zcL6Gmnwih96vBkBlTtEu6ep0TZQozdozuAfFJHLqe/OyiYyRyAeKFC3dBFF2lDYJM24OnzGwhSSJ2R1O4hlNjxS0vZczXkQc4m+emJ0mglQOkiG4YHivfy2lgnPuv8Aw43Z7tGBcyv5iY7YiRBESNShZuL84fJdLFPFILMrqCMTtQvZrRfHTHZ5nhXOdbB54suAQQbEHmDsGzKQwPQjE2t1tKju45MxG/6689qaqljQuLMyK3msfaNEjokFVG0pTmYybOB7V766CRu0A4TxKrG3ERiKOleVW6ObJ3JQFpKSNV9j+fwvj+UxafCKH3q8HrSfg+ymUF4XPteJHPfiA/l0SXIvukOQ91jVO00W5XkKhcIySRsVdCLFWU2IPFdv8OqXUh/CB8OHRgGVgbgg8SCxdJonl9hDJxTYO6qT7ThMsNNEqLuAvYcz6zoUKq9o1QVQLAASHifOHyTWy0lbAWaBw7KjE81e2K+Qzo4WRKlBIVK47HimsigGFyhLYnnpbR3LSpjtalmeWPOqLIC5X2Y7MQuDfWRfBv7LrjtKOaLmEn8xgoGxGV1GeD2lD9daPkr6aOQseRdBkIXTuK0ywsM2Y3g+D750q/8A4+I41bmKEL60u/co8moKQe3VjhRIHeslznxa2mXIfJHlv/I+E4P/ALU/n2elN7hO/PllhkWSNujIbg45soJ+8d1QJKoaWtg8H6yLxitgpFHMfd8RwFpa2KRx1DAx8WTIJ6yJM/S7aYSglMTp61MYHE+cPkpvJq2Lck4W5K9HxSlPFJBvRx6joYqR4g2OO2KhURCixs2dAp/dbBil1sE0evUGOUGRSAwK7ErM8UySqh5Kj/XWiF6Kq3v0SXTIt4XWeNPGzizd8vroYJpX9kpCr+TiSktV1bsV8FyWTuUZRZKySyk3Iym3C5zh5n/jZtPo2q92eD6Nb3ibPSm9wnf41R6mjhlKrvCF1BsO6i4O4g4pWFBMSZ0XlA/FJVlIIINiCMO47TpIhrCd+vRd2s4d7R0xmX2xeevF9Iwfn0xkRS0CKh9aMeJ4EYkDxTRrJG45MrC4PyVTxzxOCGSRQw3jE5gk56h96Y7OmiyH4+UlCCbAhtqVUSup2T2um8fXWQGnpnRWK5rMRuwpV1JDKRYgjmND5YKkmCW7ZRZ++ejIvePxIgmemV2HVm5se4rcRRM9uuUXwuXXSu+W97Zje3CkzkUaNmtb9IM+lC8r9n1KIii5ZnjIAHB9Gt7xNnpTe4Tv6ZClOILddQTFfuyZ4po2jdT4qwscO0tFOC9PL+KNxZ2hqIWurD8D1Bx5quCHj5tG4Nip4Shs8Lrlte915YUq6khlIsQRzHE9Iwfn0ldWhmhPW72bi+jKb3a/JDBERS7sxsFVRck+oYyf4c1kipZlBFkGFPZ9VuHWJsTxzRSAFXjYMpBHUYhWRHFmVwCCMP5BP8znC2KUpmzGOVd8bhTa4OwUCxVSBi+5Qj+axODcHeD9daBYagioj9kug2dGDKehBuMNvnpkLAkEhvG/e2BAMA/pCnDBZ2IVQOZJOEytHTorL0IA3dxjDvHRykKTYcrcIXJIAHUnClJI6OBHU8wyoARsfOPA/ZVHum2Us0/Z0Mkp6uGePv5u9LPPFIOjlzL+D938wSgGKQAFo3Q3DLhCssEjJyIDAcmHqPFf/IVVo6nxCjwfBDIwDKRyIPCADislYgG+52zDiekYPz6ZSDSVaNbrn8zisCB2bTbwbi4jAPyQivDPE0UiHkyOCpGC9ZQqGd1/XjwCGBsQdxBGO0ZoArE5A10JItvU4oAikWeeDHaMM+UAsqt5wxTLNDKtnVxgtPQhmaWHm8C7EiO8tLGZCgsocCzL9db7oGMDr6n0yDWwSmaJOqP3tw6P2nVMrA3BBkPDjLyPVxBV62buSBtcEg9gla3C/bJ+bZ+ceB8yf3R2fRMPvH7/AOk5PdJ3iG/aVKn92JeNMNfAL0ru5LOnzOE4bykRzj1B14npGD8+limpiE/tMbcX9lL75/keup4Hk+IskioW323A6QKPtCwCyoPzrin8zdknS7RNfRUPBMhBV0YqQQb4T/EYOpNpcVqU81gHp6ghDdsKBQswM8H7Fm8V/c0yqXoak2TpFN5/11hi01MwQAgeeN645gkH2jRJkp3JgqD0SXHj3lS0dLBJM4XmVjUsbY8STw0ZilSHawvZV7k9o6isUS+sKC3CW9+0YPz7KZYYK+ojjXnZVcgcAkHy+HZ9Ew+8fv8A1oz7zvMRFBXOSekUvFfLNTyq6HrY8j6jhlvIoWaMG+qlAuyHgls9TR+eOmrPEKgitjff0Q30rmjeklBFyL7uKmTyOeaD279Z8jzS1NPlUTR8zAF8U/cxP5VRiwMExLWXopxULTVhQZ6aQ2IbRSxVEL2zRyKGU2NxgtPCBd6Um8vsTEbRyKbMrAgg6alauhIKtS1K6yNlIy5cIyxF2MascxC33AnQSYu0IGH++EFwfrsgyUtYBUQ9Lt8fTKHqY7wT/wAcfX1sLN3l0V3g1K5/HWkI3EW4SmnLdyciF9fKU6uvCjDhdbIvqeNCynZ9K1fvTwPSMH59lAHZKpWbqFKd/jBWakScv0MDZB7zvMYaKdCAbAlGtucetcR5J4Gsw9RFwR6iOK5FH2iUT1RzclbgxgTGaWPP+5xPmT+6OlQyOpVlPIgixwLIlRKqjoAxA4jHWwVrO49UqD5HAKsCCCLgg4pXlpHu81Kgu0GCQRyI3EYl8vowRdJT56+x8T6qoWwemlIEgut/N66ItTWBVCVSC7gLhNfTuoZKqNTkOz8alqEltcjMFO9Tbrhw8csayIw5Mri4I+uuMvN2ZMXfqIZdz6SBH2kF1TdJk7zGSaisLl+mpXifQO5ShtVQxKy/MYsx4TuDSUUsqe1iItkqWeseYW6T/CrwCQwnjIINiDfZ6Vn/AMff/Rb+9TvUC+VUKE1PV4OKbEG4IxKfLaVViqupPg3AjUyxV0WRuJ+zqfdNsQmMNVM6jqrcR/h2MEoHVF+SUSl7Sstn5RS5RyYYpHhdWYKxByOAeaHxGJGRxyZSQRhf8Rp/nubTDFcuutdoJPMlXEaujc1cAg43MBdqIn8jYppIJ1teORSrbDnXUoNK5/lfXXGskcsbI6sLhlYWIIwbvSzFM3zl5qfvGhss1PMksZ6MhuMFck8QJT5reKnvBcLR0q+wtJxE+HBhiD9EbuRJQVAj++JAjcJ1CQ0iQlerSvcfk2elL7hOAbATJ+OCCCLgjkRsM2tirGhX2SoWP5O/9Kn3L96AZWBBB8Qcb6Wa8tM37h/V9q8V7UtZaCf2NybG8HbVGyxKVv4MHHE/Z1Pum2IyqS00JQ+DBV4koV5aAiNepVgfkqjSZGRgpsLoT4ofA4vW0AyDWKvnqW6rokZHQhlZTYgjkRiDy2K/6dLLLjtBJuqcnX2qcUwMotknTdKgHgGwgq6INumjH5l0ndVRCVP44vrsQgudRPZdMoyMNfAv5+7kBQLkncABi+Sapcpds3mg2HEtqp6pET2xDuPS+Iyi1VVNMEJuVEjFrcJCIZZqdEfq0YYts9KX3CcH6BTe7Gx6UX3T9/kCKzyx+15Y2RR3tb1dDeaL1qPjrxmJqKR/Jpj1KAWbbQMDQVG4i4FkPE/Z1Pum2MmpaBoR7VN+JylEkK+2Re9dqQU5GU5Wa72Y2Byrc4iqax0e26yIwx2HGIrC+uclsJSU0dviCPPippv7C4oKOqct8cgpjsiaK/6aSJgy47Wh1rBPgXOrkDScls3DZIKol3kg/UkPRMUrwVEfxo3G8aJ3hlQgq6MVIthHqU5JUp8dcVkFazkQwIrfrtg3ZyWY9SToNhBOpe5NshNm5YN0ZQykeII+usC08RCsf1XG9WwhSaCRkdT4FToPwlPKrj1gcxh7xVESuh/iHdptXI0Biia1/Pk83i+kZ/yJ3EK0lLRTzIG5Fo0LDh+lZPdJs+i4vevwWUjyCn92NhmD0lVBKntY6rv/AKTpveDvi2pan4en9SvxSfJu0ysDDpKf0Z20DpIpVlYXBBG8HAsFlcAdADwwpMlSITfpN5h2CoSnqmRvbKOJHn1VZEcvW7d4Irqzf8DEwsn8ZxOez6YNdUgNm/3Ph2Y2tdiSdskMDcEbiDiqNTSDnTzEsuJBBXKgZ6V+FTgTAKEqIwBKgHQ4iNTQ+cVqYwSFAa3n6SbXvbwvsO5no/8ALSkkkkp9dkdoK/4/RZl0zeYytLRe3m6d2/8A1U34JxZC3lUss/sN8ncZhHJIkcPtWVwrqPavD61Hvn2fRMPvH4PLUH852Pn03vl7/IEii7Qp3dzyVVcd8jvWdn3nh6sg+OnFYo6MGRgbFWBuCMOrySwKJrC1plFn24wkUNdMiJ0UPw/SMH59hynkssU/tN8nEtmjdXW+8XU3GCM8lPG7W6sLnutSkMSKTvPnNbwUeJwXoaA5DYG0rkdWHEkZHQhlZTYgjkRirCyC5grG/I+CCpFwRvBB4KI8UgKsjgFWB8CDiwZ3u9HyHtTEDxSr8ZHUqw+47Ocp2gl09UsX12KNayBoHP6ky71xGUkjZkdGFirKbEHQ+SenlWSNufnIb43JUxByt75W5Mn3Hum4AEn7sAqk8vwSnwRRlXi+EU3vW7i9ppe0Q6J1WNGDcOIIG7Ogc26yKHY+0k7Li09G8IT+Q9z7zg8zAfznYBslI8q/xxDOvf8A56/j32MLBI5nprCy6mU3AHFKhHvVQe3cjjbd21kyzEt1mUOeHyHaMH59hSyihmf74lzjiljqozC5brH3QiWqkBFPTeLtiozsosiKMqIvqGx2VPOCWGcLZLqLkZmsMS01Iji73Yu8eO3WePJuEMQRsdtV/wDRMduyJ8/Xxh8VMFaiJfxRy2Oy54FGW7lcyecPnrcbNbaFrChkf3Rbhw6qp3BKqIASqFxDrqXmlVECUtewzdDsPlmglWSNudmU3GJM0NVCrg7r7+am3IjkfrsiPktf+mtySddM9qWt3w52sqTL3SUrU9onURfwc5OMyu3k2tuvSYmQdxisIaaSfP8Aznyf8ZOGzmKmp44ULb2KxqFF9npWf/HwfCsn2AST2dUAAC5Pmd/+ev499Jz9nvZl6pNxSPgpQH9aN5rDDh0dQysORBFwdp1K1dNDInsQarhm1pk3j27CZ4Zomjccrq4sRjkCbcRktS1hydbP3MCp7T1XtSBv38VDzTysWd3NySdMJpqPm1TKpC+xcU3l9SnOWfetyLbkwAo52AttRrIjgqysAQQRYjDeQ1Ru2q5xOcUphmUAgcwwPiDsO7doUkZZJWP6aLhwpLE4yujgMrDoQcU5ehe7zQLzg8Sf4Nh1vQtrYB1il+uzlPEQH+a43qw9hwhSaCRkdT1U20Eq6kFSOYIwgFVCdVOv76jn3N70dJeCn9i8343o2l92vcbZKSCGKP2EZ+E4RqqoihDHkpkYLfHgNnpWf/Hwfp0+x+xk/Dv4vlYG3sOEKrUwRzBTvIEi5rd8UNHPC6MGFx5wwCJIJXja4K71NuR4r3mpr08u8Frx7SMEPZwAb2SPw75UdWNudgcE5JolkW4scri42FConadUqqBYACQ8SIlqmkDg/wApu4kAAXJPIDFWGkJvNWp+RMSF5HYszMbkk8ydCFnYhVVRcknkAMRhmBRoaQH3uAFAFgALAAcIZJ0uYJwLsjYhySpyI5Op5Mp0vknp5VkQ+tTyOLDXRDWID8SQbmHDAZSCGBFwQcIgoZmXXwoAupdtL2hqSaaXeFFpfrt5SssdWn4PpYmkmIjqkufiE/H9qYlSWGVFkjdTcMrC4I7i9qqcGGm/jbBuSbknjejaX3a9xkLxS1szI3Vb8JM7ivhf7omDttAf/wBTT3T8FjYVcewbF1K36XGHz+T1EkWa1s2Rit+/+jqb3Y77Aq09bCtmTxdNzcVlGuRZ09qbXz6z8I+IykeQ0/L+AbERRJVgdPWNUo4k7xJLKYHt461Sqr3CZIokUszuQqgAXJx8B2cTkMvKWZdNO0s0jfco6sfADDpV18m5p2Xci9E4rJFWQHPTS2BsfmE9GxHkmglaORejIbEaZglJX2AY8lm4kKTQyqVkjcXVlPgcROKWRi9I55NEdBsykMD6xiTOZ6WNma2W72s312C8VTEyN6r8iMD4Snky5rWDKd6t7CNM28AtRSP7juBsBzOJQ9HQgxRleTv4vx/RtL7te4Jn8np5JQvK+RS1sCxdi1ulzwkJCvMW9mqba9Kr7p+C4ualNlCp8vqDYjq57/6OpvdjvoUS0EqzBm6Mch4ucrNMKeRV5ss3mbQbWw1xiT2TISfd8T6OfznYFoZqDVJ7YnLN+fiW1tPMkqXFxmjIYXxKJIpoldHXkysLgjjTiKFSAPFmboowWh7OhY6iD/zfSrQ0a75qoqbBei9WwnrllI8+V/Fm49KP8Sh3zqvOaLAIYGxB3EEaCQQbgjcQRiYPOIhFUeBEicSHPU9nuJR/LO59Mzs9FOyepUbev12wIaugRjP1eDS5V0YMrDcQRiZB2jAgWqi5exhx5bVtbeCDqvzn4/icSFxDRwRhypQtkQC9jvHcJ9TIYMiNexJdgLcP0bP+KbUTFU7RRnPQFHHB+iRfn2fpC/kHf/R1N7sd9No6mF42IAJAdbXF8IUlgmeJ1JuQyGx4hIYG4I3EEYQp5RSRSZScxGcbMbEJ2lEznouRxxJCwSpmRNi2qimnhbreUAj8nFlR3gR6dgvgIXKoDxXzStdYKdT58r4nDBLiKJBlRBpc03Z2cW+fOB8zECxQxKFRFFgAO4whaOqcidQ25Jm0kmDtAEp0WaMcRbpKjIwvbzWFji16aodNxuLA6GGp1STf7/rtFwdxBxGFoK13lprck8WTTlMkd1ZG5Ojc1OGGSZAWS4JR/FD6xxSAoFyTuAAwbUdPeKlXqgPx/a/H+cO4o2eqqwVP8vhopkSCAK/QMTtfPp/fJwXAllo1yDrZtlLGaCKST1v3/wBHU3ux37IEro1qwoJJBclX/qy8UMHo6maFyerHW7PWm9+nEclEq0yL0uuxJbySqhl9tzquK6ApKlTGv675xkfiJ5T2kYyVj/Uj6GXFQ008zFmYnQCSSAABcknFJuBIgopPzy4QIiKFVVFgAOQHcoFmgmQo6OLgg4u0Xx4JbECRG0SZJoJFkjboyG4OBlFRDdl+a6nK6/ceJCqRVcEcqEePgx0Pa9JN9d2QSkZ4HP6kq4QpNDIyOpFrMptpklPZ05tVwr/w49a4nSaCZA6OhuCDxJx5VWEGcDmkK9w+cO421OSWX/fw5DneVIAnqQZtr59P75OD9Bn2WFqmjACeK6o9/wDR1N7sd+K3inkgbq2tGcfk4tT4QzxQ/wBUkbZYKUpdf91Owm4k9jNSqyJ1KNsOU1cBnB6mA5+K1o65TSP7ZDdOGEnrgGE03NIDiVpJZGLO7G7Mx8ToiaWaVgqIouzMfAYRHrlPwEXNIe6hR2hTXelYmwHVMKVZSQykWII8DoclLGpp/wAHXiIdS1GY1fq6vo/bn8h+u+Pz4gFrRfmnJX2KkjsmoY6wcxE55OuHDxuAyspuCD4jhOFihQ+NszeCj1nG553zBQbhFHJR7O4fOHcXLaiCKJx0fhlclVWs6exAE2kZiNS5AHJUlUk8F7GeCWJPW52YmyCCVC/f/R1N7sd+yXjiWe7dIGEjcWLOKyjnh9lgJv8Aw2fRVX7puIGJqI5YUt1bYBaKankRgCR5rCx38WRkkglR1ZDZgVN92FISohSRA245XUEX4G4DDryZJq3/ALRYJJJuSeZOiBpqiZrKo/E9AMFJ+03uNYu9Il6J3cAwVbhJ16S6C1qedWcA5SycmXDh4po1kRh4qwuOH+2qvwTQHKJOSciF23qeSr9d6BkYFWVhcEHmCMI57PnOalmb+pQ7EpfsxzZH5mnJ/FMOHRwGVlNwQeRB4Mgalo3vOw/Xn7j84dxjCFqyRco/cOTh+M9R+fa9HT/k4P0k/lOz4Vb9/wDR1N7sd+iEiSRsjIwuGDC1iMIUkidkdDzVlNiOI2VmroYieqStkYbMhTyqkmhLgXyiRSt+IBnFZEguLi0hyHYFwdxBwoVErp1VQLAAOQAOKwL0rvASWzMQu26pGilmZjYADmScS6ugIyPPyeXTTmWXKWPgqqPFji01fMo8oqP/AATvEYeGeMg3F7HwYesYFpaeVkPrA5HQAJezn1Y9aNvHDyGJKd5vvc6I3eRj5qoCWJ9QH14KeeeJxzjfkGxAYp4jYg8iPBl6g7BNR2SGN05vEG8UxOk0EyB45ENwwO3VEdrTrzTnAhwSSSSSTcknuPMG4wQZZ6GCWQgWGZ0DHjyCIRQu5diAFsvMk4cvJIxd2O8szG5J4ahb0iE7Xo6f8nBjLhatFsDb9J5myoJWsh7/AOjqb3Y7+5YeVNJduswEnEcqyupVgbEEHZ6HiEhgbgjcQRjMUqKaN1zizWZfHYiKBpg6i2UEMo4pNqqITIAP149qdIYIULyO5sABh2TsxDZ35NVH/smmK7tvdz8SNPFmOFvI1mnnYefK3ek8+ktFUeuJuT6CogrxqHJIWzc04aEeSUiIW65yX0R54nnIZfYpP14tq+0aVG1DHk/VGxA0U8TFZI2FipGxIZqAyXmpT/QlMVIMgW8lO5Alj9o2ZEn7S5R0wNyvRpMTmWedszue5+jaX3a8dGIkpzAtusxycQsUipYgC3M+btejp/ycH6fT+8Gyt9TGsqep1bv/AKOpvdjv9PkSpo42zhbCR14puT2bTEk/yxsdDhMssErxyLzs6GxHEnSSSnZ4G6oEPmKdiJwj0UQRuKZAnlCxuENiwk83ZmWKCJSzMxsLDBaHsyFvgovGQ/PfSuSBLGeoYXWNcJeRrNPOw8+V+9x54Z4mikXldXFjjeaeQhH5Z0O9H+8Yco6sGVgbEEciMKbzRgODc2dPNbSL5VLW9gwBT1sX6amZrkDqu1OsyJOYo2X5kfmjR+3P5D9eSrD2rCvmScllHzHxTSQTISGSRSDuNtiqlgmQgh0Yqdxvij8r6TxkLJjtYwZSBaZCmO245sv6kQLOcUjQEl18qkN29TIuJWlmlYs7sblmPdJWd9Qy/dG5RRx7Wqq6OOX2KC/DsXldUX2sbDFtZHCiNbeLottqQxiopJY7gXIDLz4NtZBKkiXFxmQ3GPjPGrH2kbEhQNRyNm/gGfv6lWXs+mDKQQQRGLg9/sYV10X+9uLKZJNQyexY2KLs+k6r3rcRABDPFOH9cylP/DYtqQksXFcrJG6ujDmGU3Bxvd4UYnqSumdIaeFS7u5sABjND2ZC3wUXjIfnvpUpToQaic8o1xEEiQbz4u3izHvqgS0hWGf1xudFyy/5qH2GyONJsXUrf2jFUUqqGpkjEicmKMV/ocItL2im/Ug7pk6psA5aeB33DxA3YtmkdnawsLsb6IsyxUszXK3CfXmGinhN4qlAM64gz0x5VMYJj9h6N3yUsIa2ZE9S2VrDjzEyxwzyyp0EhAXh/S4fzjb/AGR4XPUp+XYfJr4JIg1r2zi17YN8jsl+uU27789fx+QEvHBW3c9AyleLzCS+8bZ9J1XvW4m8VtNNDzsFKjW7D2FLWC69dZxVzSSuqIvVmNhgWZIkVh0IGidYYIVLySMbAAYvD2XC94ovGQ/PfSpSnjsaioIusa4gCRRjex3s7eLN1J78t4aiNo2H8WARJTzPEbqVJym17YUtHFLaVRzMbjK2N4OkE03aQz+yVRZlxK8U0TBo5ENmVhyIOBFBXEAQyDck5/7Ppe0tfKFNns2RN7aSuqKRQ/XpAk0L7jHIoZTY+IOJ/I5fGF7tDjs+WOwuJAM0ZA8Qw4CFnY2CgXJOOxapo5HyLIUKrh6WkI5B3z3/AOjHboSXpFFdcf8AqN/7GP8A1G/9jHbkT/P1yFMU0VVFGtw8Ti7+xTjs+enawPnoQPO4SHOwinB8LJdeOAFpIIIY/YUEv4vw41dDWJdTt/sjwpWd2oICxJJJOXZdXeCqlQsvIkN3356/j8gAn/MwH2ANxeS182zGUf8AxCoazdHcsDxEzmlqopsl7ZtWwa2CCrAEEG4IOmQp5Pkn9uQ8RSzMQFUC5JOLRxL8LBSsLuejPokEcMKM8jnkqqN5wWh7Mhb4KLxf999IyU6EGeoIusa4gCRJ/V2PN3PiT8gRhRWIUm9bx6HUz0iClmXoYty6RaZfhad7C6uuIGhniYq6MLEEYJDAggg2IIwQrkBIq0+LdJNDIafs8aiMLyz8300xSWsndi3z0Xcv17Rq6MLMrAEEY7JSJ3kztJCTGxx2zLE5e8aSKHRVx2pTTyXAyFWTHkP97FZSUyBbqwJlx26DDY/oYrNhp610kD+e2Vf4CFx2TTwMzBswQE8CBJVuDZ1DC49RxA9FUv8Arwbl53JKYiStpoubw/HCgXLFOAz2qFeEAeLOOPPrYpq+oeKTqhc5eHl+BlMzXPgm3+yPCkDhKJIm9Tx+aw2ct5KkzLY382bz1765RKqshiLLzAdwvErlEtrrAnnytidJoJ0DpIh3EHuf0M8X6fNs/Ph9ynFCB44BAVTrB5mlSY2o5Tzsbopbh0jTSCxfoinxY4CVnaIcss5Wwj9SaGVI0UsWYgKqgbyT4AYkZezEa0j8jUsPwTSGCu15pQtxFH4scRBIk5nxdvFm+QUUzwIaiEk2sYxfR8SshzoLfrw7ELntGBBrYkGbXoumF6sxQuKOb2KcqPglmYkkk3JJ0C5JAA6k4iKGCmTOjHMQ5F2+wRvBxEtFXEgipjX864p7I+YxTJ50ciq1rg7QuYZkkAva+Q3w6mOeFXWxzCzC/Pix5zS00s2S9s2rQvbHieH9FqPybf7I8L58/vW2WQpV00Lp7FGr776TpveDhsy5lK5gbMLjmMSTyVCVDo7zkmRspsCxOJNbQvIHmpW5N616HFTnCECRGGV0PRh3JM8klG+Ti/T5tn58PuU4rANFIKlPWr+Y2lM0cqNGy3IuGFjj4qyuq+wHgh6Ls/8ApNICLgoDinWKGJennMfEsfEnRuAxIWpklBqahTYSMv6g0w5nbe7n4kaeLNhLyNZp52Hnyv8AIcGpiWdnhW9xqn85MOVkp5kcEAE2Bx+jliV1HqYX2Io0ppCBVxJ4SE/H2UR0WcSyq4upSLz2B+wXCs0EykOhG4g4SWq7NyEv4vDl2pS0/ZzZD/KY3TizCOV41i9okcKy8RAXgoro3Qs+2LhgQR6jhcsUVbOiL0VXIA4KW8kq5YvaGtLsgamSjMS/xxuWbvsYdVeWX2PFGzqeJG4SsRJ1Ym4YnRJZxudD8SRPFWxaCuiHw9Mfzp1XuPjSzflPF+nzbPz4fcpxc5StvTuq7EWqUVspVcuUWLbdI9RLa5C8lHU4yV1cLjrAgbYuaqRbVcvLVK36g0oXlncLuBIUHmx9Qwl3azTzsPPlf5EuY2RqV+iFSXXRIuvoGMLKBYhOa6JFSNRdmYgKB6ycVEUyg2LI4cA9DbEYkilQo6kXBDDF7RPeJvnRtvU7BN5SaSFfUtndvsGC4O4g4hvSb3qaZB+h6un7my7CCvXyZh4Z2+ITxUJNTWFw3TUJxFtCKZIi/R2bgekKn3h4PpJvdps21UM8sb9bzgFfyd9julNDPJKeiFCnEhN0doJXvyVt6aXAkTc6HesiHmjYkUrLGM6A3MclvORvWvcPGlm/KeKVK1NTNOn5Nn58PuU4vx4ZFdfapvggpUQJICAR8bShCyQQFG8GATazUPZzBHRiPPnUn9TFIsMS39bNc/rNsPG3adTuiRucSeMuJWklkYs7sbszHmSdEBmqJmyoo/E9AMWmr5lGvqP+ydF+RcgemhNXEzLezQDNoJ1faELRWC/roCy6JiKciWF0Dc2NnwHlopwEqYg39HHVlxIskbqHR0IKspFwQcOPPSSArpRnd2Coqi5Yk2AAwAHggUy2JYa1/PksemY/YN3g4itRyy2ngCm0JbxHRNh2SRGDI4NirKbgg4FhUQgsu/zXU5XH3NxJnPktIC8fgry8T9vBwPSFT7w8HpSf/JssgFHVwzP7r8X776Lf3qcSAzTQKs8YHNSh2JT/AIdWsFYM1kilPKTBuDvBHH8aWb8p4vhFN71tn58PuU4zsZaKd0JdvBvOGkDUvRmJf442LNsUrSm66x7eZGGNrucWre0YyHD79UjfuLjcBsWcqMsUV7GRzyUYfNNUSs7byQt+Si/gNETSzSsFjjUXZmPgMBZe1plszc1gX5ifI3Ii2GLeS1MsIYixYIxUHD5JYZFkjYWOVkNwcAhKqnSWxIJGcXscK5elqlK26P5uiZzTVLqKRid0T/M9j4+kT6Ys1NQHXy+1fifYPiWSKRSrowuGB5gjEJPZVQ94HHJP3G2JTZLVUH5H4kiOsc2qRk+ZGMo4kgtUVYQL4rqhwPSFT7w8GMFZ6MTF+hhaw95syBCtMZvugYTf8he+oDMkdNEj9EkLlhxFJiqIXikANjldbGxxyViB9x2H/wA32ciITckvH4Nx5Aka0coLG+6624soc+SLL90x1oGz8+H3Kcb4naEBQAL+vH566ZQFgqnhKeuZbj3ekNR0N0Ii5SzIRimSKJFC7gMzW8XPNjsyrHDEpZ3Y2VVHMk4GSkp7x06dV+foBZmIAAFyScJbtBlOoh/YK3yRntWwRS+oMoyFRoCB6B88XrimJbEgRnpHIYi48wZ9BsRyOC7TUNO0Tuz5hIS1w2mMCXtFwyddSv2EIA8Eg58mRhyZOhGANbAwsVN1ZWF1YaWKxxygTWAJMT7nw4eN1DKym4II3EcK14IJJBm5XUX34ADSuzsByuxvxPp83A9IVPvDwfRcvvE2XZY6qnlhdltmCyoUNu+yXE9UkGT+Quf/AJz8WMITWyyqP3JTnTYVniF0njXm8TYkEkM0avG6m4ZWFweN9DPFjZJI+z6dHRhZlZUAII2fnw+5TjPkmgkWSNrA2ZDcYBCVVNHKoa11DrfQ+XyOqhn9tzqv/PFMWXMFknYERR/xtgeV9oBd8j70RvHIu3OHiif/ADzBebpyjB0qHjvno4PZ+u/ySWzpM8Pqs40TaumqQaaduiyYXMksbI4uRdWFjiJ42hndMjghlytax2ELPUTIllIBsTvOIwkMEaoigAWCj7CMRPaVChMSrzlQ802JQ09EdQ/sUeZwgjNU2gAZvn8Vy5qZZZ7dCTk4HpCp94eD1qPcPtZtVTVs8Mdzc5Y3Ki/fAAlTXzSxetQqx/inFdSKymgmT1BV1P4psz3noJfgl8dQ/GteZ44Wv0c8RC7F1AUAkkk+A2vnw+5TjuNd2fOxVeR1MxzaC4gnyZ8jZW8xg+KSKnhW1kRQBuFrnqdtga+rVoqZQwDJcG83sXDl3dizMxuWJNySdCMOzqZlCp4VL4QIigKFUWAA5ADp8kuqmEJOQekR0GxBuD6xiUvKUEc97XEqCzYcMZZtf7BL5+xEdVSwmONuryfYTQCjr25BQqxy6b6rtFNV7HXeOEYubzv89f1BxfCKb3rcD0hU+8PBIDNXRRH+CY6p9oEKZxIfbMgkbvnWq983FCiKWgMKdbwuWPvNmYJA7iGpJ5amQ2bjIpWqq1DexBfiIzkdpU7EKCSFVwSdr58PuU45UQVf+VmLEKAsh4O9IFuEuAzseSjFg8pAVByRFFgo0RkUEDqaub1eKD1tiFYYIVCxxqLBQPkpS0clJKrAEg8tLv5/w8GILCeiGeULYO6MRsBxNMoqJw11Ikl+wmARNEQjEfEccmGEKTQSsjqfAqbaHyyxOro3RlNwcFbzwKXCnMFcbmX7jwSDFTEUqEKVJ1XFZGbyYS3XpMTIOB6QqfeHgvlhp6+nlka17IjhjtQhdbQRM7WtncFl74tj/htN+QcX/wB5/wDHtMDLTp5NJYWAaHiyjVWmlZOj8RlAo6aeZ+pVl1P4vtfPh9ynHNiORwzmVEEE1ySc8YsTtziKCIXJ8b+CqPFji8VHESKam8FHVurHQDnmazPYkRoObnEdl5ySN8eV/Fm+TFCSJWS3AIIF2vokyaqZc/QoTZgQMPOz0buQ7JZHWUaYwaamYVNTdQylIv1SD8/7CqHz2WOrX8j6bkr/AJuH2bkccCMuKWmlmKqbEiNS1hiQvLM7PI55szG5PF9F0nuxwPSFT7w8H5w2k8wJUi/fIwkUUCLGg5KqrYDi/wDvP/j2nFp0E8PtTixlDSwRQH8/EezQ0sUATqJ3ufd7Xz4fcp3CeyVSayBf302pxFTwj7yfBVHixxeKjiJFNTDko6t1c6Iy808ixxoObO5sBjVPX1BzVEq+7B6L8m2+GlEyWN/MfaLCbtNwfZFCSq/YVy5amndAWXMFYjzWt6jY4jyTwSvHIvOzIbEaN5p5AXS4GeNtzp94xIsiSKGR1N1ZWFwQdtgJe0Z1T16qHz3I4263ZlL7scD0hU+8PCNy3ZtKWJ3kkxjZS6QVyvKegZSnexeKesgjkANrq7gHHIAAfdxf/ef/AB7ROQzCKQKASUl8w8TkBfDu4qKmR0L/ABghPmg+wcSAI9ZWMUfxeKMBdr58PuU7gWElPMjizZScp5Xw94qiFZF58m2JxFBEN58SfAKPEnF4qOIkU1MOSjq3Vjpo7V8u+lR+cMXW3g5+TiuSqpEZB/B5mzukqZggPTqcIqRQxLGiqLAKosLD7C0NoKyIRTN/+fHpYmp7NOrN2JLRMboduS8HZ0SwDpn5vxfnr+PB9IVPvDwsocU+q3CwtCxiXZcAxBJjfpEwbvchQeVq9/5Xn8YLqoqEzr1vO5U+72ms6MGU9CpuMOXE9NG2YixJPDd1dqdoYijZXEk/mAjiylw8An9hnJkttfPh9yncZrOXaWiB/q6aZxFBELk+JPgqjxJxeKjiJFNTDko6t1c6aVj2fARqVYWWeTAsBuAHydH8D5K6B+rh9lb+TfAwfxv9hdS0yx62EC1y8Xn6SBTVg8mm9QfaKgU0DuL3sWA81d3U4JLyOWYk3JLG/F+ev48H0hU+8PCQp5JNNB7TfWbLMolpJQWW1xu73IEFKks59YAycYgpSwQQxewoJfxfbYXiZ4l/gjPDtneVqt+qqgKJxLayeVI0ubDM5sL4RFEcaoAosBYeG18+H3KdxmaGeFg8ciGzKwxN5FWRr57hCYnx2h5XMvKGAYtFBELRUyE5F6tpRxSoymrmHKOPEIip4ECRp0A+T/GefYF2YhQOpOEyskYabqZWF3vb7C4BBFiDyIxC0cImzwhvmPoJDAggg2IIxKHmEQSfmLOm47I3ztr5T6k40bSSySoiIouzMxsAOD6QqfeHhOddDXM7j1SKNkZkdSrDqCMIVSKplRVPMKrEDvRQJT0ZVvbKdg5URSzE+AAucdmSz0PjUhrP9yNie8i5RJBILOhbbNgN5JwmTymqllyXzZc7XttzEiKs8xL8gycN3NOjCGnDHlHHxIGliSbWuF8BGLhttWCCqMVj1hAjPdoGlqJ3yRoPE4RTUyKjVk3MySgflHh8oMgSnqmRvbKNgMKbs0id26uPiJ9hkKpmRoH6sU0vZK5Q8HTWpsXyopY26AYvkd7Qr82JdyjjelKT3g4C3KKWt7BhApqJ5JSo3gGRs1uE4zl6c7UbJrJg6X8UYd6cFCYoMmxM6PVuzzWfnEng40TvDUQuHSRTYgjDqK2GyVcYBAVtrIWmganjVjzaYZOB+wg4U+rqZ11NN7X4pcLTUpTluYy7fpOq963doE8vqBeHrDEflFCWqazOG9UK7ABqe0wlS56IwvEv2GXANI8c+lrTU0quu8i9uYNvA8jhSEqoI5UDWBAdb6WtVdp3j9kI+OeP6VpPejgfsjw/R5/ONorkqaOMoP4O9FclTWXT/YLbGQpRKtIpHWMkv/RjpJ8jntHVrbMcnUYfNHIodWHiCLjZfkDUTAP9yBhwAuSeizs3iDE3CIMPZ3x/XM/FkuKqsJC9NVt+k6r3rd1gV6CjayI6m0svyk660STuU0htQz56ggE2iQXOAFVQAANwAH2GXyeUU8kRYC9s4y4N8jst+tjplJno5DND/Ik0EKqgkkmwAGCTTqdVSjpCnH9K0nvRwP2R4f0ap/JtPvIkgyd6FtdJLKvrRzpBMVLBJKwBAJCLewv4nEjPJI7M7sbszMbkk9TsOBPRreC5+PFsOFjjUu7HkAo34zZJpiYwSTlQblHA9Gz/AIrwSM6JaFfnStuUYfNJK7O7HxZjcnisjulKh3cvP8/a8MSCSKXtCpeNxyZWkJBHdAbMQ88m74KEEZ3woSGniWNBYclHM28TzPykSZKajAk9rsW005WesIEDHnqPsN05giStl1ceUqAha66bmFXKTfwSDKcOGRgGUqbgg+IxOPKawg1AHNIV7gCUSZ5v98CGVeB+yPDcqXqgjetG2owZYq5FR/FQ696jKSrSJcHTkMvaE6IF/cjOctsm0tNKHAuQGHip9TDEpenqEzJcWIsSCpHUHTLaor763qsC8H0bP+K8Ga9F2c+Rl8Gn5O3FCl56mNFDGy72wAFAsANwAG10PdELOxAVQLkk8gBhB/iNYFedioDRg8ovlOMpqMkB9ZjGiEw9lB7tMw/ShOaJiNUjjUKiKLBVHIAfYbSyVEEDxexVCbBaegCMYDzaJ+YT+BsfpKhy2UEkIvgg9Q7h0qvcPwArSQUU0iBrlSVXhvlljqoipsDbztqEyPqFNgLmyuGJ7yLu7BVHUk4GV4qaJHF72ZUAOl3yUVMoZf1M8nnEjTnWhpoG1jobNnkBVAMJmRrtBOvxJU0OopaxmeDqk+hrQU0TO1iATbkov4sdww7EyMQiE3EUQPmoOCXDwUiIOhEp4BtXV2eKDmDGtt8owSSTck8yeKsTpQwPOVf/AKFK7fQ90pbwJY0KPyd/n/KkQqKCpmDu8fOJm8GGBJFSEq0EHJ5h1fomI1jjjUKiKAFVQNwA8APsOei094/delV7h+B6On/JwzZ0YMpHgQcEM700TsepZQTssEaopZYlZt4BkQrc45qSP6d4AMstXEqhjYXzaWCpGpdmPIAC5OCpaoqJHuospudIIqapjUzr0Z+S4bI1w0MoFyrjEBjlQ/c6+DKcSNHLGwZHU2KsDcEHEp8rgVYqlej4kcUlJIwqGDbppV/7JwkOQxwANtyKkMKFiSbXIG5R6zgZA1kiiBuI0XkOMUOuqFgX566oZzt5dbTUNRLHcXXNGhYXHERKGFwSDObP/wBGK2jqmL2KAlMUUtNI65lVxa67IaLsqJt78mnb5iYhWKCJQsUaiyoo8PspAXJqx+TuvSq9w/A9HT/k4hDTSUiXIAG07MlNWzRKzcyEcjvCZzHVLK3qSPeTpkdJJUEMbJ4NLpgz01M2vn8FCpphv2pSJema4XOvijY3EYdQK2maGS4va/6w9Y4aOqPXXRuoCbRsBvJOJlPZdO/x05TuvHcMz0wnLBcv6c63b9FVfum4UbO7sFRFBLMxNgAMRJL2lKu6NgGWnVvxfTQxVEfR1uR7Dio8rj5+TSELLjsDtDMjFTand1uOhUEHHYFfnc2XPA0a/ezgAYkR9W6lKWI3R/5mIVigiULHGgsqqPAfZT61f4J3XpVe4fgOyFtQntVpVBHEYuUeWNPUiNtRFEkeOb2tKgdz3gDJT00zynoGGTTkLoWnfqukLre0XzJ1ESbETLB2imv9Ql5SLxEAMrSSp60dtqTOWOWsnT3S8dynlVVFCXC5iodgpbHIbcWfNSGD2eUsIb8KBXRG/wAijfPXm5X7LnWr/BO6rIfJqWeQZQCLldX5/A+fT++TiShilWGEZbkCm1bUy0BhT+OJyze87xbUpSpCeud3DDTMskVOVp4yBbdHoNi7Kt+lzbGW1PBHFdRlBKixOxfXQQTSv7JiFX8nElLpDSRWY2ubi+y4k7RnQrM/hAjD8/cM4Wip5ZbgXBZhqgp4HWm9+nB3J8edyDZY1woWKKNURRyCqLD7LiEzQV4iR+iSoS3dfRE3vY+A9kqa+OOUdVUF+IGL1FIHToBEdp7CGqkgCfz0z/8AGTvCWimniRG9cYJbQHKUtNJKwTnZFvuw7PJIxd3Y3ZmY3JJ0PkEUpn5XvqRntsztLTRFYICTdbRCxyeotc8MqHlq4gM3Lns1EU/aL3V5UIZKbwPtfEjPI7FmdjcsTzJPcIbPWT5Ee/NIuA9hU18MMo6oFaT8U4AJJNgBvJOAPLa200/MFOkf2XQxlenzxqguzPCRKFHtK919Eze8TgelE90/EmEaTF4pOjKVJttJd4JqeSM9HLhO8ABamsmmj9aWCaM4NbPFTqyn2ufuITS65IqVISniTK+Yfk2JCkurMVORz10gsnEhV4qKJ5m9R5KdJAUC5J3AAYna7XWorR+EXcokRxAryhTmBd/OY8BwHbtNDb2RvwBak7NmUoPnz8x/0fZfACQVDasBi1o385P+D3T0TN7xOAxsfKz7viRl1pqmKYoDYsI2DWxuuoP9dmISyy0M6RofFyht3jLmNOZhY3GWdzKugMBDTvOxvubWtkHu9MOXyqvldG8XRAqbCkLSJrZPW8vEicOTHBG+ioWCnhF3duQxIYOy/iM/J5+5MFEtXHckZhZTfG4DgfPrPwj20D1FRJkQEgDChUiQBmAALv4u32XwbSoaaX2pvXunomb3icB7zQwzyuOiylVX8nFMrOaVY3aQ3ZpITq3c+0rs82Uj+owVL088kTEci0bFT3dMk1PQ08Uigg2dECnQrKI5lgsesCiI6SxVqGOY36zjWnS4SGCJndiQNyjDlnqJ3kJIANifVxC+eqeWdw/gScmH8preQpYmFwbXBfoMSgBEyRQx3WJB6h3NHtSwZEf9TPJwUbWwwzTFvArKQo/JtxMs890pgfCL7MEZeaJdfEObXj7p6Jm94nA9Ew+8fiyu70NXdU8Ein2r5PKc+/rKA57sAZqmeOGME2GeRso0MFVQWYsbAAeJxIZJZpnd3P6zMbk6Iy8s0ixxoObO5sBhFREUAKoACgDcAOg0vaWvlEe5gDq13txDYE88S2SlpUpZa/kZRGgS8WJGd2N2diWYn1k90Fn7QmMnO4yJ5i8H0YnvH2iVgQGWocC+WNcKFSNQiKOQVRYD7MC3SRShF7XBFjjL/lqh0GUki3c/RM3vE4ErOsMVOidFBiV7Di1LItZSEIng8sZDbVPkSppUfOFsJHHdmUMtdHMbm26A61tDqif4fULnYgC7IVA0pncV8MhHqiYOx2CdX2dCqWKj48gzt8g82IA9pwkSGnpo0YR/ELgecw9p4JJAjp/dLtQhK6ttNUErZ1DfET7MX0tu5+iZveJwEZAk4gs3WnQRHiymOOOqQSsFudU5yuNpRqQssR/jbuzqoo4J536sCuq/F9HzI/eLpjLCETO/qXVldJChFLEsbAADxOECGqqJZigNwusYtb5BLhKWXyqR1HJYd/CjCaufUe0QAR7I/wAp2bIrKPnz81/6PsxsWY1c1yTcnzz3P0TN7xOBIHhm7QqHjfwZWckHimxBuD0IwH1s1OucsbklPNJ+8jZch6SrQhfBtZ3YKYoKHVP7ZnBH5NEpQS1sMbjqmn0ZN+dNOQtND5Mqv4685Db5C6rRxe8fhZtXPWzOlxY2L7CZ553CRqSACThV+CjGsYAAvJ4sfsx74a86+Ju5+iZveJttkhhieR2sTZUFybDHIsSOMLGlqrhr8xLsxFtVEJU9Tp3Zl1cssMKj1xAsfz6PSEOlE1qQwBH8VVy2mP8AT1bzZ+moTJ/zrPkJUV50NTIU5sZvOW/rC8E2A5nH7Z/x2I21rlo6T1JyZ/syBRWwXejcm3n+IOIHhnhcpJG4sVI7kgIrKWeFvUFGu/FNskJ5DLH1N5RkX/luO6KlbAye113qBsqWkellVFHMsVIAwMrKSrA+BHdQMtVXO8XsVQmj0hDp/Y02mS8CUGsROjyOwY/IIa9TOiEqLlVJ85vuGN9gB/Tg+NDUfkOwxSOxlnkAvkiTECwwQqFjjUWVVH2ZYkh7QCgQ1SjzwV5Buq4hCsVDI6Eski9UPcUVi9WsBDdJ/gjtopFXURQt+fjyOmoqEclPjWB32x8WRQwv0Ivsyaww1kq5wLX391ZSZFeZbdJWLjR6Qh0/sabTyVIPdL8ggFOz4C/OxzyeaOFIyOKawYHwYgbEbLX9oIkk4PNE5on2Z4BLBKPvv4Mp8CMFqzs4v7Zov4+4SMjxOrq6EhlKm4IOFdVqYI5lVrXAkXMAdoyLcPUP8xvBe4FA9IPJpEVrkGPZLkSlJjfrKobuoCyw0UKuAQQCBojZhFWQvJp/Y02mPJqqjUe3UDV3+Qba2tqDzSzBI+Eq2nlihct0bShFFQOr8jaWX7NSpSVoVm1Ki0UzFr4pXgnjtmjfmL8d7y0TvA93u3UbUjtFRosCq3JSO4E2dBVRAD2I+zFZXorFwtgzK57ohaSR1RFHizGwGBlZIkUjoQuj9gnvU0/sabT6Tqfzn5AF2dgqjqSbDBctT0yI2bhfToNAvNUOEBINl6sbeAwtkhXefnOfjN9mulDgEmKRTkdGItcHEflVBvK1USkqFvYa35p4y7q1BIr9Hh2VuIone17Xyi+CzPPKzm7Fj5x5X7gQIhUauRmfIqpMDGWJ6Le+yt4oaiVJG9bjukbO5rYSFUXJs4OlM6eQTPa5G+MZ10/sabSzMHlWY36zIJD8gBTGJdbICxW6RDOQCOH9Og0JIvadZHZ0fdqU8E+zbGro6lWRwGVlIsQQfA4tDNd3ekPxH9UeKd4J4jZ43FiDxAC9NOsliL3thgVmiV1sQdzC/MbAUy9otqPYnNj3KZ5JJaRBK7bryoMkh/qNhyvkk8M4913RCbTkn/pOlynlNPJEXAuVEilcfqsR/TQ5EUtAzunVo2AXTGUSaKB4j4MojC/ICLlihWFCU/XfxQ8Od4busgdACVZcVUNdRw3aCG3NwRlL/Zwp7SLcxzx7nQlbYXymg8wCrQWUM3gy8SX/ADNDvguecDbBUwdmLqlIIa7tYv3Jk/y06zoC3nkSizbAJUUM0igdYBrF7p9Cn2JBIaaqliLgWDZGIvoiL+WQTQD3ulwVnpXgCeuB85958gBxJWM1UVYjcJLBbW6qPs+gMrCxBFwRiPUVWa70rPaJ/wCAtikkp50AJjkUqbHhZikT2mRT8eJtzLiVJYZkV43U3DKwuGGgqZlTJTIf15n3JiRnkkYs7sSWZmNyST3Itq629M6qOefYjWSORSjowBVlYWIIOAQQSCCLEW7n4USbBYh5hMb9Z0EraFZlNTqrL1nUxDTCC9BVgs9+UM3mHv5USVVRHEpbkC7WucRqkcahURQAqqosAoHID7P9IHsVKyrZZVy9GwDX0CLcuthKnXMnCqXMqXehJ8UAuyaHvTdnXD9GnPc2IeGRXUgkG6m/MYKslRCj3W9rkbxv2LZnrpZhY3FpzrV/4buZOuDRQ7HOroYZZfapMX4JotraaeOaO4uM0bZhcaY1d5qSQRBzZdaN6MT6m7+gK0UOSL+bN9oHeDj/ACfaTgkOn6KR/wB9cUjpZiEmAJilA8UbgStHNE4dHUkEEYKL2lPeAQAFxHPhru7FmJ8ST3RnL0Eup5ADJzXYkzeWU0E/8Fl1X/h3NGVJamII2xB4TwyzhfYUQnTUtOz0USyyHm0qDJJz/eGnlNM1REQAAUmJbvyqs8oM89gAc8ngSCblR9oOnWeCZbSI43EYkZutHK35GxSywTISGR1Knce+SWiroboC368exJcz0jxFOghe/wDzn7n9Nl2AClLXxSy+pWBj0slqSskiQLzyNaX8X0qoMDamb2P31L0tNaeo6FV5LgAACwA5AfaFollKiyScpEBIJswwG7Roh0trxhSrKSGUixBHge9EgU86s1lDHIdzWB9WORAI+/TbVRSTQnreUBh3P6bLsSKhSDX+0QES6QoSWlSYv4gxNkH59IGrqImX2N4NhbS08rRuPWp74tqqvtM/UIfiD7REHklY9z5TAAGLfvjk2KTX0v0mC7p3pndxAIZWkOZ2eLzGJOnme0R7tu5pYT1MsqetNhM801DOkakgXZl0hiJXaAAdZVKbERZMojrPwR+9rfs+iKvPvsXY/EQfaLI7Oqm8EUalsULanwqI/PiPeCqyLKtWnVw4CNp+ZV/inc/GBveHY/ZtptrYamN0uLi4bYTPDUxNE6+NmHh0IwCUBL08m74WEkhX7zFrKiobKi4ALgB55ASdZMygM/2jEDKeYYXBwF7PrbXCcoHxQNEshYRyBg6Pl6Fe7Oy07Ew1FiQMknXqFNm0oVWipoYedwxYa0/n7n4wN7w7DhZoKGeSNiAQCq6TZkYMp9YOGzSzU0UjkC12ZATsNHHX05LU7sOfVGPRsLllidkdbg2ZTYjvAQ11XGMiWDamP7R6BkcFWVgCCDzBGHXs6YDfE5d4pMdnOkZAOtQiRPvZe6zjyqg3IC294cBjFSwSSsAQCwRb2F/E4CiWqnkmkCiy5pGLG3c/GBveHYJCvRSRCwv58wyLsfQIPdjZpGNfFvnSMfpkHN/avd6fo9JSP7yT7SSKyMLMrAEEesYcdnVLcwu+FsdmyNEqltfCDJFZQCSSO5sfgnAcdUbcwxPn8qRJ6lhy1RAZF7p4wN7w7EgV55oEjHVxIH0mwd1Unpc2w5ZIIUjDHmQi2udqJFmfMZ6XkH/fTCsjoxVlYEFSDvBHdIOj0lI/vJPtKi4PMHED0FQbkvT2VWbqy4pz2nTM1klplJf70wCCOYIse4nunjA3vDsRfp6qSfP/ACFyf859KylJKlNZqx5yopuzcA+T9qZPZFN/Hiklp505pIpU9xpJaid75Y41LNYYdantAoLJbzKf7TNCBPu+Hi8yTFWtXEu8QP5kuKKancMykSIVuVNjbu9BPUMxKjIhIuBexOKCKLP+pLKqPilpv7647IeZEiMjPARIoGI2jddzIwKsPaDwAAI6mZF2HQx01EZPWHmcg/8ACaeVBBZbN+vPwaMPa2SVbLKnsfCeX0YuQ0Y+FVR89MAqykggixBHGAoaJrMJJfjup+YuKUITmzzPZpXufFvtOUUNTEbeZIoYbjfFU9FMeULefDiiz01hepgJki7nTtNUTNlRFwVraoc4QTqFxAkSD9VFCj/jY7MgnJvZmQZgSLXBxVXAufJJ/wAEfFO8FRA5SSNxvB2mcUle6KhAuEm0ziKGMe1ix5Ko8ScJkNRLdU8VRRlQH2AaQRVVbGqmUixQvyTh0hgq5Oc8HmMT1OCnaNOngm6awW5OTFPLBMls0ciFHW4uLg8Gnknmc2SONS7sR0Axk7Op35627TWtcHJijNTUoN01Qc+NwH2oOyYknbOTPB8E95ObHJuZsdoxVK+EMw1T47NqKZrX89CBYm3HhzO293O5I08Xc4GaV7GonIs8r8CkV+YSYACSH1o2D5V2c7sElTnH6pNqsLVyX8lducsSjl63XH+a7QdGKQJyToZcVRdQbpApIij/AIF0xH/DqJg7kqCssq2Ii41BT1SK2cLNEsihrWuAwxDU0fVYJbKx9jh8dvpI+flPEYgF9qF8CkrAwNzFLk95bHZaf348dlp/fjwKWjC8mklD+7vjt+KN77lgiMoK+1ymIqusBWwWaay/dqgmKCClj3HLFGqZiBYFrcz9qWFJY2tmV1DKbG/I4ikoZ35tBYJz+ZiWGvRRyU5HxQz0zhmUCRCoYobGx5Hhw55H3sx+LGvizHAzStZp5yPOlfhKGVgQQRcEHCamdVUmi5I/8GIWiniYrJGwsVI2JminhYNHIpsykYcs7ElmJuSTzJOmK7tvdz8SNPFmOAto1GskChTI/i5+1/TRTJIpVkkUMCrcwb4ifs+Ykm8DWT/obFbBX2QEoRqHJx2RV0yiUxh3jYIzDwVuR2he+Im7PoCwLl907r0RMUyp5qrJKQDJKV8XPFi1NWLZKuEDW+w9VxBraY2yVUQYxHao5KiVrXCC4UE2zOfBcWmr51HlM/8A4J0X7YYBUixB3gg47DgRxGUDwjUkfcmO1KyntfPnAlvjtyJh+vr0KY7boP8A/fHbVTPF4osYjx2auvUW18p1kncIEmglQo6OLhgcOAOb0kz+7bFBNAyG2ZlOQ+xtETyOb2VFLE29QxB/h9N5pLzDzyD0TEJGds8srkNJIf3j9tyKORTvs6hhu9Rx2PSOuQpYxLyJDfiuKKniYcmSNVO/1j/9/s//xAAUEQEAAAAAAAAAAAAAAAAAAADg/9oACAECAQE/AH0h/8QAFBEBAAAAAAAAAAAAAAAAAAAA4P/aAAgBAwEBPwB9If/Z" alt="agnes" style="width:100%;max-height:3.5in;object-fit:contain;display:block;margin:0.1in auto 0.25in;&gt;&lt;/div&gt;
        &lt;br&gt;
        &lt;br&gt;
        &lt;br&gt;
        &lt;div class=" body">Phish&#39;s &quot;What&#39;s Going Through Your Mind,&quot; which starts with a guitar vamp echoing James Gang&#39;s &quot;Walkaway&quot; crunch, includes the chorus: <br><br>To the years we&#39;ve suffered most<br>From things we&#39;ve never spoken<br>Still I think you know<br>If looks could kill, we&#39;d both be broken<br>Though after all this time it seems<br>We&#39;re not each other&#39;s kind<br>Never think that I don&#39;t know<br>What&#39;s going through your mind<br><br>The word &quot;mind&quot; is repeated 28 times with each chorus, and more once the jam takes flight. In the December 31, 2024 version we count XX total &quot;mind&quot;s </div>
      </div>
    </div>

    <div class="cell">
      <div class="panel">
        <h3>What&#39;s Going Through Your Mind</h3>
        <h1>mind mind mind mind mind mind mind mind mind mind mind mind mind mind mind mind mind mind mind mind mind mind mind mind mind mind mind mind mind mind mind mind mind mind mind mind mind mind mind mind mind mind mind mind mind mind mind mind mind mind mind mind mind mind mind mind </h1>
      </div>
    </div>

    <div class="cell">
      <div class="panel">
        <h3>Page 6</h3>
        <div class="body">Aviation/Aerospace</div>
      </div>
    </div>

    <div class="cell">
      <div class="panel">
        <h3>Page 7</h3>
        <div class="body">Body text</div>
      </div>
    </div>
  </div>
</div>
</div>



<script>
// when the page is about to reload via servr, remember the scroll position
document.addEventListener('servr:reload', function(e) {
  sessionStorage.setItem('pagedown-scroll', window.scrollY);
});
</script>
</body>
</html>
